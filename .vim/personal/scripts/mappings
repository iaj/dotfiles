"" vim: set filetype=vim : ""
" noremap <D-i> :%s/^/> /<CR>:nohl<CR>gg

"fold tags
nnoremap <silent> <F2> :TlistToggle<CR>

"make document a textobject - well not really working with registers so not
"a really good choice
"Nnoremap dad ggdG
"Nnoremap yad ggyG
Nnoremap vad ggVG
Nnoremap =ad gg=G
Nnoremap gqad gggqG

"imap ,. <C-o>a
cabbr %% <C-R>=expand('%:p:h')<CR>
map <leader>e :e <C-R>=expand("%:h")<cr>/
map <silent> <leader>E :e <C-R>=expand("%:p:h")."/"<CR>

map <silent> <leader>b :CtrlPBuffer<CR>
map <silent> <leader>r :CtrlPMRUFiles<CR>
map <silent> <leader>f :CtrlP<CR>
map <silent> <leader>gf :CtrlPCurFile<CR>
map <silent> <leader>F :ClearCtrlPCache<CR>
map <silent> <leader>gd :CtrlPCurWD<CR>
map <silent> \a :CtrlP 

nmap dD "_dd
"nmap dD :normal 0y$"_dd<CR>
"vmap dD :normal gvygv"_x<CR>
"vmap <BS> :normal gv"_x<CR>
"vmap dC :normal gv"_xP<CR>
"nnoremap dd :normal! dd<CR>
"nnoremap d<Space> :normal! d<CR>

nnoremap <C-w><C-w> <C-w>p
nnoremap <silent> <leader><space> :noh<cr>
inoremap <C-L> <C-O>:nohls<CR>
"noremap <C-L> <C-O>:nohls<CR>
fun! WordUnderCursor() "{{{
    let substr = strpart(getline('.'), -1, col('.')+1)
    let substr = matchstr(substr, "[^ \t]*$")
    echomsg substr
endfunction "}}}
nnoremap \dg call WordUnderCursor()

"searching
"nnoremap / /\v
"vnoremap / /\v
"nnoremap <tab> %
"vnoremap <tab> %
"map <tab> %

" Pressing an 'enter visual mode' key while in visual mode changes mode.
vmap <C-V> <ESC>`<<C-v>`>
vmap V     <ESC>`<V`>
"vmap v     <ESC>`<v`>
vnoremap v <ESC>

nnoremap Q gq}

" Formatting, TextMate-style
map \q gqip
map \= =ap

" Faster scrolling
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" Run Make with ctrl-m or ,m
map <silent> <C-m> :make<CR>

nnoremap <silent> ,A :if &l:nu \| setl rnu \| else \| setl nu \| endif<CR>
"map <silent> ,b :LustyBufferExplorer<CR>
"map <silent> <leader>b :FufBuffer<CR>
"map <silent> <leader>b :CommandTBuffer<CR>

" buffer stuff
" map <silent> <leader>g :LustyBufferGrep<CR>
" map <silent> <leader>B :FufBuffer<CR>
" map <silent> <leader>x :FufBookmarkFile<CR>
" mru stuff
" map <silent> <leader>r :FufMruFile<CR>
" map <silent> <leader>r :MRU<CR>
" map <silent> <leader>x :FufMruCmd<CR>
" map <silent> <leader>f :lcd %:h<cr>:pwd<cr><Plug>PeepOpen

" map <silent> <leader>t :FufTagWithCursorWord<CR>
" map <silent> <leader>T :FufTag<CR>

" and lets make these all work in insert mode too ( <C-O> makes next cmd
" happen as if in command mode )
"imap <C-W> <C-O><C-W>

" use - and + to resize horizontal splits
map - <C-W>-
map + <C-W>+

" Mappings for fast resizing windows
" and for vsplits with alt-< or alt->
map <M-,> 3<C-W><
map <M-.> 3<C-W>>
"map ,o :TToC<cr>
map ,X :he XPTemplate<CR>

"map ,i :.w >> temp.csv<CR>
map <silent> <leader>d :bd<CR>
" Delete all buffers
" nmap <silent> ,da :exec "1," . bufnr('$') . "bd"<cr>
" map <silent> ,l :ls<CR>
map <silent> <leader>ms :messages<CR>
map <silent> <leader>sv :source $HOME/dotfiles/.vimrc<CR>
map <silent> <leader>sm :source /Users/iaj/dotfiles/.vim/personal/scripts/mappings<CR>
map <silent> <leader>sf :source %<CR>

" highlights the current typed word (all occasions)
imap <F2> <esc>:let @/=expand("<cword>") \| set hls<cr>a
nnoremap <leader><leader> <c-^>
"nmap ,, :LustyJugglePrevious<CR>
"map <silent> ,. :LustyJuggler<CR>
nnoremap \v <C-w><C-v><C-l>:e $MYVIMRC<cr>
map <silent> <leader>v :e ~/dotfiles/.vimrc<CR>
"map <silent> ,E :e ~/dotfiles/.vimperatorrc<CR>
map <silent> <leader>z :e ~/dotfiles/.zshrc<CR>
nnoremap \z <C-w><C-v><C-l>:e ~/dotfiles/.zshrc<cr>
map <silent> <leader>M :e ~/dotfiles/.vim/personal/scripts/mappings<CR>

"cabbr js !js /Users/iaj/bin/js/runjslint.js "`cat %`" \| /Users/iaj/bin/python/format_lint_output.py
"cabbr mg ftp://www.marcgalal.com/httpdocs/fileadmin/
"cnoremap <C-Space> <C-U>e ftp://www.marcgalal.com/httpdocs/fileadmin/
cnoremap jk <C-c>
imap jk <Esc>

map <leader>w :set invwrap<cr>:set wrap?<cr>

"ctags settings
"map <F8> :!/usr/bin/ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>
map <F9> :!/opt/local/bin/ctags --exclude=.svn --exclude=target -R .<CR>
map <Leader>ct :!/opt/local/bin/ctags --exclude=.svn --exclude=target -R .<CR>
"map <F9> :!/usr/bin/ctags -R .<CR>
"exuberant-ctags -R --language-force=java -f.tags /opt/sun-jdk-1.5.0.08/share/
"com! Tags '/Users/iaj/bin/ctags -R --language-force=java -f.tags /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Classes'

" bachelor arbeit specific (rofl)
"com! Tags '/Users/iaj/bin/ctags -R --language-force=java ~/Documents/workspace'
"
" Window movement-enhancements - making things easier!
" create a new vertical split window and switch over to it
nnoremap <leader>W <C-w>v<C-w>l
nnoremap <leader>H <C-w>s<C-w>j
" Close the window below this one
noremap <silent> <leader>cj :wincmd j<cr>:close<cr>
" Close the window above this one
noremap <silent> <leader>ck :wincmd k<cr>:close<cr>
" Close the window to the left of this one
noremap <silent> <leader>ch :wincmd h<cr>:close<cr>
" Close the window to the right of this one
noremap <silent> <leader>cl :wincmd l<cr>:close<cr>
" Close the current window
noremap <silent> <leader>cd :close<cr>
" Move the current window to the right of the main Vim window
noremap <silent> <leader>ml <C-W>L
" Move the current window to the top of the main Vim window
noremap <silent> <leader>mk <C-W>K
" Move the current window to the left of the main Vim window
noremap <silent> <leader>mh <C-W>H
" Move the current window to the bottom of the main Vim window
noremap <silent> <leader>mj <C-W>J
noremap <silent> <C-7> <C-W>>
noremap <silent> <C-8> <C-W>+
noremap <silent> <C-9> <C-W>+
noremap <silent> <C-0> <C-W>>

nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

nnoremap <leader>D :lcd %:h<cr>:pwd<cr>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>

" Fuck you 2 manual key
nnoremap K <nop>

nnoremap <silent> gb :bnext<CR>
nnoremap <silent> gB :bprev<CR>

" Spellchecking
nmap <Leader>ss :set nospell<CR>
nmap <Leader>se :set spell spelllang=en<CR>
nmap <Leader>sd :set spell spelllang=de<CR>

" Return to visual mode after indenting
xmap < <gv
xmap > >gv

" awesome, inserts new line without going into insert mode
map <S-Enter> O<ESC>D
" hilight everything in visual mode that was just pasted!
nnoremap <Leader>V '[V']

"no comment lines - we just don't want them sumtimes
nmap go o<Esc>S
nmap gO O<Esc>S

"map <Leader> ss :set nospell!<CR>:set nospell?<CR>
nmap <Leader>ss :set nospell<CR>
nmap <Leader>se :set spell spelllang=en<CR>
nmap <Leader>sd :set spell spelllang=de<CR>

" Spelling
" Quickly add a new spelling abbreviation for the word under cursor to this file.
nmap <C-F6> :let tmp=@f<CR>"fyaw<Esc>:bot split ~/.vimrc<CR>G?LAST_SPELL<CR>zRkoiab<Space><Esc>"fp<Esc>:let @f=tmp<CR>a

" Y behaves like D rather than like dd
nnoremap Y y$

" Backspace should delete to the black hole register, not move left
nnoremap <BS> "_X
nnoremap <Leader>N <Esc>:enew<CR>

" I'm sorry.  :(  Some Emacs bindings for the command window
cnoremap <C-A>     <Home>
cnoremap <ESC>b    <S-Left>
cnoremap <ESC>f    <S-Right>
cnoremap <ESC><BS> <C-W>
cnoremap <C-A>      <Home>
"cnoremap <C-B>      <Left>
cnoremap <C-E>      <End>
"cnoremap <C-F>      <Right>
"cnoremap <C-N>      <End>
cnoremap <C-P>      <Up>
cnoremap <ESC>b     <S-Left>
cnoremap <ESC><C-B> <S-Left>
cnoremap <ESC>f     <S-Right>
cnoremap <ESC><C-F> <S-Right>
cnoremap <ESC><C-H> <C-W>

" Extra functionality for some existing commands:
" <C-6> switches back to the alternate file and the correct column in the line.
nnoremap <C-6> <C-6>`"
" CTRL-g shows filename and buffer number, too.
nnoremap <C-g> 2<C-g>

" Make [[ and ]] work even if the { is not in the first column
nnoremap <silent> [[ :call search('^\S\@=.*{$', 'besW')<CR>
nnoremap <silent> ]] :call search('^\S\@=.*{$', 'esW')<CR>
onoremap <expr> [[ (search('^\S\@=.*{$', 'ebsW') && (setpos("''", getpos('.'))
            \ <bar><bar> 1) ? "''" : "\<ESC>")
onoremap <expr> ]] (search('^\S\@=.*{$', 'esW') && (setpos("''", getpos('.'))
            \ <bar><bar> 1) ? "''" : "\<ESC>")

" Execute current line
function! ExecuteLine()
    let save_reg = @@
    normal ^y$
    exe @@
    let @@ = save_reg
endfunction
nnoremap <silent> <leader>i :call ExecuteLine()<CR>

"""" easymotion
" for now we won't bug our keys !! <leader> is ',' as well...
" let g:EasyMotion_do_mapping = 0
" let g:EasyMotion_leader_key = '\'
" nnoremap <silent> <Leader>f      :call EasyMotionF(0, 0)<CR>
" onoremap <silent> <Leader>f      :call EasyMotionF(0, 0)<CR>
" vnoremap <silent> <Leader>f :<C-U>call EasyMotionF(1, 0)<CR>
" nnoremap <silent> <Leader>F      :call EasyMotionF(0, 1)<CR>
" onoremap <silent> <Leader>F      :call EasyMotionF(0, 1)<CR>
" vnoremap <silent> <Leader>F :<C-U>call EasyMotionF(1, 1)<CR>
" onoremap <silent> <Leader>t      :call EasyMotionT(0, 0)<CR>
" onoremap <silent> <Leader>T      :call EasyMotionT(0, 1)<CR>

" Warnings:
"inoremap <Esc> <Esc>:echo "You should use Ctrl-[, or rather 'jj'"<CR>
"inoremap <BS> <Esc>:echo "You should use Ctrl-H"<CR>
" Learn your hjkl!
nmap <Left>     <Esc>:echo "You should have typed h instead"<CR>
nmap <Right>    <Esc>:echo "You should have typed l instead"<CR>
nmap <Up>       <Esc>:echo "You should have typed k instead"<CR>
nmap <Down>     <Esc>:echo "You should have typed j instead"<CR>

" Allocate colors with or without # respectively!
"nnoremap <leader>G :hi Normal guibg=#<c-r>=expand("<cword>")<cr><cr>
nnoremap <leader>G :hi Normal guibg=<c-r>=expand("<cword>")<cr><cr>
" this one is specialized for molokai theme
nnoremap <leader>U :hi Normal guifg=#F8F8F2 guibg=#272822<cr>

nnoremap j gj
nnoremap k gk

" yet to be verified - Araxa's mischief
"nnoremap :: q:
nnoremap <leader>/ q/
nnoremap ?? q?

" Add semicolon to the end of the line. Thanks to
" http://www.van-laarhoven.org/vim/.vimrc for this idea and godlygeek in #vim
" on Freenode for an improved version which doesn't clobber any marks.
nnoremap <silent> <leader>; :call setline(line('.'), getline('.') . ';')<CR>

"only in javafiles !!
" noremap \pl :ProjectList<CR>
" noremap \pc :ProjectClose
" noremap \po :ProjectOpen

" word swapping
nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>

" omnicompletion like in several IDEs
inoremap <C-Space> <C-X><C-O>

"noremap <F3> :!sed -e (regex) && doxygen yourproject doc && zip -r release.zip doc src
" Ack
map <leader>a :Ack

nnoremap \1 yypVr=

" Eclim Settings
" ,i imports whatever is needed for current line
nnoremap <silent> \ji :JavaImport<cr>
" ,d opens javadoc for statement in browser
nnoremap <silent> \jd :JavaDocSearch -x declarations<cr>
" ,<enter> searches context for statement
nnoremap <silent> <Leader><cr> :JavaSearchContext<cr>
" ,jv validates current java file
nnoremap <silent> \jv :Validate<cr>
" ,jc shows corrections for the current line of java
nnoremap <silent> \jc :JavaCorrect<cr>
nnoremap <silent> \jm :JavaImportMissing<CR>
nnoremap <silent> \\ :call My_Java_Error_Jumping()<CR>

au BufWrite *.java let b:error_jump_counter=0
fun! My_Java_Error_Jumping() "{{{
    "let g:tlist=map(getloclist(0), 'get(v:val, ''bufnr'')')
    if (b:error_jump_counter == 0)
        let b:error_jump_counter += 1
        ll
    else
        if (len(getloclist(0)) == b:error_jump_counter)
            let b:error_jump_counter = 1
            lr
        else
            let b:error_jump_counter += 1
            lne
        endif
    endif
endfunction
noremap <leader>E :e <C-R>=substitute(expand("%:h"), '.\zs$', '/', '')<CR>

" map <C-\> :e<CR>:exec("tag ".expand("<cword>"))<CR>
" set tags=./tags;$HOME
" for current word search for eclim
" nmap <f9> :exec 'vimgrep /\<'.expand(’<cword>’).'\>/g **/*.xml **/*.java'<CR>
" for vimgrep next and previous result

" Undo in insert mode                                           {{{2
" make it so that if I accidentally press ^W or ^U in insert mode,
" then <ESC>u will undo just the ^W/^U, and not the whole insert
" This is documented in :help ins-special-special, a few pages down
inoremap <C-W> <C-G>u<C-W>
inoremap <C-U> <C-G>u<C-U>

cmap w!! w !sudo tee % >/dev/null

"command wq w | bd

" enable java function folding with \f
nnoremap \f VaBzf

"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
" inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
"             \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
"inoremap <expr> <M-,> pumvisible() ? '<C-n>' :
"\ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

" Folding
noremap <leader>0 :set fdl=0<CR>
noremap <leader>1 :set fdl=1<CR>
noremap <leader>2 :set fdl=2<CR>
nnoremap <silent> <Space> @=(foldlevel('.')?'za':'l')<CR>

" The following beast is something i didn't write... it will return the
" syntax highlighting group that the current "thing" under the cursor
" belongs to -- very useful for figuring out what to change as far as
" syntax highlighting goes.
nmap <silent> <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name")
            \ . '> trans<' . synIDattr(synID(line("."),col("."),0),"name")
            \ . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")
            \ . ">"<CR>

nmap \<tab> :Sscratch<cr><C-W>x<C-W><C-j>:resize 15<cr>

" fugitive
nmap \gs :Gstatus<cr>
nmap \gc :Gcommit<cr>
nmap \ga :Gwrite<cr>
nmap \gl :Glog<cr>
nmap \gd :Gdiff<cr>

" easy filetype switching ツ
nnoremap \st :set ft=typoscript<CR>
nnoremap \sl :set ft=tex<CR>
nnoremap \sh :set ft=html<CR>
nnoremap \sc :set ft=css<CR>
nnoremap \sj :set ft=javascript<CR>
nnoremap \sp :set ft=php<CR>
nnoremap \sw :set ft=mail<CR>
nnoremap \sx :set ft=xml<CR>

command! W :w

nnoremap <ESC>P P'[v']=
nnoremap <ESC>p p'[v']=

" nnoremap <silent> \F :FufEditDataFile<CR>

" command-T configuration
" let g:CommandTCursorStartMap='<leader>f'
" map <silent> <leader>f :CommandTFlush<cr>\|:CommandT<cr>
" map <silent> <leader>gf :CommandTFlush<cr>\|:CommandT %%<cr>
" map <silent> <leader>F :CommandTFlush<cr>\|:CommandT %%<cr>
" map <silent> <leader>b :CommandTBuffer<CR>
" map <leader>gv :CommandTFlush<cr>\|:CommandT app/views<cr>
" map <leader>gc :CommandTFlush<cr>\|:CommandT app/controllers<cr>
" map <leader>gm :CommandTFlush<cr>\|:CommandT app/models<cr>
" map <leader>gh :CommandTFlush<cr>\|:CommandT app/helpers<cr>
" map <leader>gl :CommandTFlush<cr>\|:CommandT lib<cr>
" map <leader>gp :CommandTFlush<cr>\|:CommandT public<cr>
" map <leader>gs :CommandTFlush<cr>\|:CommandT public/stylesheets/sass<cr>
" map <leader>gf :CommandTFlush<cr>\|:CommandT features<cr>
" map <leader>gg :topleft 100 :split Gemfile<cr>
" map <leader>f :CommandTFlush<cr>\|:CommandT<cr>

" vim-fuzzee
" nnoremap <Leader>f :F<Space>
" nnoremap <Leader>t :F */
" cnoremap ,pj  <S-Left>public/javascripts/<End><C-z>
" cnoremap ,,pj public/javascripts/<C-z>

imap <c-l> <space>=><space>

nnoremap <silent> \V :Vimrex<CR>

"removes superfluous blank lines..
map \L :g/^\s*\n\s*$/d<CR>

" Map ,e and ,v to open files in the same directory as the current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%
"map <leader>v :view %%
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

command! KillWhitespace :normal :%s/ *$//g<cr><c-o><cr>

function! OpenChangedFiles()
    only " Close all windows, unless they're modified
    let status = system('git status -s | grep "^ \?\(M\|A\)" | cut -d " " -f 3')
    let filenames = split(status, "\n")
    exec "edit " . filenames[0]
    for filename in filenames[1:]
        exec "sp " . filename
    endfor
endfunction
command! OpenChangedFiles :call OpenChangedFiles()

" In these functions, we don't use the count argument, but the map referencing
" v:count seems to make it work. I don't know why.
function! ScrollOtherWindowDown(count)
    normal! 
    normal! 
    normal! 
endfunction
function! ScrollOtherWindowUp(count)
    normal! 
    normal! 
    normal! 
endfunction
nnoremap g<c-y> :call ScrollOtherWindowUp(v:count)<cr>
nnoremap g<c-e> :call ScrollOtherWindowDown(v:count)<cr>

" GRB: clear the search buffer when hitting return
nnoremap <silent><CR> :nohlsearch<cr>

command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
            \ | wincmd p | diffthis

inoremap <c-cr> <esc>A<cr>

" Search the current file for what's currently in the search register and display matches
nmap <silent> ,gs :vimgrep /<C-r>// %<CR>:ccl<CR>:cwin<CR><C-W>J:nohls<CR>
" Search the current file for the word under the cursor and display matches
nmap <silent> ,gw :vimgrep /<C-r><C-w>/ %<CR>:ccl<CR>:cwin<CR><C-W>J:nohls<CR>
" Search the current file for the WORD under the cursor and display matches
nmap <silent> ,gW :vimgrep /<C-r><C-a>/ %<CR>:ccl<CR>:cwin<CR><C-W>J:nohls<CR>
" Shrink the current window to fit the number of lines in the buffer.  Useful
" for those buffers that are only a few lines
nmap <silent> ,sw :execute ":resize " . line('$')<cr>

nnoremap <leader>s<Space> :%s//g<left><left>

" gary bernhardts stuff for window management
" nnoremap <c-n> :let &wh = (&wh == 999 ? 10 : 999)<CR><C-W>=
" concentrate on the current fold and close all them others
nnoremap <leader>Z zMzv
