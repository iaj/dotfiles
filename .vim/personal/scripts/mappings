"" vim: set filetype=vim : ""
noremap <D-i> :%s/^/> /<CR>:nohl<CR>gg

"fold tags
nnoremap <silent> <F2> :TlistToggle<CR>
nnoremap <silent> <F3> :NERDTreeToggle<CR>
"noremap <silent> <leader>n :NERDTreeToggle<cr>

"make document a textobject - well not really working with registers so not
"a really good choice
"Nnoremap dad ggdG
"Nnoremap yad ggyG
Nnoremap vad ggVG
Nnoremap =ad gg=G
Nnoremap gqad gggqG

"imap ,. <C-o>a
cabbr %% <C-R>=expand('%:p:h')<CR>
"nnoremap <Leader>e :e <C-R>=expand('%:p:h') . '/'<CR>
map <leader>e :e <C-R>=expand("%:h")<cr>/
map <silent> <leader>E :e <C-R>=expand("%:p:h")."/"<CR>


nmap dD "_dd 
"nmap dD :normal 0y$"_dd<CR>
"vmap dD :normal gvygv"_x<CR>
"vmap <BS> :normal gv"_x<CR>
"vmap dC :normal gv"_xP<CR>
"nnoremap dd :normal! dd<CR>
"nnoremap d<Space> :normal! d<CR>

nnoremap <C-w><C-w> <C-w>p
" Map <C-L> (redraw screen) to also turn off search highlighting until the
" next search
"nnoremap <C-L> :nohl<CR><C-L>
nnoremap <silent> <leader><space> :noh<cr>
inoremap <C-L> <C-O>:nohls<CR>
"noremap <C-L> <C-O>:nohls<CR>
nnoremap \dg call WordUnderCursor()
fun! WordUnderCursor() "{{{
    let substr = strpart(getline('.'), -1, col('.')+1)
    let substr = matchstr(substr, "[^ \t]*$")
    echomsg substr
endfunction "}}}

"searching
"nnoremap / /\v
"vnoremap / /\v
"nnoremap <tab> %
"vnoremap <tab> %

map <tab> %
" Pressing an 'enter visual mode' key while in visual mode changes mode.
vmap <C-V> <ESC>`<<C-v>`>
vmap V     <ESC>`<V`>
"vmap v     <ESC>`<v`>
vnoremap v <ESC>

nnoremap Q gq}

" Formatting, TextMate-style
map \q gqip
map \= =ap

" Faster scrolling
nnoremap <C-e> 3<C-e>
nnoremap <C-y> 3<C-y>

" Run Make with ctrl-m or ,m
"map <silent> <leader>m :make<CR>

" Toggle search highlighting
"nnoremap <C-Bslash>       :set hls!<bar>:set hls?<CR>
"inoremap <C-Bslash>       <Esc>:set hls!<bar>:set hls?<CR>a

" FuzzyFinder 
nnoremap <silent> ,A :if &l:nu \| setl rnu \| else \| setl nu \| endif<CR>
"map <silent> ,b :LustyBufferExplorer<CR>
map <silent> <leader>b :FufBuffer<CR>
"map <silent> <leader>b :CommandTBuffer<CR>
"map <silent> <leader>g :LustyBufferGrep<CR>
"map <silent> <leader>B :FufBuffer<CR>
map <silent> <leader>B :FufBookmarkFile<CR>
map <silent> <leader>x :FufBookmarkFile<CR>
map <silent> \B :FufBookmarkDir<CR>
map <silent> <leader>r :FufMruFile<CR>
"map <silent> <leader>x :FufMruCmd<CR>

map <silent> <leader>f :CommandT<CR>
"map <silent> <leader>f :lcd %:h<cr>:pwd<cr><Plug>PeepOpen
"nmap <silent> ,T :CommandTFlush<CR>
"map <silent> <leader>e :LustyFilesystemExplorerFromHere<CR>
map <silent> <leader>t :FufTagWithCursorWord<CR>
map <silent> <leader>T :FufTag<CR>

" and lets make these all work in insert mode too ( <C-O> makes next cmd
" happen as if in command mode )
"imap <C-W> <C-O><C-W>

" use - and + to resize horizontal splits
map - <C-W>-
map + <C-W>+

" Mappings for fast resizing windows
" and for vsplits with alt-< or alt->
map <M-,> 3<C-W><
map <M-.> 3<C-W>>
"map ,o :TToC<cr>
map ,X :he XPTemplate<CR>

"map ,i :.w >> temp.csv<CR>
map <silent> <leader>d :bd<CR>
" Delete all buffers
"nmap <silent> ,da :exec "1," . bufnr('$') . "bd"<cr>
"map <silent> ,l :ls<CR>
map <silent> <leader>ms :messages<CR>
map <silent> <leader>sv :source $HOME/dotfiles/.vimrc<CR>
map <silent> <leader>sm :source /Users/iaj/dotfiles/.vim/personal/scripts/mappings<CR>
map <silent> <leader>sf :source %<CR>

" highlights the current typed word (all occasions)
imap <F2> <esc>:let @/=expand("<cword>") \| set hls<cr>a
nnoremap <leader><leader> <c-^>
"nmap ,, :LustyJugglePrevious<CR>
"map <silent> ,. :LustyJuggler<CR>
nnoremap \v <C-w><C-v><C-l>:e $MYVIMRC<cr>
map <silent> <leader>v :e ~/dotfiles/.vimrc<CR>
"map <silent> ,E :e ~/dotfiles/.vimperatorrc<CR>
map <silent> <leader>z :e ~/dotfiles/.zshrc<CR>
map <silent> <leader>M :e ~/dotfiles/.vim/personal/scripts/mappings<CR>
"cabbr en enew

"cabbr js !js /Users/iaj/bin/js/runjslint.js "`cat %`" \| /Users/iaj/bin/python/format_lint_output.py
"cabbr mg ftp://www.marcgalal.com/httpdocs/fileadmin/
"cnoremap <C-Space> <C-U>e ftp://www.marcgalal.com/httpdocs/fileadmin/
cnoremap jk <C-c>
imap jk <Esc>

"map <Space> <C-f>
"map <S-Space> <C-u>
map <leader>w :set invwrap<cr>:set wrap?<cr>
"nmap ,ccd :lcd %:h<cr>

"ctags settings
"map <F8> :!/usr/bin/ctags -R --c++-kinds=+p --fields=+iaS --extra=+q .<CR>
map <F9> :!/opt/local/bin/ctags --exclude=.svn --exclude=target -R .<CR>
map <Leader>ct :!/opt/local/bin/ctags --exclude=.svn --exclude=target -R .<CR>
"map <F9> :!/usr/bin/ctags -R .<CR>
"exuberant-ctags -R --language-force=java -f.tags /opt/sun-jdk-1.5.0.08/share/
"com! Tags '/Users/iaj/bin/ctags -R --language-force=java -f.tags /System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Classes'

" bachelor arbeit specific (rofl)
"com! Tags '/Users/iaj/bin/ctags -R --language-force=java ~/Documents/workspace'
" Window movement-enhancements - making things easier!
" create a new vertical split window and switch over to it
nnoremap <leader>W <C-w>v<C-w>l
nnoremap <leader>H <C-w>s<C-w>j
" Move the cursor to the window left of the current one
noremap <silent> <leader>h :wincmd h<cr>
" Move the cursor to the window below the current one
noremap <silent> <leader>j :wincmd j<cr>
" Move the cursor to the window above the current one
noremap <silent> <leader>k :wincmd k<cr>
" Move the cursor to the window right of the current one
noremap <silent> <leader>l :wincmd l<cr>
" Close the window below this one
noremap <silent> <leader>cj :wincmd j<cr>:close<cr>
" Close the window above this one
noremap <silent> <leader>ck :wincmd k<cr>:close<cr>
" Close the window to the left of this one
noremap <silent> <leader>ch :wincmd h<cr>:close<cr>
" Close the window to the right of this one
noremap <silent> <leader>cl :wincmd l<cr>:close<cr>
" Close the current window
noremap <silent> <leader>cd :close<cr>
" Move the current window to the right of the main Vim window
noremap <silent> <leader>ml <C-W>L
" Move the current window to the top of the main Vim window
noremap <silent> <leader>mk <C-W>K
" Move the current window to the left of the main Vim window
noremap <silent> <leader>mh <C-W>H
" Move the current window to the bottom of the main Vim window
noremap <silent> <leader>mj <C-W>J
noremap <silent> <C-7> <C-W>>
noremap <silent> <C-8> <C-W>+
noremap <silent> <C-9> <C-W>+
noremap <silent> <C-0> <C-W>>

"nmap <Left> <C-w>h
"nmap <Down> <C-w>j
"nmap <Up> <C-w>k
"nmap <Right> <C-w>l

nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

nnoremap <leader>D :lcd %:h<cr>:pwd<cr>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
"Fuck you 2 manual key ツ
nnoremap K <nop>

nnoremap <silent> gb :bnext<CR>
nnoremap <silent> gB :bprev<CR>

" Spellchecking
nmap <Leader>ss :set nospell<CR>
nmap <Leader>se :set spell spelllang=en<CR>
nmap <Leader>sd :set spell spelllang=de<CR>

" Return to visual mode after indenting
xmap < <gv
xmap > >gv

" awesome, inserts new line without going into insert mode
map <S-Enter> O<ESC>D
" hilight everything in visual mode that was just pasted!
nnoremap <Leader>V '[V']

" no comment lines - we just don't want them sumtimes
nmap go o<Esc>S
nmap gO O<Esc>S

"map <Leader> ss :set nospell!<CR>:set nospell?<CR>
nmap <Leader>ss :set nospell<CR>
nmap <Leader>se :set spell spelllang=en<CR>
nmap <Leader>sd :set spell spelllang=de<CR>
" Spelling
" Quickly add a new spelling abbreviation for the word under cursor to this file.
nmap <C-F6> :let tmp=@f<CR>"fyaw<Esc>:bot split ~/.vimrc<CR>G?LAST_SPELL<CR>zRkoiab<Space><Esc>"fp<Esc>:let @f=tmp<CR>a

" Y behaves like D rather than like dd
nnoremap Y y$

" Backspace should delete to the black hole register, not move left
nnoremap <BS> "_X
nnoremap <Leader>N <Esc>:enew<CR>

" Yankring
"nnoremap <silent> <F11> :YRShow<CR>

" I'm sorry.  :(  Some Emacs bindings for the command window
cnoremap <C-A>     <Home>
cnoremap <ESC>b    <S-Left>
cnoremap <ESC>f    <S-Right>
cnoremap <ESC><BS> <C-W>
cnoremap <C-A>      <Home>
"cnoremap <C-B>      <Left>
cnoremap <C-E>      <End>
"cnoremap <C-F>      <Right>
cnoremap <C-N>      <End>
cnoremap <C-P>      <Up>
cnoremap <ESC>b     <S-Left>
cnoremap <ESC><C-B> <S-Left>
cnoremap <ESC>f     <S-Right>
cnoremap <ESC><C-F> <S-Right>
cnoremap <ESC><C-H> <C-W>

" Extra functionality for some existing commands:
" <C-6> switches back to the alternate file and the correct column in the line.
nnoremap <C-6> <C-6>`"
" CTRL-g shows filename and buffer number, too.
nnoremap <C-g> 2<C-g>

map <F4> :FufLine<CR>
imap <F4> <ESC>:FufLine<CR>
vmap <F4> <ESC><ESC>:FufLine<CR>
"nnoremap <F5> :GundoToggle<CR>

"nmap ,sp :vsp<CR>
" Make [[ and ]] work even if the { is not in the first column
nnoremap <silent> [[ :call search('^\S\@=.*{$', 'besW')<CR>
nnoremap <silent> ]] :call search('^\S\@=.*{$', 'esW')<CR>
onoremap <expr> [[ (search('^\S\@=.*{$', 'ebsW') && (setpos("''", getpos('.'))
            \ <bar><bar> 1) ? "''" : "\<ESC>")
onoremap <expr> ]] (search('^\S\@=.*{$', 'esW') && (setpos("''", getpos('.'))
            \ <bar><bar> 1) ? "''" : "\<ESC>")

" Execute current line 
function! ExecuteLine() 
    let save_reg = @@ 
    normal ^y$ 
    exe @@ 
    let @@ = save_reg 
endfunction 
nnoremap <silent> <leader>i :call ExecuteLine()<CR>

" Warnings:
"inoremap <Esc> <Esc>:echo "You should use Ctrl-[, or rather 'jj'"<CR>
"inoremap <BS> <Esc>:echo "You should use Ctrl-H"<CR>
" Learn your hjkl!
nmap <Left> 	<Esc>:echo "You should have typed h instead"<CR>
nmap <Right> 	<Esc>:echo "You should have typed l instead"<CR>
nmap <Up>	<Esc>:echo "You should have typed k instead"<CR>
nmap <Down> 	<Esc>:echo "You should have typed j instead"<CR>

" Allocate colors with or without # respectively!
"nnoremap <leader>G :hi Normal guibg=#<c-r>=expand("<cword>")<cr><cr>
nnoremap <leader>G :hi Normal guibg=<c-r>=expand("<cword>")<cr><cr>
" this one is specialized for molokai theme
nnoremap <leader>U :hi Normal guifg=#F8F8F2 guibg=#272822<cr>
nnoremap \dd :set dictionary /usr/share/dict/words<CR>

nnoremap j gj
nnoremap k gk

" yet to be verified - Araxa's mischief
"nnoremap :: q:
nnoremap <leader>/ q/
nnoremap ?? q?

" Add semicolon to the end of the line. Thanks to
" http://www.van-laarhoven.org/vim/.vimrc for this idea and godlygeek in #vim
" on Freenode for an improved version which doesn't clobber any marks.
nnoremap <silent> <leader>; :call setline(line('.'), getline('.') . ';')<CR>

noremap <Leader>p "+p
noremap <Leader>y "+y
"only in javafiles !!
noremap \pl :ProjectList<CR>
noremap \pc :ProjectClose
noremap \po :ProjectOpen
"noremap <Leader>d "+d

" word swapping
nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>

" omnicompletion like in several IDEs
inoremap <C-Space> <C-X><C-O>
"noremap <F3> :!sed -e (regex) && doxygen yourproject doc && zip -r release.zip doc src
" char swapping
nmap <silent> gc xph
" Sort 'm CSS properties
map <leader>S ?{<CR>jV/^\s*\}?$<CR>k:sort<CR>:noh<CR>
" Ack
map <leader>a :Ack 
" Rainbows!
nmap <leader>R :RainbowParenthesesToggle<CR>
nnoremap \1 yypVr=

" Eclim Settings
" ,i imports whatever is needed for current line
nnoremap <silent> \ji :JavaImport<cr>
" ,d opens javadoc for statement in browser
nnoremap <silent> \jd :JavaDocSearch -x declarations<cr>
" ,<enter> searches context for statement
nnoremap <silent> <Leader><cr> :JavaSearchContext<cr>
" ,jv validates current java file
nnoremap <silent> \jv :Validate<cr>
" ,jc shows corrections for the current line of java
nnoremap <silent> \jc :JavaCorrect<cr>
nnoremap <silent> \jm :JavaImportMissing<CR>
nnoremap <silent> \\ :call My_Java_Error_Jumping()<CR>

au BufWrite *.java let b:error_jump_counter=0
fun! My_Java_Error_Jumping() "{{{
    "let g:tlist=map(getloclist(0), 'get(v:val, ''bufnr'')')
    if (b:error_jump_counter == 0)
        let b:error_jump_counter += 1
        ll
    else
        if (len(getloclist(0)) == b:error_jump_counter)
            let b:error_jump_counter = 1
            lr
        else
            let b:error_jump_counter += 1
            lne
        endif
    endif
endfunction
noremap <leader>E :e <C-R>=substitute(expand("%:h"), '.\zs$', '/', '')<CR>

"map <C-\> :e<CR>:exec("tag ".expand("<cword>"))<CR>
"set tags=./tags;$HOME
"for current word search for eclim
"nmap <f9> :exec 'vimgrep /\<'.expand(’<cword>’).'\>/g **/*.xml **/*.java'<CR>
"for vimgrep next and previous result
"nmap <c-n> :cn<CR>
"nmap <c-p> :cp<CR>

" damn that ^ thingie, who needs the first column anyhow?
"map 0 ^

" Undo in insert mode                                           {{{2
" make it so that if I accidentally press ^W or ^U in insert mode,
" then <ESC>u will undo just the ^W/^U, and not the whole insert
" This is documented in :help ins-special-special, a few pages down
inoremap <C-W> <C-G>u<C-W>
inoremap <C-U> <C-G>u<C-U>

"cmap w!! w !sudo tee % >/dev/null

"command wq w | bd
" ==================================================
" HTML
" ==================================================
" enable a shortcut for tidy using ~/.tidyrc config
"map <Leader>T :!tidy -config ~/.tidyrc<cr><cr>
"nnoremap <silent> <Leader>T :!tidy -utf8 -m --show-body-only yes %<CR>
"nnoremap <silent> <Leader>T :!tidy -utf8 -m -i %<CR>
" enable html tag folding with \t

" Make selecting inside an HTML tag less dumb
"nnoremap Vit vitVkoj
"nnoremap Vat vatV

" enable java function folding with \f
nnoremap \f VaBzf

"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
            \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
"inoremap <expr> <M-,> pumvisible() ? '<C-n>' :
"\ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'

" Folding
noremap <leader>0 :set fdl=0<CR>
noremap <leader>1 :set fdl=1<CR>
noremap <leader>2 :set fdl=2<CR>
nnoremap <silent> <Space> @=(foldlevel('.')?'za':'l')<CR>

" The following beast is something i didn't write... it will return the
" syntax highlighting group that the current "thing" under the cursor
" belongs to -- very useful for figuring out what to change as far as
" syntax highlighting goes.
nmap <silent> <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name")
            \ . '> trans<' . synIDattr(synID(line("."),col("."),0),"name")
            \ . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")
            \ . ">"<CR>

nmap \<tab> :Sscratch<cr><C-W>x<C-W><C-j>:resize 15<cr>

"rebind my favorite commands from Git.vim for Fugitive
nmap \gs :Gstatus<cr>
nmap \gc :Gcommit<cr>
nmap \ga :Gwrite<cr>
nmap \gl :Glog<cr>
nmap \gd :Gdiff<cr>

" TextMate-Style Autocomplete
"inoremap <ESC> <C-P>
"inoremap <S-ESC> <C-N>

" easy filetype switching ツ
nnoremap \st :set ft=typoscript<CR>
nnoremap \sh :set ft=html<CR>
nnoremap \sc :set ft=css<CR>
nnoremap \sj :set ft=javascript<CR>
nnoremap \sp :set ft=php<CR>
command! W :w

"nnoremap <silent> sj     :FufBuffer<CR>
"nnoremap <silent> sk     :FufFileWithCurrentBufferDir<CR>
"nnoremap <silent> sK     :FufFileWithFullCwd<CR>
"nnoremap <silent> s<C-k> :FufFile<CR>
"nnoremap <silent> sl     :FufCoverageFileChange<CR>
"nnoremap <silent> sL     :FufCoverageFileChange<CR>
"nnoremap <silent> s<C-l> :FufCoverageFileRegister<CR>
"nnoremap <silent> sd     :FufDirWithCurrentBufferDir<CR>
"nnoremap <silent> sD     :FufDirWithFullCwd<CR>
"nnoremap <silent> s<C-d> :FufDir<CR>
"nnoremap <silent> sn     :FufMruFile<CR>
"nnoremap <silent> sN     :FufMruFileInCwd<CR>
"nnoremap <silent> sm     :FufMruCmd<CR>
"nnoremap <silent> su     :FufBookmarkFile<CR>
"nnoremap <silent> s<C-u> :FufBookmarkFileAdd<CR>
"vnoremap <silent> s<C-u> :FufBookmarkFileAddAsSelectedText<CR>
"nnoremap <silent> si     :FufBookmarkDir<CR>
"nnoremap <silent> s<C-i> :FufBookmarkDirAdd<CR>
"nnoremap <silent> st     :FufTag<CR>
"nnoremap <silent> sT     :FufTag!<CR>
"nnoremap <silent> s<C-]> :FufTagWithCursorWord!<CR>
"nnoremap <silent> s,     :FufBufferTag<CR>
"nnoremap <silent> s<     :FufBufferTag!<CR>
"vnoremap <silent> s,     :FufBufferTagWithSelectedText!<CR>
"vnoremap <silent> s<     :FufBufferTagWithSelectedText<CR>
"nnoremap <silent> s}     :FufBufferTagWithCursorWord!<CR>
"nnoremap <silent> s.     :FufBufferTagAll<CR>
"nnoremap <silent> s>     :FufBufferTagAll!<CR>
"vnoremap <silent> s.     :FufBufferTagAllWithSelectedText!<CR>
"vnoremap <silent> s>     :FufBufferTagAllWithSelectedText<CR>
"nnoremap <silent> s]     :FufBufferTagAllWithCursorWord!<CR>
"nnoremap <silent> sg     :FufTaggedFile<CR>
"nnoremap <silent> sG     :FufTaggedFile!<CR>
"nnoremap <silent> so     :FufJumpList<CR>
"nnoremap <silent> sp     :FufChangeList<CR>
"nnoremap <silent> sq     :FufQuickfix<CR>
"nnoremap <silent> sy     :FufLine<CR>
"nnoremap <silent> sh     :FufHelp<CR>
"nnoremap <silent> se     :FufEditDataFile<CR>
"nnoremap <silent> sr     :FufRenewCache<CR>
nnoremap <silent> \F :FufEditDataFile<CR>

let g:CommandTCursorStartMap='<leader>f'
map <leader>f :CommandTFlush<cr>\|:CommandT<cr>
map <leader>gf :CommandTFlush<cr>\|:CommandT %%<cr>

nnoremap <silent> \V :Vimrex<CR>
"removes superfluous blank lines..
map \L :g/^\s*\n\s*$/d<CR>
map ; :
" Map ,e and ,v to open files in the same directory as the current file
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>e :edit %%
"map <leader>v :view %%
function! RenameFile()
    let old_name = expand('%')
    let new_name = input('New file name: ', expand('%'))
    if new_name != '' && new_name != old_name
        exec ':saveas ' . new_name
        exec ':silent !rm ' . old_name
        redraw!
    endif
endfunction
map <leader>n :call RenameFile()<cr>

command! KillWhitespace :normal :%s/ *$//g<cr><c-o><cr>
"imap <c-l> <space>=><space>

function! OpenChangedFiles()
    only " Close all windows, unless they're modified
    let status = system('git status -s | grep "^ \?\(M\|A\)" | cut -d " " -f 3')
    let filenames = split(status, "\n")
    exec "edit " . filenames[0]
    for filename in filenames[1:]
        exec "sp " . filename
    endfor
endfunction
command! OpenChangedFiles :call OpenChangedFiles()

" In these functions, we don't use the count argument, but the map referencing
" v:count seems to make it work. I don't know why.
function! ScrollOtherWindowDown(count)
    normal! 
    normal! 
    normal! 
endfunction
function! ScrollOtherWindowUp(count)
    normal! 
    normal! 
    normal! 
endfunction
nnoremap g<c-y> :call ScrollOtherWindowUp(v:count)<cr>
nnoremap g<c-e> :call ScrollOtherWindowDown(v:count)<cr>

" GRB: clear the search buffer when hitting return
nnoremap <silent><CR> :nohlsearch<cr>
