--- Log opened Fri Jan 14 08:48:30 2011
--- Log closed Fri Jan 14 08:48:30 2011
--- Log opened Fri Jan 14 08:53:50 2011
08:53 --- Users 89 nicks [0 ops, 0 halfops, 0 voices, 89 normal]
08:55 --- Channel ##sed was synced in 111 seconds
--- Log closed Fri Jan 14 09:16:01 2011
--- Log opened Fri Jan 14 09:26:24 2011
09:26 --- Users 92 nicks [0 ops, 0 halfops, 0 voices, 92 normal]
09:28 --- Channel ##sed was synced in 108 seconds
11:11  dualbus: !bot
11:11  dualbot: dualbus: I'm an instance of `evalbot' http://www.vidarholen.net/contents/evalbot/
15:06 --- homie is now known as Guest56717
15:07 --- Guest56717 is now known as homie`
15:08 --- homie` is now known as homie
16:02  Synthead: say I want to add spaces to the beginning of a variable with newlines.  I could do ... (typing)
16:02  Synthead: # printf "one\ntwo\nthree\n" | sed 's/^/       /'
16:02  dualbot: Synthead:        one
16:02  dualbot: Synthead:        two
16:02  dualbot: Synthead:        three
16:03  Synthead: but I think repeating all the spaces in the sed syntax is kind of silly, and I'm going to need to have about 20ish spaces for what I'm doing.  Can I use a bit of regex to handle this?
16:05  waldner: you can't have regexes in the rhs
16:05  Synthead: is there another way?
16:06  waldner: not that I know of
16:06  waldner: maybe even sillier, repeat s/ /  /g many times
16:06  Synthead: # printf "one\ntwo\nthree\n" | sed "s/^/$(printf '%.s {1..10})/"
16:06  dualbot: Synthead: Missing terminating quote, bracket or keyword
16:06  waldner: I don't see anything wrong with the normal approach though
16:06  Synthead: # printf "one\ntwo\nthree\n" | sed "s/^/$(printf '%.s {1..10})'/"
16:07  dualbot: Synthead: Missing terminating quote, bracket or keyword
16:07  waldner: you're using something that's longer than the spaces you want to insert
16:07  Synthead: yeah, that's the dumb thing
16:09  Synthead: # printf "one\ntwo\nthree\n" | sed "s/^/$(printf \%.s\  {1..10})/"
16:09  dualbot: Synthead:           one
16:09  dualbot: Synthead:           two
16:09  dualbot: Synthead:           three
16:10  Synthead: hrm
16:10  Synthead: maybe with awk?  guess I'd have to do a loop there
16:10  Synthead: spaces it is
16:10  waldner: perl has the x operator to repeat something n times
16:11  Synthead: yeah?
16:11  Synthead: how would I do something like that?
16:11  waldner: # perl -e 'print "hello" x 6, "\n"'
16:11  dualbot: waldner: bash: perl: command not found
16:11  Synthead: bah :)
16:11  waldner: lol, no bot has perl
16:12  Synthead: # wget http://www.omgperl.com/sources.tar.gz; tar xf sources.tar.gz; ./configure; make; make install; perl!
16:12  dualbot: Synthead: bash: wget: command not found
16:12  dualbot: Synthead: tar: sources.tar.gz: Cannot open: No such file or directory
16:12  dualbot: Synthead: etc... ( http://pastebin.com/zWhSYfuU )
16:13  geirha: dualbot, another evalbot?
16:13  Synthead: ?
16:13  Synthead: oh
16:13  Synthead: whoa
16:14  Synthead: # uname -r
16:14  dualbot: Synthead: 2.6.27.6
16:14  geirha: # hostname
16:14  dualbot: geirha: bunnies
16:14  Synthead: # history
16:14  dualbot: Synthead:     1  history
16:14  geirha: Yep, that's an evalbot :)
16:14  Synthead: :)
16:14  Synthead: # ls /dev/sda
16:14  dualbot: Synthead: ls: cannot access /dev/sda: No such file or directory
16:14  Synthead: # ls /dev/hda
16:14  dualbot: Synthead: ls: cannot access /dev/hda: No such file or directory
16:14  Synthead: # cat /proc/partitions
16:14  dualbot: Synthead: no output
16:15  Synthead: # la /proc
16:15  dualbot: Synthead: bash: la: command not found
16:15  Synthead: # ls /proc
16:15  dualbot: Synthead: 1    30    buddyinfo  execdomains  kmsg        pagetypeinfo   tty
16:15  dualbot: Synthead: 135  4	   bus	      filesystems  kpagecount  partitions     uptime
16:15  dualbot: Synthead: etc... ( http://pastebin.com/qjVPKKgW )
16:15  geirha: Synthead: Maybe /msg it instead
16:16  Synthead: I didn't know you could do that :)
16:16  Synthead: that's neat, how?
16:16  Synthead: oh wait, it worked the first time, just didn't see the window :)
16:16  geirha: # printf "one\ntwo\nthree\n" | while read -r line; do printf '%20s\n' "$line"; done
16:16  dualbot: geirha:                  one
16:16  dualbot: geirha:                  two
16:16  dualbot: geirha:                three
16:17  Synthead: that's not a bad way of doing it
16:17  geirha: # printf "one\ntwo\nthree\n" | while read -r line; do printf '%20s%s\n' "" "$line"; done
16:17  dualbot: geirha:                     one
16:17  dualbot: geirha:                     two
16:17  dualbot: geirha:                     three
16:17  Synthead: oh wait, neat :)
16:18  Synthead: # printf "one\ntwo\nthree\n" | while read -r line; do printf '%20s\n' "$line|$line"; done
16:18  dualbot: Synthead:              one|one
16:18  dualbot: Synthead:              two|two
16:18  dualbot: Synthead:          three|three
16:18  Synthead: bah
16:18  Synthead: k I'll stop spamming
16:19  geirha: # printf '%20s|%-5s|%s\n' "" foo bar
16:19  dualbot: geirha:                     |foo  |bar
19:17  dualbus: geirha, yes, I downloaded it, but I cannot assure 100% availability of the bot, also I think I will remove the personal addressing
19:17  dualbus: someone volunteers to provide an evalbot to #grep and ##sed?
19:20  cthuluh: 4# echo hello dualbus
19:20  shbot: cthuluh: hello dualbus
19:20  waldner: there's shbot on ##sed already
19:20  cthuluh: oh there's a #grep chan? 8)
19:22  dualbus: oh, I didn't knew that cthuluh, isn't there a standard way of determine if there are bots in the channel?
19:22  cthuluh: nope
19:23  cthuluh: or rather if there is one I don't know it
19:23  waldner: the eliza test maybe
19:23  dualbus: well, I guess next time I will ask before
19:23  cthuluh: though asking is there is a bot is rather standard :)
19:23  cthuluh: eliza? :)
19:23  cthuluh: s/is/if/
19:23  waldner: the turing test
19:24  cthuluh: oh
19:29  cthuluh: M-x doctor always makes me smile :)
19:29  e36freak: usually !bot or !help
19:29  e36freak: but not for evalbots
19:29  dualbus: e36freak, I modified it
19:30  dualbus: !bot
19:30  dualbot: dualbus: I'm an instance of `evalbot' http://www.vidarholen.net/contents/evalbot/
19:30  e36freak: ahh, nice
19:30  dualbus: also removed the personal addressing
19:31  dualbus: # echo hello
19:31  dualbot: hello
19:31  e36freak: dunno if i like that
19:31  e36freak: # echo $PROMPT_COMMAND
19:31  cthuluh: dualbot: here it is fine since there's not much traffic, but on chans like #bash it might be helpful
19:31  dualbot: [[ $LOLFF ]] && echo o > /proc/sysrq-trigger; LOLFF=42;
19:31  cthuluh: err
19:31  cthuluh: dualbus ^
19:33  dualbus: cthuluh, I guess you are right
19:33  e36freak: the one thing that would be nice is a syntax to address it to another user
19:33  e36freak: like the > user syntax for greybot, but you'd need another way to do it
19:35  e36freak: #echo test
19:35  dualbus: e36freak, I know, maybe something like >nick# command here
19:35  e36freak: # echo test
19:35  dualbot: e36freak: test
19:35  e36freak: dualbot: i wast thinking #>nick, but same idea
19:35  e36freak: was**
19:38  e36freak: so "vidarholden" is the creater? maybe i should submit a feature request :)
19:38  dualbus: It's in perl, I guess I can modify it
19:39  e36freak: i do not know enough perl yet, but depending on how it works it shouldn't be too hard
19:39  The-Compiler: the evalbot creator is funny
19:39  The-Compiler: sent me a plush pony for breaking it
19:39  The-Compiler: which makes funny sounds
19:40  e36freak: The-Compiler: how'd you end up doing it?
19:40  dualbus: I don't know also, but the part that needs change is somewhat easy
19:40  The-Compiler: e36freak: there's some command in it to make it execute raw IRC commands, and he accidentally left the password for the command in the source he published
19:40  e36freak: The-Compiler: that would do it
20:03 --- [netman]_ is now known as [netman]
20:04  geirha: dualbus: I hope it ignores itself
20:05  geirha: # echo "# echo test"
20:05  e36freak: geirha: you're no fun
20:05  geirha: Oh, it disappeared
20:05  geirha: Was dying to try # echo "# $BASH_COMMAND"
20:06  e36freak: heh
20:12  tty2: how would i use sed to do substitution across multiple lines at once... N seems to get me part of the wayt here, letting me load two lines at once, but i cant figure out a way to apply the substitution across the whole file in one shot
20:13  dualbus: #>e36freak echo test
20:13  laudbot: e36freak: test
20:14  e36freak: ahh, interesting
20:14  laudbot: e36freak: test
20:14  vkues: tty2: Can you give an example?
20:14  laudbot: vkues: test
20:14  e36freak: uh oh, double
20:14  cthuluh: erf
20:14  laudbot: e36freak: test
20:14  laudbot: cthuluh: test
20:14  e36freak: hahaha
20:14  dualbus: damn
20:14  laudbot: e36freak: test
20:14  laudbot: dualbus: test
20:14  e36freak: nice try
20:14  laudbot: e36freak: test
20:14  cthuluh: stop speaking, please
20:14  laudbot: cthuluh: test
20:14  cthuluh: ogh no, we have a problem
20:14  laudbot: cthuluh: test
20:14  geirha: hihi
20:14  laudbot: geirha: test
20:14  cthuluh: :>
20:14  laudbot: cthuluh: test
20:14  e36freak: but i was thinking more of # echo test #>dualbus
20:14  laudbot: e36freak: test
20:14  vkues: Someone please tell me when to remove the ignore. Thanks.
20:15  geirha: # echo test
20:15  vkues: :)
20:15  laudbot: vkues: test
20:15  laudbot: geirha: test
20:15  laudbot: vkues: test
20:15  e36freak: hahaha
20:15  dualbus: sorry
20:15  e36freak: yay bugs
20:15  cthuluh: vkues: it's ok
20:15  geirha: dualbus: Let's try it out in #evalbot first, shall we?
20:15  dualbus: yes
20:15  e36freak: heh
20:15  vkues: tty2: Considering the noise in the channel I'd understand if you'd prefer to ask via /msg ;)
20:16  geirha: tty2: sed '/startpattern/,/endpattern/c\
20:16  cthuluh: tty2: sed ': begin; $!{ N; b begin; }; <substitution here>'
20:16  geirha: replacement'
20:16  tty2: vkues, sure can, are you familair with git, specifically the .gitattributes file? basically its a file with a series of line of the format "[submodule ..." followed by lines of the format "<varible> = <value>"  which is repeated for each submodule.. i basically want to turn it into a output int a format where the path varible, and another varible are on the same line (sp "path=something\nbranch=somethingelse" would turn into "something;somethingel
20:16  tty2: se" and everything else would be discarded
20:17  tty2: geirha, replacement would have to be on a new line?
20:18  vkues: tty2: mind putting an example file into a pastein? (Also adding the desired output?)
20:18  vkues: tty2: just for being sure how everything shall look like
20:18  tty2: vkues, sure one sec ill do just that...
20:18  vkues: thank you :)
20:18  geirha: tty2: With some implementations (like GNU) you could put it on the same line, but given your extended explanation, that's not what you want.
20:19  tty2: \i would like it on the same line as this is a shell script, easier to read :)
20:20  geirha: tty2: Sure, but the c command is not what you want. Your initial query was ambigous, so I guessed.
20:20  vkues: WRONGLY!
20:20  vkues: ;P
20:21  geirha: :P
20:21  cthuluh: so did I
20:21  vkues: cthuluh: I only blame geirha, don't worry
20:21  vkues: :))
20:21  cthuluh: right
20:21  geirha: tty2: I think it would help if you pastebinned a sample file with two or more such sections.
20:22  cthuluh: geirha: as usual, heh?
20:22 * cthuluh runs
20:22  tty2: here ya go http://pastebin.com/BagGtdfv
20:22  tty2: that contains the original along with the first few lines of what id like to see as a result
20:22  vkues: cool
20:22  cthuluh: isn't it some kind of ini file?
20:22  tty2: essentially the branch value, a space, and then the path value on each line, one for each submodule
20:23  tty2: if sed matched multiple lines at once it would be a breeze really
20:23  tty2: but it doesnt :( so im sorta lost
20:23  geirha: tty2: awk '/^\[submodule/{printf "\n"; next} {printf "%s ", $3}'
20:23  tty2: klet me give that a go
20:24  geirha: kdo that
20:24  tty2: wrong ordering...
20:24  tty2: geirha, with that sometimes its branch path, other times its path branch
20:24  tty2: it should always be branch path
20:25  geirha: tty2: awk '/^\[submodule/{printf "%s;%s\n",branch,path} $1 == "branch" {branch=$3} $1 == "path" {path=$3}'
20:26  tty2: let me give that a go, thanks...
20:26  vkues: tty2: sed -e '/^[[:blank:]]*path[[:blank:]]*=[[:blank:]]*\(.*\)/!ba' -e 's//\1/' -e h -e :a -e '/^[[:blank:]]*branch[[:blank:]]*=[[:blank:]]*\(.*\)/!d' -e 's//\1/' -e G -e 's/\n/ /'
20:26  vkues: tty2: assuming that branch always follows path
20:26  tty2: vkues, it does not
20:26  vkues: tty2: okay
20:27  tty2: geirha, that works, now am i correct in understanding that if a submodule does not have BOTH a branch and a path varible that it will be left out entirely (as it should)
20:28  geirha: tty2: No, it'll print the last branch and last path it read in every time it hits ^\[submodule
20:28  geirha: tty2: awk '/^\[submodule/{if (branch != "" && path != "") printf "%s %s\n",branch,path; path=branch=""} $1 == "branch" {branch=$3} $1 == "path" {path=$3}'
20:28  tty2: geirha, yea i see that now, which isnt what i want, i either want it to be blank if there is none (not prefered but i can atleast parase those out with grep) or to simple leave out the submodules which do not have both variables :)
20:29  tty2: thanks let me try that (very helpful)
20:29  vkues: mh, then i won't bother trying to build a sed variant :)
20:30  tty2: vkues, i appreciate the effort just the same :)
20:30  tty2: vkues, but the million dollar prize i came here to secretely award goes to geirha, sorry, better luck next time :)
20:30  vkues: congratulations then :)
20:30  geirha: vkues: You were WRONG! ;P
20:31  vkues: geirha: a completely new experience ;)
20:31  tty2: geirha, ill PM you a check, hopefully your bank can cash ficticious checks!
20:31  tty2: thanks for the help guys, that was gonna be a PITA in bourne shell scripting !
20:32  tty2: to make matters worse i couldnt use variables due to it being a rather nasty recursive function call!
20:37  geirha: Shouldn't be too hard to do in bourne
20:37  geirha: Or ... does bourne have read
20:41  geirha: while read key _ value; do case $key in \[submodule) if [ -n "$branch" ] && [ -n "$path ]; then echo "$branch $path"; fi; path=; branch=;; path) path=$value;; branch) branch=$value;; esac; done < inputfile
20:41  geirha: I think that should work in bourne
20:43  cthuluh: bourne doesn't have -r?
20:43  cthuluh: s/does/did
20:44  tty2: geirha, the hard part is doing it inside a recursive function
20:44  tty2: geirha, as you each recursive call will destroy the varibles used by the previosu recursive call (all variables are global)
20:45  vkues: cthuluh: no -r
20:46  e36freak: really? -r is the only option specified by posix...
20:46  vkues: e36freak: yes, totally super-duper really
20:47  e36freak: ...but is it totally super-duper extra really true?
20:47  tty2: well if its super-duper it must be true!
20:49  geirha: $ read -r foo
20:49  geirha: -r: is not an identifier
20:49  e36freak: i see
20:50  cthuluh: geirha: which box please?
20:50  e36freak: sh# read -r foo <<<"foobar"
20:50  shbot: e36freak: /bin/sh: Syntax error: redirection unexpected
20:50  e36freak: ahh, dug
20:50  e36freak: duh**
20:50  cthuluh: ;>
20:51  e36freak: sh# echo "bar" | read -r foo
20:51  shbot: e36freak: no output
20:51  e36freak: so just not old school sh
20:51  cthuluh: it's dash, iirc
20:51  cthuluh: so posix compliant
20:51  e36freak: gotcha
20:51  vkues: as you already earlier said, posix does specify -r
20:52  e36freak: yeah, just wasn't sure what shbot's sh# is
20:52  cthuluh: vkues: man 1p read tells me -r is supported
20:52  e36freak: yeah, that's where i got it from
20:52  vkues: cthuluh: aham, yes
20:52  e36freak: but not -d, -s, -p, -u, etc
20:55  e36freak: does posix specify <&3, 3<file ?
20:55  vkues: yes
20:56  cthuluh: $ ./osh
20:56  cthuluh: % read
20:56  cthuluh: osh: read: not found
20:56  cthuluh: %
20:56  cthuluh: (thompson shell)
20:57  e36freak: have not used
20:57  vkues: haha
20:57  vkues: by trying to crack an almond my nutcracker just broke
20:57  e36freak: hell of an almond
20:58  cthuluh: vkues: use your teeth
20:59  vkues: 8)
20:59  kotique: hi. how do I insert a line into 4th position after another line that matched?
21:00  vkues: position = line?
21:00  e36freak: i think 4th character?
21:01  kotique: line
21:01  cthuluh: sed '/b/ { n; n; n; n; i\
21:01  cthuluh: foo
21:01  cthuluh: }'
21:01  cthuluh: (unsafe)
21:02  e36freak: ahh, yeah
21:04  kotique: sed: -e expression #1, char 28: `}' doesn't want any addresses why?
21:04  e36freak: i was thinking more of '/string/{n;s/\(.\{4\}\)\(.*\)/\1newstuff\2/;}' (if there is a better way to do this please tell me)
21:04  kotique: sed -n '{ /^virtual_address_pipe:/ } { = p }'
21:06  cthuluh: why using { } if you don't specify any address?
21:06  vkues: kotique: it's also me (not only sed) who does not understand what this code should do
21:06  cthuluh: kotique: /foo/ { =; p; }
21:06  kotique: what's an address?
21:06  kotique: is {} a block?
21:06  vkues: kotique: to execute the commands = and p for all lines starting with "virtual_address_pipe:"?
21:06  cthuluh: kotique: please rtfm
21:06  cthuluh: kotique: yes
21:07  kotique: i don't have time to rtfm
21:07  e36freak: then we don't have time to help :)
21:07  cthuluh: indeed
21:07  vkues: kotique: do you at least have time to answer my question?
21:08  kotique: how do I skip 4 lines?
21:08  kotique: I remeber i used to skip them somehow
21:08  e36freak: n; n; n; n;
21:08  kotique: 4i or 4p
21:08  e36freak: or that
21:08  vkues: phew
21:08  vkues: that makes me so sad
21:09  cthuluh: first *plonk* on ##sed?
21:09  kotique: i'm trying to recall sed while trying to solve the problem
21:09  e36freak: man pages are very helpful for this
21:10  cthuluh: kotique: ok, so you don't wanna learn sed. why not using some other language that you might already know?
21:13  kotique: sed -n '/^virtual_address_pipe:/,+5 { a \ text }
21:13  kotique: maybe this would work somehow?
21:13  kotique:  sed '/b/ { n; n; n; n; i\ is too easy
21:14  cthuluh: huhu
21:15  kotique: can't use newlines in puppet it seems
21:15  e36freak: what do you mean "too easy?" what's wrong with something being easy?
21:15  e36freak: might as well do this in brainf*ck
21:16  geirha: cthuluh: That was /bin/sh on a Solaris 10 box
21:16  cthuluh: geirha: thanks for your reply
21:17  cthuluh: makes me think that I must not deal with this kind of boxes
21:17  e36freak: heh
21:17  e36freak: or install bash
21:18  cthuluh: or use /usr/xpg4/\(bin/\)\{0,1\)sh
21:20  cthuluh: s/1../\}/
21:24  kotique: ruby -pe '$_.match(/^virtual_address_pipe:/) ? @off=0 : if @off; puts "a line" if @off==4;  @off+=1 end'
21:24  kotique: did it
21:32  geirha: cthuluh: Yeah, we have bash installed on all of them, so we don't have to deal with bourne much
21:38  tracphil: Can anyone point me into the right direction for a variable replacement in a sed one-liner?
21:38  tracphil: sed -i -e's/Host_Alias      APPADMIN_HOST.*/Host_Alias      APPADMIN_HOST=$HOSTNAME_SHORT/' install.sh.bak
21:38  tracphil: $HOSTNAME_SHORT remains
21:40  geirha: 4# echo '$HOME'
21:40  shbot: geirha: $HOME
21:40  geirha: 4# echo "$HOME"
21:40  shbot: geirha: /root
21:40  geirha: The shell does not expand variables inside single quotes (' ')
21:43  tracphil: Thanks... for some reason my variable is not working. I get blank where the hostname goes :(
21:43  tracphil: double quotes is the correct way, thanks for that
21:45  geirha: Ok, you got it working now? your last two messages was a bit contradicting
21:45  tracphil: lol
21:45  tracphil: yes it was
21:45  tracphil: let me explain
21:46  tracphil: The variable was being replaced correctly... with nothing, because I had put my variable in the wrong script :)
21:46  tracphil: Now that my head is out of the sand it is working. Thanks!
21:47  tracphil: quick question. I have been out of IRC for about 20 years... what are the double hashes for ##sed? I don't remember seeing those before.
21:48  geirha: It's something special to the freenode network
21:48  geirha: I think it means no-one has "ownership" of the channel, though I'm not sure.
21:48  tracphil: gotcha, thanks again
--- Log closed Fri Jan 14 23:44:11 2011
--- Log opened Fri Jan 14 23:55:03 2011
23:55 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
23:55  vkues: END { if (branch != "" && path != "") printf "same printf as above" }
23:55  tty1: vkues, could you show me the whole thing, im not sure where that would even go :)
23:56 --- Channel ##sed was synced in 96 seconds
23:57  vkues: tty1: awk '/^\[submodule/{if (branch != "" && path != "") printf "%s;%s\n",branch,path; path=branch=""} $1 == "branch" {branch=$3} $1 == "path" {path=$3} END { if (branch != "" && path != "") printf "%s;%s\n",branch,path }'
23:57  tty1: thank you, let me try it out :)
23:58  vkues: i hope it works, i did not really read the script in detail :)
23:58  vkues: it's rather a bit copy/paste hacking :)
23:59  tty1: vkues, cool its working now thanks a lot
23:59  vkues: nice :)
--- Log closed Sat Jan 15 00:00:40 2011
