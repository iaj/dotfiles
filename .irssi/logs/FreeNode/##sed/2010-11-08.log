--- Log opened Mon Nov 08 00:00:15 2010
00:00 --- Channel ##sed was synced in 118 seconds
--- Log closed Mon Nov 08 01:53:02 2010
--- Log opened Mon Nov 08 02:03:28 2010
02:03 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
02:05 --- Channel ##sed was synced in 119 seconds
05:06  fahmad: can some one tell me how can i go to line numbers if i take them using sed -n and then i want to get 5 more lines after that line number ...
05:07  yitz_: Try not cross-posting, fahmad
05:09  fahmad: yitz_: sorry
05:19  jwillia3: fahmad, sed -n '10,15p'
--- Log closed Mon Nov 08 05:59:24 2010
--- Log opened Mon Nov 08 05:59:49 2010
05:59 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
06:00  fahmad: ok
06:02 --- Channel ##sed was synced in 186 seconds
07:27  live: hey #sed
07:29  live: dumb question: is there a way to get "exit status" from a pattern match in sed?  e.g. grep has the -q switch.  the shell has "read".  sed has conditional loops.  but is there an easy way to get a 0/1 exit status?
07:35  jwillia3: live, to do what?
11:18  kwtm: Hi! Need help with regex.  How do I say, "change all occurrences of A into B, but only in the second half of the line where it occurs after C"?  For example, I want to change "AA C AA" into "AA C BB", and "AAAA C AAAA" into "AAAA C BBBB".
11:20  waldner: is the number of A's variable or is it known in advance?
11:22  kwtm: waldner: Variable, unfortunately, or else I could use s/A/B/some number, right?  Yeah, I thought of that, too. :(
11:52  waldner: but is the structure always "<some As> C <some Bs>" ?
11:52  waldner: er, <some As> at the end
12:17  kwtm: There will be other characters, as in "A def A ghi A   C    A def A ghi A".
12:17  waldner: but only one "C"?
12:17  kwtm: I actually ended up doing it manually in a rather non-elegant way with some premade scripts I had, but eventually I'll need to do it with automated script.
12:18  kwtm: waldner: C is a string of characters of my own choosing.  I'll give you the background:
12:18  waldner: try sed ':a;s/\(C.*\)A/\1B/;ta'
12:19  kwtm: Here are more details: The text is a list of filenames with spaces.  I want create a script to rename all the files with spaces replaced with underscore "_".
12:19  waldner: man rename
12:19  kwtm: So, first I so %s/^\(.*\)$/mv "\1" "\1"/, which changes (say)   This Filename Has Spaces.txt  to  mv "This Filename Has Spaces.txt" "This Filename Has Spaces.txt"
12:19  kwtm: But then I have to change the second "This Filename Has Spaces.txt" to "This_Filename_Has_Spaces.txt"
12:19  kwtm: Wups, that command %s should be just plain s
12:20  waldner: so why don't you change spaces to _ first, and add mv later?
12:20  kwtm: rename?  Seriously?  I thought it was "mv"...
12:20  waldner: or mmv also
12:20  kwtm: I can certainly add mv later.  But the thing is, there are two occurrences of "This Filename Has Spaces.txt", and I want to change only on the second of that occurrence --for each line.
12:21  waldner: first, take the original name, change the " " to _
12:21  waldner: then add "mv originalname" in front
12:21  waldner: but much much better is use dedicated rename tools
12:30  geirha: See http://mywiki.wooledge.org/BashFAQ/030 for several ways to do that.
14:31  bezourox: Hi, I would like to erase a line to rewrite a new line, can you help me ?
14:35  bezourox: sed "/.*<domains>/s|\(.*[^<]*\)<.*|\1 $newchaine<\domains>|" /cf/conf/config.xml > /cf/conf/result
14:35  bezourox: this command add $newchain
14:35  bezourox: but not erase the the old
14:36  bezourox: before execute my commande, file "config.xml" contains <domains>google.fr</domains>
14:37  bezourox: $newchain=<domains>google.fr test.com coucou.de</domains>
14:37  bezourox: I excute my command line, and the result is
14:37  bezourox: <domains>google.fr google.fr test.com coucou.de</domains>
15:02  bezourox: anyone to help me ?
15:22  guther: 4# foo="NEW URL";echo "foo<domain>old URL<\domain>bar" | sed -r "s/(>)[^<]*/\1$foo/"
15:22  shbot: guther: foo<domain>NEW URL<\domain>bar
15:23  bezourox: Hi guther
--- Log closed Mon Nov 08 18:38:51 2010
--- Log opened Mon Nov 08 18:39:00 2010
18:39 --- Users 101 nicks [0 ops, 0 halfops, 0 voices, 101 normal]
18:40 --- Channel ##sed was synced in 117 seconds
19:07  Synthead: is there a more elegant way of doing  sed -e '/<state>/!d' -e 's%.*<.*>\(.*\)<.*>.*%\1%' | sed -r 's%(^.|.)%\U&%' ?
19:08  Synthead: I would love to put the two together :)
--- Log closed Mon Nov 08 19:21:43 2010
--- Log opened Mon Nov 08 19:26:57 2010
19:26 --- Users 104 nicks [0 ops, 0 halfops, 0 voices, 104 normal]
19:28 --- Channel ##sed was synced in 107 seconds
--- Log closed Mon Nov 08 22:08:36 2010
