--- Log opened Thu Dec 09 00:00:18 2010
00:03  craiggle1: oh thanks.
00:04  craiggle1: sorry to bother you but could you make the sed for me cthuluh, just im in a rush. thanks.
00:05  cthuluh: well, don't you have the answer?
00:06  cthuluh: sure, I'm willing to help
00:06  cthuluh: but here you have everything you need
00:08  craiggle1: so should i be using exactly what you said or.. ([[:digit:]]{1,})
00:09  cthuluh: what I said, plus what you deduced yourself: \1 instead of $1
00:10  craiggle1: sed 's/id: ([[:digit:]]{1,}) name: (.{1,})/_id.put("\1", "\2");/i' Item\ Codes.txt Item\ Codes.txt .. this isn't working... yeah sorry for being a noob ill get around to learning sed later i just want a quick and easy file modification.
00:11  cthuluh: ok so you aren't listening to me, and are trying random commands
00:11  cthuluh: I won't help you giving you a solution
00:13  craiggle1: I'm sorry I was in a rush.
00:13  craiggle1: Right, i'll liste.n
00:14  cthuluh: why are you stripping the backslashes off of what I said? you don't like backslashes? :)
00:14  craiggle1: oh sorry. heh.
00:14  craiggle1: i thought they werent needed...for some reason.
00:15  cthuluh: they are
00:15  cthuluh: then you're passing a flag to you sed 's///' command
00:15  cthuluh: what is it supposed to do?
00:15  cthuluh: (the flag is 'i' here)
00:16  craiggle1: case insensitive i was hoping for.
00:16  craiggle1: but thanks, its getting teher.
00:16  cthuluh: hmm, dunno this flag
00:16  cthuluh: you can achieve case insensitivity easily
00:17  cthuluh: writing '[aA]' instead of 'a'
00:17  cthuluh: (as an example)
00:18  cthuluh: the you're giving twice the same file name to sed. why?
00:18  cthuluh: then*
00:18  cthuluh: do you really want to parse the file twice?
00:18  craiggle1: oh, no.
00:18  craiggle1: from a tut i thought the params were old file new file
00:19  craiggle1: i need some help getting the right sed.
00:19  craiggle1: http://pastie.org/1360550
00:21  craiggle1: i want it in the form _id.put("\2", "\1");
00:21  cthuluh: ok
00:21  cthuluh: is that your input data?
00:21  cthuluh: or the result of your sed command?
00:22  cthuluh: please paste your input data
00:22  craiggle1: thats the output from the sed command.
00:23  craiggle1: http://pastie.org/1360550 is the syntax of the file.
00:27  cthuluh: sorry I was afk
00:27  craiggle1: it's alright.
00:28  cthuluh: works for me :-]
00:28  craiggle1: why isnt it working for me then? :(
00:28  cthuluh: sed 's/ID: \([[:digit:]]\{1,\}\) Name: \(.\{1,\}\)/_id.put("\2", "\1");/' pastie-1360550.rb
00:28  cthuluh: _id.put("Dragon Party Hat", "10117");
00:28  cthuluh: ...
00:28  cthuluh: is that what you want?
00:29  craiggle1: yeah.
00:29  cthuluh: then you _actual_ data is not what you pasted
00:29  cthuluh: your*
00:29  craiggle1: ill upload the file.
00:30  craiggle1: http://craiggles.co.uk/Item%20Codes.txt
00:33  cthuluh: ok
00:33  cthuluh: you have carriage returns in your file
00:33  cthuluh: they are erasing the beginning of each transformed line
00:34  cthuluh: sed 's/\r$//; ...' file
00:34  craiggle1: how can i remove them? (bloody windows..)
00:34  craiggle1: cheers.
00:34  cthuluh: should do it
00:34  cthuluh: if not, then replace \r with the key sequence C-v C-m
00:34  craiggle1: thanks!
00:34  craiggle1: works :)
00:34  cthuluh: cool
01:42 --- grrrrrr is now known as barbanegra
08:04  hemanth: using sed -n '/PLACE_HOLDER1/,/PLACE_HOLDER2/p' is there a way to avoid Place holders in the output?
08:08  SiegeX: 4# echo -e "foo\nPLACE_HOLDER1\nshow this\nPLACE_HOLDER2\nbar" | sed '1,/PLACE_HOLDER1/d;/PLACE_HOLDER2/,$d'
08:08  shbot: SiegeX: show this
08:21  hemanth: SiegeX, kool, if i have set of starting and ending place holders, is there way to do the same ?
08:22  SiegeX: explain?
08:23  hemanth: few files with tightly coupled placeholder pairs, need to extract text between those placeholders, but before that i need to check if that pair is present in the current file, i'm trying to parse, if not need to try a different pair
08:28  SiegeX: sounds like awk might fit your requirements better
15:18  Synthead: can I cram this into one sed command?
15:18  Synthead: sed -e "/<${keywords[$i]}>/!d" -e 's%.*<.*>\(.*\)<.*>.*%\1%' | sed -r "s%^.%\\${capital[$i]}&%"
15:19  Synthead: ${capital[@]} is either U or L
15:21  csabo: good morning!
15:21  Riviera: What's the point of using that pipe in the first place?
15:22  Riviera: I don't see why that's necessary; but I also didn't really bother completely understanding that command.
15:55  csabo: can i use -n with more than one expression in a single line?
15:55  Riviera: once -n is set, it's valid for the whole script
15:55  Riviera: which is kinda clear if you understand what -n does
15:55  csabo: never claimed to be an expert :)
15:55  csabo: i was unaware you can go multiline with sed
15:56  csabo: i see that now a '\' does it, it appears
15:56  Riviera: I don't understand :)
15:57  csabo: that makes 2 of us
15:57  csabo: welcome to my world, please have a seat
15:57  Riviera: What I meant is:
15:57  csabo: chairs are comfy
15:57  Riviera: I don't understand what you mean ;-)
15:57  Riviera: You do neither? :)
15:58  csabo: its pretty obvious by your confusion, that i'm not asking a real question
15:58  csabo: which happens when you dont know what the hell you're doing
15:58  csabo: what i know is, i've got a log file i'm creating with a script, that i need to pull certain lines out based on X, and build an "overview" at the top of the log
15:59  Riviera: okay
15:59  csabo: I dont like people doing my work for me, so i attempted to research, then ask a specific question
15:59  csabo: which, i failed to do apparently
16:00  Riviera: Please manage somehow to include the reasons for asking about -n and \ and multiline in your explanations.
16:00  Riviera: :)
16:01  csabo: okay, i've got a log from a backup product, any line containing 'Failed' or 'Missing' , I want to take thoes lines, and put at the top in a new section, called issues, or whatever
16:01  csabo: i tested, "sed -n /Missing/p $FILE" works fine
16:01  Riviera: oaky
16:01  csabo: but it seems stupid to have multiple sed commands
16:02  Riviera: well
16:02  Riviera: sed processes a stream
16:02  Riviera: if you want toi take something from a file
16:02  Riviera: and begin the output with that
16:02  Riviera: after which other parts of that file follow
16:02  Riviera: this would require, with only one sed invocation,
16:03  Riviera: sed to store parts or the whole file into memory.
16:03  csabo: okay
16:03  Riviera: :)
16:03  csabo: okay, i think i follow
16:03  csabo: (i've only used sed to replace words, very basic stuff, forgive my ignorance)
16:03  Riviera: Do not worry :)
16:03  csabo: this product could have a manual the same size as the one for the US space shuttle
16:03  Riviera: no, not at all
16:03  Riviera: sed is really a very trivial tool
16:04  Riviera: the very moment one understood it, everything is easy
16:04  Riviera: only its tight syntax makes that a bit troublesome at first.
16:04  csabo: :)
16:05  csabo: i was looking at this http://www.faqs.org/docs/abs/HTML/sedawk.html
16:07  Riviera: The ABS is not very cool.
16:07  csabo: oh :(
16:07  Riviera: Wow.
16:07  Riviera: Even worse.
16:07  Riviera: for file in $( find $directory -type f -name '*' | sort )
16:07  Riviera: that's canned lameness.
16:07  Riviera: (From http://www.faqs.org/docs/abs/HTML/loops.html#FINDSTRING )
16:08  Riviera: Hardly any line in these scripts that's not a total piece of crap.
16:08  csabo: so in my case, is it possible to grab the lines i need, and put them in another part of that file?
16:08  Riviera: I honestly don't know, because I never bothered reading them; but the links in the topic of this channel might have better material for learning sed.
16:09  Riviera: grep -Fe Missing -e Failed "$file" > file-with-missing-and-failed-lines
16:09  Riviera: If you want to have the rest of the file following that
16:09  csabo: hmm
16:09  Riviera: { grep -Fe Missing -e Failed -- "$file"; cat -- "$file"; } > new_file
16:09  Riviera: but I guess that's not really what you had in mind :)
16:10  csabo: i'd rather not build another file
16:10  csabo: but if thats my only option, i can live with it
16:11  csabo: grep -Fe Missing -e Failed test.txt > file.txt
16:11  csabo: only created one entry in that new file, one with Failed
16:12  Riviera: I'd be surprised if your input contained other lines with "Missing" or "Failed" then :)
16:12  csabo: it does, i'm looking at it :)
16:12  Riviera: :)
16:12  csabo: again -n /exp/p worked fine, got all 4 lines with Missing in it
16:15  Riviera: So.
16:15  Riviera: Uhm.
16:15  Riviera: What is the output of these commands: grep -Fce Missing "$file"  and  sed -n '/Missing/p' "$file" | wc -l
16:16  csabo: 0 on the first
16:17  csabo: sorry, miss spelled
16:17  csabo: 3 on the first
16:18  csabo: 100% my fault
16:18  csabo: its missed not missing
16:18  csabo: so the grep cmd worked
16:24  Riviera: :)
16:26  csabo: you're the man, i think i can manage what i need, i'll let you know if i cannot!
16:27  csabo: oh, is there a good tutorial, or guide on creating ascii "art" for this stuff? like i'm using a line of  ***** WORDS *********
16:28  csabo: and it looks like crap
16:28  csabo: using lines of asterisks for seperators is nasty looking
16:28  Riviera: mh :)
16:28  csabo: mh?
16:28  Riviera: What's that tutorial? :)
16:28  csabo: http://linux.die.net/man/5/mh-mail
16:29  csabo: yeah, i don thave mh :)
16:29  csabo: i'm using AIX 53
16:30  csabo: Riviera:  i'm going about this all wrong
16:30  csabo: rather than creating logic to pull out specifc entries.. it would alot easier to delete any line with "Completed' In it
16:31  Riviera: then do so :)
16:34  csabo: so sed -n '/Completed/p' $FILE
16:35  csabo: that look about right?
16:35  csabo: erm
16:35  csabo: d not p
16:36  csabo: hrm
16:36  csabo: it didnt remove anything
16:37  Riviera: prefer file over FILE and double-quote parameter expansions; "$file"
16:37  Riviera: apart of that, yes, sed '/Completed/d'  "$file" or  grep -Fv 'Completed' "$file"
16:38  csabo: okay
16:38  csabo: it doesnt appear to have actually deleted it out of the file
16:38  csabo: i left off -n and it printed it out to the screen
16:39  Riviera: sed does not change the file
16:39  csabo: ah right
16:39  csabo: stream
16:39  Riviera: "d" means "delete from the output"
16:39  Riviera: yes
16:39  csabo: okay, one more question then i can leave you alone i think :)
16:39  Riviera: shoot :)
16:40  csabo: one of the fields is too long, so in the log it drops down, and i theres a line between each line, that has a few chars, varies with each job name
16:40  csabo: so my logic would need to be
16:40  csabo: i dont even know, lemme show you what im dealing with
16:41  csabo: http://pastebin.com/tEKJ5Th9
16:42  csabo: lol, how do i deal with that
16:43  Riviera: The problem is that the next line should also be deleted? The one after Completed?
16:46  csabo: hmm
16:46  csabo: if the word completed is in the line, then the overflow below it needs to be removed
16:47  Riviera: And it is overflow because it starts with whitespace=?
16:47  csabo: if the status isnt Completed, then the line below needs to stay
16:47  csabo: as you can see the schedule name, screws everything up
16:48  Riviera: Yes, and now, the answer to my question please :)
16:49  csabo: oh, i suppose so
16:49  Riviera: Try, this, then:
16:49  Riviera: sed -e '/Completed/!b' -e '$!N' -e 's/.*\n//' -e '/^[[:blank:]]/d'
16:49  Riviera: Ah, well, wait.
16:49  Riviera: That will not work if "Completed" appears in the last line of a file.
16:50  csabo: it wont :)
16:50  csabo: ANR1462I RUN: Command script EVENT completed successfully.
16:50  csabo: oh wiat thats not hte bottom
16:50  csabo: ANS8002I Highest return code was 0.
16:50  csabo: thats the bottom
16:50  Riviera: Okay, anyway,
16:50  Riviera: better try this:
16:50  Riviera: sed -e '/Completed/!b' -e '$d' -e 'N' -e 's/.*\n//' -e '/^[[:blank:]]/d'
16:51  Riviera: This will remove all lines that contain "Completed"
16:51  Riviera: and all lines beginning with whitespace that follow a line that contains "Completed"
16:51  csabo: you are the MAN
16:52  Riviera: Does it work?
16:52  csabo: didnt try yet
16:52  Riviera: okay, then
16:53  csabo: i dont even get how tha tworks
16:53  Riviera: sed -e '/Completed/!b' -e '$d' -e N -e '/\n[[:blank:]]/d' -e D
16:53  Riviera: That should even be cooler.
16:53  csabo: what does that do
16:53  Riviera: The same, only slightly cooler 8)
16:53  csabo: where do i put the file name
16:54  Riviera: sed -e '/Completed/!b' -e '$d' -e N -e '/\n[[:blank:]]/d' -e D "$file"
16:55  csabo: epic, works perfectly
16:55  csabo: what is all that jazz?
16:55  csabo: it looks like you just went nuts in the char editor
16:55  csabo: charmap**
16:56  Riviera: /Completed/!b   This means: If a line does not contain "Completed," jump to the end of the script and just print this line to the output. (Which is the default if the -n option was not set.)
16:56  Riviera: So, all the other following commands are only executed if the current line contains "Completed."
16:56  Riviera: $d    delete the line if it was the last line of the input (basically, ending the script)
16:57  Riviera: N    read in the next line and append it to the current line
16:57  csabo: you are a boss
16:57  Riviera: (which only happens if there was another line, because of the $d)
16:57  Riviera: so, in the buffer currently are two lines:
16:57  Riviera: <line with completed>\n<next line>
16:58  Riviera: /\n[[:blank:]]/d   this checks if this buffer contains the pattern <newline><whitespace>
16:58  csabo: ah
16:58  Riviera: if so, delete the buffer (d) and care for the next input line, it then deletes the two input lines, the one with completed and the following one that starts with whitespace
16:58  Riviera: D    this command will only be executed if the following line did not start with whitespace, then D only deletes the part until the \n,
16:59  csabo: wow
16:59  Riviera: letting the following line being printed, because it did not start with whitespace
16:59  Riviera: that's it.
17:01  csabo: if i asked you to write a sed statement (one liner) to parse the entire bible and turn it into a harry potter book, could you?
17:01  csabo: :P
17:03 * cthuluh wonders what he would prefer: a bible or a harry potter book...
17:03  csabo: HP has better movies
17:08  csabo: hmm
17:09  Riviera: :)
17:09  csabo: if i wanted to remove, say the first 5 lines of a file would "sed '1,5d' $FILE be the way to do it?
17:09  csabo: or is google wrong
17:09  Riviera: You could do that, yes.
17:10  Riviera: But, again, it would not change the file :)
17:10  csabo: yeah i know
17:10  Riviera: also, prefer "$file" over $FILE
17:10  Riviera: ;)
17:10  Riviera: but I have to leave now
17:10  csabo: alright mate
17:10  csabo: take care
17:10  Riviera: have a good day / evening / .. :)
17:10  Riviera: bye :)
17:12  csabo: hey cthuluh
17:12  cthuluh: yup
17:12  csabo: so im working on removing the lines, and i'd like to throw it into the expression he gave me
17:13  csabo: however, since its first logic bit is if it doesnt contain completed, move along.. how would i do that?
17:13  cthuluh: I knew it was a trap :P
17:13  csabo: haha
17:13  csabo: if i have to i suppose i can create a 3rd txt file for tmp usage
17:13  csabo: i'd just rather not :)
17:13  cthuluh: you mean that you have a way to do it with a temp file?
17:14  cthuluh: (I don't know what is "it", btw, I didn't backlog)
17:14  csabo: well, yeah, i could run sed '1,10d' $file > tmp2.txt
17:14  csabo: then run sed again against that file, and run the expression / arg he gave me
17:14  csabo: and pipe to a tmp3.txt
17:14  csabo: or the other way around
17:15  cthuluh: well, juste do sed 1,10d < "$file" | sed ... > tmp.txt
17:15  csabo: in this case, the first 11 and the last 4lines need to go
17:16  cthuluh: I'm sorry csabo, I'm tired and have a lot of work to be done, here
17:16  csabo: no worries
17:17  cthuluh: don't forget that you have a solution ;)
17:17  csabo: yeah :)
17:17  cthuluh: "le mieux est l'ennemi du bien"
17:17  csabo: i'll keep playing with it
18:07  ldfsilva: folks any help for the following match..
18:08  ldfsilva: need to make a parsing of 2 lines in 4, example I have 4 lines and I just want to show the lines which contains the word cat and the word dog
18:09  gnubien: ldfsilva: sed -n '/cat\|dog/p' filename
18:09  ldfsilva: sed '/(cat|dog)/!d'   didn't work
18:09  gnubien: ldfsilva: sed -n '/cat/,/dog/p' filename
18:09  ldfsilva: what is the or in sed expression ?
18:10  gnubien: cat\|dog
18:12  ldfsilva: beteween or without parenthesis ?
18:16  gnubien: try it and see
18:27  ldfsilva: weird... it worked in bash and not in ksh
18:27  ldfsilva: just cat\|dog
18:28  gnubien: ksh is the problem
18:29  ldfsilva: :\
18:31  gnubien: ldfsilva: ask in #ksh about problem syntax
18:36  ldfsilva: i though it would be independent of shell.. weirdo.. will try to figure out, then i share with you
18:37  cthuluh: did you quote your sed expression?
18:37  cthuluh: 'cat\|dog'
18:38  cthuluh: and remember that not all sed support \|
18:44  ldfsilva: i quoted.. just ran in both SHELLs got different answers
18:44  ldfsilva: I think would be something generic to get that instead of |
18:45  cthuluh: same OS?
--- Log closed Thu Dec 09 20:00:34 2010
--- Log opened Thu Dec 09 20:15:59 2010
20:15 --- Users 99 nicks [0 ops, 0 halfops, 0 voices, 99 normal]
20:16  ldfsilva: cthuluh .. different os
20:17  ldfsilva: linux ( bash )/ aix ( ksh )
20:17 --- Channel ##sed was synced in 106 seconds
20:35  geirha: ldfsilva: \| is a GNU-extension. You probably don't have GNU sed on aix, which is why it fails.
20:36  geirha: A portable alternative is   sed -e '/cat/!d' -e '/dog/!d'
--- Log closed Thu Dec 09 20:41:09 2010
--- Log opened Thu Dec 09 20:46:36 2010
20:46 --- Users 101 nicks [0 ops, 0 halfops, 0 voices, 101 normal]
20:48 --- Channel ##sed was synced in 100 seconds
21:14  ldfsilva: didn't work geirha ... going to make some tests at home.. brb
--- Log closed Thu Dec 09 21:41:05 2010
--- Log opened Thu Dec 09 21:46:29 2010
21:46 --- Users 100 nicks [0 ops, 0 halfops, 0 voices, 100 normal]
21:47 --- Channel ##sed was synced in 96 seconds
21:51  csabo: hmm
--- Log closed Thu Dec 09 22:00:15 2010
--- Log opened Thu Dec 09 22:05:37 2010
22:05 --- Users 100 nicks [0 ops, 0 halfops, 0 voices, 100 normal]
22:07 --- Channel ##sed was synced in 99 seconds
--- Log closed Thu Dec 09 23:18:41 2010
--- Log opened Thu Dec 09 23:19:08 2010
23:19 --- Users 99 nicks [0 ops, 0 halfops, 0 voices, 99 normal]
23:20 --- Channel ##sed was synced in 103 seconds
--- Log closed Thu Dec 09 23:42:11 2010
--- Log opened Thu Dec 09 23:47:35 2010
23:47 --- Users 102 nicks [0 ops, 0 halfops, 0 voices, 102 normal]
23:49 --- Channel ##sed was synced in 101 seconds
23:49  ldfsilva: it has joined the line below.. I would like to do the same but for four lines instead of just ... ex. echo -e "a\nb\nc\nd"
23:49  ldfsilva: i'd like to have... all in one line a b c d
23:51  cthuluh: : label; $!{ N; b label; }
23:51  cthuluh: I'm curious about why you used /$/ in your example
23:54  ldfsilva: didn't get the way you wrote it, could you explain that cthuluh ?
23:54  cthuluh: the first command defines a label
23:55  cthuluh: then we have a group of commands that get executed for every line but the last line
23:55  cthuluh: $ matches the last line, ! reverses the match
23:56  cthuluh: so for every line but the last line, input gets appended in the buffer
23:56  cthuluh: after those commands, you can do whatever you want with your buffer that now contains the whole file
23:57  ldfsilva: buffer would be what why i've set in label ?
23:58  cthuluh: I don't think I understand
23:59  ldfsilva: how would that be in the abcd example ? after echo -e "a\nb\na\nb"
23:59  cthuluh: oh, I heve forgotten to explain the 'b' command. it just jumps to the mentioned label
23:59  cthuluh: well
--- Log closed Fri Dec 10 00:00:03 2010
