--- Log opened Sat Dec 11 00:52:09 2010
00:52 --- Users 102 nicks [0 ops, 0 halfops, 0 voices, 102 normal]
00:53 --- Channel ##sed was synced in 95 seconds
02:19 --- kizoku_ is now known as kizoku
02:54 --- sabat is now known as sabat-afk
--- Log closed Sat Dec 11 03:25:25 2010
--- Log opened Sat Dec 11 03:29:05 2010
03:29 --- Users 99 nicks [0 ops, 0 halfops, 0 voices, 99 normal]
03:30 --- Channel ##sed was synced in 85 seconds
03:57  planet8: Is there a way to get sed (or perhaps grep) to display all lines in a lot of files where some string exists with capital letters?
03:57  Riviera: Is this different from displaying all lines that contain an uppercase letter somewhere?
03:57  planet8: That's "match any string with a capital letter" in *.php files
03:58  Riviera: grep '[[:upper:]]' ./*.php
03:58  Riviera: sed '/[[:upper:]]/!d' ./*.php
03:58  planet8: Riviera, beautiful :-) Thanks!
03:59  Riviera: :)
04:05  planet8: Is it possible to extend the search and say "Match any string with more than one capital letter in the same line somewhere"?
04:06  Riviera: grep '[[:upper:]].*[[:upper:]]'
04:06  Riviera: like that?
04:06  Riviera: Do you mean something like this? grep '[[:upper:]].*[[:upper:]]'
04:07  Riviera: Or do you only want to return that particular string, not the whole lines?
04:07  planet8: Only that particular string if possible
04:08  Riviera: Mh.
04:08  Riviera: planet8: Do you have GNU grep?
04:09  planet8: Yes
04:09  Riviera: planet8: Is the set of characters that words consist of somehow defined?
04:09  Riviera: planet8: like to letters and numbers?
04:10  planet8: I'm not sure what you mean..
04:10  Riviera: planet8: those strings that you want to extract,
04:10  Riviera: planet8: I'd need to know which characters they can contain
04:10  Riviera: planet8: or
04:11  planet8: Ah
04:11  Riviera: planet8: which they cannot contain (like whitespace)
04:11  planet8: All chars between A-Z
04:11  planet8: And underscore
04:11  planet8: nothing else
04:11  planet8: They look like this: THIS_IS_MY_CONSTANT
04:12  Riviera: planet8: grep -o '\<[[:alpha:]_]*[[:upper:]][[:alpha:]_]*[[:upper:]][[:alpha:]_]*\>'
04:13  Riviera: 4# grep -o '\<[[:alpha:]_]*[[:upper:]][[:alpha:]_]*[[:upper:]][[:alpha:]_]*\>' <<< 'test line with THIS_IS_MY_CONSTANT and THIS_IS_ANOTHER_CONSTANT :)'
04:13  shbot: Riviera: THIS_IS_MY_CONSTANT
04:13  shbot: Riviera: THIS_IS_ANOTHER_CONSTANT
04:13  planet8: Damn, you're good Riviera :-)
04:13  planet8: You have literally saved my from hours of manual searching.
04:13  planet8: my = me
04:13  Riviera: these strange looking [[:alpha:]_] things also match other characters, like äöü
04:13  Riviera: depending on the locale you might use,
04:14  planet8: I see..
04:14  Riviera: if that's not desired, you could maybe change the locale to C
04:14  planet8: I tried to research the subject before I came here.. how did you figure this out so quickly?
04:14  Riviera: A-Za-z_ would probably still match not only those 26 letters you might expect
04:14  Riviera: mh
04:14  Riviera: wasn't that ard
04:14  Riviera: hard*
04:15  Riviera: If you don't know anything else than that stuff, it's pretty easy ;))
04:15  Riviera: and actually, I was a bit happy that you said you have GNU grep
04:15  Riviera: otherwise that thing would indeed have been a bit tricky :)
04:16  planet8: I see.. :-) I love using GNU tools like this, but I find regex and the like extremely difficult to remember. Also I don't use it regularly.
04:17  planet8: And if I add "-n" I even get line numbers.. how cool is that :-))
04:18  Riviera: yes, it is hard to remember, because the GNU (and similarly in general the Unix-) tools are a collection for solving particular problems
04:18  Riviera: so it's almost as memorizing something for each possible problem 8)
04:18  Riviera: which is silly, but a result of their interactivity
04:19  Riviera: general purpose scripting languages are better in that
04:19  Riviera: more powerful, usually easier to learn (i. e., less memorizing required), but a bit more to type
04:20  Riviera: (because of not being used interactively)
04:20  planet8: Recommend anyone in particular for tasks like this?
04:20  Riviera: I cannot really; I like Python, but that is only me, other languages are good as well
04:21  planet8: Okay :)
04:21  Riviera: I mainly just wanted to say "do not worry about that difficult to remember thing" ;)
04:22  planet8: I got that :-)
04:22  Riviera: :)
04:22  planet8: I usually take notes from a lesson like this one, then if I need something similar I try to "figure out" how to adapt.
04:23  Riviera: planet8: check the material the channel #bash has (its FAQ, its wiki, its bot's "factoids")
04:23  Riviera: planet8: there's plenty of useful stuff there if it's about shell scripting
04:24  planet8: okay, thanks :)
04:24  Riviera: :)
04:24  Riviera: and I need to catch some sleep
04:24  Riviera: nite :)
04:24  planet8: Goodnight :-)
04:24  Riviera: :)
04:50 --- grrrrrr is now known as barbanegra
15:20 --- grrrrrr is now known as barbanegra
21:22  z11: Trying to use "sed" in a bash script to remove a string of characters beginning with "ZZZ" up to and including a "/" character. I keep getting an error and the command I'm using is sed 's/ZZZ.*\////' which returns the error sed: -e expression #1, char 12: unknown option to `s'. I tried removing the single quote characters which then returns the error sed: -e expression #1, char 10: unknown...
21:22  z11: ...option to `s'. What is wrong with my command?
21:22  Riviera: z11: The syntax of the s command is something like that: s <delimiter> <regular expression> <delimiter> <replacement> <delimiter> <flags>
21:22  Riviera: z11: So, let's see how your command applies to that syntax:
21:22  Riviera: z11: Your command is s/ZZZ.*\////
21:22  Riviera: z11: the delimiter is /
21:22  Riviera: z11: the regex is ZZZ.*\/
21:23  Riviera: z11: the replacement part is the empty string
21:23  Riviera: z11: the, uhm, what the fuck is the last slash?
21:23  Riviera: z11: there is not another delimiter in the syntax of the s command.
21:23  Riviera: 4# sed 's/ZZZ.*\///' <<< 'one two ZZZ three'
21:23  shbot: Riviera: one two ZZZ three
21:24  Riviera: 4# sed 's/ZZZ.*\///' <<< 'one two ZZZ/ three'
21:24  shbot: Riviera: one two  three
21:24  Riviera: now yours:
21:24  Riviera: 4# sed 's/ZZZ.*\////' <<< 'one two ZZZ/ three'
21:24  shbot: Riviera: sed: -e expression #1, char 12: unknown option to `s'
21:24  Riviera: !
21:24  Riviera: :)
21:25  z11: Oh, too many /'s? I was thinking / find this/   and /replace with/
21:25  Riviera: ah, that explains it; but no :)
21:28  z11: Riviera: I just changed the script to sed s/ZZZ.*\/// and it still fails sed: -e expression #1, char 10: unknown option to `s'
21:29  Riviera: z11: yes, quote your command, otherwise the shell will do its shellish evil
21:29  Riviera: (word-splitting, globbing)
21:30  z11: Riviera: My bad, It looks like I needed the ' around it
21:30  z11: Riviera: Ok, thank you very much.
21:30  Riviera: welcome :)
--- Log closed Sun Dec 12 00:00:40 2010
