--- Log opened Thu Nov 04 08:21:56 2010
08:21 --- Users 95 nicks [0 ops, 0 halfops, 0 voices, 95 normal]
08:23 --- Channel ##sed was synced in 112 seconds
11:15  bezourox: Hi, I have a problem to replace a line in an XML file by an other line
11:18  guther: bezourox: 1st consider using a xml-parser, 2nd paste an example of in- and desired output
11:19  bezourox: ok
11:19  bezourox: I prepare a pastebin
11:24  bezourox: guther : http://pastebin.com/MsfW4Fi6
11:25  bezourox: the source is a text file
11:26  bezourox: One word by line
11:26  bezourox: I concatenate this word whith a space between
11:26  bezourox: theses worlds :s
11:27  guther: uhm - 's/old/new/', or in your case "s/$old/$new/" I'ld guess
11:27  bezourox: sed -e 's/"$oldchaine"/"$newchaine"/g' /cf/conf/config.xml > /cf/conf/config.xml.tmp
11:27  bezourox: I tested this
11:28  guther: sed " <= !! not '
11:28  guther: in single quotes your vars are not expanded
11:29  bezourox: ok
11:29  bezourox: sed "s/$oldchaine/$newchaine/" /cf/conf/config.xml
11:29  bezourox: I will test this
11:32  bezourox: result : sed: 1: "s/                             <domains>google.c ...": bad flag in substitute command: 'o'
11:32  bezourox: :s
11:32  guther: if ur pattern contains '/' you'ld have to use different delimiter
11:33  guther: could you paste values for $newchain and $oldchain
11:34  bezourox: yeah
11:34  bezourox: may values contains / :s
11:34  bezourox: http://pastebin.com/MsfW4Fi6
11:34  bezourox: you have hear the result
11:34  number_number: so, I want to take the output of `uptime`.. and all I want to get is the "up 1d, 2h, 59m" part of the string
11:35  number_number: from the following " 10:10:23 up 1 day, 9 min,  9 users,  load average: 0.04, 0.03, 0.07
11:35  bezourox: http://pastebin.com/59R5MNcv : here
11:35  number_number: so, basically, from the first a-z to the comma before users
11:36  number_number: my best attempt is pretty poor, but i can show if it might help?
11:36  guther: bezourox: can't see what's in vars - plz paste 'echo $newchain;echo $oldchain'
11:39  bezourox: ok
11:39  bezourox: #
11:39  bezourox: OLD chaine : <domains>google.com google.fr free.fr pagesjaunes.fr ipadsl.net</domains>
11:39  bezourox: #
11:39  bezourox: NEW chaine : <domains>google.com google.fr free.fr pagesjaunes.fr ipadsl.net geekzone-clan.org gmail.com </domains>
11:39  bezourox: I have two solutions
11:39  bezourox: replace all the line
11:40  bezourox: or juste replace that is between <domains>...</domains>
11:44  guther: sed 's|\(.*[^<]*\)<.*|\1 geekzone-clan.org gmail.com<\domain>|'
11:47  guther: of course you could do foo="geekzone...", then substitute "..\1 "$foo".."
11:48  guther: ah - and you also might want to make sure to catch only lines beginning with '<domain>' => sed "/^<domain>/;s..."
11:48  guther: sry - without ';' ;)
11:54  guther: number_number: 's/\(.*\)users,.*/\1 users/'
11:59  bezourox: guther : difficult to understand sorry
11:59  bezourox: [11:44] <guther> sed 's|\(.*[^<]*\)<.*|\1 geekzone-clan.org gmail.com<\domain>|'
11:59  bezourox: it will be never the same
12:00  bezourox: the goal is to update an url list
12:00  bezourox: when I add an URL in my text file
12:00  bezourox: I launch my .sh
12:00  bezourox: ans my .xml is update
12:01  guther: sed "/^<domain>/s|\(.*[^<]*\)<.*|\1 $foo<\domain>|" where $foo is the string that is to be appended/inserted
12:02  guther: ah - and $foo should also be "$foo"
12:02  bezourox: ok I will test
12:04  guther: this will only process lines starting with '<domain>' and then appends "$foo" just before the closing tag '<\domain>'
12:05  bezourox: not working :s
12:06  bezourox: sed "/^<domains>/s|\(.*[^<]*\)<.*|\1 $newchaine<\domains>|" /cf/conf/config.xml
12:07  guther: could you paste /cf/conf/config.xml
12:08  number_number: thanks guther! :)
12:08  bezourox: I will paste just a part
12:08  guther: number_number: yw
12:09  guther: bezourox: what is the value of $ligne?
12:09  bezourox: http://pastebin.com/z768Wzbr
12:10  guther: ok the lines are not starting with <domains>!
12:10  guther: is it multiline?
12:10  guther: sry
12:10  bezourox: in the xml file, just one line begin with <domains>
12:10  guther: it isn't - saw the linenumbers
12:11  bezourox: it's that line that i want to replace
12:11  bezourox: impossible to know the line numer
12:11  bezourox: number
12:11  guther: sed "/.*<domains>/s|\(.*[^<]*\)<.*|\1 $foo<\domains>|" where $foo is the string that is to be appended/inserted
12:12  bezourox: same :s
12:14  guther: don't know - works for me, tried it with your paste
12:17  guther: #4 foo=XXXXXXXXX;echo "         <domains>google.com google.fr groupe-michel.com free.fr pagesjaunes.fr ipadsl.net</domains>" | sed "/.*<domains>/s|\(.*[^<]*\)<.*|\1 $foo<\domains>|"
12:17  bezourox: ok I understand the problem
12:17  bezourox: when I redirect the result of sed command in a new file
12:17  bezourox: all is ok
12:18  bezourox: sed "/.*<domains>/s|\(.*[^<]*\)<.*|\1 $newchaine<\domains>|" /cf/conf/config.xml : don't work
12:18  bezourox: sed "/.*<domains>/s|\(.*[^<]*\)<.*|\1 $newchaine<\domains>|" /cf/conf/config.xml > /cf/conf/result.xml
12:18  bezourox: result.xml is ok
12:18  bezourox: I just have to do a mv after that
12:18  guther: so we*re fine?
12:19  bezourox: I think all is okey now
12:19  guther: great :)
12:20  bezourox: It's ok boss
12:20  bezourox: Thank's very much
12:20  guther: yw
12:20  bezourox: but sed is not an easy command :)
12:21  guther: uhm, think the 1st I said was: "1st consider using a xml-parser"... ;)
12:22  bezourox: guther : not stupid
12:22  bezourox: =)
17:11  number_number: hi guys, I'm still stuck! :(... so, from `uptime` I want to sed to give me "19d, 8h, 41m"
17:11  number_number: instead of 16:11:52 up 1 day,  6:11, 10 users,  load average: 0.34, 0.31, 0.22
17:12  number_number: now, guther helped me out earlier to get rid of the trailing bit, but the best I've managed so far is : uptime | sed 's/\(.*\)...users,.*/\1/'
17:12  number_number: which gives: 16:09:11 up 1 day,  6:08,
17:13  number_number: any ideas?!
17:16  geirha: number_number: Are you on linux?
17:17  geirha: If so, grab the number of seconds from /proc/uptime, then do some math to get it into your format. See http://mywiki.wooledge.org/BashFAQ/102
17:17  geirha: And ''man proc''
17:18  number_number: yeah
17:18  number_number: ah ok, that's a much better idea
17:19  number_number: i'll check it out
17:19  number_number: ty
17:25  guther: OR...you could do it with sed...:
17:25  guther: uptime | sed -e 's/[[:punct:]]/ /g' -e 's/.*up \([[:digit:]]*\) days[ ]*\([[:digit:]]*\)\([[:digit:]]\).*/\1d, \2h, \3m/'
17:25  guther: lovely, isn't it? ;)
17:26  guther: 4# uptime | sed -e 's/[[:punct:]]/ /g' -e 's/.*up \([[:digit:]]*\) days[ ]*\([[:digit:]]*\)\([[:digit:]]\).*/\1d, \2h, \3m/'
17:26  shbot: guther: bash4: uptime: command not found
17:28  number_number: guther & geirha: none of them have worked fo me yet, but hopefully I'll get them going soon
17:28  number_number: i think cat /proc/uptime is probably a bit more elegant
17:28  number_number: but i do quite like sed
17:29  number_number: meanwhile, you guys can marvel in the horror of the monstrosity that I had put together
17:29  guther: 4# echo " 17:22:22 up 264 days, 23:42,  0 users,  load average: 1.29, 1.32, 1.25" | sed -e 's/[[:punct:]]/ /g' -e 's/.*up \([[:digit:]]*\) days[ ]*\([[:digit:]]*\)\([[:digit:]]\).*/\1d, \2h, \3m/'
17:29  shbot: guther: 264d, 2h, 3m
17:29  number_number: uptime | sed 's/^[ \t]*//;s/.........//;s/....users.*//;s/,.//;s/,//'| sed 's/.days/d /;s/:/h /;s/$/m/'
17:33  guther: uhm - sry...space between the two digits and asterisk at the end of 2nd one - but then ist's working
17:38  number_number: guther: how come the one with `echo` works but I can't get it to work when I pipe uptime?
17:38  number_number: is there some wildcard expansion that I don't know about?
17:40  guther: don't know - works with uptime | sed too
17:40  number_number: okay, no, it works for your your uptime but not mine! is it dependant on how long the string is?
17:40  guther: ah wait - u mean your sed?
17:41  Sp4rKy: number_number: what about : uptime|awk '{print $3"d, "$5"m"}' |sed 's/,//2;s/:/h, /'
17:41  number_number: no, my sed seems to work fine with your uptime, but not mine
17:41  guther: your prog gives me: up 264d 23h 56m
17:41  number_number: Sp4rky: i'll try!, give me two seconds
17:42  number_number: guther: try this uptime string : " 16:41:02 up 1 day,  6:40, 10 users,  load average: 0.08, 0.04, 0.09"
17:42  Sp4rKy: works with mine :)
17:42  Sp4rKy: 1d, 6h, 40m
17:43  guther: number_number: MAN - your only here to show off with that load of yours, aren't you? ;)
17:43  number_number: Sp4rKy: works perfectly! how do you decide when to use awk/sed?
17:43  number_number: :D
17:44  Sp4rKy: feeling :)
17:44  number_number: i always thought awk was for columns and sed was for everything else? or is that far too simplistic?
17:44  Sp4rKy: awk is simpler to isolate some fields, no matter of length and so
17:44  Sp4rKy: (as soon as you have a "common" delimiter)
17:45  Sp4rKy: I'm sure it could be done only with awk, but don't ask me how :)
17:45  number_number: Sp4rky: yeah, I get you, your solution seems very elegant
17:45  number_number: well, if it seems so, its because it is
17:46  Sp4rKy: ^^
17:46  Sp4rKy: much more than 's/[[:punct:]]/ /g' -e 's/.*up \([[:digit:]]*\) days[ ]*\([[:digit:]]*\)\([[:digit:]]\).*/\1d, \2h, \3m/' :p
17:47  number_number: well, in fairness, strictly speaking, it was a sed question
17:47  number_number: but either way, I'd like to think we all learn something by looking at different approaches
17:49  Sp4rKy: sure :)
17:51  number_number: thanks guys! :)
17:52  number_number: my 'screen' hardstatus is looking better than ever! :)
--- Log closed Fri Nov 05 12:52:00 2010
