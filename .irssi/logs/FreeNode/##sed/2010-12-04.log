--- Log opened Sat Dec 04 00:00:40 2010
--- Log closed Sat Dec 04 12:46:32 2010
--- Log opened Sat Dec 04 12:46:42 2010
12:46 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
12:48 --- Channel ##sed was synced in 143 seconds
13:48  cocox: 'sup gurus
15:18  cocox: is that a simpler way to change a sentence like: cat this a is to: this is a cat
15:18  cocox: My Example is: echo "cat this a is" | sed s'|\(cat\) \(this\) \(a\) \(is\)|\2 \4 \3 \1|'
15:19  cocox: is there a simpler way I doesn't know yet?
15:23  go|dfish: s/.*/this is a cat/
15:24  Sp4rKy: ahah
15:25  cocox: omg
15:25  cocox: :D
15:25  waldner: echo "this is a cat"
15:26  cocox: that was just for example waldner
15:26  go|dfish: you want to reverse all "words" ?
15:26  cocox: go|dfish: just sometimes
15:26  jsz`: 4# foo=( cat this a is ); for bar in 1 3 2 0; do printf "${foo[$bar]}"; done
15:26  shbot: jsz`: thisisacat
15:29  cocox: okay, ill try
15:29  cocox: thanks a lot xD
15:29  jsz`: 4# foo=( 'cat ' 'this ' 'a ' 'is ' ); for bar in 2 4 3 1; do printf "${foo[$bar]}"; done
15:29  shbot: jsz`: a is this
15:29  jsz`: xD
15:29  jsz`: 4# foo=( 'cat ' 'this ' 'a ' 'is ' ); for bar in 1 3 2 0; do printf "${foo[$bar]}"; done
15:29  shbot: jsz`: this is a cat
17:09  uber-n00b: 4# foo=( 'cat ' 'this ' 'a ' 'is ' ); for bar in 1 3 2 0; do printf "${foo[$bar]}"; done
17:09  shbot: uber-n00b: this is a cat
17:09  uber-n00b: sweet
22:51  grepper: how would I get "/opt/ffmpeg" from a string "blah blah --prefix=/opt/ffmpeg blah blah" with sed ?  I'm using "awk '{ for(i=1; i<=NF; i++) if($i ~"--prefix.*"){gsub("--prefix=", ""); print $i} }' but it seems a little long winded and I think sed would be more suitable (?)
22:53  grepper: it needs to return empty if now --prefix=blah is found in the string though
22:53  grepper: s/now/no
22:56  geirha: parsing a configure log?
22:58  grepper: var=$(ffmpeg -version 2>&1)
22:59  grepper: it will only have "--prefix" in the string if it was passed at configure time though, so if its empty I need to set the result to "/usr/local", the default
23:00  grepper: as in ffmpeg_prefix=${ffmpeg_prefix:-/usr/local}
23:01  grepper: I guess the awk command is good enough, just looks like overkill if there is an shorter sed way
23:24  Riviera: :D
23:29  Riviera: grepper: both, prototypical awk and sed solutions are notorious "underkill"
23:30  Riviera: grepper: a clean solution would parse the whole thing, granted in a most trivial way, but still cleaner and safer than any of this regex-crap.
23:31  Riviera: grepper: so your reasoning (let alone the absurdity of worrying about "overkill" in shell scripts) is IMHO wrong. IIRC I said said things about parsing already in #awk.
23:32  grepper: hmm
23:34  grepper: I don't see a problem with looking for a field that contains "--prefix=" in that output .  I don't see any other way to do it
23:41  Riviera: So seeing problems is the ultima ratio here?
23:41  Riviera: I wonder what the problem is about "awk being overkill" and how using sed would solve this problem.
23:41  Riviera: (No, I don't wonder.)
23:42  Riviera: You asked because you wanted a better solution,
23:42  Riviera: even if there is no real problem.
23:49  grepper: I'm fine with the solution, there is no problem there.
23:50  grepper: thanks for your time
23:51  Riviera: Yes, and you came because you wanted a better solution
23:51  Riviera: then I tell you what in my eyes a better solution is
23:51  Riviera: and you say
23:51  Riviera: that it's not because you don't see a problem
23:52  Riviera: but for your idea of "better" there also is no problem.
23:52  Riviera: anyway, welcome.
23:52  Riviera: :P
23:54  grepper: well, I didn't understand your better solution (not using regex), which is why I said what I did.  But you didn't elaborate on how to NOT use a regex for a solution.
23:55  grepper: ${ffmpeg_prefix//*--prefix=} ${ffmpeg_prefix// *} works too :P
23:55  grepper: gotta go out, have a good night !
23:55  Riviera: thanks, you too :)
--- Log closed Sun Dec 05 00:00:32 2010
