--- Log opened Mon Dec 20 00:00:07 2010
00:00 --- Users 98 nicks [0 ops, 0 halfops, 0 voices, 98 normal]
00:01 --- Channel ##sed was synced in 145 seconds
00:03  FastPutty: its an AND
--- Log closed Mon Dec 20 00:25:15 2010
--- Log opened Mon Dec 20 00:30:39 2010
00:30 --- Users 97 nicks [0 ops, 0 halfops, 0 voices, 97 normal]
00:32 --- Channel ##sed was synced in 128 seconds
--- Log closed Mon Dec 20 01:24:42 2010
--- Log opened Mon Dec 20 01:30:12 2010
01:30 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
01:31 --- Channel ##sed was synced in 116 seconds
--- Log closed Mon Dec 20 03:25:01 2010
--- Log opened Mon Dec 20 03:30:28 2010
03:30 --- Users 95 nicks [0 ops, 0 halfops, 0 voices, 95 normal]
03:30 --- Server: [kornbluth.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
03:32 --- Channel ##sed was synced in 113 seconds
04:15 --- luptenschteiner is now known as probonono
04:16  ryoohki: i want to change all occurances in a file from 'value=f95htg-ig-953-f8hngf' to 'value=XXXXXX-XX-XXX-XXXXXX' to obscure the private data.
04:20  ryoohki: what i want is something like ^\(.*=\)\(\([A-Za-z0-9]\)*-\)*\([A-Za-z0-9]\)*$ and then something like \1 followed by  tr from . to X for the correct number of chars and then a - and ending with a tr . to X for the correct number of chars.
04:21  ryoohki: tr would work if there was a way to tell it to only effect chars after the = sign
04:54  ryoohki: is there a way to negate [:alnum:] to mean [:nonalnum:]?
04:56  probonono: ryoohki, ^[:alnum:]
04:57  ryoohki: probonono: actually i think it's [^[:alnum:]] but i'll try both
04:57  ryoohki: probonono: thanks
04:58  grop: ryoohki, hmm don't know how to do that, but this function does at least return somethingâ€¦  obs() { grep -E -o 'value.*([^ ]*)' "$1" | cut -d= -f2 | tr -c '[^\-\n]' 'X'; }; obs file
05:00  grop: ryoohki, and yes it's [^[:alnum:]]
--- Log closed Mon Dec 20 08:31:21 2010
--- Log opened Mon Dec 20 09:19:45 2010
09:19 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
09:21 --- Channel ##sed was synced in 117 seconds
09:22 --- kurohige is now known as barbanegra
10:43  hjb: hi. i'm searchig for a "real streaming" editor
10:44  hjb: where i can stream a bunch of bytes into and get them out instantly
10:44  hjb: changing some combinations of them to some other
10:50  waldner: why isn't sead real enough for you?
10:52  waldner: *sed
10:54  hjb: waldner: as far as i have seen (which doesn't mean anything, as i haven't used sed much before), it piles up the bytes in memory until a newline is fed into it
10:54  hjb: which causes trouble on input that's not line oriented
10:55  waldner: you can't use sed to edit binary files, if that's what you're trying to do
10:57  waldner: if you know where the data you want to change is, you may be able to do something with dd plus some scripting
10:59  hjb: waldner: i need something to convert combinations of ascii control charaters into (surprise!) newlines
11:00  waldner: which control characters?
11:01  waldner: with gnu sed you may be able to match those by using \x1, \xd etc.
11:01  hjb: 1D GS    1E RS   1F US
11:02  waldner: yes, so \x1c\x1e etc.
11:02  hjb: waldner: yes, thanks to some guy at #solaris i've got a script that does the changes even with solaris standard sed
11:03  hjb: waldner: but the problem is that the input doesn't have newlines
11:03  waldner: do you need to change any of those characters into a newline?
11:03  hjb: instead of instantly writing the changes out, sed waits for newline or eof until outputting anything
11:04  hjb: waldner: yes, that's what i need to
11:04  waldner: then you can probably use tr
11:04  waldner: tr '\035\036\037' '\n\n\n'
11:04  hjb: waldner: but tr won't help, because only some *combos*, like \x1e\x1f should become newline
11:05  hjb: single instances must not be altered
11:05  waldner: [10:03:43] <     waldner> | do you need to change any of those characters into a newline?
11:05  hjb: waldner: sorry, overread that "any"
11:05  waldner: you'll have a single input line, what's wrong with sed waiting for eof?
11:06  hjb: waldner: that line is about 12 gb in size
11:06  hjb: sed dumps core
11:06  waldner: fair enough
11:06  hjb: that's my real problem, if sed wouldn't dump core, i could wait
11:07  waldner: have you tried gnu awk, with something like gawk -v RS='\x1e\x1f|\x1d\x1e' etc.
11:07  waldner: that way you'd just have to print out the different records
11:07  waldner: eg gawk -v RS='\x1e\x1f|\x1d\x1e' '{print}'
11:07  waldner: as the default output separator is \n already
11:10  hjb: waldner: no, but that sounds like a reasonable approach
11:10  hjb: i'll try it :)
11:10  waldner: cool
11:11  waldner: that should rule out the memory problems as (I think) awk will read in a chunk at a time only (ie until a RS)
11:11  waldner: it needs gnu awk though
11:11  hjb: i can modify the output seprator, right?
11:11  waldner: yes
11:12  waldner: you can say -v ORS='what you want'
11:12  waldner: or set it in the BEGIN block
11:14  hjb: great
11:14  waldner: if you need to have different output separator based on which combination of control character was found as RS, gawk puts it in RT so you can inspect that and set ORS accordingly for each record
11:15  waldner: eg if(RT ~ /\x1e\x1f/)ORS='\n';else if(RT~/\x1d\x1e/)ORS='blah'; print
11:15  waldner: you get the idea
11:16  hjb: definitely
11:16  hjb: perhaps i have a usecase for this, but i'm not sure
11:17  hjb: maybe simple ORS will also suffice
11:17  waldner: you know your data :)
11:18  hjb: not really, but i'm getting intimate ;)
11:23  hjb: waldner: thanks mate, works!
11:25  waldner: cool
11:25  waldner: no problem
12:48  ptl: hey murder.
15:31  lunaphyte_: hi.  i'm looking for a one liner to match the leading comments in a file (lines beginning with #), to store in a bash var.  i thought sed might be suitable for this.  here is an example input file:  http://dpaste.com/288611/
15:34  guther: sed -n '/^#/p' foo.bar
16:09  xelister: hi, how to count how many lines in subdirs of foo/  contain text  $something,  where something !='html' and !='form'.  So line "$x" counts, line "$html" does NOT count, and "$html $foo" counts again.
16:34  lunaphyte_: guther: thanks.  i'd like to also preserve the whitespace among the comments.  how can that be done?
16:38  cthuluh: lunaphyte_: it depends on how you use the shell, not sed. please try using double quotes around your parameter expansions
16:39  cthuluh: output=$(sed ....); echo "$output"
16:39  lunaphyte_: cthuluh: double quotes doesn't seem to affect the output, in this case.
16:39  lunaphyte_: oh, i thought you meant double quotes around the sed expression.
16:39  lunaphyte_: i'm just running the sed command directly for the moment.
16:40  lunaphyte_: sed -n '/^#/p' filename
16:43  matt_keys: I need to add double quotes at the end of each non-blank line. I used: sed -i s,$,\", in testing and it worked but it doesn't seem to be working now
16:45  cthuluh: you seem to apply the 's' command to _any_ line, not to any non-empty line. but please describe the error / output you get
16:47  matt_keys: each line contains a string that is 6 characters long, e.g. ABC123. I have three sed lines in the script, one that removes blank lines, one that adds double quote at the beginning and one at the end: sed -i "/^$/d"  sed -i 's/^/\"/'  and sed -i s,$,\", . The output looks like "ABC123
16:47  matt_keys: no errors
16:49  cthuluh: try this: sed '/^$/d; s/^/"/; s/$/"/' file
16:50  cthuluh: your quoting is rather inconsistent
--- Log closed Mon Dec 20 16:50:57 2010
--- Log opened Mon Dec 20 16:51:41 2010
16:51 --- Users 98 nicks [0 ops, 0 halfops, 0 voices, 98 normal]
16:52  lunaphyte_: maybe there's a better way to ask for what i'm after.  how can i match all lines preceding (and inclusive of) the last instance of a line whose first non whitespace character is # ?
16:53 --- Channel ##sed was synced in 95 seconds
16:55  cthuluh: perhaps something like: sed -n '1,/^[[:space:]]#/p'
16:55  matt_keys: ctuluh: same effect, doesn't add in that ending double quote
16:56  cthuluh: 4# printf '%s\n' foo '' bar baz | sed '/^$/d; s/^/"/; s/$/"/'
16:56  shbot: cthuluh: "foo"
16:56  shbot: cthuluh: "bar"
16:56  shbot: cthuluh: "baz"
16:58  cthuluh: lunaphyte_: so, do you think that I have understood you better? :)
16:58  matt_keys: weird huh?
16:59  lunaphyte_: cthuluh: heh, maybe.  that command returns all input - but i was just doing some reading, trying to learn what 1, does
17:00  cthuluh: lunaphyte_: let's take your example: do you want the line "# format is key <whitespace> value
17:00  cthuluh: "
17:00  cthuluh: to be printed?
17:01  matt_keys: cthuluh do I need to double escape the trailing "?
17:01  matt_keys: eg sed '/^$/d; s/^/"/; s/$//"/'
17:02  lunaphyte_: cthuluh: yes, i do.  does this help illustrate my goal? http://dpaste.com/288644/
17:02  cthuluh: matt_keys: in sed commands, the slash is not an escape character
17:04  cthuluh: lunaphyte_: sed '/^$/b; /^[[:space:]]*#/! {d; q;}'   does the trick here
17:04  lunaphyte_: aha, that looks like it works.  thanks.  :)
17:06  lunaphyte_: ah, so if i follow correctly, that deletes all lines whose first non whitespace character isn't # ?
17:06  cthuluh: it deletes it, and then exits the sed command
17:06  waldner: and are not empty
17:07  matt_keys: cthuluh: http://dpaste.com/288647/
17:07  lunaphyte_: where is the "and are not empty" part?
17:08  cthuluh: /^$/b
17:08  lunaphyte_: ah, i see.
17:08  cthuluh: "if the line is empty, then skip the next commands and start a new cycle" or something like that
17:09  lunaphyte_: gotcha.
17:09  cthuluh: note that using the 'b' command all alone (without label) is not portable
17:09  matt_keys: cthuluh: that's with a tail -n 3 after the sed
17:10  matt_keys: no other modifications are made, it simply transfers the file via ftp afterwards
17:10  cthuluh: matt_keys: I don't understand the result lines. perhaps do you have carriage returns at the end of the lines of your data?
17:10  lunaphyte_: i'd like to make one last adjustment, if possible, and not include blank lines following the final # line.
17:11  cthuluh: I don't see how to do this easily...
17:11  cthuluh: (with only one sed invocation)
17:12  lunaphyte_: multiple sed commands would be ok, from my perspective.
17:12  cthuluh: matt_keys: be sure you use binary mode when using ftp
17:12  cthuluh: matt_keys: not ascii mode
17:12  matt_keys: cthuluh: unfortunately i have to
17:12  matt_keys: this is going over to a hp3000
17:13  cthuluh: lunaphyte_: then use ... | sed '${ /^$/d; }'
17:14  cthuluh: matt_keys: ok so your data contains carriage returns when you get it, and should still contain carriage returns after having parsed it with sed?
17:14  lunaphyte_: cthuluh: that looks like it only got the last line.
17:16  matt_keys: cthuluh: I'm not certain. The data is created with a vb script I believe. each 6 character string needs to be on a different line for subsequent scripts to work right
17:16  matt_keys: is there an easier way to insert quotes before and after?
17:18  gnubien: echo -e "foo\nbar\n\nbaz" | sed '/^$/!s/^/"/; /^$/!s/$/"/'
17:19  cthuluh: 4# printf '%s\r\n' foo '' bar baz | sed '/^\r\?$/d; s/^/"/; s/\r$/"&/'  # matt_keys (probably GNU specific)
17:19  shbot: cthuluh: "foo"
17:19  shbot: cthuluh: "bar"
17:19  shbot: cthuluh: "baz"
17:20  cthuluh: hmm
17:20  cthuluh: make that: sed '/^\r\?$/d; s/^/"/; s/\r\?$/"&/'
17:20  cthuluh: lunaphyte_: well... 8)
17:21  matt_keys: cthuluh: that did the trick, thanks so much!
17:21  lunaphyte_: cthuluh: i stumbled across this one, which seems to work:  sed -e :a -e '/^\n*$/{$d;N;ba' -e '}'
17:21  lunaphyte_: it looks much more involved though.  :)
17:22  matt_keys: what was the problem with the prior command?
17:24  cthuluh: matt_keys: the carriage return modifies the way characters are printed on your terminal, so you could not see the final " anymore
17:24  matt_keys: ahh
17:24  cthuluh: lunaphyte_: the final -e '}' is rather funny :)
17:25  lunaphyte_: can that expression be improved?
17:33  lunaphyte_: ah.  sed -e :a -e '/^\n*$/{$d;N;ba}'  seems to give the same result.
17:34  lunaphyte_: cthuluh: that's what you were referring to?
--- Log closed Mon Dec 20 21:34:39 2010
--- Log opened Mon Dec 20 21:40:01 2010
21:40 --- Users 91 nicks [0 ops, 0 halfops, 0 voices, 91 normal]
21:41 --- Channel ##sed was synced in 106 seconds
22:29 --- xelister is now known as xelister_
22:35  pyoor: Hi all.  I've checked several google resources and haven't been able to find an answer to this.  For some reason I can't replace \r\r with \r in sed.  I've tried a number of possibilities all of which failed so its probably of no use to post them here.  Any ideas?
22:42  pyoor: Eh, figured out what my problem was.  Thanks anyway.
22:54  pyoor: Ahh I take that back.  Can anyone tell me why lines 4 & 5 aren't working?  http://pastebin.com/k5nLTRWv
--- Log closed Mon Dec 20 23:31:37 2010
--- Log opened Mon Dec 20 23:31:58 2010
23:31 --- Users 89 nicks [0 ops, 0 halfops, 0 voices, 89 normal]
23:33 --- Channel ##sed was synced in 106 seconds
23:51  kn0x: how can i escape curly brackets?
23:52  kn0x: /s/{$/${/
23:52  kn0x: i tried /s/\{$/$\{/
23:53  cthuluh: 4# echo 'foo{ar' | sed 's/{/b/' # kn0x
23:53  shbot: cthuluh: foobar
23:54  The-Compiler: kn0x: what are the //s and the $s for? o_O
23:54  kn0x: im trying to replace {$ with ${
23:55  cthuluh: but sed /s/... isn't a valid sed command
23:55  kn0x: cthuluh: i meant s/ sorry
23:55  The-Compiler: sed 's/{$/${/g'
23:55  The-Compiler: a { is a literal {, \{ is a { with special meaning (quantifier)
23:56  cthuluh: sed 's/{[$]/${/g' rather
23:56  The-Compiler: just be sure to quote your regular expression, so your $ don't get eaten by your shell
23:56  cthuluh: $ is special when in the LHS
23:56  The-Compiler: heh, what does it stand for?
23:56  The-Compiler: oh, wait
23:56  cthuluh: end of the buffer
23:56  The-Compiler: *selffacepalm*
23:56  kn0x: ahh
23:56  kn0x: ok
23:56  kn0x: thanks guy
23:56  kn0x: s
23:56  kn0x: it was the $
23:57  kn0x: []
23:57  cthuluh: yw
23:57  cthuluh: pyoor: did you find why your solution wasn't working?
23:57  pyoor: cthuluh: unfortunately, no.
23:59  cthuluh: ok, so first, make line 4 look like: ... -e ':a; $!{ N; ba; }; s/\n/\r/g' ...
23:59  cthuluh: because you don't want to call N if you're on the last line
--- Log closed Tue Dec 21 00:00:01 2010
