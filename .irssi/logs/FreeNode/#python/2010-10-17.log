--- Log opened Sun Oct 17 12:27:40 2010
12:27 --- Users 711 nicks [0 ops, 0 halfops, 0 voices, 711 normal]
12:27  marlun: DasIch_: Used in a simple script so I don't think that matters much here.
12:29 --- Channel #python was synced in 102 seconds
12:29  GrIM147: is wx likely to be ported to python 3 ?
12:29  marlun: DasIch_: Is it very inefficient or just a little less efficient then doing it some other way? :)
12:30  DasIch_: marlun: depends on how many functions you are calling and what they are doing
12:32  marlun: DasIch_: walking a directory tree looking for changed files in this case.
12:33  DasIch_: marlun: i would avoid it
12:50  ssbr: GrIM147: Yes. Eventually.
12:50  opc_0de: Hi all , I found a programming puzzle site - http://challenge.greplin.com/  it's kinda like projecteuler but only 3 levels,  have a look.
12:50  ssbr: assuming you mean wxPython
12:51  GrIM147: ssbr, yea i mean wxPython
12:51  ssbr: opc_0de: looks more like the Python Challenge
12:51  GrIM147: ssbr, that is good to know
12:51  merijn: ssbr: It's not, it's a bunch of exercises more aking to Programming Praxis/Code Kata's, etc
12:52  merijn: Stuff like "find the long palindrome in this string", etc
12:52  opc_0de: ssbr: It's rather language agnostic, you just need to solve the puzzles and enter the answer to get to the next level, but python knowledge certainly reduces the coding time taken.
12:52  merijn: Python Challenge was more trial and error puzzles last time I looked
12:53  merijn: In fact, the first challenge is literally copied (including the search string) from Programming Praxis
12:53  nvictor: holaaa
12:53  lvh: merijn: this is the internet, plagiarism isn't a real crime anymore
12:54  opc_0de: merijin: palindrome problem algo is actually quite well known, But it took me some time to realize that If the input text is so small even brute force algo would work.
12:54  merijn: lvh: Silly me and my ideas of crediting people :)
12:55  opc_0de: Wasted lot of time to implement the *elegant* approach to palindrome solution. :/
12:55  lvh: What's the palindrome problem?
12:56  lvh: Anagram-of-a-palindrome?
12:56  lvh: I don't understand why you would bruteforce it, the elegant solution is easier to write
12:56  kaitlyn: lvh: A function that returns true if the input is a palindrome and false if it's not.
12:56  merijn: I was going to write a solution to the challenge, but have to much class work to do and am spending too much time procrastinating to work on silly programming challenges.
12:56  opc_0de: lvh: given input text, find the longest string which is a palindrome.
12:57  lvh: kaitlyn: That couldn't possibly be called a 'problem' by any stretch of the imagination
12:57  lvh: kaitlyn: palindrome = lambda s: s == "".join(reversed(s))
12:57  kaitlyn: lvh: Nope, it's an exercise in someone figuring out how to reverse a string in the given programming language and compare it.
12:58  nocture: nice one lvh :)
12:58  nocture: i would have used a stack
12:58  merijn: That problem is much smaller and simpler then finding the longest palindrome in an input text
12:58  opc_0de: lvh: finding whether a string is palindrome or not was not the original problem!!, but I needed to find the longest palindrome present in the input text.
12:58  kaitlyn: sub is_pal { reverse $_[0] eq $_[0] } # Go go gadget implict return
12:58  merijn: Doing the latter efficiently is at least mildly challenging for large inputs
12:59  lvh: opc_0de: Yes, yes! No need to shout, I was replying to kaitlyn!
12:59  kaitlyn: opc_0de: Oh, go me not actually reading up.  ^.^
13:00  opc_0de: lvh kaitlyn : Okie..
13:01  bradleyayers: what convention should i use for a changelog?
13:02  kaitlyn: bradleyayers: http://github.com/symkat/Stalker/blob/master/ChangeLog That's the one I like if it's any inspiration =)
13:02  lvh: bradleyayers: Version control
13:02  bradleyayers: lvh: okay, well i guess my real question is how should i document backwards incompatible changes in my library?
13:02  bradleyayers: im using git, if that's relevant
13:03  lvh: bradleyayers: you poor soul
13:03  opc_0de: lvh:  *palindrome = lambda s: s == "".join(reversed(s))*, can't it just be palindrome = lambda s: s == s[::-1] , I don't see any need to do a explicit join.
13:03  merijn: opc_0de: Yes
13:03  bradleyayers: lvh: git makes me a poor soul?
13:03  kaitlyn: git++
13:04  bradleyayers: kaitlyn: thanks for the link too
13:04  lvh: bradleyayers: I would expect backwards-incompatible changes to be visible in at least a CHANGELOG file and in the "real" documentation (the kind you would generate with Sphinx)
13:04  lvh: bradleyayers: Yeah. I've been drawn in that discussion too many times, though.
13:05  lvh: bradleyayers: I've used git very, very extensively and I agree with most of the reasons the PSF decided not to use it with Python.
13:05  lvh: bradleyayers: (Which is that most people I know that use git don't know it very well, and there are a lot of subtle false-friends in the git toolkit that don't do what you want.)
13:07  cteng04: hey guys
13:07  cteng04: i'm getting a typeerror error: __init__() takes exactly 12 arguments (13 given)
13:07  cteng04: this is my class (http://dpaste.com/259191/)
13:07  lvh: cteng04: Argh. What disgusting thing are you using that takes 12 arguments?
13:08  merijn: cteng04: Well, stop giving the __init__() more arguments then it needs then?
13:08  bjarni: How do I get the integer part of a number, f.e. '123' as the integer part of '123abc' - I remember vaguely some simple way to accomplish this
13:08  merijn: And I second lvh's comment that if you need 12 arguments you're doing something wrong
13:08  lvh: bjarni: "123abc" is a fine hex number
13:08  lvh: bjarni: Consider "".join
13:08  cteng04: oops nvm just found error
13:08  lvh: err
13:08  cteng04: sorry about that guys
13:09  lvh: bjarni: "".join(takewhile(str.isdigit, s))
13:09  lvh: that gives you the first contiguous bunch of digits
13:09  lvh: oh, it's django
13:11  merijn: If that's what Django code looks like I'm glad I never decided to try it >.>
13:12  lvh: merijn: (It doesn't have to, but stuff that looks like that is common with Django newbies, yeah.)
13:12  bradleyayers: cteng04: still fighting with that i see :P
13:13  bjarni: thx lvh
13:14  lvh: bradleyayers: To be fair, github is pretty awesome. Everything that isn't the issue tracker is pretty good.
13:14  bradleyayers: lvh: i haven't used github for my own repo yet
13:15  cteng04: hahah naa
13:15  cteng04: bradley good to hear from you
13:15  cteng04: we got it resolved
13:15  bradleyayers: cteng04: what'd you end up doing?
13:15  cteng04: ended up taking your advice and going with suds
13:15  bradleyayers: cteng04: cool
13:15  cteng04: so soap 1.1, which suds uses, does not need a header
13:15  cteng04: but the example they provided was soap 1.2
13:16  cteng04: the other issue was the xml request should have been sent to a different url that works on soap 1.1
13:16  cteng04: the one in their documentation was for soap 1.2
13:16  cteng04: once i changed the url it worked
13:16  cteng04: sadly it was just poor documentation on their end
13:16  cteng04: surprise..
13:16  bradleyayers: cteng04: ahhh, wow that would have made it easier, haha
13:16  lvh: If you're using SOAP you're pretty much always some degree of screwed unfortunately.
13:16  cteng04: yes no joke
13:16  cteng04: 20 hours poured to 1 parameter
13:16  cteng04: yay O_o
13:16  lvh: The S in SOAP stands for "simple", not "sane".
13:16  cteng04: anyway, thanks again for working wiht me through that
13:17  bradleyayers: cteng04: yeah no worries, im glad suds worked in the end, since i told you to use it :P
13:18  cteng04: :)
13:19  bradleyayers: it's good to know about 1.1 vs 1.2 though, in case i run into it
13:24  cteng04: for sure
13:31  Darkproger: hi! how to make python go through all .py in the package, dump bytecode (.pyc) and exit without executing anything?
13:33  Darkproger: oh, i see: python -m compileall .
13:35  smorg: morning
13:40  smorg: palandrome = (lambda z: partial(lambda a, b: a(a, b), z))(lambda f, x, y: y[0] + f(f, x, y[1:]) + y[0] if len(y) > 1 else y[0] + x + y[0])
13:43  smorg: palindrome = lambda *z: reduce((lambda x, y: y + x + y), z)
13:44  smorg: palindrome('c', 'amanaplana') -> 'amanaplanacamanaplana'
13:44  smorg: :/
13:44  merijn: Smoko: That's awful
13:44  merijn: s/Smoko/smorg
13:45  opc_0de: smorg: Yeah, i don't get your code, what is it supposed to do?
13:45  ssbr: should probably be y + x +y[::-1] ?
13:46  smorg: take a letter and a list and sandwich them until the list is empty
13:46  smorg: or "iterable"
13:48  opc_0de: smorg: How this can be used to find the palindrome, still clueless..
13:49  lvh: opc_0de: That *produces* palindromes.
13:50  opc_0de: lvh,smorg: Oh, ok.
13:50  smorg: it's a bit flawed
13:51  smorg: that first one you'd still have to do palandrome(palandrome, x) since I wrote the fake Y combinator wrong
13:51  opc_0de: smorg: yeah, i think you should put in the ssbr change -  "should probably be y + x +y[::-1] ?"
13:52  merijn: A better question would be "Why do you need this?"?
13:53  smorg: I don't. opc_0de pasted one up a bit and I decided to write a stupid one.
13:53  merijn: He pasted one that checked whether a string was a palindrome, not one that makes palindromes
13:54  smorg: yeah... I saw the reversed thing and thought it was just taking a string and concatinating a reversed version
13:56  opc_0de: smorg: given a input string, it just checks if the input string and it's reversed form is same.
13:58  qwerty1793: heya, what should run faster:- for i in range(len(x), len(x) + len(y)): foo(i) OR:- for i in range(len(y)): foo(len(x) + i) ?
13:59  qwerty1793: timeit seems to think the second one (by about 40%) but does this sound reasonable to people? http://pastie.org/1227458
13:59  lvh: Here's a simple review question. You should be able to do this in under 2 minutes if you know Python. Write something that checks if something is an anagram of a palindrome. So 'adcacbb' can be rearranged to 'abcdcba', so your algorithm would return True.
13:59  lvh: (Feel free to PM results so you don't spoil it for others.)
14:00  Thiryal: qwerty1793: Is there any reason to disbelieve the actual results timeit gives to you? Or are you asking about why that should be the case?
14:01  qwerty1793: i'm slightly surprised by the results, surely the range has to be recalculated on each itteration in case it's changed - so this shouldn't be any faster, right?
14:01  qwerty1793: could you explain why this is the case?
14:01  lvh: Signature should be something like String -> Bool.
14:03  Thiryal: qwerty1793: From the language reference for `for`: "The expression list is evaluated once; it should yield an iterable object." So I don't agree that range is recalculated on each iteration, to start with. :)
14:04  qwerty1793: Thiryal: but "for i in R: R.append('1')" loops forever, so surely it must be being re-evaluated, right?
14:05  Thiryal: qwerty1793: Nope, R yields an iterable object exactly once, like the language reference says.
14:06  qwerty1793: ah, ok then
14:06  Thiryal: That iterable is queried for a new result on each iteration, which is why it loops forever in that particular example.
14:06  qwerty1793: ok that makes sense
14:06  ronny: qwerty1793: you should not change the collection you iterate
14:06  Thiryal: Very true. :)
14:08  qwerty1793: what about in somthing like dijkstra algorithm where i want a list of nodes to look at and slowly wor my way through whilst adding new ones when needed?
14:10  merijn: qwerty1793: On slightly related note, don't modify lists(or sequences) while iterating over them, it's asking for problems
14:10  ronny: qwerty1793: people tend to use queues for that
14:10  qwerty1793: ok, can you suggest an alternative method in a situation lie pathfinding?
14:10  ronny: qwerty1793: push stuff to one end, pop stuff from the other end
14:11  Thiryal: qwerty1793: Yes, use a structure that's designed to be modified while iterating over, e.g. stack, queue, etc. :)
14:11  ronny: collections.deque should help
14:12  merijn: stacks and queues are not really helpful for Dijkstra's algorith though. On the other hand I don't think I would implement that using a for loop in the first place
14:12  qwerty1793: ok, but in what im actually doing i dont want to 'pop' (remove) the first item off of the list
14:14  qwerty1793: the list needs to remain 'whole' and just have items added to it
14:14  merijn: qwerty1793: In pseudo code: http://dpaste.com/259208/
14:15  ssbr: merijn: queues are good for dijkstra's algorithm.
14:15  merijn: Or pseudo comments even
14:15  ssbr: heapqueues makes for fast implementations.
14:15  merijn: Where results is a set of whatever
14:15  ssbr: make*
14:15  ssbr: I used heapq when I wrote an implementation of A*
14:15  merijn: Oh wait,  I think I might be thinking of the wrong algorithm >.>
14:15  qwerty1793: merijn: ok, but i dont want #remove it from setofcandidates, in which case the algo doesn't work
14:16  dalela: Hi. I have a text with a few newlines. Now I want to print out each line with a \t before it
14:16  dalela: How can I do this in one line?
14:16  ssbr: qwerty1793: er, yes you do
14:16  Thiryal: qwerty1793: re: your original question, the formulation is actually confusing the issue with a speed difference due to a different cause. Here's another way to put it: http://pastie.org/1227493
14:16  merijn: qwerty1793: Yes it does...
14:17  merijn: qwerty1793: Once you select one of the candidates it is no longer a candidate since you selected it already...
14:17  ssbr: qwerty1793: the way dijkstra's algorithm works is, you go out from the center in an expanding circle. Once an element leaves the edge of the circle, a quicker path cannot be found for it, so it's removed from consideration and given a final distance/edge-weight
14:17  dalela: I'm searching this special syntax like print ["\t%s" for each self.response.info().split("\n")]
14:18  ssbr: qwerty1793: dijkstra's algorithm just selects nodes in order of how close they are given all previous nodes, and finalizes their distance, and updates neighbors
14:18  qwerty1793: ok, i agree your algo works but dijsktras was just an example of a similar type of problem, in mine i dont want to remove items from the list
14:18  qwerty1793: just a min, ill write some pseudo-code
14:18  merijn: Don't give wrong examples then?
14:19  km0r3: dalela: so you want the remove the newlines?
14:19  km0r3: s/to/the
14:19  qwerty1793: sorry, although i did say "in what im actually doing i dont want to 'pop' (remove) the first item off of the list"
14:22  dalela: km0r3: No I want to add a \t at the beginning of each line
14:22  kerio: what's the best way to accept starting values in a constructor?
14:22  kerio: this is a class that represents a sudoku board
14:23  kerio: but i could want to create it starting from a string, a list, a list of lists, or maybe something else
14:24  nosklo: kerio: make many constructors
14:24  kerio: is it ok if i make the default constructor just make it empty, and then have classmethods to accept the starting values?
14:24  nosklo: kerio: exactly
14:24  kerio: the second "make" should be read as "leave"
14:24  kerio: nosklo: ok
14:25  dalela: I have a text with a few linesbreaks. Now I want to add a \t at the beginning of each line. How can I do this in one line?
14:26  qwerty1793: merijn: ok, this roughly describes what it's doing: http://pastie.org/1227514
14:26  dalela: ["\t",header for self.response.info().split("\n")] does not work
14:28  dalela: any ideas?
14:28  km0r3: dalela: ["\t" + i for i in text.split("\n")]
14:28  km0r3: this should work
14:28  km0r3: you were close ;-)
14:29  kerio: "\n".join("\t" + line for line in text.split("\n")) won't take more memory than it's needed - probably
14:29  kerio: not sure how efficient is split
14:29  kerio: what does it return? a list or an iterator?
14:30  kerio: oh but of course
14:31  kerio: "\t" + text.replace("\n", "\n\t")
14:31  km0r3: that's a cool way to solve the problem, kerio
14:32  kerio: it is
14:32  kerio: :)
14:32  kerio: i want a frozenset literal :(
14:35  lvh: kerio: let's just remove sets
14:35  kerio: why :(
14:35  lvh: kerio: mutability is lies
14:35  kerio: and yet
14:35  ssbr: f{a, b, c}
14:38  kzar: It happens quite often that some library raises an exception, then when I try to allow for that I get an undeclared global error. Then I have to figure out where that exception was declared and import it, but sometimes I can't figure out where it was declared. Is there an easier way?
14:38  kerio: tuple(tuple(set(range(1, 10)) for x in range(9)) for y in range(9))
14:38  kerio: nested containers suck :(
14:40  Yhg1s: kzar: well, you can skip the first NameError because unless you already explicitly import the name, the name won't be available.
14:41  Yhg1s: kzar: other than that, the module should be fairly apparent from the traceback or from the documentation of what's raising it. If it isn't, sometimes it's tricky to find, yes.
14:41  Yhg1s: (but if you don't know how or why the exception is raised, should you be handling it at all?)
14:42  rdpate: kzar: it's common to raise either standard exception types (ValueError, TypeError, etc.) or a custom type local to a specific module; look in the module (specifically its docs) you call for exception types
14:44  kzar: OK here's an example, I'm playing with one of Google's APIs and messing with google Calendar. If your token isn't valid or isn't present it throws a NonAuthSubToken exception. It doesn't say which module it's in or anything and there's quite a few that I had to include to try this stuff out
14:45  kzar: I know I need to accept the exception because it just means they aren't logged in, it seems dumb I have to include the name when it seems to really be a string literal anyway
14:45  kzar: like in Lisp or something you would just write 'example , I don't see why it needs to be included anyway?
14:49  xeer: perhaps I'm doing this wrong: foo = "bin", func(foo="bar"), print foo <-- expects "bar"
14:49  xeer: value "bar" should also get passed into func
14:49  kerio: what's "," there?
14:49  kerio: a newline?
14:49  kerio: use a pastebin
14:50  jasonx: func(foo="bar") passes "bar" to func's foo key argument. it doesn't change foo you assigned "bin" to
14:50  rdpate: kzar: exception types aren't just string literals in python
14:51  jasonx: xeer if you had def func(foo=None, bar=None)   func(bar=10) is the same as foo(None, 10)
14:52  kzar: rdpate: Yea I just noticed, I just found this one and it's an object. That makes me wonder though, what else do they do?
14:52  merijn: kzar: Usually not much
14:53  merijn: But you could store debugging info on them, I gues
14:53  xeer: perhaps I'm doing this wrong: foo = "bin", func(foo="bar"), print foo <-- expects "bar" and value "bar" should also get passed into func
14:53  kzar: merijn: So I guess that makes me wonder, why are they objects or at least why can't they be assumed not to be unless they are
14:54  merijn: kzar: Because in python everything is an object
14:54  rdpate: kzar: depends on the exact type, look at IOError for example; the most important bit they do is just provide a unique hierarchical identity plus a rudimentary explanation (e.g. when converted to a string and output)
14:54  merijn: And yes, the inheritance hierarchy lets you make more sense of their meaning
14:55  kzar: yea that's true
14:55  ssbr: xeer: you are. you're thinking of C syntax, but this isn't C.
14:55  ssbr: xeer: in Python, x = y is not an expression, it's an assignment statement
14:55  jasonx: xeer did you read anything I said above?
14:55  ssbr: xeer: foo(x=y) is a call expression, passing y as the value for the x parameter
14:55  ssbr: it's a "keyword argument"
14:56  robertpayne: Isn't communicate() on Popen supposed to take stdin?
14:57  eggy_: robertpayne: no, it's supposed to take input (as a string)
14:57  rdpate: robertpayne: http://docs.python.org/library/subprocess.html#subprocess.Popen.communicate
14:57  robertpayne: eggy_: Ah. it does not write it to stdin?
14:58  rdpate: it does write it to the child process's stdin
14:58  eggy_: robertpayne: it does
14:58  rdpate: robertpayne: did you set stdin=PIPE as that link mentions?
14:58  robertpayne: Popen(['echo', '-n'], stdin = PIPE).communicate(u'Hello World')[0]
14:59  rdpate: "Similarly, to get anything other than None in the result tuple, you need to give stdout=PIPE and/or stderr=PIPE too." :)
15:00  sabalaba: if I have a string 'foo' and a Longint barL, how do i figure out their types?
15:00  rdpate: /bin/echo doesn't read stdin though, does it?
15:00  robertpayne: rdpate: shit*
15:01  robertpayne: rdpate: haha thanks
15:04  sabalaba: i just found the isinstance('foo', str) function returns True *yay*
15:05  merijn: sabalaba: That is almost certainly the wrong solution
15:05  merijn: sabalaba: Why do you need to figure out their type?
15:06  sabalaba: function baz(item) base36encodes or base36decodes an item based on whether it is a str or an int
15:06  dalela: I imported a package via m = __import__('modules.%s.%s' % (i, i))
15:06  sabalaba: merijn, is there a better way to do that?
15:06  merijn: That is awful, why not make separate encode and decode functions?
15:06  dalela: Now I want to call a function from modules.FOO.FOO how can I do that?
15:07  VladDrac: sabalaba, define two functions, encode and decode
15:07  dalela: the function is called "Init"
15:07  VladDrac: no need to stuff everything in a single function
15:07  VladDrac: refactor common code into another shared function (but I doubt there is any)
15:07  VladDrac: having a function do two different things based on type is certainly wrong
15:07  sabalaba: VladDrac, merijn so my idea was to allow people plugging into the api to swap an id for a hash with just one function
15:08  merijn: sabalaba: Don't.
15:09  sabalaba: ok, two functions it is ;0
15:09  sabalaba: that was supposed to be :)
15:12  xeer: perhaps I'm doing this wrong: foo = "bin", func(foo="bar"), print foo <-- expects "bar" and value "bar" should also get passed into func
15:14  Yhg1s: xeer: you're doing that wrong, yes.
15:14  Yhg1s: 'func(foo="bar")' doesn't assign to 'foo'. it passes "bar" as the keyword argument 'foo'.
15:14  Yhg1s: you can't assign to 'foo' in a functioncall. that's not how assignment works in Python.
15:16  Yhg1s: dalela: 'm' will be the 'modules' package, you will need to use getattr() to get the 'i' module from it, and then getattr again to get the 'i' function (or whatever modules.i.i will be.)
15:17  kzar: Another question about exceptions, I find sometimes the program logic is hard to write when you have to mix if statements and exception catching. Is there an easier way to do that?
15:18  kzar: (Best I could see was hackish, setting a flag in the exception handler and then checking for that flag in my logic)
15:19  Yhg1s: kzar: hard to say. it depends greatly on what kind of code you're writing, and why you're catching the exceptions at all.
15:19  kzar: Yhg1s: Why I'm catching the exceptions at all: it's the only way I can check if the token I have is valid or not.
15:20  kzar: Yhg1s: I'm writing something like "If user in database and user.token is valid then LOGGED IN otherwise NOT LOGGED IN"
15:21  kzar: oh sorry, that's wrong it's more like this.. "If user in database and user.token is valid then LOGGED IN, else if get parameter is there TURN THAT INTO A TOKEN otherwise NOT LOGGED IN"
15:21  Yhg1s: Put the 'is the token valid' operation in a function, then.
15:21  robertpayne: There any easy helpers for bytearray to write ints, shorts and the such?
15:22  Yhg1s: robertpayne: the struct module.
15:22  kzar: Yhg1s: What's the point of their function to check if a token is valid throwing an exception if everyone then just has to wrap it in their own function that hides the exception?
15:23  kzar: Yhg1s: (good idae though I'm going to do it)
15:23  Yhg1s: kzar: you'd have to ask whoever wrote this function.
15:25 --- rizzuh_ is now known as rizzuh
15:29  kzar: Yhg1s: Thanks, that looks a lot better now
15:29  xeer: I'm reading my process stdout with communicate but it's blocking and I can only get data once the process child has terminated. is there an async method to reading stdout?
15:32  bsdbandit: good morning all
15:32  bsdbandit: hows everything going
--- Log closed Sun Oct 17 21:23:13 2010
