--- Log opened Thu Dec 23 00:00:36 2010
--- Day changed Thu Dec 23 2010
00:00  geirha: if ((i==0)); then echo "No integer found"; exit 1; fi
00:00  geirha: Weird thing to do though
00:17  Bushmills: why not   [[  121 == *[!0-9]* ]] && echo "not integer"    ?
00:19  Bushmills: # [[  123x == *[!0-9]* ]] && echo "not integer"
00:19  evalbot: Bushmills: not integer
00:19  Bushmills: # [[  4x321 == *[!0-9]* ]] && echo "not integer"
00:19  evalbot: Bushmills: not integer
00:19  Bushmills: # [[  4321 == *[!0-9]* ]] && echo "not integer"
00:19  evalbot: Bushmills: no output
00:20  Bushmills: oh. nm. scanning for first non digit. missed that
00:21  nunojpg: can ftp(1) itself be used to download all files like "/*/*/*/*.ABC"?
00:21  nunojpg: or I'm looking for a script to first list them and then download one by one?
00:23  geirha: I think you can use patterns like that with lftp. Not sure though.
00:25  knoppix_____: you can certainly do it with scp and get all the files
00:27  knoppix_____: nonojpg: but then you may need appropriate access to the remote maschine
00:27  knoppix_____: machine
00:27  knoppix_____: nunojpg:  sorry sticy fingers
00:28  lhunath: nunojpg: no
00:28  lhunath: ftp(1) sucks.
00:28  lhunath: avoid at all cost.
00:28  Bushmills: # var=123456_456; idx="${var/[!0-9]*}"; echo ${#idx}   # this would do
00:28  evalbot: Bushmills: 6
00:28  nunojpg: ftp sucks
00:29  lhunath: you mean the protocol?  sure.  but the program does more.
00:29  lhunath: !ftp
00:29  greybot: http://mywiki.wooledge.org/FtpMustDie
00:31  nunojpg: I think I've read that before a few months ago, that opened my eyes about it
00:31  nunojpg: But i'm using a embedded device that still doens't take scp
00:31  nunojpg: but I have hope
00:37  lhunath: install rsync
00:44  nunojpg: mget -d */*/*/*.T02
00:44  nunojpg: worked, thanks!
00:44  nunojpg: I almost killed myselft yesterday looking to do this with ftp(1)
00:44  nunojpg: and actually searching at google for "recursive ftp" and such didn't get me to lftp(1)
00:49  i0nic: how would I add to a script to check the time stamp on a file, if it is within the last 30 mins, then do nohting?
00:51  i0nic: would -ot work?
00:51  e36freak: what command -ot?
00:52  e36freak: i would parse stat -c %y or whatever you need personally
00:54  Bushmills: # arr=([a-z]); echo "$arr"
00:54  evalbot: Bushmills: [a-z]
00:54  Bushmills: mine outputs "m"
00:55  Tramp: yes
00:55  Tramp: # touch m; arr=([a-z]); echo "$arr"
00:56  evalbot: Tramp: m
00:56  Tramp: always quote globs
00:56  Bushmills: ah.
00:56  Tramp: yw
01:08  Bushmills: # arr=({a..z}); echo "${arr[@]}"   # how could I output all items without seperating space
01:08  evalbot: Bushmills: a b c d e f g h i j k l m n o p q r s t u v w x y z
01:08  Bushmills: # arr=({a..z}); x="${arr[@]}"; echo "${x// /}"   # so it looks like this but without the extra intermediate assignment?
01:08  evalbot: Bushmills: abcdefghijklmnopqrstuvwxyz
01:10  e36freak: hmm
01:11  Tramp: # arr=({a..z}); printf "%s" "${arr[@]}"
01:11  evalbot: Tramp: abcdefghijklmnopqrstuvwxyz
01:12  Bushmills: good one, thanks.
01:12  Tramp: echo outputs its arguments space-seperated. So use something that does not do this
01:12  Tramp: yw
01:20 --- Unknown[NF] is now known as Unknown[OFF]
--- Log closed Thu Dec 23 01:30:08 2010
--- Log opened Thu Dec 23 01:30:30 2010
01:30 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
01:31  i0nic: e36freak: so a IF statement works like this If variable = variable then execute commands else (unless) something is whatever then exit (if I set it to exit) ?
01:32 --- Channel #bash was synced in 101 seconds
01:33  TheBonsai: no. if executes commands and branches according to their exit status
01:37  i0nic: So I want a If statement to run if the variables match, unless the file is older than 30 minutes. then exit.
01:37  i0nic: how would I accomplish this?
01:37  mhahe: from what i understand depending on how u login certain dotfiles get looked at when others do not. what i dont get is why would transient thngs such as aliases and function should be placed in .bashrc? console login ignore bashrc.... so why if i do want my aliases no matter what just leave them in bash_profile?
01:38  TheBonsai: i0nic: you'd need a command that sets a useful exit code if two strings match or not. you can use this command for the if-clause
01:39  i0nic: TheBonsai: sorry, still confused.
01:39  seekwill: I have two text files. I'd like to know which lines in the first file are not in the second.  I can't seem to get diff to work, as it's showing me the same lines that are in both tables, perhaps because of the position of the line
01:41  tsolox: mhahe: .bashrc gets sourced for each new session... whereas .bash_profile is once during login.. functions and aliases cannot be exported, so they should be in .bashrc
01:41  i0nic: TheBonsai you mean a command to check the time on the file ? I could touch a file then compare that file with [ FILE1 -ot FILE2 ]
01:41  TheBonsai: i0nic: if test "$foo" = "$bar"; then ...; else ...; fi
01:42  mhahe: sourced meaning?
01:42  i0nic: so the 30 minute file check would have to come right after the if foo=bar ?
01:42  TheBonsai: i0nic: now I am confused. you wanted to compare two strings first
01:43  tsolox: mhahe: meaning, it's executed and the values inside that script persist and don't evaporate after execution
01:44  i0nic: TheBonsai: yes, compare two strings and then look for a file, if the file is there compare to current time, if older than 30 minutes continue or exit.
01:44  tsolox: if inside a script there is 'a=123', if this script is executed, the value of 'a' will not persist. If you source the script, the value of a=123 will stay
01:45  tsolox: mhahe: also, a function inside .bash_profile is of no use in other terminals...
01:46  TheBonsai: i0nic: well, nest 2 if's. the time checking.... hm, could be simplified. imho you could check if find /where/ever -type f -name "foo.txt" -mmin +30 outputs any text or not (GNU find)
01:47  i0nic: or find -mtime yeah
01:47  mhahe: but wait ive tried exporting things in a shell on the terminal.. then after closing it and opening another they are still there.... but with .bash_profile my exported variables are persistant, why is that? if ur saying they get sourced once?
01:47  TheBonsai: -mtime isn't usable here
01:48  TheBonsai: i0nic: -mtime's granularity is a 24h wide window
01:48  i0nic: ah
01:48  i0nic: May I msg you for a minute?
01:48  TheBonsai: y0
01:50  tsolox: mhahe: export a=123, and closing the terminal will loss the value of a. That's for sure.
01:51  mhahe: so why is bash_profile exports persistant?
01:52  tsolox: mhahe: `ps -ef|grep bash`  <----------- and if you see several '-bash' with a hyphen then your bash sessions are configured as login sessions, and therefore sources again your .bash_profile ( this behavior is bad, fix it!)
01:52  TheBonsai: they are as persistent as they can be
01:52  TheBonsai: you can never influence any other processes with export, except newly created child processes
01:53  tsolox: mhahe: .bash_profile should ONLY be executed once... and not for every new shell that you open..
01:55  mhahe: how do i change that my bash sessions are not login sessions?
01:55  tsolox: mhahe: what is your window manager?
01:55  seekwill: "login sessions"?
01:55  mhahe: think aqua? im running osx
01:56  tsolox: seekwill: "-bash'
01:57  TheBonsai: the INVOCATION section describes it pretty clear, mhahe
01:58  mhahe: thanks
01:59  TheBonsai: and that might give you an idea about exporting/not exporting and in general about what a process tree is http://wiki.bash-hackers.org/scripting/processtree
02:04  tsolox: mhahe: /quit
02:37  getxsick: hi
02:37  getxsick: ssh $WWW1 "if [ -e $STATICDIR/$dir ]; then; ln -s $STATICDIR/$dir $WWWDIR/$dir; fi"
02:37  getxsick: i get some errors
02:37  getxsick: bash: -c: line 0: syntax error near unexpected token `;'
02:38  e36freak: no ; after then
02:38  e36freak: also
02:38  e36freak: ![[
02:38  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
02:38  e36freak: and
02:38  e36freak: !varcaps
02:38  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
02:39  getxsick: $dir is from the for loop, local var..
02:39  getxsick: anyway thanks
02:39  getxsick: you helped me out!
02:39  e36freak: np
02:39  tsolox: hmmm... i use [[ in a ksh script..
02:39  e36freak: getxsick: $dir is a directory?
02:40  getxsick: e36freak: yes
02:40  e36freak: ssh $www1 "[[ -d $staticdir/$dir ]] && ln -s foo bar"
02:40  TheBonsai: tsolox: naturally. [[ comes from the korn shell (just as many other good features)
02:41  getxsick: e36freak: is that [[ bash dependent?
02:41  TheBonsai: in #bash, yes
02:41  e36freak: getxsick: read the faq
02:41  getxsick: i read
02:41  tsolox: getxsick: it's in bash and ksh, i think not in sh
02:41  getxsick: and i think it's a bit risky
02:42  getxsick: as i can't be sure what shell is run on a remote machine
02:42  e36freak: *shrug* at least -d tests for a directory specifically, probably the better argument
02:42  tsolox: getxsick: then, you specify it...
02:42  e36freak: and you can always do "bash -c [[ -d foo ]] && ln -s foo bar"
02:43  e36freak: well, with more quotes and such, but yeah
02:43  TheBonsai: simply use [
02:44  getxsick: ssh $WWW1 "[ -e $STATICDIR/$dir ] && ln -s $STATICDIR/$dir $WWWDIR/$dir"
02:44  getxsick: yeah
02:44  getxsick: this one rocks
02:44  grop: TheBonsai, I thought you had to use [[ in bash, and not […
02:44  TheBonsai: grop: he doesn't write for bash, he said
02:44  grop: TheBonsai, oh sorry
02:45  TheBonsai: grop: he said he doesn't know the shell on the other side. so it's best to assume a minimal bourne like shell
02:45  getxsick: i'm staying with -e as there is a possibility there won't be only directories in the future
02:45  TheBonsai: use more quotes
02:45  getxsick: TheBonsai: for what for?
02:45  TheBonsai: for expansions of $STATICDIR which contain IFS whitespace
02:46  getxsick: i'm sure there won't be any whitespaces
02:47  TheBonsai: that means you coded discipline code to make it sure?
02:47  TheBonsai: otherwise you are not sure. period.
02:56  Dribble: what would i use a for i in {1..10}; echo $i;sleep 1;done to actaully do somthing
02:57  Nisstyre65: Dribble, for loops are generally to iterate over a set of data and perform some action
02:57  Dimitar: command1 && command2
02:57  Dimitar: what does that mean guys?
02:57  Dimitar: that against command1 || command2
02:57  Dribble: its a exit status
02:57  Nisstyre65: Dimitar, command2 only runs if command1 ran successfully
02:57  Dribble: && is true || is false
02:58  Dimitar: command1 && command2 wait lets first take a look at this :)
02:58  Dimitar: && command2 means is command 2 true?
02:58  Dribble: so if command 1 exit stuats is 0  "&&" or true then it will do command 2
02:59  e36freak: Dimitar: foo && bar, bar is done if foo is successful
02:59  e36freak: Dimitar: foo || bar, bar is done if foo errors
02:59  e36freak: Dimitar: or has an exit status >0
02:59  tsolox: or -1
02:59  e36freak: Dimitar: you can use foo && bar || baz like an if; then; else statement
03:00  e36freak: Dribble: to step through numbers youre better off with a c style for loop, for (( i=0; i<10; i++ )); do foo; done
03:00  e36freak: Dribble: you can use that to turn a string into an array
03:01  Tramp: Dimitar: you can, but you should not
03:01  Tramp: !pf ||
03:01  greybot: http://mywiki.wooledge.org/BashPitfalls#pf22 -- Don't do this! -- cmd1 && cmd2 || cmd3
03:01  Dribble: ok
03:02  e36freak: for (( i=0; i < ${#foo}; i++ )); do array[i]="${foo:i:1}"; done
03:02  Dribble: well you know every scripting guide shows how they are constructed but they don't really show good examples of what you can do with them
03:02  e36freak: erm, array[$i]
03:02  Nisstyre65: Dribble, bad scripting guides
03:02  getxsick: does bash have dictionaries?
03:02  Nisstyre65: most of the shell scripts you see on the internet are poorly written
03:02  Dimitar: what does echo -n mean?
03:02  Dimitar: echo is print but -n?
03:03  e36freak: dont print a new line afterwards
03:03  e36freak: and theres also printf
03:03  Nisstyre65: getxsick, are you wanting to spellcheck something? use aspell
03:03  e36freak: # echo -n "foo"; echo "bar"
03:03  Tramp: getxsick: bash4 has associative arrays, which is probably what you mean
03:03  evalbot: e36freak: foobar
03:03  pragma_: Written by high school kids hired as interns who call themselves sysadmins.
03:03  getxsick: Tramp: yes
03:03  Dribble: yeah I've look but only some are helpfull at least it gives me some idea
03:03  Dimitar: if  [ “$izbor” = . ] why would you do this? why put a variable like that in quotes
03:04  e36freak: if $izbor is unset or contains spaces
03:04  Tramp: Dimitar: there is a guide in the /topic which explains stuff like that and more
03:04  e36freak: http://mywiki.wooledge.org/BashGuide
03:04  Tramp: Dimitar: additionally you should have manpages on your system and, for builtins, "help"
03:04  Dribble: is there any other ones you guys know of besides the ones on this page
03:04  Tramp: Dimitar: to find out, if a command is a builtin use "type"
03:05  getxsick: Tramp: although i have 3.2 ;-)
03:05  Dimitar: and what does these mean ls - . and ls –l
03:05  Tramp: then you don't have associative arrays
03:05  Dimitar: i have my ubuntu broken i cant play with manual at moment
03:05  Dribble: the - is an option switch
03:05  Dimitar: just need help with those two commands please
03:05  Dimitar: yep i know what are the options though
03:05  Tramp: then search the bloody web. We are not interactive manpages
03:05  Dimitar: ls is list
03:05  Dribble: its in the manual of each command
03:06  Dribble: man ls
03:06  Dimitar: i said i have my ubuntu down so i cant check
03:06  Dribble: oh
03:06  Dribble: sry
03:06  skraito: hi guys
03:06  skraito: any one free to help
03:06  skraito: ?
03:06  Dimitar: what reference for commands you guys use?
03:06  skraito: http://yohanespatra.wordpress.com/2010/12/19/0x71-perl-logger-to-syslog-simple-key-logger/
03:06  getxsick: Dimitar: what is wrong with your Internet connection then?
03:06  skraito: i need to convert this perl to
03:07  skraito: bash script
03:07  skraito: any one free and willing to code it in bash ?
03:09  getxsick: is it possible to get dynamic var names? something like $$VAR where $VAR refers to FOO, so in fact it would equal to $FOO
03:09  Nisstyre65: whut
03:09  Tramp: !faq indirect
03:09  greybot: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
03:10  Tramp: getxsick: ^^
03:11  getxsick: Tramp: thx
03:11  Tramp: yw
03:13  g3d: hi, can dd accept hex values in its parameters? I tried but it only worked with decimals for me...
03:14 --- Aranel_ is now known as Aranel
03:16  tsolox: Tramp: is this indirection, for as long as how many nesting we do in that expansion?
03:17  Tramp: sorry, I fail to parse the question
03:17  tsolox: Tramp: i can indirect 20 or more times?
03:18  TheBonsai: !tias
03:18  greybot: Try It And See
03:19  Tramp: tsolox: you can't nest the ${!var} construct.
03:20  skraito: hi guys
03:20  Tramp: however, in arithmetic context it goes pretty deep
03:20  skraito: how do i display `whoami`and `pwd` at the same time
03:21  skraito: is there any function in bash that like print in perl ?
03:21  e36freak: printf is like C, i dont know perl
03:21  skraito: printf ?
03:21  skraito: thx u
03:21  e36freak: and is "whoami & pwd" what youre looking for?
03:21  skraito: yes with out space
03:22  skraito: so i can display root@/root >
03:22  grop: printf "$(whoami) ; $(pwd)\n"
03:22  e36freak: for your prompt?
03:22  e36freak: PS1?
03:22  skraito: yes
03:22  grop: but PS1 has \u and \w
03:22  skraito: thx u
03:22  e36freak: export PS1='\u@\w'
03:22  tsolox: good lord...
03:22  skraito: i am totally noob at bash script
03:23  skraito: sory for newbie question
03:23  skraito: dont know how to start it
03:23  e36freak: and put that last command in ~/.bashrc
03:23  e36freak: http://mywiki.wooledge.org/BashGuide
03:23  grop: The PS1 variable already has its own syntax…
03:23  tsolox: skraito: use this --> \[\033[1;32m\][\[\033[1;34m\]\u@\h \w\[\033[1;32m\]]\n\[\033[0;37m\]\$>\[\033[1;30m\]
03:24  e36freak: heh, looks like mine
03:24  e36freak: although i dont have a newline (assuming thats what \n is)
03:25  grop: skraito, http://pastebin.com/ai5aBqci
03:26  skraito: actually i am not trying for PS1
03:26  skraito: what i want is
03:26  skraito: SHELL = `whoami && pwd`
03:27  grop: what?
03:27  skraito: echo -n SHELL
03:27  skraito: and read the user input from SHELL
03:27  TheBonsai: don't use "SHELL" unless you know what you're doing
03:27  skraito: hmm shell a default variable ?
03:27  skraito: didnt know that dang
03:27  TheBonsai: it's used by various things, yes
03:27  grop: don't use the variable SHELL that is already declared
03:28  e36freak: whoa wha, do not use SHELL
03:28  skraito: any good start or can someone help me to convert this script to shell script
03:28  e36freak: !varcaps > skraito
03:28  greybot: skraito: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
03:28  skraito: http://yohanespatra.wordpress.com/2010/12/19/0x71-perl-logger-to-syslog-simple-key-logger/
03:28  skraito: sigh nvm
03:29  skraito: looks like i need to start from 0 before i can convert it to shell script
03:29  skraito: thx guys
03:29  grop: it's not bash
03:29  skraito: any good quick start up website
03:29  skraito: ?
03:29  skraito: for me to read other than google
03:29  skraito: google give me alot of crap that i dont need
03:29  e36freak: skraito: http://mywiki.wooledge.org/BashGuide
03:30  skraito: thx
03:30  LukeL: how would i trim "./" from all elements of an array?
03:30  pokoko222: listc=`ls  *.c` why the quotes?
03:30  pokoko222: does the quotes encapsulate command result?
03:31  pokoko222: why not without quotes listc=ls *.c
03:31  e36freak: !`
03:31  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
03:31  tsolox: that`s a backtique
03:31  knoppix_____: is it possible to have } and ] in your PS1
03:32  e36freak: knoppix_____: sure, i use { } for user and [ ] for root
03:32  pokoko222: e36freak like that ? listc= ’= $ls *.c
03:32  knoppix_____: I couldn't get it to accept { }
03:33  e36freak: pokoko222: read the FAQ, and it would be listc=$(ls *.c)
03:33  knoppix_____: I have a keyboard that wont type these and am pretty much always in a terminal
03:33  e36freak: also
03:33  e36freak: !ls > pokoko222
03:33  greybot: pokoko222: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
03:33  knoppix_____: e36freak: whay do you use for user?
03:33  knoppix_____: what
03:34  e36freak: knoppix_____: {\u@\h:\w}$ with color
03:34  e36freak: different color for different computers because i spend a lot of time in ssh terminals
03:36  grop: # array=( ./bar ./baz ./qux ); echo "${array[@]/.\/}" # you mean that LukeL?
03:36  evalbot: grop: bar baz qux
03:37  skraito: guys sory for another noob question
03:37  skraito: why is this fail
03:37  skraito: DIRECTORY = `pwd`
03:38  skraito: cant we do this ?
03:38  knoppix_____: odd it works fine now
03:38  e36freak: skraito: theres already an environment variable that tells you that, $PWD
03:38  Tramp: skraito: no. That's not an assignment. And you already have $PWD
03:39  e36freak: skraito: and did you not see the varcaps thing?
03:39  skraito: varcaps ?
03:39  grop: skraito, you can't put spaces in a variable declaration. and don't capitalize your variable name unless you know what you're doing. directory=$(pwd)
03:39  knoppix_____: oh thanks e36freak that is a great idea.  I am usually ssh'd to at least 4-6 different locations, I love your color idea
03:39  e36freak: # echo "$PWD"; mkdir foo; cd foo; echo "$PWD"
03:39  evalbot: e36freak: /root
03:39  evalbot: e36freak: /root/foo
03:39  skraito: oh okay thx for the tips
03:39  e36freak: !varcaps > skraito
03:39  greybot: skraito: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
03:41  grop: !` > skraito
03:41  greybot: skraito: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
03:41  knoppix_____: e36freak: my netbook keyboards keep dying on me, I now just make sure I have all the problematic key outputs handy for snarfing
03:41  skraito: wow thx
03:41  skraito: that help alot
03:42  e36freak: knoppix_____: or you could get a decent keyboard. i have a mid-level mechanical one now, thinking about grabbing an hhkb
03:43  skraito: directory=$(pwd)
03:43  skraito: whoami=$(whoami)
03:43  skraito: echo -n $directory @ $whoami>
03:43  skraito: why it cant work guys ?
03:43  grop: what's the @ ?
03:43  grop: !umq
03:43  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
03:44  e36freak: is there a section on PS1?
03:44  skraito: ok
03:44  e36freak: http://www.cyberciti.biz/tips/howto-linux-unix-bash-shell-setup-prompt.html
03:44  e36freak: skraito: ^^
03:44  e36freak: quick google
03:46  LukeL: yes, thank you grop
03:46  skraito: wow so nice this community in bash
03:46  skraito: is really helpfull
03:46  skraito: thx to u guys
03:46  skraito: #perl is crap
03:47  skraito: they will just dont answer most of the question nor guiding them
03:47  skraito: i thought i gonna be head shot for asking noob question here
03:47  skraito: lol
03:49  e36freak: ...its not too late
03:53  BaD_CrC: is there a simple way to get the last directory name in the pwd output? ex: /music/metallica/reload, i just want it to return reload
03:54  BaD_CrC: i'm assuming it's something simple, but for the life of me i can't figure it out.
03:56  knoppix_____: e36freak: haha     this is for an eeepc which I very often have to balance on my lap lacking anywhere to put it
03:57  grop: !basename > BaD_CrC
03:57  greybot: BaD_CrC: basename(1) can strip the directory and extension from a path. (a/b/c.d -> c.d or c). Or you can use a parameter expansion: "${path##*/}" or "${path%.*}"
03:57  BaD_CrC: ooh, thank you. I will try that.
03:58  knoppix_____: BaD_CrC: what do you mean?  it only shows one directory the working directory, what do you mean by last?
03:59  BaD_CrC: 'reload' would be the last directory in the pwd
04:00  knoppix_____: !parameter expansion
04:00  knoppix_____: nothing?
04:00  skraito: how about this guys
04:00  skraito: while [ $userinput ne "exit" ]
04:01  skraito: what is the command for matching string
04:01  skraito: != or ne ?
04:01  skraito: !ne
04:01  skraito: !ne > skraito
04:02  e36freak: either or
04:02  e36freak: -ne is the POSIX way iirc
04:02  knoppix_____: !test >skraito
04:02  greybot: skraito: help test <Enter> http://mywiki.wooledge.org/BashGuide/TestsAndConditionals | http://bash-hackers.org/wiki/doku.php/commands/classictest
04:02  e36freak: and you dont need to quote "exit", but you do need to quote $userinput
04:02  e36freak: [ "$userinput" -ne exit ]
04:03  e36freak: or [[ "$userinput" != exit ]] which is how i would do it for bash
04:03  skraito: thx
04:04  skraito: how about ignoring signal ?
04:04  e36freak: ?
04:04  skraito: nvm i will google it
04:04  knoppix_____: maybe it is there skraito it should be != for strings
04:04  e36freak: read the guide
04:04  e36freak: the whole thing
04:04  e36freak: then ask
04:05  knoppix_____: numeric is -ne
04:06  knoppix_____: skraito the guides here are so much better than anything you could google for - don't waste your time googling
04:07  skraito: ok
04:08  curious: cat /dev/ttyS0 | tr -cd '\n '.1234567890- | awk '// {print $0 ; system ...
04:08  curious: could anyone give me a hand why this does not work ?
04:09  grop: skraito, http://pastebin.com/eyxGVpeB I did what I could do.
04:09  curious: problem is with introducing tr as garbage filter
04:10  skraito: thx alot that help
04:10  skraito: i will publish the code once it finish
04:13  grop: skraito, well I missed a syntax
04:14  grop: skraito, proper one http://pastebin.com/P9HvPw0T
04:16  skraito: nice
04:21  grop: skraito, line 31, we just write the PID of our script in a file called PERLPID?
04:22  skraito: yes
04:22  skraito: it is uncessary
04:22  skraito: let me publish the code
04:22  skraito: it should be simple something like this
04:22  skraito: because it perl it call another perl process
04:22  skraito: instead of the bash
04:23  skraito: http://pastebin.com/EjaYWeuw
04:23  skraito: its something like that
04:24  skraito: i am trying to get it working
04:24  skraito: by if
04:24  grop: Wrong syntax…
04:24  skraito: err is the if one
04:24  skraito: let me read the if section
04:26  skraito: not in the website
04:26  skraito: sample of if and else
04:26  skraito: nvm let me google it
04:27  grop: http://pastebin.com/9rZaGdLL
04:27  grop: I don't understand your else part, though.
04:28  grop: Neither your if…
04:29  skraito: http://pastebin.com/Y5cg6wc2
04:29  e36freak: yeah, poorly designed algorithm
04:30  skraito: the if function just test if the command equal to exit
04:30  grop: « While the user input is not 'exit', then if the user input is 'exit' [...] »… Weird.
04:30  skraito: the rest of it
04:30  skraito: oh we need to kill -9 $$
04:30  skraito: thats why we need the if exit
04:30  skraito: to kill the bash completely
04:30  skraito: http://pastebin.com/Y5cg6wc2
04:30  skraito: the complete code
04:31  skraito: and once we put it on /etc/profile
04:31  skraito: it will be working fine
04:31  skraito: because from /etc/profile it get user pid of the bash
04:31  grop: #
04:31  grop: while [[ $userinput != "exit" ]]
04:31  grop: #
04:31  grop: do
04:31  grop: #
04:31  skraito: thats if i am not wrong
04:31  grop: if [[ $userinput == exit ]]; then
04:31  grop: wtf
04:32  skraito: grop the problem once the user type exit with out that if
04:32  skraito: user exit to normall shell
04:32  skraito: u need one testing if the user == exit kill -9 $$
04:32  e36freak: you should pretty much never kill -9
04:33  skraito: its safe though just to be safe it really kill the shell
04:33  e36freak: !kill > skraito
04:33  greybot: skraito: Unsafe Use of Kill: kill -9 sends SIGKILL to a process which is the exact same thing as normal kill (SIGTERM), except that it prevents the process from cleaning up after itself. You do NOT want to use it. See http://partmaps.org/era/unix/award.html#uuk9letter
04:33  skraito: let me taste it on  /etc/profile
04:33  skraito: which no is sigterm ?
04:33  e36freak: no number is SIGTERM
04:33  skraito: nvm let me read manual sigh i am not good with signal
04:33  tenthirteen: 15
04:34  skraito: okay let me change it to -15
04:34  skraito: that should do the trick is a simple keylogger script
04:34  skraito: so much work on perl site
04:34  skraito: thx everyone
04:37  skraito: i guess much work to do
04:37  skraito: ignoring control c + control z + control \
04:37  skraito: how do i do that in bash script ?
04:38  e36freak: hmm?
04:38  grop: Hmm, maybe just ^C ^Z ^\
04:38  e36freak: you just want to fork it into the background?
04:38  e36freak: so that it wont stop?
04:38  e36freak: nohup ./script &
04:39  grop: e36freak, no, he wants to launch a script that will make a fake prompt in which everything is logged in a file…
04:39  skraito: nope we cant fork it on background
04:39  e36freak: ohh
04:39  skraito: so the user can do anormal function
04:40  skraito: nvm let me google it thx alot guys
04:40  skraito: u guys is a really big help
04:44  skraito: !trap > skraito
04:44  greybot: skraito: If you want processes to communicate, the easiest way (besides a pipe) is to use signals. See: help trap <Enter>, man kill and man bash /SPECIAL PARAMETERS | http://mywiki.wooledge.org/ProcessManagement
04:46  skraito: lol ignoring ctrl + c is so easy in perl
04:46  skraito: not in bash script
04:49  grop: skraito, the "tester" in the perl script is just an empty string, right?
04:49  skraito: which one $tester ?
04:50  skraito: let me see the code hang on
04:50  skraito: $tester = $perlpid[$_];
04:50  skraito: i am getting all /root/perlpid into and array
04:51  skraito: call @perlpid
04:51  grop: The variable is just declared like that : « my ($tester); » and nothing is append to it. So it's to test whether a string is empty or not, right?
04:51  skraito: $tester = $perlpid[$_] is the pid
04:51  skraito: nope
04:51  skraito: its not an empty string, it contain the pid id for the process perl process
04:52  skraito: basically the logic is something like this
04:52  skraito: write all the pid to "/user/perlpid"
04:52  skraito: read it
04:52  skraito: once it is read close the file handler
04:52  skraito: incase the user open another shell
04:53  skraito: push the pid to an array
04:53  skraito: after that check all the array which contain the pid
04:53  skraito: if user enter one of the pid dont sent it to system just print user denied
04:53  skraito: this way the user is block from killing the perl pid
04:54  skraito: if the user dont enter the pid no send it to system
04:54  skraito: thats all the script do
04:54  skraito: it cant protect from top kill
04:54  skraito: and shell script kill
04:54  skraito: thats why i want to write it in shell script so the pid is equal to the current bash pid
04:55  skraito: brb going to walk my dog
04:57  e36freak: hunterm: how did you ignore ctrl-C in that virus emulation?
04:58  Nisstyre65: what would be the equivalent of 'pass' in python in sh?
04:58  hal: can anyone tell me if there is anything wrong with this?   find ~/workspace/ -name 'tiapp.xml' -exec touch \{\} ;
04:58  hunterm: e36freak: trap 'echo "code goes herp derp"' TERM i think
04:58  hunterm: or INT
04:58  grop: skraito, http://pastebin.com/2WgVtpnH
04:58  hal: it returns that exec is missing an arg
05:01  grop: find ~/workspace/ -name 'tiapp.xml' -exec touch {} \;
05:01  hal: ah I see grop - thank you :)
05:04  grop: skraito, http://pastebin.com/hUUThJwC
05:10  kingsley: Sometimes "pdftotext" produces misaligned columns of text. Is there a tool that's smart enough to align columns of text perfectly vertically?
05:13  kingsley: Ideally, the tool would accept tabular text output from pdftotext, and shift fields a little left or right so that each column starts in only one column.
05:13 --- mmnicola1 is now known as mmnicolas
05:14  kingsley: The "column" command fails when fields in some lines, but not others, contain more than one word.
05:16  e36freak: i do raw, sed to CSV, and import it into a spreadsheet
05:16  skraito: back
05:16  kingsley: e36freak: Please elaborate?
05:17  grop: skraito, http://pastebin.com/TvgEazLu
05:17  skraito: grop
05:17  skraito: there is no need to get user pid anymore from bash
05:17  e36freak: kingsley: i have to convert pdf's into excel sheets at work sometimes, pdftotext -raw file, and then sed -i 's/ /,/g' the file, and work with it from there
05:17  skraito: thats why this script is good enough
05:18  e36freak: kingsley: perhaps not the best solution, but it works
05:18  skraito: it just need couple of trap on top
05:18  skraito: trap ' ' 2
05:18  skraito: something like that i test it work for ctrl + c ignore
05:18  skraito: let me try in /etc/profile
05:18  kingsley: e36freak: I see.
05:18  skraito: and see how it work
05:19  skraito: btw couple of hardening script for centos dns
05:19  skraito: on my blog
05:19  skraito: grab it if you want is a good one in perl
05:19  e36freak: kingsley: excel likes CSV, you can just import it. i can play with it in vim too, i dont know how your vim-fu is
05:22  kingsley: e36freak: In my case, some fields in some lines are blank. While the remaining fields are well enough aligned to be obvious to a person, they're still to stepped for something like the "cut" command to always work.
05:23  kingsley: s/to stepped/too stepped/
05:23  e36freak: kingsley: yeah, i know what you mean. what is the end-result that youre looking to do with it? sorry if that was phrased poorly
05:23  kingsley: e36freak: Much like you, I'd like to import a CSV file into a spread sheet.
05:24  kingsley: Unfortunately, getting from the table in a pdf file to a properly formatted CSV file isn't obvious, ta least to me.
05:24  lkthomas: guys, does scp overwrite dir from source to destination ?
--- Log closed Thu Dec 23 05:28:25 2010
--- Log opened Thu Dec 23 05:34:14 2010
05:34 --- Users 530 nicks [0 ops, 0 halfops, 0 voices, 530 normal]
05:34  kingsley: e36freak: Although it's easy for people to discern the real columns, we use contextual hints, like the type of data on neighboring lines and in similar, if not identical, columnar positions.
05:35 --- Channel #bash was synced in 100 seconds
05:36  kingsley: It seems to me that I'm not the first person to need a sophisticated alignment tool that can use contextual hints to more precisely align table columns.
05:36  e36freak: yeah, i cant think of one
05:36  e36freak: im playing with it in vim to see if theres a command/series of commands that will help
05:38  e36freak: how big is the full file?
05:38  e36freak: line-wise
05:39  kingsley: e36freak: 164 lines.
05:39  e36freak: ouch
05:39  e36freak: what does the output of -raw look like?
05:39  kingsley: e36freak: I like your idea of looking for a way to quickly align it in vim.
05:40  e36freak: vim rules
05:40  e36freak: that or to get it in correct CSV
05:41  kingsley: e36freak: It seems to me that -raw removes all leading spaces.
05:42  kingsley: e36freak: This may be a question for #vim, but do you happen to know if it's possible to repeat editing commands *and* cursor moving commands at the same time, with the "." key in vim?
05:42  e36freak: with a macro, but ask in #vim
05:43  kingsley: That would greatly speed up my owrk.
05:43  kingsley: s/owrk/work/
05:43  e36freak: you could also try to write a while read -n line script
05:46 --- skraito_ is now known as skraito
05:50  hal: I am attempting to loop through some paths in an array to pass to some find statements. With the following array...
05:50  hal: paths=( "/opt/mydir/" "/opt/mydir\ version-1.2.2/" "/opt/mydir3/")
05:51  hal: the second one is interpretted as two parameters
05:51  hal: how do I escape the space?
05:56  hal: ok I'll think about it tomorrow
05:56  hal: thanks for the help earlier :)
05:56  hal: nn
05:59 --- nisstyre is now known as Nisstyre65
06:09  skydrome: when you declare clauses in a case statement, if you write for ex.  clean  )    does that match "clean" and/or "clean  "?
06:11  e36freak: you want to be able to ignore spaces?
06:11  e36freak: lets find out
06:11  skydrome: just curiosity atm
06:12  e36freak: # foo() { case "$1" in bar  ) echo "baz";; esac; }; foo bar
06:12  evalbot: e36freak: baz
06:12  e36freak: # foo() { case "$1" in bar  ) echo "baz";; esac; }; foo "bar  "
06:12  evalbot: e36freak: no output
06:13  e36freak: theres your answer
06:14  grop: # i=1; case $i in 0    ) echo ko;; 1    ) echo ok;; esac
06:14  evalbot: grop: ok
06:14  e36freak: # foo() { case "$1" in "bar  ") echo "baz";; esac; }; foo "bar  "
06:14  evalbot: e36freak: baz
06:14  skydrome: ok so spaces arent taken into account in the clause
06:14  e36freak: not unless you quote
06:15  e36freak: as the last example shows :)
06:15  skydrome: right
06:15  skydrome: ok thanks a ton
06:21  grop: !ppid
06:22  grop: !pid
06:22  greybot: Process ID: An integer that identifies a single process on a POSIX system. Using PIDs for checking whether a process is running is flawed (they're really not good for anything other than managing the current process' children) because of race conditions and the fact that PIDs are recycled by the kernel.
06:22  e36freak: skydrome: you can ignore the spaces at the end of a variable with extglob if thats what you want to do
06:23  grop: What's the best way to retrieve a PPID?
06:23  e36freak: !pm > grop
06:23  greybot: grop: http://mywiki.wooledge.org/ProcessManagement
06:23  e36freak: i would say pgrep though
06:24  e36freak: or pidof
06:24  grop: For PPID not PID ^^
06:24  e36freak: can do with pidof
06:25  e36freak: pidof -o %PPID /path/to/file
06:25  e36freak: a lot of that has to do with context
06:27  grop: I mean, instead of using « ps -o ppid $$ | grep -v PPID » in a script, what should I do? Your solution doesn't return, whereas the ps and the grep one does.
06:28  kingsley: e36freak: I'm happy to report that learning how to define a macro and associate its execution with a certain key allows me to edit the file more quickly.
06:28  kingsley: s/more quickly/quicker/
06:29  e36freak: kingsley: awesome! and that'll be really handy from now on. vim <3
06:32  e36freak: grop: ive never had a need to do that, i cant think of anything else
06:33  e36freak: grop: im sure greycat would know, whenever he gets back on
06:34  grop: e36freak, thank you anyway. :)
06:34  e36freak: grop: im asking
06:35  e36freak: grop: $PPID
06:35 * e36freak facepalm
06:35  grop: e36freak, ah ! Thanks !
06:35 * grop *facepalm* too
06:54  avis: i have this log file http://pastebin.com/fKxjfGuR  and would like to delete anything that says "is not even detected as mp3"
06:54  avis: can anyone help ?
06:54  avis: also were it possible, also delete any files with 10 errors or more
06:55  e36freak: can be done, give me a bit, a little busy atm.
06:55  avis: oh thank you
06:55  avis: thank you so much
06:56  seekwill: grep -v "is not even detected as mp3"
06:56  avis: your someones savior tonight because my music collection means alot to me, and its a real killer hearing bad sound files.  take your time, i have all the time in the world
06:57  avis: i'll wait for e36freak he might be able to help further
06:57  seekwill: You don't like mine :(
06:59 --- lkthomas_ is now known as lkthomas
06:59  e36freak: seekwill: i think he wants to delete the actual file
06:59  anon33_: is there a way to specify bin files in a find command? find -t doesn't look like aything besides using 'f' but that returns files i'm not looking for
06:59  seekwill: oh hehe
06:59  e36freak: avis: correct?
07:00  e36freak: avis: what is the full path to the log file?
07:02  avis: its at the base of my ~/Music directory
07:02  avis: /home/user/Music
07:02  e36freak: and thats where the paths in the file start?
07:02  avis: yes
07:02  e36freak: whats the actual name of the log file?
07:03  avis: allbad.log
07:03  avis: there are some mp3s with thousands of errors
07:03  avis: so i'm hoping maybe it can be pruned even more
07:03  avis: i can't offer you anything in return
07:03  e36freak: give me a second
07:03  avis: but i can tell you this is one of the best christmas presents i could get
07:03  e36freak: no worries, i enjoy doing this
07:07  Dribble: yeah I see you on here all the time
07:10  anon33_: e36freak: would you happen to know anything about my earlier question?
07:12  Dribble: anon:what do you mean by bin files
07:12  knoppix_____: e36freak would it be along the lines of:for i in /home/user/Music/*/*;do echo $i |grep \.mp3 || rm $i;  grep $(basename $i) allbad.log && rm $i;done
07:12  knoppix_____: ?
07:13  anon33_: sorry! i mean compiled files. mostly, the tools in the android-sdk (so programs)
07:13  knoppix_____: polished of course
07:13  avis: i'm hoping he can add one more step to it, so it will keep some with some errors.  i do not know how many errors is acceptable for an mp3
07:13  Dribble: ok
07:14  e36freak: knoppix_____: similar, almost done
07:14  Dribble: I would try with the locate command
07:14  anon33_: Dribble: ah, i'll look into that. thanks
07:14  Dribble: np
07:15  e36freak: avis: http://paste.pocoo.org/show/308750/
07:15  avis: thank you e36freak
07:15  knoppix_____: e36freak I missed the number of errors and that it was just files in the badlog that were to be removed (keeping non-mp3s not logged).  so forget that
07:15  e36freak: avis: the "rm" lines are commented so you can test it first without them being removed. put the script in ~/Music
07:15  avis: ok
07:17  Dribble: thats a good looking script efreak
07:17  knoppix_____: nice approach e36freak
07:17  avis: e36freak, i believe the number of files it would have deleted to be low
07:18  avis: without uncomment
07:18  e36freak: avis: can you find one it would have missed? is that the whole log you pasted?
07:19  avis: http://pastebin.com/ygaT6EF8
07:19  avis: that was the test run
07:19  avis: this is the original list http://pastebin.com/fKxjfGuR
07:19  anon33_: hmm... Dribble, i can't seem to find anything about specifying type or programs in locate
07:20  e36freak: avis: gimme a second
07:20  Dribble: oh im sorry I misunderstood  anon
07:20  knoppix_____: I haven't been here much when you have e36freak, but I really like all the scripts I have seen you come up with.  Usually quite elegant.
07:21  Dribble: so you want to just look for installed programs or just type of files
07:21  Dribble: ?
07:21  e36freak: god this netbook is slow
07:21  anon33_: just for compiled files. things like ant, adb, etc - files that would be in bin
07:21  avis: e36freak, you can take all the time in the world
07:22  avis: ty
07:22  e36freak: ok, something isnt quite right. more to be done
07:23  Dribble: so you want all of them or just a few
07:23  anon33_: just the bin-type files
07:23  anon33_: there's directories, shell scripts, etc other type of files
07:23  anon33_: i just want the executables
07:24  Dribble: find ./
07:24  Dribble: wait thats wrong
07:26  Dribble: idk im thinking
07:27  bmoqimi: I have test="2010-11-12/filename" , how can I cut the filename part using parameter expansion ?
07:27  avis: your a saint e36freak
07:28  Dribble: yeah sorry anon I don't know how to
07:28  e36freak: avis: http://paste.pocoo.org/show/308756/ just got 264 results from the file
07:28  pgas: bmoqimi: ${var%/*}
07:30  bmoqimi: pgas: i have done this to remove the filename part,and by "cut" I mean cut and use it in another var,sorry for ambigiouty
07:30  pgas: bmoqimi: ${var##*/}
07:31  bmoqimi: pgas: thx this was it ;)
07:33  knoppix_____: I am absolutely not suggesting he use this, but e36freak, do you think this would work?  for i in /home/user/Music/*/*;do echo $i |grep \.mfp3 || echo "removing $i";grep "$(basename $i)" allbad.log|grep -o "has [0-9][0-9][0-9]* errors" $ && echo "removing $i";done
07:34  knoppix_____: that extra $ came from
07:35  e36freak: christ
07:35  e36freak: i cant even
07:35  knoppix_____: or i in /home/user/Music/*/*;do echo $i |grep \.mfp3 || echo "removing $i";grep "$(basename $i)" allbad.log|grep  "has [0-9][0-9][0-9]* errors"  && echo "removing $i";done
07:36  knoppix_____: tried to make it one line, hard to read among other problems.  don't bother looking if you don't want to e36freak
07:36  e36freak: first of all, you dont need echo "$i" | grep, grep <<<"$i" is much better
07:36  knoppix_____: oh very true
07:36  Dribble: what does the <<< do
07:36  lhunath: knoppix_____: never grep filenames.
07:36  e36freak: second of all, you need a lot more quotes
07:36  knoppix_____: it reads from a variable
07:37  e36freak: !<<<
07:37  greybot: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
07:37  Dribble: ah
07:37  lhunath: knoppix_____: always quote your PEs.
07:37  knoppix_____: PEs?
07:37  lhunath: !pe
07:37  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
07:37  lhunath: if [[ $i = *.mfp3 ]]; then ...
07:37  Dribble: damn where can I get a greybot
07:38  e36freak: knoppix_____: its just dirty. im not sure if it would work, because i dont wanna but forth the effort into mentally parsing that
07:38  lhunath: !greybot > Dribble
07:38  greybot: Dribble: I'm written in perl using POE::Component::IRC, and my source is at http://wooledge.org/~greg/greybot/
07:38  Dribble: thats cool
07:38  e36freak: knoppix_____: and yours evaluates every mp3 in the directory, it just isnt needed. would be orders of magnitude slower
07:39  knoppix_____: Ihunath the logfile was being grepped for a string it is the filenames in the for that were used.
07:39  lhunath: knoppix_____: I'm talking about the other grep.
07:39 --- lkthomas_ is now known as lkthomas
07:39  knoppix_____: e36freak, I didn't mean for you to waste your time looking at the details, it was the overall approach I was asking about.
07:40  knoppix_____: I know more quotes should have been added
07:40  e36freak: knoppix_____: when you have 2 lists to work with, its generally better to use the shorter one
07:40  e36freak: well, 2 to compare
07:40  e36freak: yours checks the log file against every mp3 in the directory
07:40  e36freak: why? you can just parse the file once, line by line
07:41  knoppix_____: oh right
07:42  knoppix_____: I had thought he wanted to eliminate non-mp3s not listed in the file
07:42  knoppix_____: as well
07:42  e36freak: that would be different, but no
07:43  e36freak: just corrupted mp3s it would seem
07:43  Dribble: efreak how did you learn so much just from doing or what?
07:43  e36freak: Dribble: i still have a _lot_ to learn, but when i wanted to do something, i figured it out
07:43  Dribble: i've been at this for over a year and still like what
07:44  e36freak: ive learned a lot more from being in here all the time recently
07:44  e36freak: my scripts have gotten so much more efficient
07:44  knoppix_____: I really just wrote that to get your insight and it did prove valuable to me, unfortunately not to anyone else though
07:44  Dribble: no it did
07:45  Dribble: thats why I come here to hash it out and find out what works and what won't
07:45  Dribble: I learn a lot by watching
07:45  e36freak: yeah. when i dont know something, i just sit back and read what everyone else says. and then i know it :)
07:47  e36freak: i dont know awk worth shit though
07:49  e36freak: !awk
07:49  greybot: Check the topic of #awk and also http://www.grymoire.com/Unix/Awk.html -- awk questions belong to #awk. Note: If you are piping through more than one (grep|sed|awk), you're likely doing it wrong.
07:50  Dribble: yeah its just hard for my to think in programing
07:51  e36freak: good exercise: take simple tasks, like making a PB&J sandwich, and break them down into small simple steps
07:51  knoppix_____: one is confronted with all of ones weakness here
07:52  knoppix_____: the awk comment is a perfect example
07:52  Dribble: its a whole other can of worms
07:52  knoppix_____: I used to have horrendous strings of awk grep and sed piping along.  It is better now but I am far from cured
07:54 * skraito http://yohanespatra.wordpress.com/2010/12/23/0x71-keylogger-bash-script/ thx to grop on #bash 
07:54  e36freak: skraito: finish it?
07:54  skraito: yes thx to grop
07:54  e36freak: nice
07:54  skraito: its so easy at first look but alot of problem
07:54  skraito: lol
07:54  skraito: most of the code is done by grop
07:55  skraito: he clean everything
07:55  skraito: http://pastebin.com/ynR6NHws
07:55  grop: Well, the `` and the ps and grep are not by my mind, let's say :p
07:55  skraito: put it on /etc/profile and it will be loggin in no time
07:55  e36freak: skraito: use $PPID for... well... ppid
07:55  e36freak: skraito: its already a variable, like $$ and $!
07:56  Dribble: !typeset
07:56  skraito: yeah grop saying it too
07:56  grop: e36freak, I told him…
07:56  e36freak: skraito: and why did you keep the kill -9? thats horrendous
07:56  skraito: but its okay incase some crap not working
07:57  grop: e36freak, I told that too :p
07:57  skraito: grop said pkill $pid
07:57  skraito: but it wont work
07:57  skraito: so i just kill it roughly
07:57  skraito: i havent try with kill -15 though
07:57  skraito: i am too tired to try it
07:57  e36freak: !kill
07:57  greybot: Unsafe Use of Kill: kill -9 sends SIGKILL to a process which is the exact same thing as normal kill (SIGTERM), except that it prevents the process from cleaning up after itself. You do NOT want to use it. See http://partmaps.org/era/unix/award.html#uuk9letter
07:57  e36freak: try -15, then -2, then -1
07:58  e36freak: many things to try before resorting to -9
07:59  skraito: yeah
07:59  skraito: i will test it with -15 abit later
07:59  skraito: in 5 minutes let me break for awhile
07:59  e36freak: also
07:59  e36freak: !`
07:59  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
07:59  e36freak: $() > ``
07:59  grop: skraito, -15 doesn't work.
08:00  skraito: ic than it must be kill -9 than
08:00  skraito: it just a bash shell
08:00  e36freak: -1 is probably what he wants
08:00  e36freak: s/he/you
08:01  e36freak: possibly -2
08:01  grop: e36freak, I told him about `` but he says that it doesn't work with $() (maybe because of the subshell?)
08:01  e36freak: that makes no sense
08:02  e36freak: then why would $(whoami), $(hostname), and $(pwd) work in the same command?
08:03  e36freak: erm, s/command/script/
08:03  skraito: nvm its working anyway
08:03  grop: Well this one works like a charm on my shell : http://pastebin.com/U0uf6eEL ; but not his shell
08:03  skraito: i am not gonna touch it again
08:03  skraito: is it working with -1
08:04  grop: Yes.
08:04  skraito: i am going to start apache hardening script
08:04  skraito: oh okay i will change it later to -1
08:04  e36freak: grop: yeah, thats much cleaner
08:04  skraito: let me try it again
08:05  e36freak: also missing quotes
08:05  skraito: yap its working
08:05  skraito: which one is missing ?
08:05  e36freak: [[ "$userinput" != exit ]]
08:06  grop: No, not between [[ ]]
08:06  skraito: oh nvm its working anyway lol
08:06  e36freak: grop: no? its good practice anyway
08:06  e36freak: grop: what if there are spaces in $userinput?
08:07  e36freak: which there almost certainly will be
08:07  skraito: okay will it work with space e36freak ?
08:07  grop: e36freak, it still works with spaces
08:07  e36freak: ahh, interesting
08:07  knoppix_____: why those particular sigspecs for trap?
08:09  knoppix_____: that is the one line I don't really understand
08:09  knoppix_____: !trap
08:09  greybot: If you want processes to communicate, the easiest way (besides a pipe) is to use signals. See: help trap <Enter>, man kill and man bash /SPECIAL PARAMETERS | http://mywiki.wooledge.org/ProcessManagement
08:10  Dribble: !unset
08:10  greybot: Usually it suffices to know whether a variable contains something: [[ $var ]], but to check whether it is truly unset, use: [[ $var || -z ${var-x} ]]
08:13  skraito: thx e36freak and grop
08:13  skraito: another succesfull script gonna take a break for 15 minutes before coding that apache
08:13  skraito: brb
08:15  grop: skraito, « edit /etc/profile add line perl /root/keylogger.bash » ??
08:16  skraito: oh yeah i forgotten lol
08:16  skraito: i am just too tired
08:16  skraito: it should be bash /root/keylogger.bash
08:16  grop: And don't put extensions on bash scripts… (another history)
08:17  skraito: ic
08:17  grop: !.sh
08:17  greybot: Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
08:17  skraito: okay i will remove it
08:17  seekwill: Well...
08:17  skraito: done
08:18  seekwill: I think in some cases, it would be helpful to know that it's a script, and not a compiled executable
08:18  skraito: done updating
08:18  skraito: my perl script keylogger is history now
08:18  grop: skraito, if keylogger is chmoded, then you can just put « /root/keylogger » in the /etc/profile.
08:18  skraito: that crap peace of code
08:18  skraito: piece of code
08:19  skraito: make me think so much and still a failure
08:19  e36freak: seekwill: file foo
08:19  skraito: nah grop its fine i gonna post in http://ox71.net forum
08:20  seekwill: e36freak: Sure, but it'll be faster to know
08:20  e36freak: seekwill: true
08:20  seekwill: As a quick overview... oh, that's the script, that's the binary it'll run... etc
08:21  e36freak: # echo '#!/bin/bash' > foo; touch bar; file *
08:21  evalbot: e36freak: bash: file: command not found
08:21  e36freak: wtf evalbot
08:22  edgy: Hi, sed '5p' /etc/passwd won't display line 5 till I use -n option, why isn't it default and why one would want to use the command without -n?!
08:22  grop: sed -n '5p'
08:23  e36freak: edgy: in most cases, you dont want to use -n
08:23  e36freak: thats like asking why -i isnt default in GNU sed
08:24  edgy: e36freak: can you please explain more? when I do sed '5p' without -n, what's the output useful for?
08:25  grop: -n is to avoid printing
08:25  grop: If you don't use -n you will have the same output twice
08:26  e36freak: edgy: there are plenty of uses for sed that dont include the p command
08:26  e36freak: sed -n 's/foo/bar/g' would not do what you would want
08:27  grop: edgy, or just use « head -5 /etc/passwd | tail -1 »
08:29  grop: # sed 's/foo/bar/' <<< foo
08:29  evalbot: grop: bar
08:29  grop: # sed -n 's/foo/bar/' <<< foo
08:29  evalbot: grop: no output
08:29  grop: # sed -n 's/foo/bar/p' <<< foo
08:29  evalbot: grop: bar
08:31  grop: # sed 's/foo/bar/p' <<< foo
08:31  evalbot: grop: bar
08:31  evalbot: grop: bar
08:33  knoppix_____: has <<< always been a part of bash or did it start out with standard here docs?
08:33  e36freak: i dont know
08:33  knoppix_____: only
08:33  e36freak: its really nice either way
08:34  knoppix_____: it is very convenient
08:34  e36freak: theres some faq about it, no idea what the command is
08:34  e36freak: !changes
08:34  knoppix_____: !here
08:34  knoppix_____: noppe
08:34  knoppix_____: nope
08:35  Dribble: !<<<
08:35  greybot: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
08:35  knoppix_____: !signals
08:36  Dribble: !type
08:36  greybot: type tells you how a command will be interpreted by the shell. Don't use 'which'; use 'type -P' instead, because it's portable and consistent.
08:36  Dribble: !foreach
08:36  greybot: 'foreach' isn't bash. Try 'help for'.
08:36  Dribble: lol
08:36  knoppix_____: most of the systems I have been on which was just an alias for type -P
08:37  edgy: grop: sorry again, but still lost: sed '5p' file means display line 5 and all other lines or what?
08:37  Dribble: !source
08:37  greybot: ''source <script>'' or ''. <script>'' reads and executes the commands from <script> into the current shell, only one script per invocation the rest is passed as arguments to it
08:37  grop: edgy, it's simply not the correct syntax
08:38  Dribble: !while
08:38  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
08:38  edgy: grop: fine. now can you give me an example with and without -n where both outputs would be useful
08:39  Dribble: !tty
08:39  grop: # sed 's/foo/bar/' <<< foo
08:39  evalbot: grop: bar
08:39  e36freak: edgy: he did
08:39 --- sin__tax is now known as sin_tax
08:39  e36freak: edgy: scroll up
08:39  grop: # sed -n 's/foo/bar/p' <<< foo
08:39  evalbot: grop: bar
08:39  e36freak: it would make more sense in a more complex command
08:39  Dribble: #for i in {1..10};do echo $i;sleep 1;done
08:39  grop: It you don't put the -n
08:39  grop: # sed 's/foo/bar/p' <<< foo # it prints twice
08:39  evalbot: grop: bar
08:39  evalbot: grop: bar
08:39  e36freak: possibly with '/foo/s/bar/baz/p'
08:40  Dribble: !mtools
08:40  grop: !plonk
08:40  greybot: The sound a name makes when it hits a kill file (or /ignore list).
08:40  e36freak: Dribble: for (( i=1; i<=10; i++ )); do echo $i; sleep 1; done
08:41  Dribble: whats the diffrence it looks a lot harder
08:41  e36freak: !for
08:41  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
08:42  e36freak: !seq
08:42  greybot: seq(1) is a highly nonstandard external command used to count to 10 in silly Linux howtos. Use one of these instead: for x in {1..10} (bash3.x) or for ((x=1; x<=10; x++)) (bash 2.04+) or i=1; while [ $i -le 10 ]; do ...; i=$(($i+1)); done (ksh/POSIX)
08:42  edgy: grop, e36freak: thanks, the one that printed twice means the first bar is what and the second is what?
08:42  e36freak: edgy: it prints it anyway, and the "p" command makes it print again
08:43  Dribble: ahh
08:43  e36freak: Dribble: just more efficient, more backwards compatible, and C-style which is nice
08:44  e36freak: Dribble: you can also step through multiple variables with it too
08:45  Dribble: like i know the statement but I don't know why I would use it at this point its only to display 1 -10 lol I know it does other stuff but I dont know
08:46  knoppix_____: which statement is this?
08:47  e36freak: # for (( i=1, j=100; i<=10; i++, j-=5 )); do echo "i = $i"; echo "j = $j"; done
08:47  evalbot: e36freak: i = 1
08:47  evalbot: e36freak: j = 100
08:47  evalbot: e36freak: etc... ( http://pastebin.com/mhb2HKyu )
08:47  e36freak: # for (( i=1, j=100; i<=10; i++, j-=5 )); do echo -n "i = $i |"; echo -n "j = $j |"; done
08:47  evalbot: e36freak: i = 1 |j = 100 |i = 2 |j = 95 |i = 3 |j = 90 |i = 4 |j = 85 |i = 5 |j = 80 |i = 6 |j = 75 |i = 7 |j = 70 |i = 8 |j = 65
08:47  evalbot: e36freak: |i = 9 |j = 60 |i = 10 |j = 55 |
08:48  Dribble: what would that be for tho
08:49  e36freak: more complex algorithms
08:49  Dribble: oh algorithms
08:49  e36freak: array handling while also doing something with a number sequence
08:49  grop: # while sleep 1; do ((i++)); echo $i; done # e36freak, Dribble
08:49  evalbot: grop: 1
08:49  evalbot: grop: 2
08:49  edgy: grop, e36freak: ok thanks. now would sed execute the multiple commands if any in the first line read, the go to 2nd line or would it execute the first command on the first line, 2nd line, the go to the second command, and would this make any difference?
08:49  e36freak: whoa brain overload
08:49  grop: Well it fails
08:50  e36freak: grop: yeah, that too :)
08:52  knoppix_____: ??
08:55  grop: # while sleep 1; do ((i++)); echo $i; ((i==11)) && exit 0; done | tr '\n' ' '
08:55  evalbot: grop: no output within the time limit
08:55  e36freak: # foo="random.long.string"; for (( i=0, j=2; j<${#foo}; i++, j+=2 )); do array[$i]="${foo:j:2}"; done; echo "${array[@]}"
08:55  evalbot: e36freak: nd om .l on g. st ri ng
08:55  e36freak: bah
08:56  e36freak: # foo="random.long.string"; for (( i=0, j=0; j<${#foo}; i++, j+=2 )); do array[$i]="${foo:j:2}"; done; echo "${array[@]}"
08:56  evalbot: e36freak: ra nd om .l on g. st ri ng
08:56  e36freak: Dribble: ^^
08:56  Dribble: ! ^^
08:57  Dribble: whats that arrows
08:57  e36freak: as in, look at the thing above
08:57  Dribble: lol
08:57  ritztech: if i had phrases in my file Can i just remove a block of characters anything that containts body=[ad;lfkjasd;lfjas;df]  so from body=[  to ]
08:57  ritztech: i tried grep -v but it removes the whole line that contains it
08:58  lhunath: grep is not a file editor.
08:58  Dribble: man thats blowing my mind efreak
08:58  lhunath: it's a tool to select lines from a stream.
08:58  lhunath: ed and ex are file editors.
08:58  ritztech: well i want to Cat or in my case links -dump it but im not sure how to remove nonsense
08:59  lhunath: so you want to edit a steam?
08:59  lhunath: stream*
08:59  lhunath: sed then.
08:59  ritztech: yea
08:59  e36freak: sed '|body|!s|body=\[||;!s|]||' <<<"body=[ntoaeuhnatohe]"
08:59  e36freak: # sed '|body|!s|body=\[||;!s|]||' <<<"body=[ntoaeuhnatohe]"
08:59  evalbot: e36freak: sed: -e expression #1, char 1: unknown command: `|'
08:59  e36freak: bah
09:00  e36freak: # sed '/body/!s/body=\[//;!s/]//' <<<"body=[ntoaeuhnatohe]"
09:00  evalbot: e36freak: body=[ntoaeuhnatohe]
09:00  e36freak: nope, damn
09:00  e36freak: my sed-fu is still weak
09:01  ritztech: wow though theres alot of characters for me to understand the ;!s lol
09:01  e36freak: # sed '/body/!s/body=\[//;!s/\]//' <<<"body=[ntoaeuhnatohe]"
09:01  evalbot: e36freak: body=[ntoaeuhnatohe]
09:02  e36freak: too tired to figure that out, 'night
09:07  e36freak: !html
09:07  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
09:13  grop: # sed '/body=\[/,/\]/s/\[.*\]/[]/' <<< "body=[ad;lfkjasd;lfjas;df]" # dunno
09:13  evalbot: grop: body=[]
09:22  ritztech: man sed definetly uses alot of \/\/\/\\/\/// lol
09:23  jww: :)
--- Log closed Thu Dec 23 09:30:08 2010
--- Log opened Thu Dec 23 09:30:37 2010
09:30 --- Users 526 nicks [0 ops, 0 halfops, 0 voices, 526 normal]
09:30 --- Server: [calvino.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
09:31  skraito: .*\]
09:31  ritztech: # sed '/body=\[/,/\]/s/\[.*\]/[]/' <<< "body=[REMOVE1] KEep1 body=[REMOVE2] Keep 2 "
09:31  evalbot: ritztech: body=[] Keep 2
09:32 --- Channel #bash was synced in 104 seconds
09:32  ritztech: hmmm i should see only KEep1 Keep 2
09:34  ritztech: i wonder if sed supports muliple patterns in the file to be able to delete or remove anything that has body=[blah] but its in alot of differnt parts and has random things not needed im gooooogling sed
09:37  koala_man: ritztech: also, #sed
09:38  ritztech: geesh didnt know they had its own room
09:39  lhunath: superlinux: sed.
09:39  m4n: superlinux: or awk
09:40  superlinux: lhunath, ok thanks
09:40  m4n: only gnu sed supports address range with +
09:40  superlinux: thanks m4n
09:40  Dribble: How would i export all my .aup files to mp3 some of the .aup files have more then one audio track that would need to be exported seperatly but is this possible
09:41  lhunath: find a program that understands aup and can speak mp3.
09:42  lhunath: bash can't.
09:42  Dribble: :(
09:42  Dribble: it was worth a shot
09:43  lhunath: your package manager might know more.
09:45  hotwings: can you do a range when using case?  for example:  a-z)   or 0-9)   ?
09:45  Dribble: so I can't write a bash script that excutes the programs internal commands
09:45  Dribble: for whatever program
09:45  lhunath: !bashis
09:45  greybot: Bash is a shell. That's a program which can do simple math, logic and run other programs. It's NOT a terminal, it's not a kernel, it doesn't manage the system's authentication or environment, it's not your OS and it's not X, KDE or Gnome.
09:45  Dribble: meaning I cant get bash to save a file in blender
09:46  lhunath: math, logic and run other programs.
09:46  Dribble: well I want it to do more then
09:47  lhunath: hotwings: too vague.
09:47  lhunath: hotwings: case works by matching your string against a glob.
09:48  lhunath: figure out how to express whatever the heck you mean by using a glob.
09:49  lhunath: if you mean to match "one character, in the range of a through z" then the glob [a-z] would do.
09:49  lhunath: !patterns
09:49  greybot: Globs, Braces and Regular Expressions: http://mywiki.wooledge.org/BashGuide/Patterns
09:56  m4n: superlinux: awk -vN=3 -vM=2 'NR >=M && NR < (M+N)'
09:57  superlinux: thanks mate.
09:57  ritztech: # sed 's/body=\[[^]]*]//g' <<< "body=[REMOVE1] KEep1 body=[REMOVE2] Keep 2 body=[REMOVE3] KEep3 body=[REMOVE4] Keep 4 "
09:57  evalbot: ritztech:  KEep1  Keep 2  KEep3  Keep 4
09:57  ritztech: woot woot thanks m4n ;)
09:57  m4n: yw
09:58  amidelalune: i=0;lines=();while IFS= read -r "lines[i++]"; do if ((i==5)); then printf '%s\n' "${lines[@]}" | cat; i=0; fi done < <(tail -F testlog)
09:58  amidelalune: with this script^ I have got a little problem
09:59  amidelalune: when the ^c the running script
09:59  maximveksler: I want to redirect stderr to file, show should I do this?
09:59  amidelalune: a process remains
09:59  amidelalune: maxb, http://mywiki.wooledge.org/BashFAQ
09:59  amidelalune: maximveksler, , http://mywiki.wooledge.org/BashFAQ
09:59  amidelalune: sorry maxb
10:00  pgas: maximveksler: 2>file
10:00  maximveksler: amidelalune: I mean for the whole script (exec > /to/file), now how I get stderr to follow stdout 2>&1 doesn't seem to work.
10:00  pgas: amidelalune: try to add: trap 'kill $(jobs -p)' EXIT
10:01  pgas: maximveksler: exec >/to/file 2>&1
10:01  maximveksler: pgas: If I do it on 2 seperate lines it does not have the same effect ?
10:02  pgas: ? it's only one command
10:02  maximveksler: I see.
10:02  pgas: oh you meand exec 2>&1 on another line?
10:02  maximveksler: yes!
10:02  maximveksler: I think I understand now what I'm missing.
10:02  pgas: yes that probably works provided you have 2>&1 after the exec >file
10:03  maximveksler: I've been doing 2>&1 (no exec)
10:03  maximveksler: Cool, thanks.
10:03  maximveksler: pgas: Another iteration: I would like to show stderr to the user and to a file. I should be somehow mixing tee here but how?
10:03  maximveksler: so that stdout goes to log file, stderr shows on screen and goes to the same log file as stdout
10:05  amidelalune: pgas, jobs -p doesn't seem to return anything inside the script
10:06  pgas: maximveksler: it's possible but you will not like the result
10:06  pgas: amidelalune: ah, hmm I see, the task is probably not started with & but the one in <( )
10:07  amidelalune: pgas, yeah right the pipe
10:07  pgas: hmm, not sure if there is  a nice solution for this one...
10:08  maximveksler: pgas: Why? :)
10:08  pgas: maximveksler: because the output will be buffered and mixed up
10:09  pgas: exec >file ;exec 2> >(tee -a file)# >( ) is a bashism
10:09  maximveksler: bettet then nothing I guess, this will be used for EC2 machine boot time logging. I practicly have not other method of knowing what is going on there.
10:10  pgas: amidelalune: perhaps you can do something like <( exec -a $0.$$ cmd) and trap 'kill $0.$$' EXIT
10:11  amidelalune: pgas, hmm, not a clean solution but 'll have to do it if I don't find another solution
10:12  hotwings: lhunath - thanks, i think thats what i was looking for
10:12  pgas: amidelalune: sure I told you I don't think there is a good solution
10:12  pgas: maybe playing with jobs control and put all the child in a new group...
10:12  pgas: then kill the group with kill -TERM -PID
10:14  amidelalune: pgas, i ask myself if it is really a child process? if so it should have been killed by the parent getting killed
10:14  maximveksler: pgas: Can you please look at this http://bash.pastebin.com/vPUpXW2H ?
10:15  maximveksler: why fil only get's 1 line?
10:16  pgas: amidelalune: nope,  bash doesn't normally kill the children in a script
10:17  pgas: maximveksler: well you only print one line to stdout
10:17  maximveksler: But I also do echo "TO STDERR" >&2 which is redirected into exec 2> >(tee /tmp/fil.txt | cat >&3)
10:18  pgas: ah, but that doesn't appear in your paste
10:18  maximveksler: (I've updated the #14 line with "exec 2> >(tee /tmp/fil.txt | cat >&3)" but > >(cat >&3) should work just as well, no?
10:18  pgas: you need tee -a or tee will truncate and not appened
10:19  maximveksler: trying it now.
10:19  pgas: hmmm and you are right about the 3rd fd, but you don't need cat
10:19  pgas: just tee >&3
10:19  TheBonsai: y0
10:20  maximveksler: pgas: Can you please show the full line?
10:20  pgas: exec 3>&2 1>file 2> >
10:20  pgas: exec 3>&2 1>file 2> >(tee -a file >&3)
10:21  maximveksler: Will try, Thank You!
10:21  pgas: hmm, on linux you might perhaps do something like
10:22  pgas: exec 3>&2 1>file 2> >(tee /dev/fd/3 >&1)
10:22  pgas: it might be a bit better..not sure
10:22  maximveksler: pgas: Thats great. Let me get into something that works and then I'll try to optimize from there.
10:23  maximveksler: Will update in a minute.
10:23  pgas: err >&1 is of course doing nothing and not needed
10:26  maximveksler: pgas: exec 3>&2 1>/tmp/fi2.log 2> >(tee -a /tmp/fi2.log >&3) works!
10:26  maximveksler: thanks a lot!
10:26  maximveksler: and you are right, the result is buffed and wired.
10:26  maximveksler: but yet, it's better then nothing I guess.
10:26  maximveksler: Thanks a a lot
10:27  pgas: can you try the other version? I wonder if the resulting log file looks beter
10:27  refund: Can I make my bash script wait for user response before continuing the script? Like "Do you want to do this Y/n?"
10:27  refund: or rather, how
10:28  pgas: read -p "Do you want to do this Y/n?" -n 1 r; if [[ $r = [Yy] ]];then
10:28  maximveksler: pgas: sure, 1sec.
10:28  refund: pgas, thanks
10:29 * amidelalune thinks bravo pgas, very fast answer, did he have it copied in a buffer?
10:29  maximveksler: pgas: Same behaviour.
10:30  pgas: ok thanks
10:30  maximveksler: I think I will stick with the first version which is less complex to read to people who are not bash guru's.
10:30  maximveksler: thank you for the great help.
10:31  pgas: you can probably make it a bit better using something that reads stderr and flushes after each lines but it will probably still not be clean
10:32  maximveksler: Will be willing to try stuff but from my POV it's good enough
10:41 * skraito say hi all
10:41 * hansel waves
10:41  skraito: boring
10:41  skraito: sup hansel
10:41  skraito: :p anything interesthing happend lately ?
10:42  hansel: nada... just talking to my wife about this guy who she used to live next to.... he had 1.5 billion in his apartment.  Yes... billion.
10:42 --- Weust`afk is now known as Weust`
10:42  skraito: wtf
10:42  hansel: he got arrested... cops confiscated it all.  :)
10:42  skraito: are u kidding ?
10:42  hansel: nope.
10:42  skraito: or is that real ?
10:43  hansel: ....and her sister had to sign as a witness.
10:43  hansel: the odd thing is... it was an exact even amount of money.
10:43  hansel: so we're pretty sure the cops got a nice christmas  :P
10:43  skraito: oh really
10:43  skraito: where are u from anyway ?
10:43  hansel: I'm from Arizona in the USA.
10:43  skraito: 1.5billion rupiah in indonesia mean around
10:44  skraito: i dont know i cant count may be around 1 million dollar
10:44  hansel: :D
10:44  skraito: :p
10:44  hansel: we're wondering whether it was drugs or prostitution...
10:44  skraito: man 1.5 billion at his house is dang crazy
10:44  hansel: crazy though to think that much money was just sitting in an apartment.  her sister says the room was STACKED with money.
10:45  skraito: yap i can imagine that
10:45  hansel: We were watching "million dollar money drop" and realized that compared to the amount in the apartment it was nothing. hahah
10:45  pgas: this is not #bash.org, please take this to another channel
10:45  hansel: figured it was dead... /offtopic
11:17  amidelalune: pgas, how is this one? trap 'pkill -P $$' EXIT
11:18 --- Unknown[OFF] is now known as Unknown[NF]
11:21  Django23: Hey everyone. I'm looking for declaring a associative array (i need to set keys.) i only know this command.    : declare -a names=('max' 'sam' 'stage');
11:21  TheBonsai: declare -A
11:22  Django23: And then ?
11:24  Django23: Can i declare strings as key ?
11:25  Django23: TheBonsai, thanks, i found it
11:28  amidelalune: is this a good solution for killing the child processes of a script after it is stopped? trap 'pkill -P $$' EXIT
11:32  eilartt: hi, i'm trying to use sed with -r option and i can't get \1 working in the replacement zone to get the captured group (i get a literal "1"). Have i to escape something?
11:33  cthuluh: !quotewhen
11:33  greybot: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
11:33  eilartt: echo "sources.1540"|sed -r s/\(sources[\.]?\)/\1/
11:34  eilartt: i get 11540
11:34  go|dfish: eilartt:  when using -r it's () not \(\)
11:34  eilartt: urka
11:34  eilartt: did'nt know
11:34  cthuluh: but you still need to escape them
11:34  geirha: -r, isn't that the non-standard option that turns on ERE?
11:34  cthuluh: since you didn't quote them
11:35  go|dfish: oh right, no quotes
11:35  cthuluh: eilartt: [.] is enough
11:35  go|dfish: i guess i'm confused by the whole thing, as it appears you want 'sources'
11:35  cthuluh: eilartt: but the ? could be quoted
11:36  eilartt: i want sources
11:36  geirha: sed 's/.*\(sources\.\{0,1\}\).*/\1/'
11:36  eilartt: well, actually i want the \1 working
11:36  eilartt: i don't need help with the regexp
11:36  geirha: # echo \1
11:37  evalbot: geirha: 1
11:37  geirha: That's what sed gets, just a 1
11:37  cthuluh: you've been said you needed to quote your sed command, anyway
11:37  geirha: # echo '\1'
11:37  evalbot: geirha: \1
11:38  eilartt: yeah, single quote seems to work and i don't need to escape ()
11:38  eilartt: thanks
11:40  kotique: guys, what does bash < <( curl -L http://bit.ly/rvm-install-system-wide ) mean?
11:41  kotique: I don't quite get it, why double <?
11:41  amidelalune: koala_man, <(command) is replaced by a file name
11:41  amidelalune: which is the stdout of the command
11:42  amidelalune: kothog, ^^
11:42 * amidelalune is really sorry
11:42  amidelalune: kotique, ^^
11:42  kotique: lol
11:42  amidelalune: it's called process substitution
11:42  kotique: it's failing in non-interactive shell
11:43  kotique: bash -c 'bash < <( curl -L http://bit.ly/rvm-install-system-wide )'
11:43  kotique: this is the command and it's failing when invoked by puppet agent
11:43  geirha: It'll fail if you try to run it from sh
11:44  kotique: what do you mean?
11:44  geirha: process substitution is not POSIX
11:45  geirha: So make sure the non-interactive shell, where you say it fails, is bash and not sh.
11:46  kotique: bash -c shoudl be enough, right?
11:47  geirha: ah, yes.
11:47  geirha: # bash -c 'bash < <(echo echo hello)'
11:47  evalbot: geirha: hello
11:49  kotique: bash -c 'curl -L ${rvm_installer_source} | bash -l' did it.
12:00  lhunath: wtf.
12:04  geirha: I didn't dare to ask
--- Log closed Thu Dec 23 12:29:36 2010
--- Log opened Thu Dec 23 12:29:58 2010
12:29 --- Users 538 nicks [0 ops, 0 halfops, 0 voices, 538 normal]
12:30  pif: ah found MANSECT
12:30  eilartt: hi, is there something i have to enable to use regexp in case statement?
12:31  pif: shopt -s extglob ?
12:31 --- Channel #bash was synced in 102 seconds
12:41  geirha: eilartt: case does not take a regexp period.
12:41  hendry: is there a better way of doing: $(basename $(pwd)) ?
12:42  complete: Good Noon from Germany.
12:42  geirha: You can use an extglob if you enable extglob. You can do most stuff you can do with a regexp with extglob.
12:42  geirha: hendry: "${PWD##*/}"
12:43  complete: When I use screen, it looks like my bashrc does not get loaded.
12:43  complete: Any ideas how to change that?
12:44  geirha: Why would screen read you .bashrc?
12:44  geirha: *your
12:45  complete: well, i did not say screen does not iread it. i said it does not get loade. by bash.
12:45  complete: i mean... inside screen, i AM in bash, aint i?
12:46  geirha: If your login shell is set to bash, screen will run that if you don't specify any other command.
12:46  complete: my login shell should be bash
12:46  complete: $SHELL contains "/bin/bash"
12:46  hendry: geirha: i think $(basename $(pwd)) is at least readable compared to "${PWD##*/}"
12:46  complete: "screen -s /bin/bash" doesnt help either
12:46  geirha: Does your .bashrc do something based on what TERM is?
12:47  twb: Anybody know offhand what exit status 13 from gnu coreutils' cat indicates?
12:48  twb: I can't see a mention in man or info pages
12:48  geirha: hendry: Well, a PE should be more efficient than using an external command.
12:48  geirha: hendry: Though anyway, you need quotes.
12:49  BaD_CrC: I'm having a similar issue with this: mp3dt_directory="${$(pwd)##*/}"
12:49  complete: AAAH!! I use .profile instead of .bashrc
12:49  complete: ok
12:49  BaD_CrC: i don't want to rely on the $PWD environment variable if script is run on a non-BASH shell
12:49  ferret: BaD_CrC: that's because it's wrong
12:49  complete: so let me rename .profile to .bashrc and see what happens...
12:50  ferret: BaD_CrC: you can't put anything smart for the parameter name, it has to be an identifier
12:50  ferret: If you want to do a PE on the result of a command you have to store it
12:50  BaD_CrC: ahh, i see
12:51  BaD_CrC: thanks. i'll try that
12:51  complete: Ok. Now my next problem is that vim inside screen does not show 256 colors. outside screen it does. Any ideas?
12:51  geirha: complete: echo "$TERM"
12:52  complete: geirha: screen
12:52  complete: when in screen
12:52  complete: otherwise xterm
12:53  geirha: See if there's one that does 256 colors. On my system it's in /usr/share/terminfo/s/
12:54  geirha: Anyway, there's #screen which probably knows this better than me.
12:54  complete: well, in xterm the 256 colors work
12:54  complete: they dont work in screen
12:55  Mowee: Hey ^^
12:59  MTecknology: Peng: considering you're measure of units, it's hard to hold any value at all to your numbers
12:59  eilartt: ah, and how can i match a string composed by four digits with extglob?
12:59  MTecknology: sorry, wong channel
12:59  eilartt: ex. "1512"
13:00  geirha: [0-9][0-9][0-9][0-9])
13:00  eilartt: thanks
13:01  geirha: +([0-9])) will match a string containing only digits, though you can't specify how many.
13:01  eilartt: ok
13:05  geirha: Another approach; case $str in *[!0-9]*) echo "Not a number" ;; ????) echo "Four digit number";; esac
13:08  ks07: Hey, I've got an array and a text file containing #arraycontentshere - how would I go about replacing that comment with the array's contents?
13:09  geirha: printf '%s\n' '/#arraycontentshere/c' "${array[@]}" . w | ed -s file
13:09  ks07: ty
13:09  geirha: It replaces the whole line
13:10  ks07: Is there any way to insert newlines between each value in the array? Or is that gonna be over-complicated?
13:10  geirha: ks07: That's what it does there
13:11  geirha: See what   printf '%s\n' "${array[@]}"   outputs
13:11  ks07: oh it does? *stupid* Thats great ty :)
13:11  ks07: I see awesome
13:11  geirha: ks07: Note that the ed script will fail if one of the array elements are "." (a single dot)
13:12  eilartt: how can i retrieve a variable value using a variable name stored in a string?
13:12  ks07: ok, no need to worry about that it ^^
13:12  eilartt: how can i retrieve a variable value using a variable name stored in another variable?
13:12  geirha: eilartt: Bad idea
13:12  koala_man: !faq variable variable > eilartt
13:12  greybot: eilartt: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
13:12  geirha: eilartt: You should avoid variable indirection
13:13  eilartt: maybe i shoud use arrays
13:13  geirha: If you have bash4, consider associative arrays
13:13  eilartt: i have bash3
13:24  eilartt: in arrays it is safe to use sparse indexes? (eg. start from 1549)
13:24  lhunath: yes
--- Log closed Thu Dec 23 13:28:58 2010
--- Log opened Thu Dec 23 13:34:27 2010
13:34 --- Users 545 nicks [0 ops, 0 halfops, 0 voices, 545 normal]
13:35 --- Channel #bash was synced in 102 seconds
13:39  eilartt: well, everthing works: thank to everybody
13:54  [bottzman]{xmb}: bonsai is a big sucker weak one, he banns xmb for free speech
13:54  [bottzman]{xmb}: what a weak motherfuker
13:54  [bottzman]{xmb}: det bonsai
13:55  lhunath: go speak freely in a channel that cares.
13:55  [bottzman]{xmb}: will do
13:55  [bottzman]{xmb}: like
13:55  [bottzman]{xmb}: watch /msg
13:57  [bottzman]{xmb}: buh bye
13:58  [bottzman]{xmb}: once u see a ban against maiceuv, kill the banner
13:58  [bottzman]{xmb}: latercsy
13:58  [bottzman]{xmb}: z
13:58  cthuluh: *shrug*
13:59  lhunath: every town needs its idiot.
14:00  cthuluh: sometimes he is, sometimes not. but clearly I hate when he's using a rough language
14:00  geirha: The sheet should probably have an example like array[i+1]="foo bar"
14:06  mar77i: http://bit.ly/icTWFc *hits it*
14:09 * cthuluh hates bit.ly
14:10  lhunath: geirha: http://mywiki.wooledge.org/BashSheet#Using_Arrays first example, looks OK?
14:11  geirha: Yeah, that's using, but no assigning
14:11  Bersam: hi everybody, how can i copy a line in a file with root permision? $ echo "foo" >> /etc/php/php.ini
14:11  lhunath: right; should add it there too
14:11  lhunath: so as to show you can assign to a single index
14:11  Bersam: $ sudo echo "foo" >> /etc/php/php.ini ... won't answer
14:12  cthuluh: Bersam: sudo bash -c 'echo "$line" >> /file'
14:13  koala_man: echo foo | sudo tee -a /etc/php/php.ini
14:13  Bersam: cthuluh: worked, tnx :)
14:13  Bersam: koala_man: good way :)
14:18  lhunath: !learn sudo> sudo echo foo > /etc/bar -- The file redirection (> /etc/bar) is bash syntax, so bash performs the opening of the file.  To make a sudo'ed process open the file, use: echo foo | sudo tee /etc/bar
14:18  greybot: OK, lhunath
14:20  knob: Good morning everyone =)
14:21  lhunath: mm, might be a little dangerous for mindless copy-pasters.
14:21  lhunath: !forget sudo>
14:21  greybot: OK, lhunath
14:21  cthuluh: lhunath: I suggest using <<<, too
14:21  lhunath: !learn sudo> sudo echo foo >> /etc/bar -- The file redirection (> /etc/bar) is bash syntax, so bash performs the opening of the file.  To make a sudo'ed process open the file, use: sudo tee -a /etc/bar <<< foo
14:21  greybot: OK, lhunath
14:21  lhunath: cthuluh: ok ;-)
14:21  cthuluh: :)
14:23  geirha: nitpicking, but  >> /etc/bar  vs  (> /etc/bar) :P
14:24  lhunath: arg, now it's bugging me too.
14:24  lhunath: !forget sudo>
14:24  greybot: OK, lhunath
14:24  lhunath: !learn sudo> sudo echo foo >> /etc/bar -- The file redirection (>> /etc/bar) is bash syntax, so bash performs the opening of the file.  To make a sudo'ed process open the file, use: sudo tee -a /etc/bar <<< foo
14:24  greybot: OK, lhunath
14:27  geirha: :)
14:39  shaiguitar: wayneeseguin: Hey
14:48  wayneeseguin: shaiguitar: :)
14:49  shaiguitar: wayneeseguin: PM'ed
14:49  wayneeseguin: k
14:55  tuxnani: how to know whether a cron job was successfully run
14:55  nikolaidis: tuxnani: does your system have /var/log/cron* ?
14:57  tuxnani: nikolaidis, i want to retrieve the time of last successful cron run and write a script to log the changes happened to system since that time as the cron itself, any idea how i can get it?
14:57  nikolaidis: Hm.
14:58  nikolaidis: Assuming your system logs to /var/log/cron*, could you check the dates of those log files for modification?
14:58  lhunath: tuxnani: make one cron job that runs all your system-changing jobs and afterwards summarizes the changes.
14:59  nikolaidis: lhunath: But that would cause changes. If I understand correctly, it sounds like tuxnani wants to audit what has already happened, not make things happen.
15:00  tuxnani: exactly
15:00  nikolaidis: I'd monitor the cron logs, and then invoke tripwire or something comparable afterward to see what's changed.
15:01  lhunath: you want to audit what has already happened while you had no audit system in place?
15:01  lhunath: shrug.
15:01  tuxnani: i am running a server and want to know what files users have added with their sizes to a text file, that in turn has to be mailed to me, all these tasks are to be accomplished by a cron and the time is since last successful cron run
15:02  hal1: I am attempting to loop through some paths in an array to pass to some find statements. With the following array...
15:02  hal1:  paths=( "/opt/mydir/" "/opt/mydir\ version-1.2.2/" "/opt/mydir3/").  The second one is interpretted as two parameters. Would someone tell me how to escape the space, please?
15:02  nikolaidis: Tuxnani: Users modifying their files is not happening via cron though, is it?
15:02  tuxnani: yes
15:03  nikolaidis: Interesting.
15:03  nikolaidis: Okay, in that case, I stick with my suggestion and run tripwire any time your cron logs are modified.
15:03  nikolaidis: So, essentially, you are monitoring users' cron jobs and want to know what havoc they are wreaking on your system.
15:05  tuxnani: i would write a script for finding files added since some particular time, and then mail them using another script, now this is done by my cron job, and the particular time is what the last successful cron run should give me
15:06  geirha: hal1: paths=( "/opt/mydir/" "/opt/mydir version-1.2.2/" "/opt/mydir3/")
15:06  nikolaidis: Tuxnani: So you could look at cron run times and use find to check for files within those date constraints.
15:06  geirha: !$@ > hal1
15:06  greybot: hal1: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
15:08  tuxnani: nikolaidis, thats what, now the question is now i want to get the last successful run of cron, if i fix the time to say 24 hours and suddenly the cron gets failed on some fine day, the data for that 24 hours is lost
15:08  lhunath: hal1: all you need to do is quote properly.  not add backslashes in your data.  that just breaks everything even more.
15:08  hal1: geirha: unfortunately leaving the backslash out doesn't work either
15:09  lhunath: hal1: quote properly.
15:09  lhunath: hal1: when you USE the array.
15:09  hal1: lhunath: I only added the backslash because the quotes didn't work
15:09  lhunath: not when you create it.
15:09  geirha: hal1: There's a big difference between ${paths[@]} and "${paths[@]}"
15:09  lhunath: hal1: the quotes in what you pasted work fine.
15:09  hal1: ooh
15:09  lhunath: hal1: it's when you USE the array that you failed to quote.
15:09  hal1: right
15:09  craiggles: hey guys, say i have a variable, $filetype, filetype="mp3" .. is this the way you would recmmond me to get *.<FILETYPE> .. files=(*.${filetype})
15:10  geirha: files=(*."$filetype")
15:10  craiggles: thanks.
15:11  nikolaidis: Okay Tuxnani: so the question is, how are cron jobs logged on your system?
15:11  nikolaidis: Need to look there for some evidence of status (success or failure)
15:11  tuxnani: exactly
15:14  hal1: I got it working geirha and lhunath - thank you :)
15:15  BaD_CrC: is there a way to escape special characters that i get from $PWD and store in a quoted variable?
15:15  geirha: BaD_CrC: You don't need to
15:15  BaD_CrC: [: 244: /home/john/Music/[SORT]/Linkin: unexpected operator
15:15  lhunath: BaD_CrC: quote your expansions.
15:15  lhunath: !args > BaD_CrC
15:15  greybot: BaD_CrC: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
15:15  geirha: And don't use [
15:15  BaD_CrC: i keep getting that because of my funky directory setup
15:16  geirha: !tests > BaD_CrC
15:16  greybot: BaD_CrC: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
15:16  BaD_CrC: i use []'s in my directory structure
15:16  lhunath: that's fine.
15:16  BaD_CrC: it holds the year an album was released
15:16  lhunath: you can use any character byte you want except for NUL.
15:17  lhunath: (and / for filenames)
15:17  lhunath: BaD_CrC: you just need to learn to quote your expansions.  read the Arguments page I linked you to grasp why.  it's the most important thing about shell scripting you'll ever learn.
15:17  BaD_CrC: it's weird because it keeps throwing that error at the top of script exection, but the overall job is being done correctly
15:18  lhunath: that's not weird; that's a fluke.
15:18  geirha: What does the line that fails look like?
15:18  BaD_CrC: leme PB my script
15:19  BaD_CrC: http://bash.pastebin.com/79bKfiJ2
15:20  BaD_CrC: please don't criticize my messy code
15:20  BaD_CrC: it's nothing super special. :)
15:22  lhunath: $null.  funny.
15:22  lhunath: BaD_CrC: everywhere you use $something, it NEEDS to be in quotes.
15:22  BaD_CrC: *shrug*
15:22  lhunath: but you know that now, since you're reading the Arguments page.
15:22  BaD_CrC: doesn't ${...} auto expand it?
15:23  geirha: BaD_CrC: Lot's of bad practice in your script
15:23  geirha: s/'//
15:23  BaD_CrC: i'm new at this
15:23  BaD_CrC: hence why i'm here to learn and get help
15:23  geirha: !guide
15:23  greybot: http://mywiki.wooledge.org/BashGuide
15:23  geirha: That one teaches you the good practices
15:24  geirha: ls -1 | grep -i .mp3 | sort  # amusing
15:24  lhunath: BaD_CrC: we aren't, hence why we took the time to wrote down our experience in those pages.
15:24  lhunath: to write*, le sigh.
15:25  BaD_CrC: i guess i was kinda combining the old practices of DOS batch files, PHP scripting and a little C.
15:26  lhunath: overall it doesn't look nearly as bad as I'd expect from an average newcomer to bash or this channel.
15:26  BaD_CrC: thank you :D
15:28  geirha: (shopt -s nullglob nocaseglob; printf '%s\n' *.mp3) > file
15:32  geirha: !which > BaD_CrC
15:32  greybot: BaD_CrC: which(1) is an external program used to search PATH for an executable. It behaves differently on different systems and you can't rely on a useful exit code; use ''type -P'' instead. See http://mywiki.wooledge.org/BashFAQ/081
15:32  geirha: And replace all [ .. ] with [[ .. ]]
15:38  tuxnani: i am trying to use this command to find files with certain extensions, but its failing,  find -regextype egrep -type f -iregex '.*\.(avi|mpg|mov|flv|wmv|asf|mpeg|m4v|divx|mp4|mkv)$' -print0 | sort -z | tr '\0' '\n' -exec du -k {} \;
15:38  tuxnani: i want to display both size of file as well as its name
15:38  erUSUL: tuxnani: use -printf if you have it
15:39  geirha: -exec are not valid tr options
15:41  fro0g: I'm writing a script where I'd like, depending on if a second arg is given to pipe the result through awk, otherwise not. Is there an easy way of doing this?
15:42  geirha: if (($# >= 2 )); then foo | awk; else foo; fi
15:43  geirha: Or do you mean the output of your script?
15:43  geirha: !exec
15:43  greybot: exec [command] [redirections] replaces the script's process by a new one that runs the command. When no command is given, only the redirections are applied to the current shell. http://wiki.bash-hackers.org/commands/builtin/exec
15:44  fro0g: geirha: that's what I'm doing atm, but 'foo' is rather complicated, and would like not to have it in two places, if I need to modify later
15:44  sobersabre: hi, I am confused: what is the syntax of how to grab a bash function's return value ?
15:44  sobersabre: assuming it's foo(arg)
15:44  sobersabre: I want RES=foo arg
15:44  sobersabre: or something like that...
15:44  fro0g: I could use FOO=(foo), i suppose
15:45  geirha: fro0g: Use a function
15:45  fro0g: geirha: doh!
15:45  fro0g: of course
15:45  geirha: sobersabre: if myfunc; then echo "My function succeeded"; else echo "My function failed"; fi
15:46  sobersabre: geirha: good idea. what if I want the value ?
15:46  geirha: myfunc; res=$?; if (( res == 4 )); then ...
15:49  erUSUL: # f () { local a; a=$((2+3)); echo $a; };  res=$(f); echo $res
15:49  evalbot: erUSUL: 5
15:51  Wytry: Has anybody got idea how to convert RGB color to hex using bash?
15:52  geirha: sobersabre: Oh you want to capture the OUTPUT ?
15:52  geirha: Wytry: What format is "RGB color"?
15:53  erUSUL: well (s)he now knows how to do both things ;P
15:53  BaD_CrC: oh yes... on the if's that i was using $(which ...) for, i replaced them with if type -P file >/dev/null; then .... and no more errors show. thank you for your help. i really appreciate it.
15:53  geirha: Good
15:53  Wytry: 0-255, 0-255, 0-255
15:54  geirha: So you have a variable with a string like "12, 34, 56"?
15:54  BaD_CrC: so i'm gathering that using brackets in conditionals is a bad practice?
15:54  Wytry: 3 variables, each for other color
15:54  sobersabre: geirha: I want to capture what came from return!
15:54  sobersabre: f() { return "bla"  }
15:55  geirha: Wytry: printf '%02x ' "$r" "$g" "$b"
15:55  sobersabre: I want to:
15:55  geirha: !return
15:55  greybot: Every Unix process returns an exit status code to its parent. This is an unsigned 8-bit value, a number from 0 to 255 inclusive. Your script returns the exit status from the last command it executed, unless you specifically call "exit" with a value. Functions also return values, using "return".
15:55  sobersabre: val=`f()` or something like that!
15:55  sobersabre: geirha: not "values" as integers.
15:55  geirha: sobersabre: You can only return a number between 0 and 255. So you need to OUTPUT "bla"
15:55  sobersabre: I want to implement a function that returns me a home dir of a user.
15:56  Wytry: I tried this, but output must be 6 chars long. With "printf '%02x ' "$r" "$g" "$b"" sometimes it's shorter
15:56  sobersabre: geirha: echo "bla" ?
15:56  geirha: f() { echo "bla"; }; if output=$(f); then echo "function succeeded. It's output is: $output"; fi
15:56  sobersabre: geirha: trying thanks.
15:57  geirha: # r=0 g=128 b=255; printf '%02x' "$r" "$g" "$b"
15:57  evalbot: geirha: 0080ff
15:58  sobersabre: geirha: my func is using $1, so it's f() { echo "kuku-$1"; }
15:58  sobersabre: how do I capture the output again ?
15:58  geirha: output=$(f)
15:58  geirha: !faq 2 > sobersabre
15:58  greybot: sobersabre: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
15:58  sobersabre: oh, it works!
15:58  sobersabre: sorry!
15:59  geirha: Wytry: Did you see evalbot? ^
16:00  Wytry: Yes. But my script sometimes returns less than 6 chars :/
16:00  geirha: Show the exact code in your script, then.
16:00  Lunar_Lamp: I have two variable pairs: $user1 $server1, $user2 $server2.  How can I loop through the same commands for each of them: e.g. for i in 1 2; do ssh $user$i@server$i "foo"; done
16:01  Lunar_Lamp: Obviously the example I pasted won't work to create the "variable varaible".
16:01  Lunar_Lamp: What should I be doing instead?
16:02  geirha: users=( jack jill ) servers=( home office ); for i in "${!users[@]}"; do ssh "${users[i]}@${servers[i]}" foo; done
16:03  Wytry: Input: 242 13 0
16:03  Wytry: Output: F2 D 00
16:03  Lunar_Lamp: ...that's depressignly obvious geirha :-(
16:03  geirha: # users=( jack jill ) servers=( home office ); for i in "${!users[@]}"; do echo ssh "${users[i]}@${servers[i]}" foo; done
16:03  Lunar_Lamp: Thanks :-)
16:03  evalbot: geirha: ssh jack@home foo
16:03  evalbot: geirha: ssh jill@office foo
16:03  geirha: Wytry: looks like printf '%X ' and not printf '%02x'
16:04  geirha: # printf '%02x' 242 13 0
16:04  evalbot: geirha: f20d00
16:04  geirha: # printf '%02X' 242 13 0
16:04  evalbot: geirha: F20D00
16:04  Wytry: Thanks. Now it works :)
16:07  hal1: I need to find a heirarchy of 3 directories on a filesystem, and delete everything inside of their subdirectories.  Can anyone advise an how I may achieve this, please?
16:08  hal1: for example rm -rf build/directoryX/directoryY/<subdirs>/*
16:08  hal1: I know the names of subdirs
16:08  hal1: and build, dirX and dirY
16:11  geirha: rm -rf build/dirX/dirY/subdir1/ build/dirX/dirY/subdir2/ build/dirX/dirY/subdir3/
16:14  jophish: hi
16:14  jophish: I have made a mistake. I am training a program with some data via stdin. cat datafile | ./program
16:14  tuxnani: curiously asking, is there type casting in bash, eg i want $echo `date +%j`-`date +%j` to return 0
16:14  jophish: however the program requires me to type #quit at the end to save the trained data
16:15  jophish: It would be really swell if I could send #quit to this process
16:18  jophish: perhaps something in /proc
16:18  Lunar_Lamp: geirha: I clearly didn't quite udnerstand what you were doing. http://pastebin.com/i8q5M1LH
16:19  geirha: Lunar_Lamp: What version of bash?
16:19  BaD_CrC: is the datafile plain text? if it is and you can modify it a bit, you should be able to echo "#quit" >> datafile
16:19  Lunar_Lamp: 4.1.5, though I think it will also need to run on 3.2
16:19  BaD_CrC: someone please correct me if i'm wrong
16:20  jophish: BaD_CrC: I tried that, but it was too late
16:20  jophish: I realised just as it was finishing, the file has already been read
16:20  geirha: tuxnani: echo $(( $(date +%j) - $(date +%j) ))
16:21  geirha: Oh wait
16:21  geirha: tuxnani: echo $(( 10#$(date +%j) - 10#$(date +%j) ))
16:21  geirha: !sh > Lunar_Lamp
16:21  greybot: Lunar_Lamp: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
16:22  geirha: Lunar_Lamp: And what's with all the redundant vars?
16:22  Lunar_Lamp: /bin/bash: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked (uses shared libs), for GNU/Linux 2.6.15, stripped
16:23  Lunar_Lamp: geirha: well, I've just stripped it down to it's bare essentials to work out what's going on - it's part of a larger script.
16:23  geirha: Lunar_Lamp: Right, make sure you run it with bash and not sh.
16:24  geirha: ./script or bash script   NOT sh script
16:24  Lunar_Lamp: geirha: I was/am doing.
16:24  geirha: Lunar_Lamp: Oh. Now I see it. "{!users[@]}"   missing the $
16:24  geirha: And while we're at it:
16:25  geirha: !varcap
16:25  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
16:25  Lunar_Lamp: Aha! Thanks.
16:26  Lunar_Lamp: It still doesn't work properly, as it seems to loop through the same username each time, but at least you've pointed out that mistake :-)
16:27  BaD_CrC: haw! i see what the issue was where i was laughed at by testing for $null. if ! $1; then ...
16:28  Lunar_Lamp: ...which is of course because I made a typi :-)
16:40  singularity: ih
16:40  singularity: hi*
16:41  Nisstyre65: How do I make a POST request with curl without specifying any data?
16:41  singularity: hi I needed to write a bash program to run a program with looped inputs i.e from files 1.in, 2.in and output it to files 1c.out 2c.out etc
16:42  singularity: maxim, hi I needed to write a bash program to run a program with looped inputs i.e from files 1.in, 2.in and output it to files 1c.out 2c.out etc
16:43 --- maxim is now known as Guest72713
16:43  singularity: Guest72713, , hi I needed to write a bash program to run a program with looped inputs i.e from files 1.in, 2.in and output it to files 1c.out 2c.out etc
16:43  singularity: Guest72713, can you help me?
16:44  nDuff: singularity, don't pick on individual people
16:44  nDuff: singularity, ...just ask of the channel, as you did, and _wait_.
16:44  singularity: nDuff, sorry
16:44  singularity: hi I needed to write a bash program to run a program with looped inputs i.e from files 1.in, 2.in and output it to files 1c.out 2c.out etc
16:44  nDuff: ...as you already did ask of the channel, no need to keep repeating yourself, either.
16:45  singularity: ok :P
16:46  lhunath: !loops > singularity
16:46  greybot: singularity: Loops repeatedly execute a block of code. See http://mywiki.wooledge.org/BashSheet#Loops
16:46  nDuff: # touch foo.in bar.in; for file in *.in; do cat <"$file" >"${file%.in}c.out"; done; echo *
16:46  evalbot: nDuff: bar.in barc.out foo.in fooc.out
16:46  nDuff: singularity, ^^^
16:46  nDuff: !guide > singularity
16:46  greybot: singularity: http://mywiki.wooledge.org/BashGuide
16:47  nDuff: !pe > singularity (to understand how what I did works)
16:47  greybot: singularity (to understand how what I did works): Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
16:47  singularity: nDuff, sorry, but i'm a real noob, will this work in ubuntu?
16:48  nDuff: singularity, if we give you anything that isn't portable, we'll tell you.
16:48  singularity: nDuff, ok thanks! :)
16:49  singularity: nDuff, but where in the script does it run a program? because a program is run using ./
16:49  nDuff: singularity, "cat" is a program
16:49  nDuff: singularity, ...and programs are not necessarily or always run using ./
16:50  singularity: nDuff, ok
16:50  nDuff: . is the current directory, / is the separator, so ./ is saying "in the current directory"
16:51  nDuff: if you're running your program, or specifying a file, in the current directory, then it's a reasonable thing to use -- but it's not special or magic.
16:51  nDuff: singularity, see the guide we linked you to (also in the FAQ) -- it's a good place to get started with scripting.
16:52  nDuff: s/FAQ/topic/
16:55  hal1: geirha: what i mean is, I don't know where that directory hierarchy will be located on the filesystem
16:55  hal1: geirha: I need to delete the contents of the subdirs in all of them
16:55  nDuff: !find > hal1
16:55  greybot: hal1: http://mywiki.wooledge.org/UsingFind
16:56  nDuff: hal1, see in particular -wholename
16:56  hal1: nDuff: I can't find that in that page
16:56  nDuff: hal1, it's in your man page
16:57  nDuff: hal1, that page gives you general usage advice, your man page gives you the exact operators available in your version.
16:58  hal1: nDuff: ok, I didn't know about wholename - thanks
16:59  nDuff: find . -wholename '*/build/directoryX/directoryY' should get the list, and the UsingFind page gives you options on how to process it.
17:03  trhodes: how does the prompt escape \u get its username ?
17:03  trhodes: i've been trying to pretty up PS1 in a chroot
17:07 --- Damnshock2 is now known as damnshock_work
17:07  geirha: trhodes: Probably from the user database (e.g. /etc/passwd)
17:08  trhodes: ok, just getting around to setting that up
17:11  pigdude: how do i exec multiline sed?
17:11  pigdude: sed <<<... ?
17:12  geirha: trhodes: Doing a quick grep of the source it appears to use getpwuid(3)
17:13  geirha: sed 'command1
17:13  geirha: command2' file
17:13  pigdude: geirha: makes sense :^)
17:13  trhodes: geirha, ok, thanks :) i put in a minimal passwd and group file entry; no luck, so I put getent in there and it's not returning anything, so that's where the problem is, I guess
17:14  geirha: If it's very long it might make sense to make a sed script
17:15  geirha: trhodes: man pwck
17:16  pigdude: what is sed for 'delete line that matches pattern'?
17:16  pigdude: i recall a 'd' flag but forget usage
17:17  nDuff: pigdude, it's not a flag, it's a command
17:17  pigdude: nDuff: so d/pattern/?
17:17  nDuff: pigdude, just 'd' deletes all lines it's applied to. Like any other sed command, you can control which lines it's applied to with an address range or pattern match
17:17  pigdude: nDuff: or pattern/d?
17:17  pigdude: nDuff: (usage??)
17:17  nDuff: pigdude, '/pattern/ d'
17:17  pigdude: nDuff: okee doke, thanks :^)
17:18  cthuluh: pigdude: please ask sed questions in ##sed
17:18  pigdude: cthuluh: ok
17:18  sysop1: is this where I say stupid things to end up on bash.org?
17:18  sysop1: ;)
17:19  nDuff:  negative; this is where you get technical help with the Bourne Again shell.
17:19  sysop1: just kidding.
17:19  getxsick: and rather get kicked out for stupid things
17:19  nDuff: ehh, ignored, more likely; not many folks get kicked here.
17:19  geirha: There a couple of entries from this channel on bash.org though :)
17:19  cthuluh: getxsick: those cases are very rare
17:20  sysop1: i usally idle hee.  just had to reboot my box
17:21  sysop1: but was kinda ignored when looking for bash for android I first found the bash.org app for android.
17:21  sysop1: ignored I mean anoyed.
17:21  sysop1: ttyl back to idling
17:35  trhodes: geirha, pwck says "user 'root': no group 0" and "no changes" from within the chroot
17:35  trhodes: exit code 2, hmm
17:36  geirha: trhodes: Sounds apparent what you need to do, then. Doesn't it?
17:38  trhodes: but isn't a group defined in /etc/passwd (by default) ?
17:38  geirha: No, in /etc/group
17:39  trhodes: er yeah
17:39  geirha: man 5 group
17:40  MessedUpHare: hi all, i'm trying to get an if statement to return true if my variable $f contains the string "/." and i'm having difficulty with the syntax
17:40  MessedUpHare: so far i've got if [ "$f" == "*\/.*" ]; then   ... which doesn't work
17:40  nDuff: MessedUpHare, [[ $f = */.* ]] will return true if that condition is set
17:40  nDuff: MessedUpHare, == isn't valid for [ ] in POSIX sh; that's a bash extension.
17:40  The-Compiler: ![[ > MessedUpHare
17:40  greybot: MessedUpHare: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
17:41  The-Compiler: I think [ doesn't even do patterns.
17:41 * nDuff was getting to that
17:41  MessedUpHare: thanks all!
17:42  geirha: !tests
17:42  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
17:50  trhodes: geirha, the group file seems correct, though : http://sprunge.us/LAjF
17:51  trhodes: geirha, actually, i chowned root:shadow etc/shadow
17:51  trhodes: and uids/gids of host and chroot are the same
17:53 --- Weust` is now known as Weust`afk
17:56  MessedUpHare: thanks again everyone, I still need to get to grips on when to use [ and [[ etc...
17:56  MessedUpHare: but my script is now working
17:56  MessedUpHare: :)
18:00  e36freak: basic gist is "don't use [ unless you have to"
18:02  MessedUpHare: heh, i'm just taking 5 to read this greg's wiki thing greybot posted.. i assume its a personal wiki but it reads well
18:03  nDuff: MessedUpHare, this channel as a whole relies very heavily on that wiki.
18:03  nDuff: ...I wouldn't describe it as "personal" inasmuch as that implies single-contributor.
18:04  e36freak: its phenomenal, whatever you call it
18:09  g3d: hi, I wanted to "patch" some bytes in a file using dd and printf. I can do that fine with printf "\x12\x34\x56" | dd bs=1 count=3 seek=50 conv=notrunc of=myfile, but I'd like the patch (i.e. the bytes sequence in the printf) to be a variable. Can I make printf generate a sequence of bytes given a variable with a value (something like printf("%x", val), but not generating a string, but actual bytes)?
18:09  g3d: or maybe there is a better way for that than printf?
18:11  nDuff: g3d, if you _did_ want to use printf, see printf -v
18:11  nDuff: g3d, but that said, this sounds like something you can do with $'' just as well, at least assuming this is a bytes stream you can actually store in a variable (ie. no nulls)
18:12  nDuff: (and if it contains nulls, storing the printf output won't work either)
18:13  g3d: nDuff: I don't have to use printf, how would I use $'' for that? Let's say I have a val=0x1234 and I want to pipe \x12\x34 to dd.
18:13  g3d: I can skip 0x if you prefer
18:15  nDuff: g3d, dd ... <<<'\x12\x34'
18:15  nDuff: err
18:15  nDuff: $''
18:15  nDuff: dd ... <<<$'\x12\x34'
18:15  g3d: nDuff: hm, ok, but my problem is how to convert val into \x12\34, given val=1234 or val=0x1234
18:15  nDuff: ahh.
18:15  g3d: s/x\12\34/\x12\x34
18:16 * nDuff is pretty sure there's a FAQ covering that...
18:16  yitz_: !faq hex
18:16  greybot: http://mywiki.wooledge.org/BashFAQ/071 -- How do I convert an ASCII character to its decimal (or hexadecimal) value and back?
18:16  yitz_: That one?
18:16  nDuff: yup
18:16  rethus1: have this to find old backups:   find /srv/Backups/vm_backups/ -mtime +30;
18:16  rethus1: how can i encapsulate this, to not delete files names "removeBackup.sh" ?
18:17  yitz_: find /srv/Backups/vm_backups/ -mtime +30 ! -name removeBackup.sh -delete
18:17  g3d: looks like exactly what I needed, thank you nDuff and yitz_
18:17  sobersabre: guys, I have a small sed issue.
18:18  sobersabre: I have "template" with _STUB_ in certain location of a file.
18:18  yitz_: !faq template > sobersabre
18:18  greybot: yitz_: No matches found at http://mywiki.wooledge.org/BashFAQ
18:18  yitz_: !template > sobersabre
18:18  greybot: sobersabre: http://mywiki.wooledge.org/TemplateFiles
18:18 * yitz_ isn't good for much more than operating the bot
18:19  sobersabre: yitz_: trying
18:21  e36freak: yitz_: the important thing is that you know which bot commands to use
18:22  edgy: hi, shouldn't ps -p gives me the process name only?
18:24  nDuff: !pm > edgy
18:24  greybot: edgy: http://mywiki.wooledge.org/ProcessManagement
18:24  edgy: nDuff: that pages doesn't contain any reference to ps -
18:24  edgy: nDuff: that pages doesn't contain any reference to ps -p
18:26  nDuff: edgy, but it gives you alternatives
18:27  nDuff: anyhow -- reading the manual, I don't see anything in -p indicating that it should give the name only
18:27  nDuff: what's your goal?
18:27  nDuff: if you're on linux, and you know the pid, you can just read straight out of /proc
18:28  knoppix_____: are there any [:class:] classes for utf8 other than the ascii, etc. that have been around for ever.  If not what is the best way to get at some other utf8 "class"  or collation series?
18:28  edgy: nDuff: I know I can read from proc and it's easier to just use ps and see the name with my eyes but my question is why the -p option is not working, is this a bug?
18:29  nDuff: by "not working"  you mean printing a full line?
18:29  nDuff: !doesntwork
18:29  greybot: Saying something "doesn't work" helps nobody. Explain what you *want* to do, what you are *doing* and how it is *failing*. Being abstract or vague doesn't help. Copy/paste the commands that fail and the errors they produce.
18:29  nDuff: !exact
18:29  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
18:29  nDuff: ps varies between platforms, also
18:29  nDuff: only fairly limited aspects of its behavior are standardized
18:30  g3d: hm... I might be doing something wrong, the values in the file don't make sense, even if I take into account dec/hex conversions and endianness, right now I'm trying: printf \\$(printf '%08x' 0x12345678) | dd bs=4 count=1 conv=notrunc of=myfile
18:30 * nDuff off to lunch
18:31  edgy: nDuff: I typed ps -p $$
18:37  e36freak: !< <(
18:44  edgy: e36freak: can you pleas help on my previous question?
18:47  sobersabre: yitz_: THANKS, worked.
18:48  yitz_: Buy me two tylonel?
18:51  e36freak: edgy: ps -p $$ -o cmd?
18:53  Dvlpr: how to start sh script in background?
18:53  Dvlpr: so that it keeps execution even after I close telnet connection
18:53  e36freak: nohup ./script &
18:54  Dvlpr: thanks alot
18:54  edgy: e36freak: thanks a lot but then what's the difference between a command like ps -p $$ 1 and ps $$ 1
18:56  e36freak: -p has slightly less output
18:56  e36freak: thats all i know, read the man page
18:56  yitz_: ps manpage is pretty massive
18:56  e36freak: Dvlpr: or you can use screen or tmux if you want to be able to check up on it
19:06  trhodes: geirha, i forgot to add the proper nss libraries (and symlinks) - once they were added, \u in PS1 works fine
19:07  e36freak: O_o thats a lot off effort to change the PS1
19:07  e36freak: s/off/of/
19:08 --- aantix_ is now known as aantix
19:09  trhodes:  e36freak, haha yeah, but I probably prevented some other things from going haywire too
19:09  e36freak: trhodes: what distro/OS?
19:09  trhodes: slackware
19:10  e36freak: ahh, that could do it
19:12  e36freak: trhodes: how is it? i was gonna try slackware, and then i found arch
19:16  trhodes: e36freak, well, i like it quite well; not looking for another distro. Arch seems like a nice distro, too, but I've not actually run it on any of my computers.
19:16  e36freak: worth a try if you ever feel like it
19:17  trhodes: yeah, i should probably check some other distros out some time to see how they're put together too
19:18  brick: why is my ~/.bashrc not being sourced on login? i have to do ". .bashrc" manually to get my env setup.
19:18  e36freak: i stopped hopping a while ago though, once you find one you really like there isnt much of a point. ive been meaning to try BSD though
19:18  e36freak: brick: what is in ~/.bash_profile ?
19:18  brick: e36freak, doesn't exist
19:18  e36freak: brick: theres your problem
19:18  brick: there is an /etc/bashrc
19:19  brick: should one be linked to the other? is .bashrc just the wrong name for this file?
19:19  e36freak: brick: echo '. $HOME/.bashrc' >> ~/.bash_profile
19:20  brick: thanks e36freak, a symlink did the trick!
19:20  e36freak: brick: shouldnt use a symlink, just put that line in it
19:20  brick: what about .profile? is that file going to be consulted?
19:20  e36freak: brick: they do different things and .bash_profile can be used seperately
19:20  brick: instinctually i don't like the filename .bash_profile too much
19:21  e36freak: im trying to find the FAQ on it
19:21  brick: thank you...
19:22  e36freak: brick: http://www.linuxfromscratch.org/blfs/view/6.3/postlfs/profile.html just a quick google
19:23  e36freak: !dotfiles > brick
19:23  greybot: brick: http://mywiki.wooledge.org/DotFiles or - for a technical explanation - the INVOCATION section of man bash.
19:23  e36freak: there we go
19:23  Geralt: Is the Bash Pocket Guide from O'Reilly worth buying it?
19:23  brick: e36freak, thanks!!
19:24  brick: very nice
19:25  e36freak: Geralt: generally books dont seem to be that great, the wiki used here is gonna be better than any book you can buy
19:25  e36freak: !books
19:25  greybot: Most of the published shell/bash books are relatively poor. They may have a few gems here and there, but they're few and far between. Try the BashGuide instead.
19:26  Geralt: thought so, most books I've read so far about shell programming were pretty old, some were not even mentioning bash
19:26  trhodes: i borrowed "learning the bash shell, 3rd, ed." from a library and thought it was OK, but i'm not sure that i'd buy it
19:27  Geralt: I was considering the bash cookbook some time ago, but it does not cover bash 4.x and there doesn't seem to be an update anytime soon
19:33  e36freak: # echo "foo, 3" >> foo; echo "bar, 3" >> foo; baz="foo, 4"; sed -n "/${baz}/s/.*,//p" foo
19:33  evalbot: e36freak: no output
19:33  e36freak: hm
19:34  e36freak: # echo "foo, 3" >> foo; echo "bar, 3" >> foo; baz="foo, 4"; sed -n "/${baz}/p;s/foo/bar/" foo
19:34  evalbot: e36freak: no output
19:34  e36freak: # echo "foo, 3" >> foo; echo "bar, 3" >> foo; baz="foo, 4"; sed -n "/${baz}/p" foo
19:34  evalbot: e36freak: no output
19:34  e36freak: oh, duh
19:35  e36freak: # echo "foo, 3" >> foo; echo "bar, 3" >> foo; baz="foo, 4"; sed -n "/${baz% *}/p" foo
19:35  evalbot: e36freak: foo, 3
19:35  e36freak: # echo "foo, 3" >> foo; echo "bar, 3" >> foo; baz="foo, 4"; sed -n "/${baz% *}/s/.* //p" foo
19:35  evalbot: e36freak: 3
19:35  e36freak: word
--- Log closed Thu Dec 23 19:45:30 2010
--- Log opened Thu Dec 23 20:00:57 2010
20:00 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
20:02 --- Channel #bash was synced in 96 seconds
20:03  jfe: hi all
20:03  jfe: what would be the best way to 1. see if there is an argument on the command line and 2. check that the argument is a positive integer?
20:04  greycat: if (($# < 1)); then usage; exit 1; fi
20:04  greycat: !faq valid
20:04  greybot: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
20:09  jfe: greycat: thanks!
20:10  Geralt: Can I invert a glob?
20:10  greycat: !extglob
20:10  greybot: "Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob
20:11  Geralt: perfect, thanks :)
--- Log closed Thu Dec 23 20:26:18 2010
--- Log opened Thu Dec 23 20:31:40 2010
20:31 --- Users 557 nicks [0 ops, 0 halfops, 0 voices, 557 normal]
20:33 --- Channel #bash was synced in 100 seconds
21:02  mikegg: whats an appropriate bashrc entry for the path /home/mike/Downloads/epd-6.3-2-rh5-x86 ?
21:02  greycat: huh?
21:02  mikegg: argh
21:02  mikegg: i'm lost
21:02  likewhoa: heh
21:02  greycat: That looks like a filename.
21:02  mikegg: lemme backup
21:02  mikegg: I installed this for python
21:02  mikegg: http://www.enthought.com/
21:03  mikegg: at the end of the install it said I need to add the path to my bashrc file
21:03  geirha: And this is related to bash how?
21:03  greycat: Normally one does not set PATH in .bashrc.
21:03  geirha: Well that's crap
21:03  mikegg: the guys in #python told me to come here!
21:03  greycat: Normally one sets it in one's login profile, whatever that may be.
21:03  greycat: !dotfiles > mikegg
21:03  greybot: mikegg: http://mywiki.wooledge.org/DotFiles or - for a technical explanation - the INVOCATION section of man bash.
21:04  greycat: E.g. if you login via ssh or a text console, you'd add something like PATH=$PATH:/opt/pythonthing/bin to your .bash_profile
21:07 * nDuff notes that mikegg is the first person he's seen ever actually use the Enthought Python Distribution
21:07  hansel: lol
21:07  mikegg: really?
21:07  hansel: I didnt even know it existed until he mentioned it.  I knew of a few pythons out there.... not that one
21:07  mikegg: looks like it has some cool spectrum analyzer stuff
21:07  mikegg: and i'm lazy...
21:07  nDuff: nothing that can't be installed into your distro's supported Python
21:07  nDuff: or into a virtualenv
21:08  hansel: lazy is a good attribute... makes you do things more efficiently and automate so you don't have to do anything.
21:08  nDuff: "lazy" in this case is probably making more trouble for yourself later when you want to use a library installed with a distro package
21:08  greycat: !laziness
21:08  greybot: LAZINESS: The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and document what you wrote so you don't have to answer so many questions about it. Hence, the first great virtue of a programmer.
21:08  hansel: greycat++
21:08  nDuff: that's true laziness. There's also false laziness.
21:09  nDuff: As much as I hate Larry Wall, he's written about the distinction.
21:09  bgy: hi
21:10  hansel: oh hai.
21:10  bgy: What does $- mean in bash script?
21:10  greycat: Special Parameters, look for -
21:10  greycat: It's the current set of options (not shopts, though).
21:11  greycat: I still hate the fact that $- does not appear as such in the man page.  But my patch was ignored.
21:12  getxsick: $1 $2 are pointing to argvs, is it possible to do an expression like `'foo' in argv`?
21:12  greycat: !faq easily > getxsick
21:12  greybot: getxsick: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
21:12  greycat: literally:   for foo in "$@"    or   for foo
21:13  bgy: greycat: ok, thank you i'm trying to debug a bash script with bashdb to make it work on macosx
21:16  getxsick: what is the best way to check if a var is set?
21:16  greycat: !learn sp Special Parameters (magic read-only builtin "variables"): http://www.gnu.org/software/bash/manual/bashref.html#Special-Parameters
21:16  greybot: OK, greycat
21:16  greycat: !faq defined > getxsick
21:16  greybot: getxsick: http://mywiki.wooledge.org/BashFAQ/083 -- How do I determine whether a variable is already defined?  Or a function?
--- Log closed Thu Dec 23 21:27:36 2010
--- Log opened Thu Dec 23 21:33:02 2010
21:33 --- Users 556 nicks [0 ops, 0 halfops, 0 voices, 556 normal]
21:34  Lenhix: Hello. Quick question: how can I left-trim a string? I have just one space at the beggining I don't want
21:34  greycat: !faq trim
21:34 --- Channel #bash was synced in 96 seconds
21:34  greybot: http://mywiki.wooledge.org/BashFAQ/067 -- How can I trim leading/trailing white space from one of my variables?
21:34  greycat: If it's just *one* space, you can use PE:  ${string# }
21:35  Lenhix: thx greycat
21:36  Lenhix: greycat: what if that string is stored in a variable?
21:36  greycat: It *has* to be stored in a variable.
21:36  greycat: !pe
21:37  nDuff: Lenhix, "string" is in that example the variable name
21:37  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
21:37  wimpog: I have a variable that contains dollar signs, but I don't want them to evaluate when the variable is echoed
21:38  greycat: They won't be.
21:38  nDuff: !exact > wimpog (can you demonstrate how this appears to be happening?)
21:38  greybot: wimpog (can you demonstrate how this appears to be happening?): Please tell us EXACTLY what you typed, and EXACTLY what the error is.
21:38  nDuff: wimpog, more likely they're being evaluated when the variable is assigned
21:38  wimpog: nDuff: oh ok
21:38  Kramericus: BASH r0x0rz my b0x0rz!!!!!111
21:39  nDuff: wimpog, ...and if that's the case, it means you're doing the quoting wrongly.
21:39  greycat: Or he's doing eval or an eval-analogue.
21:39 * nDuff reiterates the show-us-how-you-reproduce-this request.
21:39  wimpog: nDuff: yeah, I need to do that
21:41  Lenhix: thx greycat, worked perfectly}
21:41  getxsick: http://paste.pocoo.org/show/309057/ - i get "Bad substituion" :(
21:41  geirha: getxsick: You need bash for variable indirection
21:41  getxsick: ah
21:41  greycat: Dollar sign.  Curly brace.  VARIABLE NAME.  Optional stuff.  Curly brace.
21:42  geirha: getxsick: Now why on earth you put that ! in there is a mystery.
21:42  getxsick: geirha: i read it on BashFAQ
21:43  geirha: getxsick: And what does it do?
21:43  getxsick: indirect vars? :D
21:43  nDuff: which you need for that code why?
21:43  getxsick: i don't have bash4 so i can't use hashes
21:43  nDuff: if host contains the name of another variable, why are you using it directly as an argument to exportwww?
21:44  nDuff: ie. that code doesn't make sense.
21:44  greycat: !wayttd > getxsick
21:44  greybot: getxsick: What Are You Trying To Do?
21:46  geirha: Sounds like a case case
21:46  getxsick: wait
21:46  getxsick: let me fix few things in the script
21:46  getxsick: then i will show all lines, ok?
21:47  greycat: If your algorithm requires an associative array and you don't have bash 4, use awk.
21:47  getxsick: greybot: i can go with indirect vars instead. a bit more obscure but it's not for a wide use
21:47  getxsick: greycat: ^^
21:48  greycat: You still haven't said what you're doing.
21:48  getxsick: greycat: it's a bit more complex than 1-line explanation. i will show a full script
21:48 * nDuff would prefer an explanation to a script.
21:49  nDuff: a script only tells us what you're doing now; an explanation tells us what you want to do.
21:49  nDuff: the latter is far more valuable.
21:49  greycat: A script us what he THINKS will achieve whatever mysterious goal he has, but by definition, it fails (or he wouldn't be here).
21:49  nDuff: after all, if what you were doing now was the same as what you want to do, you wouldn't be here :)
21:49  getxsick: nDuff: come on, not in case where you have some rsync, scp, ssh commands, do i really need to explain all of them for waht i use them?
21:50  nDuff: getxsick, you don't need to explain the commands, you need to explain the intent.
21:50  geirha: Are you trying to do something like this?  case $arg in home) host=foo.bar.baz;; office) host=quux.quuux.quuuux;; esac; stuff with "$host"
21:50  greycat: getxsick: "I want to read a list of hostnames from a file and ssh to each one and run some command" would be a valid first-level explanation.
21:50  getxsick: nDuff: you are right, i just want to play with shell more as usually i use Python and Perl
21:50  getxsick: no, you are all wrong
21:50  getxsick: ok
21:50  getxsick: i'm pasting the code
21:50  getxsick: with a short explanation
21:50  nDuff: explanation in-channel, please
21:51  getxsick: sure
21:51  greycat: that way we don't actually have to read the code.
21:51  geirha: we're not too fond of patebins :)
21:51  getxsick: i just have to do some stuff on some hosts
21:51  e36freak: wow, specific
21:52  nDuff: !questions > getxsick (as a first-level overview of why we don't like pastebins)
21:52  greybot: getxsick (as a first-level overview of why we don't like pastebins): Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
21:52  getxsick: and i want to have a possibility to select hosts from the command line (but not by IP just by aliases)
21:52  greycat: You want a menu of hostnames?  Dialog.  !faq dialog
21:52  getxsick: no, i don't want a dialog
21:52  geirha: getxsick: Right, so you don't need variable indirection
21:52  getxsick: i want to do something like `superscript.sh host1 host2 host3`
21:53  greycat: for host; do ...; done
21:53  getxsick: geirha: i would live to use associated arrays here
21:53  nDuff: !.sh > getxsick (as a note on convention)
21:53 --- [1]The-Bat is now known as The-Bat
21:53  greybot: getxsick (as a note on convention): Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
21:53  geirha: getxsick:  case $arg in home) host=foo.bar.baz;; office) host=quux.quuux.quuuux;; esac; stuff with "$host"
21:53  greycat: Why would you need an associative array to do "for host"?
21:53  nDuff: getxsick, sounds like a case where join would be the right tool
21:53  greycat: Ah.  He wants built-in pseudonyms.
21:53  nDuff: greycat, because he hasn't set up his system resolver, DNS, _or_ /etc/hosts correctly, I presume
21:53  pgas: i'd define the aliases in /etc/hosts
21:53  nDuff: exactly.
21:54  greycat: Or ~/.ssh/config
21:54  getxsick: nah, it's not a point in this case, sorry
21:54  nDuff: "not a point" meaning what -- you're doing this as an exercise rather than to accomplish a practical result?
21:54  getxsick: no, a practical result but i want to keep this script independent from the global system settings (such as /etc/hosts)
21:55  greycat: You want hostname aliases that aren't used by anything else?  For god's sake, why?
21:55  greycat: So you have another whole set of shit to remember?
21:55  nDuff: $HOME/.ssh/config is independent from global settings
21:55  nDuff: also, what greycat says.
21:56  getxsick: come on, i know what is /etc/hosts i know what is ~/.ssh/config but it's not a point in this case. really
21:56  nDuff: "not a point" means you have a bunch of arbitrary restrictions in your head
21:56  greycat: I don't understand his English.
21:56  getxsick: nDuff: or in my boss
21:56  nDuff: and that you're only willing to accept answers that are exactly what you expect / ask for
21:56  greycat: "Not a point" meaning it's blunt and not sharp?
21:56  nDuff: getxsick, if you have a set of restrictions from your boss, STATE THEM
21:56  nDuff: don't make us play 20 questions.
21:57  getxsick: nDuff: as i said, it has to be independent.
21:57  getxsick: geez
21:57  nDuff: "independent" means different things to different people
21:57  nDuff: if it means only editing things under the user's home directory, ~/.ssh/config is independent
21:58  nDuff: if it means only editing things specific to your script, calling ssh with an argument telling it to use a config file specific to your script is independent
21:58  nDuff: again, we're left guessing as to _exactly_ what you mean.
21:58  greycat: !b9
21:58  greybot: All examples given by the questioner will be broken, misleading, wrong, and not representative of the actual question.
21:58  getxsick: pff
21:58  getxsick: ;-)
21:58  greycat: !b18
21:58  greybot: The newbie will not accept the answer you give, no matter how right it is.
21:59 * tharkun wants a copy of the full b series ;P
21:59  getxsick: yeah, i give answers on #python and i understand what you are trying to say to me, fine then. however sometimes you just have to break rules, ok?
22:00  greycat: tharkun: you can go to http://wooledge.org/~greybot/b0 /b1 /b2 etc.
22:00  greycat: getxsick: We're asking you to TELL US what your rules are.  Because we can't seem to guess them.
22:00  getxsick: as i said, the script has to work standalone
22:00  nDuff: and you aren't defining "standalone"
22:01  getxsick: and i think that case statement would make a job
22:01  greycat: Meaning what?  It has to contain its own libresolv equivalent?
22:01  greycat: It can't use /etc/resolv.conf?
22:01 * nDuff thinks "standalone" means it has to work without an operating system :)
22:01  greycat: His English isn't helping any.  I literally have NO idea what "would make a job" means.
22:01  bassliner: hello, i check if a regex contains only the specified characters using the following regex:   [[ ! $servername =~ ^[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\ _\.\-]{1,20}$ ]];  but i seem to not be allowed to enter strings that contain "." here. any hint why would be very welcome. thanks for your help!
22:02  e36freak: bassliner: first of all, use ranges
22:02  greycat: bassliner: don't use \. because . is not special inside a range....
22:02  hansel: bassliner - that hurts my eyes.  The left one is bleeding.
22:02  geirha: bassliner: Put the regex in a var
22:02  e36freak: bassliner: ^[a-zA-S0-9]
22:02  greycat: e36freak: no, that fails if locale != C
22:03  e36freak: greycat: ahh. and his wouldnt?
22:03  greycat: [^[:alpha:]_.-]
22:03  greycat: e36freak: A-Z in a non-C locale can include things like ñ and è
22:03  e36freak: ahh
22:03  tharkun: áéíú ;P
22:03  greycat: (Yes, *lowercase* things.)
22:04  bassliner: thanks in advance.
22:04  geirha: re='^[a-zA-Z0-9 _.-]{1,20}$'; if ( LC_COLLATE=C; [[ $string =~ $re ]] ); then ...
22:04  greycat: Oh, the ^ was outside the range.  Oops.
22:05  geirha: bassliner: Might as well use a glob though.
22:05  greycat: re='^[[:alnum:] _.-]{1,20}$'
22:05  greycat: That would require thinking.
22:06  greycat: What is the opposite of "Every character of s is in the range [[:alnum:] _.-]"?
22:06  hansel: I personally choose to avoid diacritic-containing charactersets.  That way when I'm storing data and share it with others we dont have to deal w awkward conversions if one is using something different.  (something to consider if implementing in a corporation where standards don't get down to that level and you want the data to be usable to upstream/downstream apps)
22:07  geirha: Hm. Doesn't appear setting LC_COLLATE is enough. LC_ALL does the job though.
22:07  greycat: hansel: that's great if you never use the Internet.
22:07  geirha: At least with [:alnum:]
22:07  e36freak: what is... internet?
22:07  hansel: greycat - we have this issue with our company directory.  The character set allows for diacritics.  Almost every downstream vendor app we have that relies on those feeds uses different charactersets.
22:08  bassliner: i still don't see why \. in my regex doesn't work
22:08  greycat: Why would you use \. ?
22:08  e36freak: bassliner: as stated, "." doesnt have any special meaning in a range
22:08  greycat: We've shown you approximately half a dozen examples that do NOT use it.
22:08  greycat: We even told you what e36freak just said.
22:08  bassliner: greycat: because . doesn't work either. but that seems to be wrong.
22:08  hansel: and some of our security systems allow for it and others dont.   ie; the mainframes dont.
22:08  bassliner: ah, ok got it.
22:09  geirha: if (LC_ALL=C; [[ $string = +([[:alnum:] _.-]) ]] && (( ${#string} < 20 )) ); then
22:09  greycat: hansel: Playing ostrich may save you for a few years, but eventually the 21st century IS going to find you and kick your ass.  Just warning you.
22:09  geirha: err <=
22:10  greycat: All of us over the age of 20 have gone through that particular ass-kicking already, so you're welcome to moan about it when it happens.
22:10  hansel: greycat - in a huge corporation it's tough.  smaller shops have it easy.  :)  I'm 35  ;)
22:11  hansel: the other major headache is the length of name fields in all these systems.  People from south america have huge names.  the security folks inputting it pick and choose the ones they want to be their last name.
22:12  greycat: Their names also frequently have accents.
22:12  hansel: so Francisco Juan Pablo Escobar Zapata may be entered in as Franc Juan or Franciso Zapata or anything inbetween.
22:12  hansel: yup
22:13  hansel: so Emélia would get stored as Emelia so it doesn't show up as Emœlia in other apps that dont share the charset because the vendor didnt build it that way and will charge us $500k to rebuild it that way.
22:14  hansel: (i wish i was making this up)
22:14  greycat: The question becomes, what do you do when you get "Emélia" in some kind of input file that you have no control over?
22:15  mehwork: can't do this because foo is a bash script right: sudo -u apache ./foo
22:15  hansel: we just dont allow it now from the get go.  It will be Emelia  :)
22:15  greycat: Since when does apache take filename arguments?
22:15  mehwork: says permission denied even though foo is owned by apache:apache and my current user is 'mehwork' but is in sudoers
22:15  e36freak: oh god kerning killed Emœlia here
22:15  greycat: Oh... never mind, it's -u username.  Sorry.
22:16  greycat: hansel: so, you reject the entire input file?  You reject just that one line?  You do a conversion?
22:16  greycat: mehwork: does user "apache" have search (+x) permission on every directory up to that file?
22:16  hansel: conversion, yes.
22:17  hansel: and it gets manually checked (usually only a small handful of rejects)
22:17  hansel: we did have a day when 200 contractors came on from down south and that wasn't fun. :)  Those are far and few between though.
22:17  mehwork: greycat: yes
22:18  mehwork: greycat: oh no, not every directory just on that file
22:18  greycat: mehwork: *shrug* well, you have to figure out whether it's an sudo issue or a basic permissions issue.
22:18  hansel: it's either this or cough up millions to change all the downstream vendor apps that read it in.
22:18  mehwork: must be basic perm issue my bad
22:18  hansel: mehwork - setfacl and you're good  ;)
22:19  mehwork: not gonna set an acl on this :P
22:19  mehwork: would require more planning
22:48 --- thespider is now known as rustymyers
22:57 --- [1]The-Bat is now known as The-Bat
22:59  mjrosenb: I have a file that I want to read in as n words per line, following standard bash word splitting rules.  Is there any way to do this?
23:05  gniourf_gniourf: for 7 words per line: read word1 word2 word3 word4 word5 word6 word7
23:05  gniourf_gniourf: for more you might want to use an array
23:05  gniourf_gniourf: read -a array
23:11  mjrosenb: gniourf_gniourf: that does not use bash word splitting though, it just splits at every space
23:11  mjrosenb: gniourf_gniourf: so if my file contains "foo bar" baz quuz, and i want to read in 3 words, word1="foo bar" word2=baz word3=quux
--- Log closed Thu Dec 23 23:15:36 2010
--- Log opened Thu Dec 23 23:31:03 2010
23:31 --- Users 546 nicks [0 ops, 0 halfops, 0 voices, 546 normal]
23:32 --- Channel #bash was synced in 95 seconds
23:34  strull: homekevin: try :let $UNZIP=  and then try again
23:34  strull: ooops, wrong channel, sorry
23:52 * skraito say hi all
--- Log closed Thu Dec 23 23:57:24 2010
