--- Log opened Sat Nov 06 00:00:46 2010
00:01  bkpc: hi
00:06  tsaavik: Anyone know a way to get the size of a file that doesn't involve using ls/find/stat?
00:07 --- c2c_ is now known as c2c
00:07  lhunath: read size _ < <(wc -c file)
00:08  tsaavik: lhunath: thanks!
00:08  tsaavik: totally spaced, my wc even supports byte counts :D
00:08  lhunath: yes, with -c
00:09  tsaavik: thats the switch! :D Wasn't sure if it was the same, I've got busybox's version of wc :\
00:10  geirha: You can also do  size=$(wc -c < file)
00:10  tsaavik: wc seems to support reading the filehandle for you
00:11  tsaavik: wc -c file
00:11  tsaavik: unfortuntely (busybox?) wc is very slow :(
00:11  tsaavik: real    0m1.387s      VS   real    0m0.030s
00:12  tsaavik: guess streaming the entire file through and counting it is slower then looking at the filesystem table :D
00:12  geirha: Yeah, typically wc will stat(2) it.
00:13  lhunath: some wc's don't stat if you use <
00:13  lhunath: hence me not using it
00:13  geirha: So maybe busybox is one of them
00:13  nemo: ah. my problem is that grep reads the file into memory to know what line it is on
00:13  tsaavik: yeah, I don't have a user stat wrapper
00:13  lhunath: additionally; the $() will also capture spacing.
00:14  nemo: unfortunately, there doesn't seem to be a way to tell it to ignore lines and/or treat it as a binary file but still give me byte counts
00:14  nemo: hm
00:14  lhunath: tsaavik: ''wc -c file'' doesn't stat the file with you?
00:14  nemo: guess I'm using the wrong tool for the job
00:14  lhunath: nemo: what's the job?
00:14  tsaavik: lhunath: I doubt it since it takes 1.3 seconds to return
00:14  nemo: lhunath: trying to locate a pattern in a binary file
00:14  lhunath: tsaavik: even without the redirection?
00:14  nemo: grep  -a -bo -F $(echo -e "\xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1") /dev/sda
00:14  nemo: grep: /dev/sda: Cannot allocate memory
00:15  nemo: lhunath: -a is the problem
00:15  nemo: I need it to get the counts, but with it, it stores the file in mem
00:15  nemo: so. I think I'm just going to have to do something else
00:16  tsaavik: lhunath: yeah :(
00:16  lhunath: tsaavik: naughty wc.
00:16  nemo: lhunath: suggestions welcome ;)
00:17  tsaavik: yeah, it is almost 2 years old too, so probly fixed, does me no good though :D lol.
00:17  lhunath: nemo: what exactly are you after?  the location of the first appearance of that pattern?
00:17 * tsaavik kicks dirt over a ls call in the script and calls it a day
00:18  lhunath: tsaavik: you can make a system-specific ls call on a single file reasonably reliable.
00:18 * lhunath goes to bed.
00:18  nemo: lhunath: location of all appearances
00:18  nemo: lhunath: same as what grep would yield
00:19  tsaavik: lhunath: just ignore the sound of greybot gnashing it's teeth :D
00:19  nemo: I wonder if the bot is written in bash
00:19  geirha: It's written in perl.
00:20  geirha: !greybot
00:20  greybot: I'm written in perl using POE::Component::IRC, and my source is at http://wooledge.org/~greg/greybot/
00:24  ttwj: hi, is there a way to echo something to an interactive shell script while I have the read function?
00:24  geirha: nemo: Neither bash or grep is designed to handle binary files. Use a more suitable language.
00:25  tsaavik: yes something |shell_script.sh  ?
00:25  nemo: geirha: I'd rather not have to write my own scanner just to get some offsets to feed into dd
00:25  nemo: geirha: it'd be nice if there was already a tool written for it
00:26  ttwj: tsaavik: no the read thingy pauses the whole script
00:26  ttwj: is it possible to let it run something while it reads for input?
00:26  nemo: but. I guess it really isn't appropriate to bash. was just hoping perhaps there was a tool you guys were familiar with
00:26  geirha: nemo: What are you trying to do exactly?
00:27  ttwj: nvm tsaavik, got it
00:27  nemo: geirha: heh. this sounds familiar. 20 lines above. same question, already answered. but ok.   looking for the offsets in /dev/sda for that string
00:27  nemo: geirha: that command works fine in smaller files of course
00:27  nemo: say, a gigabyte or two
00:27  geirha: nemo: Yes, but why are you looking for that particular string?
00:28  nemo: 18:26 < nemo> Greetings shell gods
00:28  nemo: 18:26 < nemo> I'm trying to see if I can do a poor-man's data recovery
00:28  nemo: geirha: basically, I have a buddy booted off a USB stick hoping he can locate some files he cares about
00:28  tsaavik: nemo: finding the offset of a binary file is usually a good job for a 'hex editor'
00:28  nemo: geirha: with the offsets, it isn't too hard to snip them out, and get him the couple of files he wants
00:29  nemo: tsaavik: yeeeah, loading /dev/sda into ghex2 is a good way to crash it
00:29  nemo: tsaavik: but. oh, snarky one, I'm not actually looking to edit :)
00:30  nemo: if necessary I can do this w/ seek/scan and dd
00:30  nemo: say, in 100M chunks or somesuch
00:30  geirha: So it's an odd, fairly unknown filetype?
00:30  nemo: geirha: nope. that's the sequence that starts a word doc
00:30  geirha: Oh, there are many tools for that
00:31  tsaavik: goes ghex2 not support offsets, couldn't you walk thru the device in chunks?
00:31  geirha: foremost is one
00:31  nemo: tsaavik: ghex2 crashes on large files
00:31  nemo: tsaavik: ever tried opening a dvd in it?
00:31  nemo: or something really big?
00:31  Knirch: I'd go with photorec from testdisk personally
00:31  tsaavik: nope, never used it, I use od and not frequently
00:32  nemo: tsaavik: yeah, unfortunately neither od or xxd would really help in this case
00:32  nemo: apart from letting me overlay "lines"
00:32  nemo: I guess it'd work... I'd just have to compensate for the "line"
00:32  nemo: hm
00:33  nemo: tsaavik: foremost is console based and linux - looks promising
00:33  geirha: nemo: http://foremost.sourceforge.net/
00:33  geirha: Ah, yes, there's photorec too.
00:33  nemo: photorec doesn't seem to be in portage.
00:34  tsaavik: yeah, i'd try those, if you get desperate: od --skip-bytes=BYTES_TO_START_ON --read-bytes=BYTES_TO READ
00:34  nemo: hm. foremost recommends scalpel which isn't in portage either
00:35  nemo: tsaavik: yeah, well, the skip/seek part can be done just as easily in dd which I'm going to end up needing to use anyway
00:35  tsaavik: slap that in a incrementing loop and away you go. Might be painfully slow, lol, dunno. You could tweak the chunk size
00:35  nemo: tsaavik: I was just hoping to get all the offsets without having to repeatedly reseek
00:36  nemo: tsaavik: 'cause if I was reseeking anyway, I don't need od - I can just dd in chunks small enough for grep -a to handle :)
00:36  nemo: like, a gigabyte or so ;)
00:36  nemo: I'll try one of these forensic tools though
00:36  nemo: guess he can copy it to his rescue usb
00:36  tsaavik: true, if you intened to grab the data while searching that would probly be easist. they you could do a grep -B right in your command :P
00:36  nemo: was hoping to just give him a command to type in, but what can you do
00:37  tsaavik: (opps meant to say -A or -B)
00:39  ttwj: I'm trying to make a client in bash..
00:39  ttwj: But how can I get it to echo the stuff sent
00:39  ttwj: while reading for user input?
00:40  tsaavik: You don't have local echo?
00:40  geirha: while IFS= read -r line; do echo "Line received: $line"; done
00:41  ttwj: tsaavik: the read thingy pauses the whole script :(
00:41  nemo: geirha: say, just wondering. does that do an infinite loop?
00:41  nemo: that echoes over and over again?
00:41  geirha: nemo: It'll loop until it reaches EOF
00:42  nemo: geirha: I'm curious if I overflowed a disc recently
00:42  ttwj: geirha: uh can I echo stuff and do a read loop together?
00:43  geirha: ttwj: If that's not what you want, I don't understand what you're asking.
00:43 * tsaavik thinks he has no local term echo
00:43  ttwj: o.o
00:43  nemo: geirha: https://lists.launchpad.net/ubuntu-x-swat/msg95246.html - wondering if I got this behaviour due to a script like that :)
00:44  Knirch: nemo: [00:33] < nemo> photorec doesn't seem to be in portage.  it's in the testdisk package in debian atleast
00:44  ttwj: geirha: I'm trying to create a client, and it has to parse the input and echo to the screen while asking for user input simultaneously
00:45  nemo: Knirch: basically, dude apparently did a clean install instead of a dual boot
00:45  nemo: Knirch: he tried convincing us he'd successfully booted windows 7 once after install, but I don't think I believe him - every evidence points to linux using the whole disc, w/ no magic resizing later.
00:46  nemo: Knirch: unfortunately, no wifi on that machine yet, and trying to keep overwrites to a minimum, so I guess that means copying the .deb to his USB drive
00:47  nemo: Knirch: I might still try whipping up some commands, 'cause there are only a couple of files he actually cares about.
00:47  geirha: ttwj: You can, but it'll be very messy. Choose a different language.
00:48  Knirch: sorry for feeding the offtopicness: http://www.cgsecurity.org/wiki/TestDisk_Livecd
00:49  geirha: ttwj: You'll want some language that has curses bindings.
00:53  nemo: geirha: expect or somesuch?
00:55  geirha: No, I'm thinking perl, python, ruby, C, C++, whichever rocks your boat.
00:55  nemo: just there *are* some apps for doing the user interaction bit
00:55 * nemo shrugs
00:57  ttwj: geirha: yea thanks
00:57  ttwj: I'll try java
00:57  nemo: oh well. off to try and save that dude's data
00:57  nemo: thanks guys
01:44  VirginiaSteaks: hi folks, i don't understand this bash 'code': http://pastie.org/1276225
02:00 --- samura1 is now known as h4x0r`
02:29  Weedy: BROS, i come in search of guidance
02:29  Weedy: lines 155 to 165 http://pastebin.com/SCAXi7Lb
02:30  Weedy: it craps itself with ESSIDS containing ', and i can't think of how to get it escaped properly
03:04  wald0: is there any command similar to grep but for aproximation ?
03:04  wald0: my problem is that i have a lot of music to classify and its hard to found duplicated (by filename) songs, sometimes there's a upper char in one or numbers in other
03:04  Colloguy: define 'approximation' ?
03:05  wald0: so i want to found "similar word matches" or "a minimum number of words matched"
03:06  geirha: Weedy: Because you embed the variables into the script. ' is far from your only consern. Pass the variables as arguments to the script.
03:06  beav_35: How could I just kill vuze not all java applications like "killall java"?
03:09  Colloguy: I'd be just happy with converting to lower case and removing all non-letters :P
03:13  geirha: # file="/path/to/01 - Some artist - Some Song.ogg" file=${file,,} file=${file##*/}; read -r -d '' -a words <<< "${file//[![:alnum:]]}"; printf '[%s] ' "${words[@]}"
03:13  evalbot: geirha: bash: ${file,,}: bad substitution
03:13  geirha: err, right, bash4
03:13  geirha: 4# file="/path/to/01 - Some artist - Some Song.ogg" file=${file,,} file=${file##*/}; read -r -d '' -a words <<< "${file//[![:alnum:]]}"; printf '[%s] ' "${words[@]}"
03:13  shbot: geirha: [01someartistsomesongogg]
03:13  geirha: d'oh
03:13  geirha: 4# file="/path/to/01 - Some artist - Some Song.ogg" file=${file,,} file=${file##*/}; read -r -d '' -a words <<< "${file//[![:alnum:]]/ }"; printf '[%s] ' "${words[@]}"
03:13  shbot: geirha: [01] [some] [artist] [some] [song] [ogg]
03:14  wald0: Colloguy: sometimes the files are something like "author - songname" or "album songname" or "album_songname", there's a good bunch of possibilities, not very easy imho
03:15  wald0: or most of times just "songname", but also "song_name" or "song name"
03:16  Colloguy: is this like a one-time thing that you're doing?
03:16  geirha: The metainfo might be better for comparing.
03:17  wald0: Colloguy: not really, i have thousands of songs to classify in my disk, i never finish with this task lol
03:18  wald0: geirha: your example looks good, maybe i can simply grep every word of one song in the filename of the other song, and if it has more than 2-3 matches, consider it
03:19  Colloguy: can you like just sort your files by their md5, or do they have different metadata?
03:20  wald0: Colloguy: most of times are from different origins so a different md5... btw a good tool for that is fdupes
03:21  Colloguy: man I just use itunes and click the sort headers
--- Log closed Sat Nov 06 03:27:14 2010
--- Log opened Sat Nov 06 03:27:37 2010
03:27 --- Users 490 nicks [0 ops, 0 halfops, 0 voices, 490 normal]
03:28  VirginiaSteaks: dear bash ners, please explain this to me: http://pastie.org/1276225
03:28  VirginiaSteaks: s/ners/nerds
03:29 --- Channel #bash was synced in 101 seconds
03:30  Colloguy: echo 'hello123' | tr -d -C '[:alpha:]'
03:30  Colloguy: # echo 'hello123' | tr -d -C '[:alpha:]'
03:30  evalbot: Colloguy: hello
03:32  VirginiaSteaks: it seems to me it just doesn't make any sense
03:34  k[t: will bash ever support classes in parm-sub.. eg. ${var//[:class:]/string}
03:35  k[t: th world will never know...
03:35  falconindy: k[t: already does
03:35  k[t: DO`h
03:35  falconindy: # foo=abc123def456; echo ${foo//[[:digit:]]/}
03:35  evalbot: falconindy: abcdef
03:35  k[t: d`OH
03:37  VirginiaSteaks: good fight, good n8
03:37  k[t: # foo=abc123def456 ; echo ${foo//[:digit:]/}
03:37  evalbot: k[t: abc123ef456
03:38  geirha: It removed the d, as expected.
03:38 * k[t did not even notice that...
03:39  k[t: nvm... i get it... [set]
03:39  geirha: [:digit:] is the same as [:dgit]
03:40  k[t: good catch geirha...
03:43  k[t: hmm
03:43  k[t: #foo=abc123def456 ; echo ${foo//[0-9]/}
03:43  k[t: # foo=abc123def456 ; echo ${foo//[0-9]/}
03:43  evalbot: k[t: abcdef
03:46  jengle: hi all.
03:47  jengle: this is sort of unrelated to bash, but, does anyone think that perl is ugly and bloated?
03:48  jengle: i feel like i should learn perl because a lot of software has been written in that language, but it's just so ugly to me.
03:49  Tramp: jengle: ask #perl ...
03:50  jengle: Tramp: I would but I'm afraid to offend the perl cats who really love it.
03:50  jengle: I figured #bash would have an even mix of people who use perl and people who don't.
03:51  Tramp: so you thought "that'd be the right place to ask a completely off-topic question and hopefully raise a flamewar"
03:51  Tramp: just kidding - but, as you noted, it's off-topic
03:52  jengle: Tramp: i'm not looking to argue over something like a programming language, but i thought somebody might have some insight into why it might be useful (or not) to learn perl.
03:53  jengle: not to mention there's hardly any discussion going on here at the moment ;)
03:53  Tramp: well, your Q was "anyone thinks perl is ugly and bloated" not what you just stated.
03:54  jengle: you neglected the second part of my statement, but that's okay. i'm over it.
03:54  Tramp: however. You can write nice, structured code in Perl and you can write ugly code in almost any other language I know
03:55  jengle: good point.
03:57  geirha: except for maybe lolcode
03:57  k[t: lolcode??
03:57  geirha: HAI
03:57  geirha: CAN HAS STDIO?
03:57  geirha: lolcode.com
03:58  jengle: hehe.
03:59  k[t: .. this is lolcode... [[ -e /etc/motd ]] && { cat < /etc/motd || printf 'welcome to: %s' "$(uname -a)" ;}
04:02  k[t: invisible='cat' hahaha
04:02 * k[t now writes lolcodes...
04:32  wald0: mmmh, when i grep "party" inside "this is a stringsparty in my house" i have a match, but i want to match only if "party" is a unique word
04:32  wald0: stringsparty should be not considered
04:33  wald0: the thing is that i have lines that for example can be only "stringsparty" (so i can't possible to use: grep " party " )
04:36  wald0: apart of that, my "find of duplicated songs by similar filenames" ugly script looks ready and functional :)   http://debian.pastebin.com/8YxmenBj
04:38  geirha: [[ " $string " = *" party "* ]]
04:40  Tramp: fails for beginning/end of line
04:40  Tramp: sorry
04:40  Tramp: grep -E '(^|[[:space:]])foo([[:space:]]|$)'
04:42  Tramp: wald0: or GNU grep has a "-w", which works slightly different however
04:45  wald0: aah nice
04:45  wald0: btw how i can do foo="${foo/$arg}" but without being case sensitive ?
04:45  wald0: so, remove a piece of string in a sentence
04:49  geirha: lowercase both
04:49 * wald0 confused
04:50  wald0: arg=bar ; foo="Hello Bar" <- can't work here
05:39  Aaaarg: is there a good simple timer utility that tells you how long a command takes to run?
05:43  Aaaarg: answer: 'time'
05:43  Aaaarg: that was simple
05:45  test1234: hello
05:47  test1234: can anyone tell me what else bash can do besides call system commands if anything? I know its very usefull for writing custom scripts but I just didn't know if it was used or could be used for anything else
05:48  test1234: is anyone there?
05:59  dman777: is there supposed to be a BASH_COMPLETION variable? I did not see one listed in the man page for version 4.1.7(2)-release
06:00  twkm: then no.
06:00  dman777: i heard others talking about it...does this variable exist on a more recent version of Bash?
06:01  twkm: in patch 8 or 9?  no.
06:02  dman777: /usr/share/bash-completion/base. it's not on my system but other have that on thiers.
06:03  twkm: that's nice.
06:04  prince_jammys: test1234: uncustom scripts.
06:05  dman777: twkm: just curious about it and i figure i go to the source here
06:07  twkm: never heard of either.  i have heard of the fucktards at debian.org(feh, should be .su) deciding to use the bash-completion package name for their fork of the caliban work of the same name.  perhaps they create such a thing.
06:08  twkm: hell, i couldn't stand the caliban thing, so for all i know he is the origin of it.
--- Log closed Sat Nov 06 06:28:22 2010
--- Log opened Sat Nov 06 06:28:43 2010
06:28 --- Users 486 nicks [0 ops, 0 halfops, 0 voices, 486 normal]
06:30 --- Channel #bash was synced in 100 seconds
--- Log closed Sun Nov 07 20:54:15 2010
