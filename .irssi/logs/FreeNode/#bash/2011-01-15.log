--- Log opened Sat Jan 15 00:00:40 2011
00:06  TheBonsai: y0
00:10  anddam: I have this script http://pastesite.com/21170 taken from http://mywiki.wooledge.org/BashFAQ/044
00:11  anddam: I'd like to read $files from stdin rather than using wildcards
00:12  vkues: anddam: how are the filenames separated?
00:12  anddam: in stdin?
00:12  vkues: anddam: yes
00:12 --- jason is now known as Guest29327
00:12  erUSUL: !faq 1 > anddam
00:12  greybot: anddam: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
00:12  anddam: newline
00:12  vkues: anddam: okay, note, though, that you couldn't work with filenames containing newlines then.
00:12  anddam: not a problem
00:13  anddam: erUSUL:  the point is "assembling" lines to have the same result as files=(*)
00:13  vkues: anddam: so, it'd be easy, you just have to change the for-loop to a while-read loop, like: while IFS= read -r f; do <body of your original for loop>; done
00:13  erUSUL: anddam: ^
00:14  vkues: anddam: ah, well, you could then use a while read loop to fill the array
00:14  erUSUL: anddam: we assume you have the filenames in a text file one per line or that you get them from a find command ...
00:15  anddam: my bad, I was assuming I had to count the number of item of array because FAQ 44 wanted a progress bar while copying
00:15  anddam: I don't I'm just splitting N file per folder
00:16  erUSUL: anddam: n=${#files[*]}
00:16  erUSUL: anddam: that is the number of items in the array
00:16  erUSUL: line 5
00:16  anddam: erUSUL: but that won't apply in a "while read foo; do " case
00:16  erUSUL: !arrays
00:16  greybot: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
00:16  anddam: erUSUL: why are you pointing out that?
00:17  erUSUL: anddam: quote ... I was assuming I had to count the number of item of array ...
00:17  anddam: yes, because I used FAQ 44 that is for different need than mine
00:17  erUSUL: anddam: ok,
00:18  anddam: that's why I asked how to assemble $files when reading from stdin
00:18  anddam: I hadn't realized I didn't need it
00:18  erUSUL: ok; i see
00:20  woozly: how to pick random file from directory?
00:20  woozly: filename
00:20  ferret: !faq random
00:20  greybot: http://mywiki.wooledge.org/BashFAQ/026 -- How can I randomize (shuffle) the order of lines in a file?  (Or select a random line from a file, or select a random file from a directory.)
00:20  erUSUL: !faq random
00:20  greybot: http://mywiki.wooledge.org/BashFAQ/026 -- How can I randomize (shuffle) the order of lines in a file?  (Or select a random line from a file, or select a random file from a directory.)
00:20  erUSUL: ouch
00:21  woozly: thanks
00:22  anddam: thanks, byq
00:22  anddam: bye
00:22  pragma_: anddam: BYE!
00:24  woozly: how to run sh script (2-3 strings) buy one string?
00:47  eightyeight: echo $(echo '\\\\')
00:47  eightyeight: \\\\
00:48  eightyeight: echo `echo '\\\\'`
00:48  eightyeight: \\
00:48  eightyeight: why?
00:50  mmjj_: i think `  is depreciated
00:50  eightyeight: `` still creates a subshell as much as $() does. so, what is the difference?
00:50  eightyeight: (other than $() is easy to nest, and `` is portable with older shells)
00:50  nDuff: eightyeight, nestability
00:51  nDuff: ...and $() is POSIX, so any shell it isn't portable to is out of compliance
00:51  eightyeight: nesting doesn't have anything to do with the fact that $() will return '\\\\' and `` returns '\\'
00:51  eightyeight: what's with my example though?
00:51  nDuff: think about how `` achieves nestability
00:51  nDuff: and that'll tell you.
00:52  eightyeight: ...
00:52  eightyeight: i don't understand the difference, that's why i'm asking
00:53  ferret: one ` two three ` four ` five ` six seven
00:53  ferret: Is that quotes nested in quotes or two separate sets?
00:53  eightyeight: "echo `echo '\\\\'`" versus "echo $(echo '\\\\')"
00:53  nDuff: eightyeight, if you want to do meh=$(foo $(bar $(baz))), that's written with backticks as meh=`foo \`bar \\\`baz\\\`\``
00:54  nDuff: eightyeight, so, if `` didn't dereference backticks, you couldn't nest it.
00:54  eightyeight: but i'm not escaping the backticks. i'm escaping the backslash
00:54  eightyeight: all the backslashes are single-quoted, so they shouldn't be interpreted
00:54  nDuff: eightyeight, you think it'd be EASIER if the escaping rules were different for different characters?!
00:54  Tramp: #  foo=bar; echo $(echo \$foo); echo `echo \$foo`
00:54  evalbot: Tramp: $foo
00:54  evalbot: Tramp: bar
00:55  Tramp: eightyeight: within backquotes, the backslash escapes some stuff
00:55  Tramp: eightyeight: within $(), all characters are part of the command
00:55  nDuff: ...with backticks, it's gawdawful, but it's consistent.
00:55  nDuff: ...with $(), it's _good_ and it's consistent. :)
00:56  eightyeight: so, you're saying '' behaves differently in $() versus ``?
00:56  Tramp: eightyeight: more precisely, the backslash escapes backslash, $ (as in my example) and backquote
00:57  Tramp: eightyeight: no. I say \ behaves differently. The backslash is parsed and interpreted as part of the command-substitution before the single quotes are
00:57  eightyeight: ah, yes. right
00:57  eightyeight: ok
00:57  eightyeight: i understand
00:57  Tramp: and within backquotes, the backslash is treated special (since it /has/ to be treated special, otherwise you could not nest)
00:58  eightyeight: yes. i understand now
00:58  Tramp: but you don't want to nest anyways, because you want to use $() in any case
00:58  Tramp: yw
00:58  eightyeight: cool
00:59  eightyeight: i had cases where $() isn't supported, so `` was needed
00:59  eightyeight: at any event, thx for clearing it up
00:59  Tramp: well. not in #bash and not for any POSIX compliant shell. If it's a broken environment, all bets are off anyways.
01:00  eightyeight: it was sh, and i don't know if it was posix or not
01:01  Tramp: all I want to say is, that the explanantion I gave holds for POSIX and bash. For the environment you encountered, something completely different may have happened :)
01:02  geirha: eightyeight: Do you remember what OS?
01:02  eightyeight: hpux
01:04  geirha: Pretty sure /bin/sh on hpux is bourne
01:05  eightyeight: it is
01:05  eightyeight: i don't recall the hpux version, but all of the hpux 11 systems i have, $() works
01:05  eightyeight: it was some time ago. i don't fuss
01:05  geirha: bourne does not support $(), only ``
01:06  eightyeight: hpux B.11.11 has $() in /bin/sh
01:07  eightyeight: er, /usr/bin/sh that is.
01:07  eightyeight: "echo $(date)" works as expected
01:09  \malex\: geirha: /bin/sh is posix. on 11.11, /usr/old/bin/sh is bourne
01:13  eightyeight: it should be noted that zsh and borne both return '\' in both cases
01:14  eightyeight: anyway
01:14  eightyeight: as does ksh
01:14  eightyeight: so, bash is the black sheep. ãƒ„
01:59  Buglouse: Is there proper syntax for a function defined within a function, maybe I should just set a var? this is for usage output in a particular way.
01:59  e36freak: you can put functions in functions
02:00  e36freak: # foo() { bar() { echo "$1"; }; bar "$1"; }; foo arg
02:00  evalbot: e36freak: arg
02:00  Buglouse: yeah, i know i can what is the scope then?
02:01  e36freak: good question
02:01  Buglouse: # foo() { echo "$1"; foo2() { echo "$1"; }; }; foo 2
02:01  evalbot: Buglouse: 2
02:02  Buglouse: # foo() { echo "1:$1"; foo2() { echo "2:$1"; }; foo2 3 }; foo 2
02:02  evalbot: Buglouse: Missing terminating quote, bracket or keyword
02:02  Buglouse: # foo() { echo "1:$1"; foo2() { echo "2:$1"; }; foo2 3; }; foo 2
02:02  evalbot: Buglouse: 1:2
02:02  evalbot: Buglouse: 2:3
02:02  Buglouse: # foo() { echo "1:$1"; foo2() { echo "2:$1"; }; foo2 3; }; foo 2; foo2 4
02:02  evalbot: Buglouse: 1:2
02:02  evalbot: Buglouse: 2:3
02:02  evalbot: Buglouse: 2:4
02:02  e36freak: looks like global
02:02  Buglouse: just what i thought. yep
02:02  e36freak: and i just tried "local foo()" with no luck
02:03  Buglouse: yeah, did that b4
02:04  Buglouse: # foo() { var='no'; echo "1:$1"; foo2() { var2='y'; local var3='n'; echo "2:$1"; }; foo2 3; }; foo 2; foo2 4; echo "$var2:$var3"
02:04  evalbot: Buglouse: 1:2
02:04  evalbot: Buglouse: 2:3
02:04  evalbot: Buglouse: etc... ( http://pastebin.com/6VzjBnzU )
02:04  Buglouse: aww, was having fun
02:05  Buglouse: i used an unset foo2() b4 so that i was no longer global.
02:05  Buglouse: but I replaced that confusion with a simple echo var, better ;)
02:06  polyphanes: Ahoy.
02:07  polyphanes: I'm writing a bash script to which I want to pass in an unquoted string that contains escape characters.  How can I preserve the escape characters in the string without the shell interpreting them?
02:08  vkues: by quoting it
02:08  e36freak: polyphanes: why would you deliberately not want to quote something?
02:08  polyphanes: Is there a way I can get by without quoting the string?
02:08  e36freak: polyphanes: quotes are essential
02:09  polyphanes: e36freak: it's messing up another part of the script to throw the whole string in quoted.
02:09  e36freak: huge part of the bash syntax
02:09  e36freak: then you're doing something wrong
02:09  polyphanes: e36freak: I'll try something else then.
02:09  vkues: good luck, you'll most likely need it.
02:11 --- jason is now known as Guest12205
02:21  Buglouse: http://dpaste.com/318053/
02:21  Buglouse: ^^^ Related to getopts
02:22  Buglouse: Help with debugging, the function runs fine only once, then produces no output on future runs
02:23  Buglouse: here is again with spelling fixed: http://dpaste.com/318058/
--- Log closed Sat Jan 15 02:28:17 2011
--- Log opened Sat Jan 15 02:28:42 2011
02:28 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
02:30  vkues: Buglouse: i don't know, maybe reset optind / optarg / opterr
02:30 --- Channel #bash was synced in 86 seconds
02:30  vkues: Buglouse: also your array handling (or the lack of it) should be improved (shouldn't be related to your current problem, though)
02:31  vkues: but i'd first check about OPTIND
02:31  Buglouse: yay, unset OPTIND worked.
02:31  vkues: great
02:31  e36freak: \o/
02:32  Buglouse: u talking about the quotes for $services ?
02:33  vkues: Buglouse: about this and about "options"
02:33 --- mmjj_ is now known as mmjj
02:33  Buglouse: services was from b4, mistake for not removing. I was wondering the proper syntax for $options.
02:33  vkues: it only works like that because you don't proper quote your parameter expansions
02:34  vkues: options=("${@:3}")
02:34  vkues: expanding with "${options[@]}"
02:34  vkues: (the quotes are necessary)
02:35  vkues: by default, put "" around everything containing dollar symbols
02:38  Buglouse: I c. thnx.
02:40  Buglouse: set OPTIND as local is a better fix?
02:43  vkues: does that even work?
02:46  Buglouse: does for me
02:48  vkues: apparently i'm not the one who should give any advice about that :)
02:49  Buglouse: oh
02:50  Buglouse: oh, hmm..*
02:55  Buglouse: looking for character control on select (without case). like: [ "$REPLY" != "[0-9]*" ]
03:22  terrorpup: Does anyone have a good link on how to do avgeages?
03:26 --- [1]The-Bat is now known as The-Bat
03:27  dualbus: terrorpup, integer or float?
03:31  dualbus: terrorpup, if you have a list of numbers, each in a line you can calculate the mean in floating point with this
03:31  dualbus: (sum=0; n=0; while read -r num; do ((sum+=num)) && ((n++)); done; echo "scale=3;$sum/$n" | bc) <numbers.txt
03:31  dualbus: assuming you have the list in `numbers.txt'
03:31  terrorpup: well I am run a script that getting number from boxes then adding up. I want to get an avg from that.
03:32  terrorpup: there no number.txt
03:32  dualbus: terrorpup, then
03:32  dualbus: program | (sum=0; n=0; while read -r num; do ((sum+=num)) && ((n++)); done; echo "scale=3;$sum/$n" | bc)
03:32  dualbus: what's the output of your program
03:32  dualbus: ?
03:33  terrorpup: sec
03:35  terrorpup: total numcalls: 179 NORMAL | numcallstotal=179;3500;3800;0;4000
03:35  terrorpup: that 179 comes from 81 servers
03:37  dualbus: so you want the average of what exactly? the "179;3500;3800;0;4000"
03:37  dualbus: ?
03:39  terrorpup: total numcalls: 179 NORMAL
03:39  terrorpup: the other part is just perf data for nagios
03:40  dualbus: uhm, isn't the average of a single number... that same number? I mean, average of 5 is 5.
03:40  terrorpup: sec
03:40  terrorpup: let me show you the script
03:40  dualbus: ok
03:42  terrorpup: ok this how I get that 179 number
03:42  terrorpup: http://pastebin.com/te9fKgUV
03:45 --- [1]The-Bat is now known as The-Bat
03:45  terrorpup: so I get I need to take my output divide by the number of servers
03:48  dualbus: terrorpup, what is `shos'?
03:49  terrorpup: shos is another program that goes and gets the number of call from the server
03:58  terrorpup: I think I know a way to do it with that first line you gave me.
04:02  dualbus: http://pastebin.com/6YVZ8Mcz
04:04  dualbus: terrorpup, that should work, also you save two grep processes
04:05  CodySmith85: hello all, quick question, already tried ye ol' google and came up empty
04:05  CodySmith85: i'm reading a book on bash scripting and exit status 192 is always used, what is this?
04:05  e36freak: !books
04:05  greybot: Most of the published shell/bash books are relatively poor. They may have a few gems here and there, but they're few and far between. Try the BashGuide instead.
04:06  terrorpup: cool I am looking at it.
04:06  dualbus: CodySmith85, that's related to your OS
04:06  e36freak: CodySmith85: more than 0
04:06  e36freak: which is what's really important
04:06  CodySmith85: can u give me an example? or make it slightly more clear?
04:07  e36freak: !return
04:07  greybot: Every Unix process returns an exit status code to its parent. This is an unsigned 8-bit value, a number from 0 to 255 inclusive. Your script returns the exit status from the last command it executed, unless you specifically call "exit" with a value. Functions also return values, using "return".
04:07  CodySmith85: for example, my os defines what status 192 is?
04:07  e36freak: the important thing is if the exit status is 0 or more than 0
04:08  gh: and the first response to google 'bash exit 192' provides an answer the almost exact same question you just asked
04:08  vkues: gh 8)
04:08  CodySmith85: if ur looking at the fedoraforum one, that didn't help much, buy i am on fedora
04:09  CodySmith85: thank u tho
04:09  vkues: CodySmith85: to make it clear: exit codes depend on the things that exit
04:09  vkues: CodySmith85: and can mean anything.
04:09  peth: is there a way to check if a pipe is waiting for the output of a shell script?
04:09  CodySmith85: thank you thank you :)
04:10  vkues: CodySmith85: if you write a program that exits with code 192 when you ran out of milk, it would mean that, and only that
04:10  CodySmith85: would that mean that most of the numbers are undefined until you do it yourself?
04:10  vkues: CodySmith85: do, for example "man find" and look for "EXIT CODE"
04:11  vkues: err
04:11  dualbus: peth, if you have the PID of the shell script, you can use lsof -p <pid>
04:11  vkues: CodySmith85: sorry, "EXIT STATUS"
04:11  CodySmith85: man find?
04:11  gh: http://tldp.org/LDP/abs/html/exitcodes.html
04:11  e36freak: type "man find"
04:11  e36freak: hit "enter"
04:11  e36freak: ugh, the abs
04:11  vkues: CodySmith85: yes, GNU find's manpage, I guess yours will have that section "EXIT STATUS"
04:11  CodySmith85: hehe ok, i have tried that and it just talks about exit N
04:11  gh: that was the second google
04:11  e36freak: abs is crap
04:11  gh: google 'bash exit codes'
04:11  vkues: CodySmith85: because you use fedora, but maybe it's different, I am too lazy to check, not running fedora
04:12  CodySmith85: gh, i found nothing on google, thanks again tho
04:12  vkues: CodySmith85: my point was .. that it's described in a manpage shows that the code is particular to a tool, manpage of find merely to illustrate that as an example :)
04:12  gh: i am not saying abs is good, just simply giving reasons to see everyone says basically the same thing, it depends on the programmer outside of specific definitions
04:13  gh: CodySmith85, we must be using a different version of google
04:13  CodySmith85: thanks vkues , youve been a bit help
04:13  e36freak: gh: he's on the wrong internet
04:13  CodySmith85: i found many questions the same as mine and many people using exit status 192, but no specific definition, and if vkues is correct, there won't be one
04:14  gh: e36freak, =X
04:14  e36freak: not really, no
04:14  Tramp: POSIX says that exit status >=126 is reserved. Check http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_21
04:14  CodySmith85: anyway, thx again for the help vkues
04:14  CodySmith85: back to work :)
04:15 * CodySmith85 is away: I'm busy
04:15  gh: "it depends on the programmer outside of specific definitions" such as POSIX
04:15  Tramp: it's an informative section however
04:15  gh: thank you for the link Tramp
04:15  Tramp: CodySmith85: and please turn off the public away
04:15  Tramp: yw
04:20  peth: dualbus: is there maybe a simpler way from *within* the script like checking to what my fd are connected? i have a script that i want to call interactively from a shell (and i want it to just write to stdout then) and by a keyboard shortcut from the wm (in which case i want to write to a notification program).
04:24  peth: rethinking that, this is probably the wrong approach.
04:25  Tramp: peth: not sure, but check "help test", -t
04:28  peth: ooh that looks promising
04:28  peth: i'll try
04:30  peth: note to self, when writing a test script to test test, don't call it test and put it in the path
04:30  e36freak: peth: NICE
04:35  Tramp: yw
04:39  peth: Tramp: it works beautifully. thanks a lot!
05:09 --- [1]The-Bat is now known as The-Bat
--- Log closed Sat Jan 15 08:09:34 2011
--- Log opened Sat Jan 15 08:14:43 2011
08:14 --- Users 538 nicks [0 ops, 0 halfops, 0 voices, 538 normal]
08:16 --- Channel #bash was synced in 90 seconds
09:00  Tatsh: is it possible to do multiple things at once with expansions?
09:01  Tatsh: for i in *.avi; do echo "${i#*-s%.*}"; done <-- intended to get a 1 out of a file named "video -s1- name.avi" for example
09:01  e36freak: no
09:01  tmr: Use tmp variable and two expansions.
09:01  twkm: you typed it here, but not into your shell?  funny.
09:03  Tatsh: i pasted it
09:03  Tatsh: for i in *.avi; do NAME="${i#*-s}" && NAME="${NAME%-*}" && echo "$NAME"; done <-- correct
09:04  e36freak: !varcap
09:04  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
09:04  e36freak: also, "i" is usually used for numbers
09:04  Tatsh: but since i've been using expansions more than sed and awk recently i've wondered why multiple operations failed
09:04  e36freak: use "f" or "file", which make sense
09:04  e36freak: !pe
09:04  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
09:05  twkm: Tatsh: probably from a failure to read.
09:07  twkm: as an aside, don't use all upper-case variables for purely internal purposes.
09:07  Tatsh: how about
09:07  Tatsh: for i in CD*; do cd "$i" && if [ -e *.part01.rar ]; then unrar x *.part01.rar; else unrar x *.rar; fi && rm -v *.r* *.sfv; cd ..; done
09:07  Tatsh: does the if check fail?
09:07  Tatsh: i have not run into the case yet ;)
09:08  twkm: test will be pissed.
09:08  e36freak: glob shouldn't work inside [
09:09  Tatsh: not even with `shopt -s extglob` ?
09:09  e36freak: ![[
09:09  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
09:10  e36freak: extglob has nothing to do with it, it doesn't like glob in general
09:10  twkm: sigh.
09:10  twkm: IT IS A COMMAND.
09:11  e36freak: right
09:11  twkm: just like ls.  ls *part01.rar, does ls see the *?  fuck no.
09:11  e36freak: it just sees a list of files
09:11  e36freak: and then should give you crap about "unary operator expected" or something
09:14  k[t: !*? > k[t
09:14  pgas: IIRC unrar doesn't take more than one argument, but is able to expand the globs itself
09:14  tmr: k[t, you can query greybot.
09:15  pgas: or maybe it was unzip
09:15  tmr: I think you could even feed directory to unrar, it will find the first part itself.
09:16  Tatsh: tmr, that is true
09:17  Tatsh: if you did file.part099.rar as argument to unrar it would go back to file.part001.rar
09:18  e36freak: personally, i would probably just do the whole thing with find
09:19  Tatsh: anyone know if php can take an expression like perl -ne
09:19  e36freak: !nabq
09:19  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
09:19  e36freak: not even close
09:19  Tatsh: well, e36freak i'm thinking how to use php's ucwords() within bash
09:19  Tatsh: without writing a script to pass to
09:20  pragma_: Also, be sure to use more quotes.
09:29  Tatsh: i made a php script; but is there a way to do the uppercasing of all first letters of words without sed or awk?
09:30  pgas: with bash4 or tr or perl
09:30  e36freak: pgas: care to elaborate on that one?
09:31  pgas: 4# var="foo bar baz";echo ${var^}
09:31  shbot: pgas: Foo bar baz
09:31  Tatsh: how can tr do it?
09:31  twkm: in php?  well, i'd ask #php.
09:31  Tatsh: in php it's quite simple but i can't seem to find a -ne option similar to perl with `php`
09:31  e36freak: that's just one word, but i guess you'd loop?
09:31  pgas: Tatsh: well you have to parse the string first
09:32  pgas: e36freak: yeah, though I think there's something more with bash4
09:32  Tatsh: <?php $handle = fopen('php://stdin'); $words = fgets($handle); print ucwords($words); fclose($handle); ?>
09:32  e36freak: that's what i was wondering. how can tr handle that?
09:32  twkm: as usual php script shittiness.
09:33  Tatsh: hehe :P
09:33  Tatsh: i don't see the issue but php takes much longer to invoke than other utilities which is i don't usually use it but i know it better than perl or bash anyway
09:33  e36freak: php should be used for web scripting. and that's it
09:34  pgas: e36freak: ehe, well you can do it, I didn't say it would very simple
09:34  pgas: you need a loop with awk too
09:34  e36freak: pgas: i'd like to know how it would be done with tr
09:34  e36freak: i would use sed
09:34  pgas: e36freak: gnu sed
09:35  e36freak: yes
09:35  pgas: e36freak: well you need to loop on words and uppercase only the first letter
09:35  Tatsh: how about a way about to get the first letter of each word?
09:35  Tatsh: 'foo bar baz' => 'fbb'
09:35  pgas: set -f;for w in $word;do printf "%s%s "$(tr [:upper:]
09:35  e36freak: ok, how would you uppercase only the first letter? tr "[:lower:]" "[:upper:]" <<<"${var:0:1}" ?
09:36  pgas: yeag
09:36  e36freak: ahh
09:36  pgas: tr is just a way to uppercase (only ascii chars) then you need the rest
09:37  e36freak: printf "%s%s" "$(tr "[:lower:]" "[:upper:]" <<<"${var:0:1}")" "${var:2}"
09:37  Tatsh: any ideas?
09:37  Tatsh: somehow i did this before and i know it wasn't with php
09:38  e36freak: string="foo bar baz"; for word in $string; do printf "%s%s" "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:2}"; done
09:38  pgas: # var="foo bar baz"; set-f ;printf "%.1s" $var
09:38  evalbot: pgas: bash: set-f: command not found
09:38  evalbot: pgas: fbb
09:38  e36freak: # string="foo bar baz"; for word in $string; do printf "%s%s" "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:2}"; done
09:38  evalbot: e36freak: FoBrBz
09:38  twkm: /me shudders
09:38  e36freak: bah
09:38  e36freak: # string="foo bar baz"; for word in $string; do printf "%s%s" "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:1}"; done
09:38  evalbot: e36freak: FooBarBaz
09:38  e36freak: # string="foo bar baz"; for word in $string; do printf "%s%s " "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:1}"; done
09:38  evalbot: e36freak: Foo Bar Baz
09:39  e36freak: this fails easily though, it's intentional wordsplitting
09:39  e36freak: # string="foo bar baz"; while read -rd ' ' word; do printf "%s%s " "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:1}"; done <<<"$string"
09:39  evalbot: e36freak: Foo Bar
09:40  e36freak: meh
09:40  e36freak: # string="foo bar baz"; while read -rd ' ' word; do printf "%s%s " "$(tr "[:lower:]" "[:upper:]" <<<"${word:0:1}")" "${word:1}"; done <<<"$string "
09:40  evalbot: e36freak: Foo Bar Baz
09:40  pgas: how does it fail? you can disable globs with set -f, of course the definition of word might be more complex
09:40  e36freak: pgas: guess not, i was thinking newlines and stuff but that shouldn't actually be an issue
09:41  e36freak: you can use any delimiter with the last example though
09:41  Tatsh: heh
09:41  Tatsh: (in php...)
09:41 * Tatsh stops
09:41  pgas: yeah that will break the spacing
09:42  pgas: http://wiki.bash-hackers.org/syntax/pe#case_modification ok, it used to uppercase words in a Release Candidate
09:42  pragma_: fopen("php:\\stdin") instead of just fopen(stdin)?
09:43 * pragma_ cringes in fear.
09:43  e36freak: heh
09:44  Tatsh: not \\, //
09:44  Tatsh: and i forgot to add the mode argument
09:46  Tatsh: $words = explode(' ', $line);foreach($words as $word) {  print $word{0};}
09:46  Tatsh: yea :P
09:46  Tatsh: i'm not sure how much perl looks like php although i know it's very similar but i know it's functions are very namespaced unlike php
09:46  pragma_: explode is such a cute name for that
09:47  e36freak: perl is better :)
09:47  e36freak: more uses
09:47  e36freak: really, you should just use sed or perl for something like this
09:50  Tatsh: e36freak, do it then; please show  me how to do achive the same thing with perl
09:50  e36freak: i just started learning it
09:52  Tatsh: me too
09:52  Tatsh: unfortunately php experience is of little help
09:57  e36freak: # sed 's!\([[:lower:]]\)\([^[:space:]]*\)\([[:space:]]*\)!\U\1\L\2\3!g' <<<"foo bar baz  blah    this works"
09:57  evalbot: e36freak: Foo Bar Baz  Blah    This Works
09:58  Tatsh: # php -v
09:58  evalbot: Tatsh: bash: php: command not found
09:58  Tatsh: lol
09:59  xenoterracide: There's a command I'm looking for, I've used it in the past, but can't remember what it is. it recursively display permissions, back to the root directory /  allowing you to see if your problem with perms is anywhere allong the way
09:59  pragma_: # echo "test lol foo" | perl -ne '$_ =~ s/\b(.)/uc $1/ge; print $_'
09:59  evalbot: pragma_: bash: perl: command not found
09:59  evalbot: pragma_: bash: echo: write error: Broken pipe
10:00  pragma_: shucks
10:00 --- Gallo is now known as Gallomimia
10:00  e36freak: you broke the pipe!
10:00  pragma_: that's okay, I have rolling papers
10:01  e36freak: heh
10:06  e36freak: # touch foo; file=$(readlink -f foo); until [[ -z "$file" ]]; do ls -ld "$file"; file="${file%/*}"; done
10:06  evalbot: e36freak: -rw-r--r-- 1 root root 0 Jan 15 09:06 /root/foo
10:06  evalbot: e36freak: drwxr-xr-x 2 1000 1000 0 Jan 15 09:06 /root
10:06  e36freak: xenoterracide: ?
10:07  e36freak: # mkdir bar; touch bar/foo; file=$(readlink -f bar/foo); until [[ -z "$file" ]]; do ls -ld "$file"; file="${file%/*}"; done
10:07  evalbot: e36freak: -rw-r--r-- 1 root root 0 Jan 15 09:07 /root/bar/foo
10:07  evalbot: e36freak: drwxr-xr-x 2 root root 0 Jan 15 09:07 /root/bar
10:07  evalbot: e36freak: drwxr-xr-x 3 1000 1000 0 Jan 15 09:07 /root
10:07  xenoterracide: evalbot:  no it's some actualy comand... like not a short script. yes I know it's easy to script
10:07  xenoterracide: it's driving me nuts because I know it exists but for the life of me I can't find it
10:08  e36freak: nothing that i know of
10:08  pragma_: I have been known to pound a nail into a wall with my shoe if I can't find a hammer.
10:08  e36freak: :)
10:08  pragma_: Still gets the job done.
10:09  e36freak: you could use stat instead of ls, or whatever you want. but that structure will recurse backwards to /
10:09  xenoterracide: right
10:10  xenoterracide: I swear the command had something to do with apache, but I'll either find it eventually or won't, it doesn't really matter, I don't need it for anything, just trying to find it
10:10  e36freak: then try #httpd, see if they know
10:10  dualbus: xenoterracide, then the question doesn't belong to #bash
10:26  Tatsh: does bash regex support back references?
10:32 --- Gallo is now known as Gallomimia
11:31 --- abstract3d is now known as tzorvas
11:45  Varazir: Hello, you guy's have any tips on using telnet in bash script ?
11:46  trash: Yes, don't.
11:47  Varazir: trash: hehe, I have no choice :(
11:47  trash: That's what you think.
11:48  Varazir: that could be true
11:48  Varazir: I have dovado router that I control stuff. it has API and you need to use telnet to access it
11:50  Varazir: I think I have to read some more, google telnet and it looks ugly to work with
11:51  Varazir: The API operates over telnet
11:54  gniourf_gniourf: Varazir, you can use socket or netcat (nc) instead of telnet
11:56  Varazir: gniourf_gniourf: okay any good page you know of or should I just google ? , trash was right then :D
11:56  trash: I'd probably use python with sockets.
11:57  Varazir: well then I have to start with learning python.
11:57  trash: In bash you could try to use /dev/tcp/ but it's a pain to handle anyway in bash.
11:57  Varazir: ok
11:59  Varazir: best way to learn something is to have a goal :)
12:02  jufer: how to detect user if he has press the ctrl+p in bash sript
12:02  jufer: how to detect user if he has pressed the ctrl+p in bash sript
12:02  trash: Why would you want that?
12:02  Varazir: so this as good time as any to start with python. :D gniourf_gniourf and trash thanks
12:02  trash: Varazir: Indeed.
12:03  jufer: how to detect user if he has pressed  ctrl+p   in bash sript
12:03  trash: jufer: Go away.
12:04  jufer: why
12:04  Varazir: jufer: trash asked you a quetsion
12:04  Varazir: I guess you missed it
12:04  jufer: i'm a newbie
12:04  trash: Which is easy when spamming the same question over and over again.
12:05  Varazir: jufer: 12:01 < trash> Why would you want that?
12:07  jufer: i want to programming if user's command in my command loop
12:07  trash: Sorry, I have no time to decipher that.
12:08  jufer: who knows that
12:09  jufer: ^p?
12:52 --- Gallo is now known as Gallomimia
12:55  TheBonsai: y0
12:59 --- Cain` is now known as Cain
13:14  mijenix: hi
13:17  mijenix: I've a comprehension question, when I use variables for data how I can pass the content from commands to command?
13:17  mijenix: and what is the best way to extract a part with regex from a string with many records?
13:24  lesley: hi i have a problem, i just activated my gfx drivers on ubuntu, when i reboot it says 'fatal server error: no screens found'
13:24  lithpr: hi! i'm trying to learn more about bash. when i do "printenv" i do not see the EDITOR variable set. However, it seems that somehow nano is my default editor. Where is that set, or, how does that work in Ubuntu?
13:25  lithpr: are there environment variables set some where that do not appear in the "printenv" output?
13:28  geirha: lithpr: update-alternatives --config editor
13:32  geirha: mijenix: You pass them on as arguments, though only one argument per var.
13:32  geirha: !faq 100 > mijenix
13:32  greybot: mijenix: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
13:34 --- Gallo is now known as Gallomimia
13:39  lithpr: geirha: so the debian alternatives system handles defaults otherwise handled by env variables.  Thank you so much, that was what i was trying to figure out! :)
13:43  geirha: lithpr: You can still set EDITOR to override it, but I believe most programs run editor by default.
13:44  geirha: lithpr: This question didn't really belong in here though, one of the #ubuntu channels would be more appropriate.
13:45  lithpr: geirha: okay, but thank you anyway
13:46  lithpr: i didn't know whether this was a bash issue or ubuntu issue, although i suspected some ubuntu specific thing was happening
13:47  lithpr: i'm on chapter 2 of "Learning the Bash Shell" and couldn't find an EDITOR env var
13:47  lithpr: but fc was taking me to nano
13:49  ShackTiDe: Hello. How can I send the ' character to a remote machine via ssh? i.e. ssh user@host echo \' > /some/file?
13:52  geirha: Ubuntu's bash is probably built to use editor instead of vi by default
13:52  geirha: !faq ssh eats > ShackTiDe
13:52  greybot: ShackTiDe: http://mywiki.wooledge.org/BashFAQ/096 -- ssh eats my word boundaries!  I can't do ssh remotehost make CFLAGS="-g -O"!
13:53  ShackTiDe: thanks geirha
14:42  Varazir: Have anyone used expect ?
14:43  vkues: Consider #tcl
14:55  Varazir: vkues: ok
14:55  rafpigna: hello, can some one help me? I'm really noob on bash... I have just a simple question.. what is the difference between if [ $bootsdcard -eq 1 ]; then  and if [ -e $bootsdcard  ]; then   ? I'm trying to change a script but I would like to understand what I'm doing :)
14:56  tmr: help test
14:57  vkues: rafpigna: the first checks whether $bootscard numerically equals 1, which should in bash better be done with ((bootsdcard = 1))
14:57  rafpigna: ok I understood.. I just want that he checks is it exists... doesnt matter about the value.. so I will use "-e" thanks a lot
14:57  vkues: rafpigna: the second checks whether the file with its name in the variable bootsdcard exists, which should better be done either with double-quotes [ -e "$bootsdcard" ] or in bash with [[ -e $bootsdcard ]]
14:58  vkues: rafpigna: use the double-quotes or [[, otherwise bad things will happen.
14:58  rafpigna: roger
14:58  rafpigna: :)
14:58  vkues: Varazir: in any case, just ask your question, never ask to ask or if anyone knows or has used, etc.
14:59  Varazir: sorry about that :) should have learned about that by now
15:02  vkues: Varazir: you need to know that once you asked if anyone used expect, you raised curiousity about your problem even in some of those you cannot help you ;)
15:02  vkues: s/those you/those who/
15:13  desaiu: Can someone point me to a source for understanding symbols and what they mean in a bash script, e.g. $, _, {}, and a more direct example ${1}
15:13  desaiu: s/direct/applied/
15:13  geirha: rafpigna: The guide (see /topic) will take you through the basics. Taking the time to read it should save you from pitfalls later.
15:14  trash: desaiu: The manual.
15:14  geirha: desaiu: Also consider the guide ^
15:25  desaiu: Thank you, the guide and reference manual are both helpful.
16:04  jk4: hi
16:04  g4bittin: hi
16:04  jk4: If I run a program with env from my script will it stop functions from my script from interfering with the program?
16:05  taylanub: why would functions from your script interfere with the program?
16:05  jk4: because my function names might have the same name as other programs on the system
16:06  taylanub: !command
16:06  taylanub: ''help command''
16:06  jk4: wow, legendary
16:06  jk4: one million thanyous
16:07  taylanub: # echo () { command echo foo; };  echo;   command echo bar
16:07  jk4: i mean thankyous
16:07  evalbot: taylanub: foo
16:07  evalbot: taylanub: bar
16:07  evalbot: taylanub: etc... ( http://pastebin.com/ZGPptZDu )
16:07  pqatsi: i need to process an uniq command output, but i simply cant handle line feed. "s/\n/\ /g" dont work to transform line break into spaces.
16:07  pqatsi: the command is: echo "mmx sse sse2 bash-completion bazaar cvs git mercurial subversion curl sqlite sqlite3 pkcs11 qt3support dbus kde extras device-mapper policykit xorg declarative sql svg webkit opengl semantic-desktop qt4 png mng phonon aqua pulseaudio aac ipv6 truetype win32codecs real x264 xvid gstreamer -dso pt_BR jpeg gpg X doc oss taglib lzma a52 ffmpeg dvd flac lame mad mpeg ogg theora vorbis v4l v4l2 xv -alsa bluetooth vim-syntax aqua imagem
16:07  pqatsi: what is wrong with last sed?
16:08  taylanub: !tr > pqatsi
16:08  erUSUL: tr '\n' ' '
16:08 * taylanub fails at bot usage today
16:08  jk4: !forkbomb
16:08  pqatsi: taylanub: but why dont work using sed?
16:08  greybot: Explanation of :(){ :|:& } - http://mywiki.wooledge.org/BashFAQ/059
16:09  jk4: # :(){:|:&};:
16:09  evalbot: jk4: bash: syntax error near unexpected token `{:'
16:09  jk4: # :(){ :|:& };:
16:09  evalbot: jk4: [1] 231
16:09  taylanub: pqatsi: sed works on lines of text, it doesn't see newlines
16:09  taylanub: pqatsi: actually, you can use the 'N' command and the newline will be there...
16:09  pqatsi: hmmm
16:10  pqatsi: eh, tr worked.
16:10  pqatsi: taylanub: do you know if awk can process it?
16:11  taylanub: # printf %s\\n foo bar baz | sed ':foo; $ ! { N; b foo; }; s/.*/qux/'
16:11  evalbot: taylanub: qux
16:11  taylanub: # printf %s\\n foo bar| sed 's/.*/qux/'
16:11  evalbot: taylanub: qux
16:11  evalbot: taylanub: qux
16:11  taylanub: pqatsi: awk is normally linewise too
16:11  taylanub: pqatsi: one can change the RS (record separator) variable though ...
16:12  pqatsi: hmmm
16:13  taylanub: i don't understand why the following breaks:
16:13  jk4: is there a way to find out the name of the current function?
16:14  taylanub: # echo(){ command echo foo; };  echo
16:14  evalbot: taylanub: foo
16:14  evalbot: taylanub: events/0 invoked oom-killer: gfp_mask=0xd0, order=0, oomkilladj=0
16:14  evalbot: taylanub: etc... ( http://pastebin.com/dt35m3XE )
16:14  taylanub: jk4: bash puts it in some env var... don't remember the name
16:14  jk4: actually I think there a better way tan this
16:14  jk4: taylanub: oh, OK
16:16  jk4: # strong() { echo ${BASH_COMMAND} ; } ; strong
16:16  evalbot: jk4: echo ${BASH_COMMAND}
16:16  jk4: wtf
16:16  taylanub: what...
16:17  taylanub: is evalbot broken? or i'm stupid today
16:17  taylanub: oh lol
16:17  jk4: I BROKE THE BOT!
16:17  erUSUL: 4# strong() { echo ${BASH_COMMAND} ; } ; strong
16:17  taylanub: that's a really tricky shell variable
16:17  shbot: erUSUL: echo ${BASH_COMMAND}
16:17  taylanub: # echo foo; echo $BASH_COMMAND
16:17  evalbot: taylanub: foo
16:17  evalbot: taylanub: echo $BASH_COMMAND
16:18  taylanub: # eval $BASH_COMMAND
16:18  evalbot: taylanub: no output within the time limit
16:18  taylanub: :D
16:21  jk4: # echo the command you just typed is $BASH_COMMAND
16:21  evalbot: jk4: the command you just typed is echo the command you just typed is $BASH_COMMAND
16:21  jk4: # $BASH_COMMAND
16:21  evalbot: jk4: bash: $BASH_COMMAND: command not found
16:22  jk4: # command $BASH_COMMAND
16:22  evalbot: jk4: bash: $BASH_COMMAND: command not found
16:22  loomsen: we've got a winner :D hope you like ponys jk4
16:22  cdavis: How can I replace every other line with in a file?
16:23  jk4: yes please, I love
16:23  taylanub: cdavis: replace every other line with what?
16:23  twkm: i suggest using an editor.
16:23  cdavis: taylanub: I don't care. tr or sed
16:23  vkues: hehe
16:23  tmr: I don't see evalbot breakage, why the pony?
16:23  cdavis: taylanub: Oh, with a comma
16:24  cdavis: heh
16:24  taylanub: cdavis: so  foo\nbar\nbaz\nbat\n   will become   foo\n,\nbaz\n,\n  ?
16:25  cdavis: foo,nbar\nnbaz,nbat\n
16:25  taylanub: minus the n after the comma maybe?
16:27  cdavis: I think, I am tryin got make a csv file from that has everything in a rows, like data1.a\ndata1.b\ndata2.a\ndata2.b and I want data1.a,data1.b\ndata2.a,data2.b
16:28  taylanub: so you want to "join every two lines, separated with a comma"
16:29  taylanub: or "replace every second *newline* with a comma"  (not every second *line*)
16:29 --- Gallo is now known as Gallomimia
--- Log closed Sat Jan 15 22:32:51 2011
--- Log opened Sat Jan 15 22:44:31 2011
22:44 --- Users 564 nicks [0 ops, 0 halfops, 0 voices, 564 normal]
22:44  geirha: snaxsy: The ~/path/to/dir would be part of the output, making all lines differ
22:45  e36freak: that was the other thing i was thinking
22:45  snaxsy: ah
22:46 --- Channel #bash was synced in 101 seconds
22:46  snaxsy: if i want to pipe it to a file, can i prepend file < before the diff?
22:46  snaxsy: why am i asking that.
22:46  e36freak: snaxsy: you would append >
22:46  e36freak: !redir > snaxsy
22:46  greybot: snaxsy: Redirections: http://wiki.bash-hackers.org/syntax/redirection http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection http://wiki.bash-hackers.org/howto/redirection_tutorial http://wiki.bash-hackers.org/scripting/copydescriptor
22:48  snaxsy: thanks.
22:48  snaxsy: did the trick
22:48  snaxsy: just have to figure out what it means now!
22:48  e36freak: !guide > snaxsy
22:48  greybot: snaxsy: http://mywiki.wooledge.org/BashGuide
22:48  e36freak: !faq
22:48  greybot: e36freak: No matches found at http://mywiki.wooledge.org/BashFAQ
22:50  snaxsy: oh i meant that i have to figure out what the output means. it's a mess. apparently, the answer is that the two directorie structures are ... nothing alike! :P yay
22:53  geirha: comm -23 <(cd /dir1 && find . -type d) <(cd /dir2 && find . -type d) > "unique_to_dir1"
22:53  geirha: comm -13 <(cd /dir1 && find . -type d) <(cd /dir2 && find . -type d) > "unique_to_dir2"
22:53  geirha: !faq intersect
22:53  greybot: http://mywiki.wooledge.org/BashFAQ/036 -- How can I get all lines that are: in both of two files (set intersection) or in only one of two files (set subtraction).
22:53  e36freak: may also want to use diff -y
22:53  geirha: Oh, and you might want to sort the find output
22:54  e36freak: yeah, i thought about that
22:54  e36freak: siff -y <(cd /dir1 && find . -type d | sort) <(cd /dir2 && find . -type d | sort) > mydiff
22:54  e36freak: diff -y**
23:00  snaxsy: woah, overload. i'll look at those. siff looks interesting
23:00  snaxsy: thnaks guys
23:00  snaxsy: thanks*
23:01  e36freak: siff was a typo, meant diff
23:01  snaxsy: just found that out.
23:01  snaxsy: :P
--- Log closed Sat Jan 15 23:10:59 2011
--- Log opened Sat Jan 15 23:11:18 2011
23:11 --- Users 562 nicks [0 ops, 0 halfops, 0 voices, 562 normal]
23:12  italic: is it possible to set a env var so that echoing it will return the output of another program?
23:12  e36freak: uh
23:12 --- Channel #bash was synced in 102 seconds
23:12  e36freak: no?
23:13  e36freak: i guess you could do
23:13  e36freak: VAR="program"; echo "$(VAR)"
23:13  e36freak: !faq complex > italic (but this is the issue with that)
23:13  greybot: italic (but this is the issue with that): http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
23:13  e36freak: VAR="program"; echo "$($VAR)" # that is
23:13  italic: it's for gnu screen, it can only seem to access vars, not $(prog)
23:14  italic: so i want $BATTERY_STATUS to return the result of acpi
23:14  vkues: italic: No, that is not possible.
23:15  e36freak: nope
23:15  vkues: italic: Maybe ask in #screen how to do what you want to do.
23:15  italic: ok, thanks. i was hoping there might me some kind of symlink i could do
23:16  e36freak: you can't use a variable for that... what do you actually want to do?
23:17  vkues: italic: Pay attention to the section "String Escapes" in the screen documentation.
23:18  vkues: Or, hm.
23:19 --- ribasushi_ is now known as ribasushi
23:20  italic: yeah thanks, i'm trying to figure out the backtick command
23:20  e36freak: !`
23:20  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
23:21  vkues: e36freak: not in bash but in screen context.
23:21  e36freak: ahh
23:21  e36freak: do not even know there is such a thing
23:30  cthuluh: e36freak: usefull when you want information printed in screen's statusbar
23:45  e36freak: cthuluh: good to know.
--- Log closed Sun Jan 16 00:00:51 2011
