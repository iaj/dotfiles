--- Log opened Tue Nov 23 00:00:02 2010
00:00  neurochrome: catsup, no
00:00  catsup: # a=$(echo '&'); echo $a
00:00  evalbot: catsup: &
00:01  neurochrome: right... this works, but shows multiple entries (multpile buffers?!) get_flash_videos '$(xclip -o)'
00:01  neurochrome: Search for '$(xclip -o)' found these results:
00:01  neurochrome: [ 1] Using XCLIP to hide some parts of your block
00:01  neurochrome: [ 2] XCLIP 8
00:01  neurochrome: [ 3] YouTube - TylaxO8's Channel
00:01  neurochrome: [ 4] AutoCAD: Modifying the XCLIP Frame
00:01  neurochrome: [ 5] XCLIP
00:01  neurochrome: [ 6] playing now: Dominante meid dwingt haar vriend om ...
00:01  neurochrome: [ 7] xClip 02-desktop.m4v
00:01  neurochrome: [ 8] xclip
00:01  neurochrome: [ 9] Crime xclip
00:01  neurochrome: [10] banda Pimentas
00:01  neurochrome: Enter the number(s) or range (e.g. 1-3) of the videos to download (separate multiple with comma or space):
00:01  steve___: ah jeez
00:01  neurochrome: sorry for flood,
00:01  neurochrome: I have no idea what some of those things in the buffer are
00:02  neurochrome: ahhh, get_flash_videos has searched youtube?! lol
00:02  geirha: neurochrome: "" quotes, NOT '' quotes
00:02  geirha: !quotes
00:02  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
00:02  neurochrome: geirha, try again
00:04  neurochrome: geirha, that works, sorry for the absolute idiocy on display from yours truly, I need to get a bash book!  I use it very rarely when I have some brightspark Idea like the one I came here for
00:04  neurochrome: happy to have this working though, very handy
00:04  neurochrome: cheers
00:04  catsup: it's not a bash issue, neurochrome ...
00:04  geirha: We recommend the guide in /topic
00:05  neurochrome: catsup, it the taking the output from one command and passing it to another I get hung-up on, and hence the  "$()" is relevant I presume
00:05  catsup: neurochrome: yeah, but, the issue was, i think, the contents of the paste buffer not being what was expected
00:06  neurochrome: fair, I'll take a look at the topic guide, cheers guys n  gals
00:06 * neurochrome appreciates your assistance
00:20  Smirnov: why isnt gzip working when i redirect a (live) script to it? just sits there creating an empty file. if i redirect a non-live script output it works fine?
00:20  lhunath: it waits for your script to end.
00:21  lhunath: (for its buffer to fill)
00:21  Smirnov: blahhh, my script never ends.
00:21  Smirnov: and i ran it for a few minutes i couldnt see its buffer to fill up
00:21  lhunath: you can see its buffer?
00:21  pc400: Is there an easy way in bash to remove all spaces and newlines out of an existing variable?  Something is present which causes something ot not match, and I can't figure out what.
00:21  neurochrome: geirha, just came back to say by adding -selection clipboard to xclip it makes sure that xclip uses the copied url and not any other selected text currently in the buffer
00:22  Smirnov: maybe theres some way to get gzip to append to an existing gz file?
00:22  neurochrome: this works perfectly -- get_flash_videos "$(xclip -o -selection clipboard)"
00:22  lhunath: pc400: echo "<$var>" to see what's really in the var.
00:22  lhunath: or | cat -v, even.
00:22  lhunath: Smirnov: you're not making much sense.
00:22  lhunath: what is it you want to do?
00:22  lhunath: and what is it not doing?
00:23  lhunath: why do you even care about gzip's buffer not being full yet?
00:23  Smirnov: lhunath: ive got a script that outputs stuff every 100ms, i just need to gzip it on the fly
00:23  Smirnov: i tried the obvious './myscript | gzip > foo.txt' it just sits there ad infinitum
00:23  lhunath: gzip doesn't know when to flush its buffer.
00:24  lhunath: maybe your script should gzip its chunk that it outputs every 100ms
00:24  lhunath: since your script does know.
00:24  pc400: lhunath - all that returns is >29
00:25  pc400: The values should be "29"
00:25  lhunath: pc400: then there is a \r at the end of your data.
00:25  pc400: echo "<$CLIENTVERSION>"
00:25  lhunath: !\r > pc400
00:25  lhunath: !cr > pc400
00:25  greybot: pc400: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
00:25  Smirnov: lhunath: err yeah im doing something like that now, using read to read from the script and then every line pipe it to a gz >> myfile
00:26  lhunath: while read line; do gzip <<< "$line"; done > file
00:26  Smirnov: that seems to work, and since >> is buffered shouldnt be so bad
00:26  lhunath: don't do that
00:26 * lhunath goes to bed.
00:26  Smirnov: lhunath: oh why is that better?
00:26  Smirnov: i was doing while read line; do echo $line | gz >> file; done
00:26  lhunath: you're breaking your line because you fail to quote.
00:26  lhunath: you have extra subshells
00:27  lhunath: and you open and close and seek your file for every line
00:27  pc400: thx fixed it
00:27  pc400: I was doing the tr -d wrong.
00:27  lhunath: !quotewhen > Smirnov
00:27  greybot: Smirnov: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
00:27  lhunath: !wordsplitting > Smirnov
00:27  greybot: Smirnov: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
00:27  lhunath: !<<< > Smirnov
00:27  greybot: Smirnov: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
00:28  lhunath: now I'm off.
00:37  kristian-aalborg: hi, I'm looking to do a very simple script
00:37  catsup: kristian-aalborg: go ahead
00:37  NTU: great
00:37  NTU: thats good to know
00:38  catsup: i mean go ahead with your question
00:38  kristian-aalborg: the script should start a file and then open a window/terminal
00:38  kristian-aalborg: when the terminal is closed, the script stops
00:38  catsup: what do you mean start a file?
00:38  kristian-aalborg: to be specific
00:38  NTU: like a script inside a script
00:38  NTU: my guess
00:39  kristian-aalborg: 1) mplayer playlist.m3u
00:39  NTU: lol which is kind of stupid unless you are chroot
00:39  catsup: kristian-aalborg: mplayer playlist.m3u </dev/null & pid=$!; xterm; kill $pid
00:39  kristian-aalborg: 2) let the user know that this is being done by opening a window/terminal window/picture
00:40  kristian-aalborg: catsup: will try that
00:40  catsup: heh
00:40  catsup: probably you just want xterm -e mplayer playlist.m3u
00:43  NTU: konsole looks prettier than xterm ;)
00:48  sPiN: yakuake!
00:51  mehwork: to check if a directory exists, do you use -e or -d?
00:52  mehwork: if [ -d somedir/ ]
00:53  mehwork: seems to work either way
00:54  kristian-aalborg: catsup: I love you
00:55  nDuff: mehwork, -d also checks whether it's a directory
00:56  nDuff: mehwork, so, the question is whether you want the test to fail if it's a file, rather than a directory, existing with the name in question.
00:57  mehwork: yeah -d is what i want then
00:58  mehwork: er -e is what i want, since if it exists in any way shape or form i want an error
01:17  mehwork: when exiting from a script upon error, is 'exit' enough or should i do 'exit 1' or something to signify an error?
01:17  NTU: i use exit 3
01:17  hal: I've written a simple script to configure permissions, but I am finding that it descends symbolic links, which seems strange because the manuals seem to contradict this.  Can anyone see what I am doing wrong please?  http://hals-paste.pastebin.com/cY3z0Eha
01:17  NTU: PERSONALLY
01:18  mehwork: what's 3
01:18  NTU: I mean I use exit 3 in a highly personal and offensive matter.... just kidding
01:18  NTU: and i have no idea, i just use it
01:19  mehwork: all i know is 0 mean success and non zero means nonsuccess
01:20  NTU: i dont think it matters, they all leave the script
01:20  NTU: and dont show any error
01:20  NTU: exit 459745374557885454785789575789787578798987345734
01:20  mehwork: doesn't matter, but if someone echo's $? to see what it was they'll know
01:22  gholm: hey peeps, wondering if there's a way to find the largest folder on a linux system, without counting any subdirectories of that folder... ie : Folder A contains no files but it does have subdirectories B and C... B has 2 gig of files, and C has 1 gig. This  means folder A is total of 3 gig.. but I only want to find the B and C in order... and not count A  since A has no files.
01:22  NTU: oh god
01:22  NTU: gholm no clue
01:22  NTU: please  hold for assistance
01:23  gholm: "you are a valued customer, please hold for an operator to take your call"
01:23  NTU: lol
01:23  dagni: "what? you still there? oh, please wait"
01:24  dagni: NTU: you never sleep? :)
01:24  NTU: its only like 7PM here
01:24  NTU: 6:30
01:24  NTU: sorry
01:25  dagni: gholm: 'du -hs *' will give you total size of each directory including sub directories (it will check recursively) if you meant that
01:25  dagni: in the current dir
01:25  dagni: ;)
01:27  gholm: dagni : yeah I got that one, and it is helpful, but if a directory contains NO files, yet has a few sizeable subdirectories, it'll list in that output. I suppose I want to consider directories with no files as zero in size.
01:28  gholm: I suppose I want to find folders with lots of files in them, and not count their subdirectories in that total.
01:29  dagni: hmm
01:30  gholm: I can use a GUI tool like jdisk reporter, but I wanna go command line.
01:31  gholm: There's one native to KDE like that too but it shows blocks instead of piechart.
01:32  dagni: i'm.. thinking ;)
01:39  Bushmills: du -S | sort -n
01:39  dagni: you can do this: assuming one empty dir is 4 bytes, find all empty dirs, the sum of total empty dir * 4bytes, and then total bytes of all files minus total bytes of empty dirs
01:40  dagni: that should give you size of all files without empty dirs
01:40  dagni: ;D
01:49  gholm: Bushmills: that's looking like it, thanks man..
01:54  hotwings: is it me or can you not grep with a \t (tab) in the search string?
01:55  prince_jammys: grep probably doesn't understand backslash-t to mean tab. Type one, or use $'\t'
01:55  prince_jammys: i.e. put a literal tab character in the regex.
01:56  hotwings: that didnt seem to work either
01:56  prince_jammys: what did you try?
01:58  knob: Good evening everyone =)
02:01  pc400: What's the best way to multi-thread a bash script that has a for i in... type loop?
02:01  pc400: It just runs some commands via SSH on hundreds of IPs (very slow)
02:01  dagni: pc400: does the loop wait until the command is executed on one IP then after its finished it execute it on next IP ?
02:01  dagni: just wondering
02:02  pc400: it does, but no need to
02:02  Bushmills: that's more like ... multi-threat :D
02:02  dagni: well, that's a waste of time..
02:02  pc400: yup
02:02  dagni: you can launch the same command on all IP in the same time
02:02  dagni: ;)
02:02  pc400: well it runs several commands...
02:02  pc400: but sitll, yes.
02:03  pc400: I could do ~50 at a time or so.
02:03  dagni: i run command and commands on 200 hosts in same time
02:03  dagni: great stuff
02:03  dagni: but.. no bash involved ;P
02:04  pc400: No praticle need for more than 50 in my case.
02:04  dagni: oh
02:04  dagni: ;)
02:05  hal: ok, getting there.... This script certainly works better, but it changes perms/ownership of the current dir, whereas I want it to change them only for files and dirs *within* the current dir
02:05  hal: http://hals-paste.pastebin.com/2Mvej3iD
02:25  dagni: hal: use -maxdepth 1
02:25  dagni: for the find
02:27  dagni: hal: http://hals-paste.pastebin.com/RN4i3agq
02:27  dagni: ;D
02:28  jordanm: maxdepth 1 still matches "."
02:29  dagni: hm, true :p
02:32  dagni: hal: add these option to find: -maxdepth 1 ! iname "."
02:32  dagni: ;D
02:32  dagni: i mean -iname :p
02:33  dagni: and finally - find --help told me that ;)
02:41  hal: I don't see the need for maxdepth - could you explain?
02:42  hal: well, surely it should be maxdepth 0
02:44  hal: still maxdepth 0 also wouldn't prevent it
02:44  dagni: but ! -iname "." will prevent it
02:45  dagni: am i right?
02:45  dagni: ;)
02:45  hal: let me see
02:45  prince_jammys: there is a mindepth
02:46  prince_jammys: there is also */ , if you only need to affect subdirs at the top level
02:47  hal: dagni, no, that doesn't work  "find: paths must precede expression: "
02:47  dagni: show me your full command ?
02:47  hal: find . -type d ! . -exec chmod 775 {} +
02:47  hal: oh sorry
02:47  dagni: bug
02:47  dagni: ;d
02:48  NTU: if you change a script while its running and the script hasnt gotten that far yet, do you need to exit out and restart script or no?
02:48  dagni: find . -type d ! -iname "." -exec chmod 775 {} +
02:48 --- fipar_ is now known as fipar
02:49  dagni: NTU: no need
02:50  dagni: NTU: tell me you code something cool ;)
02:50  hal: why are the quotes needed dagni ?
02:50  NTU: im coding a script that builds all of X and GNOME
02:51  NTU: but very fancy
02:51  NTU: and all tricky and stuff
02:52  dagni: hal: no difference in that case, use quotes or not, your call
02:52  dagni: NTU: mmh, nice.. i still have no idea what to script to write for myself, but im thinking.. ;)
02:53  proprietarysucks: I have a script for that already
02:53  proprietarysucks: 'yum'
02:53  dagni: proprietarysucks: and you wrote it ? :D
02:53  NTU: proprietarysucks, it builds from git
02:53  NTU: no packages :)
02:54  hal: that's great - it's working dagni
02:54  dagni: hal: yay ;)
02:54  hal: I am still not sure I understand the significance of maxdepth though
02:54  NTU: HAL - Hardware Abstraction Layer
02:54  hal: dagni, yeah, yay! :)
02:54  hal: NTU, yeah, that's why I don't hang around in the centos dev channel any more :)
02:54  dagni: hal: i was not sure about your original question, but if you don't need the maxdepth, remove it, probably i misunderstanded you...
02:55  hal: ok thank you dagni - you were a great help :)
02:55  dagni: ;D
02:58  proprietarysucks: hal: how far down to look
02:59  proprietarysucks: hal: something/somwhere/blah/wherever like if you only want to go so far down as blah
02:59  dagni: for blah it will be -maxdepth 3 right?
02:59  dagni: ;p
03:00  hal: I suppose i could use it as an arg to the script, yes.  thanks
03:04  Snowie: hi all. i was hoping to get some input on my first script, since ive never done one before. As well as that, ive googled for hours, given up, and finally decided to have another go at it. Is there an easy way to add the escape character for spaces in a variable
03:04  Snowie: so i could use them in a file name
03:05  Riviera: Snowie: "them"?
03:05  Riviera: Snowie: the escape characters?
03:05  go|dfish: # var='foo bar baz'; echo "${var// /\\ }"
03:05  evalbot: go|dfish: foo\ bar\ baz
03:05  Snowie: that looks like what im after
03:05  Nezmer: using pipelines (|) through $@ is not working, how can I fix it ?
03:05  Riviera: Snowie: thanks for answering my question.
03:06  Snowie: go|dfish, thanks mate. i will add that now. would you be interested in giving a noob some feedback if i send you the script. its short and well commented
03:06  go|dfish: Snowie: sure.
03:06  Snowie: ok, let me just add that code.
03:09  Snowie: go
03:09  Snowie: go|dfish,
03:09  Snowie: go|dfish, lol, whats the best way to get it to you
03:10  dagni: Snowie: pastebin.ca
03:10  dagni: paste it there and post the link here
03:12  Snowie: http://pastebin.ca/1999592
03:13  Riviera: hehe
03:14  dagni: ;))
03:14  Snowie: go|dfish, lol, sorry mate, i realise i havent got that done right. let me fix
03:16  Riviera: Snowie: you rather want double-quotes.
03:17  Snowie: Riviera, ???
03:17  Snowie: http://pastebin.ca/1999593
03:18  Snowie: Riviera, so add double quotes around the entire variable?
03:19  Riviera: Snowie: you don't want to have backslash-escaping for having space characters in filenames.
03:19  Riviera: Snowie: hence my initial question (the one you ignored)
03:20  Riviera: # var='one two'; touch "file-$var.mp3"; ls -l *.mp3
03:20  evalbot: Riviera: -rw-r--r-- 1 root root 0 Nov 23 02:20 file-one two.mp3
03:20  hal: sorry, I know this must be a simple question, but I can't find the answer. How do you echo a statement with the number of args passed to the script at the end of the line?  ie  echo "No arguments passed to the script #0"
03:20  Riviera: Snowie: Like that you use the quotes.
03:20  Riviera: !$# > hal
03:20  greybot: hal: the number of arguments, not counting $0
03:21  Riviera: hal: err, well, it's $#
03:21  hal: damn, I've explained it wrongly
03:21  hal: it's not the variable that I am interested in, it's how to concatonate it to a string
03:22  Riviera: hal: "string $#"
03:22  hal: so #0 expands to the value
03:22  hal: it doesn't work
03:22  Snowie: Riviera, sorry mate, missed it. i am adding the mp3 tag when the file is moved. so let me try this
03:22  hal: ie  echo "No arguments passed to the script named #0"
03:22  Riviera: hal: $0
03:22  Riviera: hal: not #0
03:23  Snowie: Riviera, your sating it wont correctly name the files?
03:23  hal: ahhh
03:23  hal: I see what you mean
03:23  Riviera: !$0 > hal, btw
03:23  greybot: hal, btw: $0 is like argv[0] in C. It's whatever the caller decides to put there. You can't rely on it. See http://mywiki.wooledge.org/BashFAQ/028 and http://www.bash-hackers.org/wiki/doku.php/scripting/posparams#the_first_argument
03:23  hal: sorry, that was stupid of me
03:23  Riviera: Snowie: If by "it" you mean the backslash-escaping trick, then yes.
03:24  hal: thank you all
03:25  Snowie: Riviera, erm, a sec, im sure thats how ive used mv before for spaced names
03:31  Snowie: Riviera, ok, now i beleive you. so, what i should do is add a double quote to the begining and end of each variable. for title should end     .mp3"    and that should do the trick.
03:31  Riviera: not of each variable but of each filename
03:31  Riviera: but if you mean by that that you want to double-quote all expansions of variables, then yes, do that.
03:32  Snowie: the script sorts tracks into folders as well for Artist and Album. so yeah, for all variables.
--- Log closed Tue Nov 23 03:42:19 2010
--- Log opened Tue Nov 23 03:42:40 2010
03:42 --- Users 503 nicks [0 ops, 0 halfops, 0 voices, 503 normal]
03:43 --- Channel #bash was synced in 80 seconds
03:46  Snowie: Riviera,  so var="${var   ... that same line has been sitting there for ages. could you recommend some reading to adding quotes to a variable please
03:48  Riviera: !quoting
03:48  greybot: Quoting 101: Always use "double quotes" around expansions: "$foo", "$(awk ..)". Use 'single quotes' to prevent even bash expansion: awk '$1 == foo'. You "can 'nest'" quotes but can't put literal single quotes in single quotes; so use: 'Don'\''t forget to quote!'.
03:48  Riviera: !quotes
03:48  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
03:52  Snowie: Riviera, it cant be as simple as var='"$var'"   can it?
03:53  Snowie: Riviera, comment out the quotes and add them on either side :/
03:53  Riviera: Snowie: in assignments you don't need the quotes; var=$var is fine. But take the time and read <http://mywiki.wooledge.org/Quotes and http://wiki.bash-hackers.org/syntax/words
03:54  Snowie: I have been reading it. paramater expansion. ok, ill be back
04:00 --- [1]The-Bat is now known as The-Bat
04:05  Snowie: Riviera, OMFG! i think ijust had my Eureka moment. I dont need to add the quotes INTO the variable, i just need to surround each variable in quotes when im passing it to bash. RIGHT?? so /home/$USER/Music/"$Artist" instead of just plain vanila $Artist
04:09  geirha: Yes, or "$HOME/Music/$Artist". Whenever there's a $, you usually want "" around it-
04:11  Buglouse: top: Remove tasks from top. Is it possible to filter the view of top?
04:11  geirha: I believe top's manpage has some info on that.
04:12  Snowie: geirha, thanks mate. been chasing my own tail for ages trying to get the quotes INTO the variable. Learnt something though
04:13  geirha: Yeah, once you get a quote into a variable, it'll be treated as any other character, not a syntactical quote.
04:14  Buglouse: yes, but only for user or specific pid
04:14  Buglouse: i want to filter based on command: 'grep -v loop'
04:16  geirha: Ugh, well I'd as in the channel for your OS first. Maybe they'll know a better way (other command perhaps).
04:16  geirha: s/as/ask/
04:18  Buglouse: hehe, but it is not os specific. I only ask here cause everyone else is null
04:19  geirha: Yes it is. top is a non-standard command.
04:24  Buglouse: yes, my mistake. thought it was from gnu projects
04:24 --- jzacsh_ is now known as jzacsh
04:26  flaccid: !case
04:26  greybot: case word in pattern);; esac syntax is used to match a word against a particular pattern, and execute commands if that pattern matches. See 'case word in' in man bash | http://wiki.bash-hackers.org/syntax/ccmd/case
04:26  flaccid: danke
04:29  flaccid: !columns
04:29  greybot: COLUMNS and LINES are set to reflect the terminal's size, but bash does not set these values by default; furthermore it does not export them. If you really need them to be correct and up-to-date, use shopt -s checkwinsize and export COLUMNS and/or LINES. See also http://mywiki.wooledge.org/BashFAQ/091
04:30  flaccid: hmm say i have "foo bar", what is the recommended tokenization to get the columns, i.e. i need bar, col 2
04:32  flaccid: awk '{print $2}' i gues
04:41  meowz: how can i bind a hotkey that will clear the entire bash line?
04:41  meowz: i don't want to rebind the entire bash command for the entire system
04:50  meowz: how can i get a bell to ring when a command completes in bash, but only when it's a command that is finish that's not in the currently focused window?
04:54  meowz: ... or is there a global var that bash has that i can parse to see if a command is running or whatnot?
05:00  hachque: i tried ESC="\033"
05:00  hachque: but when i use
05:00  hachque: echo $ESC
05:00  hachque: i just get \033
05:00  hachque: any ideas why the escape isn't working?
05:03  geirha: !$'
05:03  greybot: Bash has a special form of quoting, $'string' in which backslash-character combinations are expanded. For example, echo $'this is a literal tab: \t'
05:04  geirha: If you need that esc to do colors, use tput instead.
05:04  hachque: nope
05:04  hachque: ESC='\033'
05:04  hachque: doesn't work either
05:04  geirha: Now try the quotes in that factoid
05:05  geirha: !tput
05:05  greybot: Terminalcodes and stuff: http://www.bash-hackers.org/wiki/doku.php/scripting/terminalcodes
05:05  hachque: oh weird
05:05  hachque: they must have changed it
05:05  geirha: Nope
05:05  hachque: it never used to require $' ' before
05:05  hachque: "\033" used to work
05:05  geirha: Nope, never has.
05:05  hachque: o_o
05:06  geirha: "\033" is 4 characters.
05:06  geirha: You can output an ESC with:  printf '\033'   or   echo -e '\033'
05:07  geirha: And you can type a literal one with Ctrl+v ESC
05:08  hachque: okay thanks
05:20  flaccid: hmm is there a better way to do "$(echo "$kernel_images" | awk '{ print $1 }')"
05:20  Snowie: could anyone shed light on why mv $File /home/$USER/Music/"$Artist"/"$Album"/"$Title".mp3 gives me ...
05:21  Snowie: mv $File /home/$USER/Music/"$Artist"/"$Album"/"$Title".mp3 is not a directory. i want it to create the file, not the directory, and it worked for others
05:22  Snowie: the line directly above this is mkdir /home/$USER/Music/"$Artist"/"$Album" -pv
05:22  Snowie: the directories do exist also after running the script, just wont mv them anymore ???
05:22  ritztech: if im using a expect script with Bash and i get an error code that states Cant fine NE could i put it in the bash as IF results return a "Cant find NE" THEN ?
05:22  Riviera: Snowie: certainly because $File contains whitespace.
05:23  Riviera: Snowie: when given more than two filename arguments, mv expects multiple files to be moved into a directory (the final argument)
05:23  Snowie: http://pastebin.ca/1999660
05:23  Riviera: Snowie: mv -- "$File" "/home/$USER/Music/$Artist/$Album/$Title.mp3"
05:23  ritztech: what could i setup my IF statement to be IF RESULTS contain a Cant Find NE"
05:23  Riviera: Snowie: try that, please.
05:24  Snowie: AAAERRRRRGGGGGGGG FFAAAAAAAAAAAAAAAAAA!!!
05:24  Snowie: sory, sorry all, but thats the exact lesson i learnt about an hour ago, and i forgot it allready
05:24  steve___: flaccid: what is "$kernel_images" set to?
05:24  Snowie: Riviera, thanks mate :S
05:25  flaccid: steve___: linux-image-2.6-bigmem-amd64 linux-image-2.6-xen-amd64
05:27  steve___: flaccid: if you want it to always get the first field (linux-image-2.6-bigmem-amd64) for record, then yes.
05:27  steve___: flaccid: do you need the subshell   ie $( )
05:28  flaccid: i guesss not
05:28  flaccid: thanks
05:32  flaccid: steve___: hmm how do i do that without the subshell with awk?
05:36  steve___: do you want your script to print the first field?
05:36  steve___: if so then just use echo "$kernel_images" | awk '{ print $1 }'
05:39  flaccid: sorry i'm using with chroot "$DEBOOTSTRAP_TARGET_DIR" dpkg-reconfigure "$(echo "$meta_packages" | awk '{ print $2 }')"
05:41  steve___: yep that looks good.
05:41  flaccid: okies thanks
05:42  steve___: ppl in here will suggest to use lower case for your variables unless they are global
05:42  flaccid: its a rightscript input so has to be in caps
05:44  steve___: you could set  kernel=$(echo "$meta_packages" | awk '{ print $2 }')  to a variable as well to keep it consistent
05:44  steve___: but that doesn't really matter.
05:44  Riviera: !pe
05:44  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
05:46  Riviera: # var='linux-image-2.6-bigmem-amd64 linux-image-2.6-xen-amd64'; echo "${var#* }"
05:46  evalbot: Riviera: linux-image-2.6-xen-amd64
05:46  ritztech: If Get Error codes from EXPECT and im connecting with bash... if i have error code 1212 Can i set the Output in my bash to be like IF Results Return a 1212 Then blah blah
05:46  ritztech:  x=`/usr/local/bin/fndchk.exp "$fndip"
05:46  ritztech: echo "$x"
05:47  flaccid: danke Riviera and evalbot
05:47  steve___: # var='linux-image-2.6-bigmem-amd64 linux-image-2.6-xen-amd64'; echo "${var##* }"
05:47  evalbot: steve___: linux-image-2.6-xen-amd64
05:47  Riviera: gerngern.
05:47  steve___: he asked about awk is all.
05:48  Riviera: ritztech: I don't understand. :)
05:51  ritztech: if using expect and i get different results like Error Code:5444 can i take that result into bash and use IF x = Contained 5444 then  blah blah
05:51  ritztech: with my expect im logging into the device and pulling active alarms
05:52  ritztech: normally they return OK or good but When i get Error :4222 i want to be able to some how do a IF
05:56  Riviera: ritztech: when you do the command shown above, what's then the output of the echo "$x"?
06:10  ritztech: a bunch of info being shown and Alamrs that are shown if i echo a $x is there a temp place i can view the last results
06:14  ritztech: or do i need to use the result function some how
06:31 --- Weust`afk is now known as Weust`
06:41 --- Weust` is now known as Weust`afk
07:01  depaulis: Hi, since I changed to bash an extra enter is occasionly inserted, it is getting alittle frustrated. I am running GNU bash 3.2.25(1) Anyone know the reason for this? and how I can get rid of this? Thanks
07:18  JanKinz: is there anyone who can help me out? i am new to unix administrator training well im learning myself, i have no experince with scripting/programming so i would like to know is there anyone who can recommend me how should i learn or start or from where? for new comers? i will appriciated if someone can help me out, thanks
07:18  flaccid: JanKinz: all the links in the topic
07:19  JanKinz: flaccid: yeah i already looked at it, but can't figure it out :< thats why i asked it from where i should take start?
07:20  flaccid: the bash guide in the topic
07:20  JanKinz: flaccid: its for beginners?
07:20  flaccid: yes
07:21  JanKinz: so nice of you thankyou so much, appriciate it
07:22  JanKinz: flaccid: can i ask you one more option?
07:22  JanKinz: *question
07:23  steve___: JanKinz: just ask
07:23  JanKinz: thanks,
07:24  JanKinz: is there any difference between linux & Unix Commands? sorry if asked stupid questions, the reason is i don't know much about it
07:24  flaccid: JanKinz: yes. bash though is a shell language, it has the same commands/language
07:25  flaccid: this is ##bash
07:25  JanKinz: thankyou
--- Log closed Tue Nov 23 07:42:08 2010
--- Log opened Tue Nov 23 07:42:35 2010
07:42 --- Users 499 nicks [0 ops, 0 halfops, 0 voices, 499 normal]
07:43 --- jzacsh_ is now known as jzacsh
07:43 --- Channel #bash was synced in 83 seconds
08:05  shai__: In bash there is a feature where you can do something like cat > /tmp/filename <<POINTER some text here POINTER
08:05  shai__: What is that called?
08:05  geirha: !<<
08:05  greybot: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
08:13  depaulis: Hi, since I changed to bash an extra enter is occasionly inserted, it is getting alittle frustrated. I am running GNU bash 3.2.25(1) Anyone know the reason for this? and how I can get rid of this? Thanks
08:14  Sonderblade: depaulis: does it happen on the command line?
08:14  depaulis: Sonderblade: yes
08:14  depaulis: not always, but sometimes
08:15  Sonderblade: do you use a colorized prompt?
08:16  depaulis: no I dont. PS1=\h [\W] $
08:16  shai__: geirha: thanks :)
08:18  Sonderblade: depaulis: then i dont know what the problem is. there was as similar known problem but only for colozired prompts in bash 3.2 maybe upgrading to bash 4.x will still help
08:19  depaulis: Sonderblade: I use colors for listings... but the problem occurs not only in the command line. Also changing windown in dwm with <alt>+[jk] can make double jumps sometimes.
08:21  depaulis: Sonderblade: I give it a try and see if it helps. thanks
08:23  SiegeX: how would you guys go about creating a fixed-length string who's text is center justified and the rest of the string is filled with '='?  For example, if the fixed lenght was 20 and the string text was 'foobar' the result would be '=======foobar======="
08:26  SiegeX: # str="foobar"; len=20; printf "%*s%s%*s\n" $(((len - ${#str})/2)) "" "$str" "$(((len - ${#str})/2))" " "
08:26  evalbot: SiegeX:        foobar
08:26  SiegeX: that works for spaces but it's ugly
08:27  SiegeX: # str="foobar"; len=20; printf "=%*s%s%*s=\n" $(((len - ${#str})/2)) "" "$str" "$(((len - ${#str})/2))" " "
08:27  evalbot: SiegeX: =       foobar       =
08:27  Sonderblade: use tr " " =
08:28  pgas: or maybe several printf
08:29  SiegeX: was thinking about tr but then I realized it would replace the spaces within the actual text
08:29  pgas: you can also create a string with $(tput cols) = and cut it with ${var:1:len}
08:29  pgas: things like this
08:31  pgas: http://wiki.bash-hackers.org/snipplets/print_horizontal_line # has some ideas
08:31  SiegeX: thanks pgas
08:33  lhunath: hmm.  why isn't this valid: printf '%*1$s' 5 ''
08:33  lhunath: seems to conform to printf(3)
08:33  lhunath: A field width or precision, or both, may be indicated by an asterisk `*' or an asterisk followed by one or more decimal digits and a `$'
08:34  geirha: # hr="====================" hrlen=${#hr} str=foobar strlen=${#str} offset=$(( (hrlen-strlen)/2 )); printf '%s%s%s\n' "${hr:0:offset}" "$str" "${hr:offset+strlen}"
08:34  evalbot: geirha: =======foobar=======
08:37  arooni-mobile: how do i quickly recursively search for a file name begging with "Sri" via command line?
08:37  geirha: find . -name "Sri*" -print
08:37  geirha: !find > arooni-mobile
08:37  greybot: arooni-mobile: http://mywiki.wooledge.org/UsingFind
08:38  lhunath: echo **/Sri*
08:53  SiegeX: !empty directory
08:53  SiegeX: how to check for an empty directory without parsing ls?
08:53  SiegeX: is that a faq Q?
08:54  pgas: !faq empty
08:54  greybot: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
08:57  SiegeX: ty
08:57  SiegeX: !ls
08:57  greybot: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
08:58 --- VmC is now known as CaHbKa
09:00 * k[t is slow, and probably incorrect...
09:00  k[t: # str=hello; printf "%-10s%-10s%$((${#str}))s\n" "=" "$str" "="
09:00  evalbot: k[t: =         hello         =
09:00  k[t: =(
09:05  SiegeX: #len=20; str="foobar"; cnt=$(((len - ${#str})/2)); filler=$(eval printf "%0.s-" {1..$cnt}); printf "%s%s%s\n" "$filler" "$str" "$filler"
09:05  SiegeX: # len=20; str="foobar"; cnt=$(((len - ${#str})/2)); filler=$(eval printf "%0.s-" {1..$cnt}); printf "%s%s%s\n" "$filler" "$str" "$filler"
09:05  evalbot: SiegeX: -------foobar-------
09:06  SiegeX: gets minus points for eval but I don't think this one is dangerous
09:11  Knirch: SiegeX: depends if width is important, as len 19 becomes 18 chars
09:20 --- kaeser is now known as bucetapodre
09:21  unfancy: line 3 of my script: if [ -z $1 -o  -z $2 ] then # no(t enough) arguments supplied echo "$0 mode needle destination"
09:22  unfancy: nihil@snake:~$ eximfwd_header_from asdf
09:22  unfancy: /home/nihil/bin/eximfwd_header_from: line 3: [: argument expected
09:22  unfancy: why?
09:22  unfancy: it does what i want with no aaargument and 2 arguments :(
09:23  unfancy: oh aand s/supplied/supplied\n/ :)
09:25  Knirch: (let's hope this is the correct factoid)
09:25  Knirch: ![ > unfancy
09:25  greybot: unfancy: [ is NOT part of the `if' syntax. It's a normal, ordinary COMMAND. The `if' just checks its exit status. See `help test', http://mywiki.wooledge.org/BashGuide/TestsAndConditionals , and http://partmaps.org/era/unix/award-example-backticks.html
09:25  Knirch: crap, sorry
09:25  Knirch: ![[ > unfancy
09:25  greybot: unfancy: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
09:27  zplinux: hi all
09:27  wheaty: How can I specify the number of iterations for a loop via command argument?
09:28  danst_: set number as $1 ?
09:28  wheaty: danst_: So for i in {1..$1} ?
09:28  pgas: !cfor
09:28  greybot: C-style for loop: for (( expr; expr; expr )); do COMMANDS; done # Each expr is done in a math context. Example: for ((i=1; i<=n; i++)); do echo "$i"; done
09:30  wheaty: Ahh, okay
09:30  wheaty: Thanks
09:35 --- whaley is now known as SirLoins
09:40  Sonderblade: i want in bash to check if a process has gotten stuck, in this case it means if it hasnt produced any console output for x minutes, can you do that in bash?
09:40  Quanta: hi, i would like to use pkill, but i am doing something wrong.... i tried: pgrep -u gpsn PB0 and i get 3 Process which is correct. but: pkill -u gpsn PB0 doesnt kill those three processes...
09:42  pgas: Sonderblade: | while read -t 180
09:42  pgas: so buffering might hit you
09:42  SiegeX: Quanta: perhaps those processes are ignoring SIGHUP
09:43  SiegeX: make that SIGTERM
09:44  Quanta: pkill -SIGTERM -u gpsn PB0 didnt worked
09:45  pgas: well, SIGTERM is the default
09:46  paissad: guys, i want my countdown function to work  like this
09:46  paissad: [3 sec] ...  --> [2 sec] .. --> [1 sec] . --> [0 sec]
09:46  paissad: but i always i have [0 sec] .. at the end
09:46  paissad: http://dpaste.com/278733/
09:46  paissad: where am i wrong in my script ?
09:46  lhunath: !pm > Quanta
09:46  greybot: Quanta: http://mywiki.wooledge.org/ProcessManagement
09:46  pgas: so try HUP, but  as SiegeX said, if they are not killed it's because they somehow ignore the signal
09:47  lhunath: paissad: expr?  seriously?
09:47  lhunath: and date +%s?
09:47  Sonderblade: pgas: what do you mean?
09:48  paissad: lhunath, and ?
09:49  SiegeX: paissad: did you refer to the ABS for this script at all?
09:49  Quanta: "-9" solved my problem
09:49  paissad: ABS ?
09:49  SiegeX: advanced bash scripting guide
09:49  lhunath: paissad: countdown() { local seconds=${1:-5}; for ((s=seconds; s>=0; --s)); do printf '\r[%d sec]' "$s"; sleep 1; done; }
09:49  SiegeX: I ask because that "guide" is littered with 'expr'
09:49  lhunath: !abs
09:49  greybot: The infamous "Advanced" Bash Scripting Guide should be avoided unless you know how to filter out the junk. It will teach you to write bugs, not scripts. In that light, the BashGuide was written: http://mywiki.wooledge.org/BashGuide
09:51  lhunath: paissad: you are doing a lot of useless work and introducing a lot of archaic and non-portable dependencies for something as simple as counting from 5 to 0.
09:52  paissad: lhunath, i plan to to include minute, hours ...
09:52  lhunath: so do some more math.
09:52  lhunath: do NOT use date.
09:52  lhunath: and do not use expr either.
09:52  lhunath: !math
09:52  greybot: Add 7 to a variable: let a+=7; ((a+=7)); a=$((a+7)); See http://mywiki.wooledge.org/ArithmeticExpression
09:52  lhunath: you do not need to know the current UNIX timestamp in order to count from X to 0.
09:53  paissad: ah i see what you mean now :)
09:53  lhunath: if s is 610 you can easily do some math to split that up into 10 minutes and 10 seconds.
09:54  paissad: i know :)
09:54  paissad: %
09:54  paissad: btw, you did not answer my main question ..
09:54  Bushmills: 4# echo {5..0..-1}     # can loop through this
09:54  shbot: Bushmills: 00005 00004 00003 00002 00001 00000
09:54  lhunath: paissad: being what, why is your script broken?
09:55  paissad: i want the dot to decrease ..
09:55  Bushmills: eh ... where does the zero padding come from?
09:55  lhunath: oh.  dots.
09:57  lhunath: shrug.  I really don't want to debug this code.
09:57 * lhunath goes back to work.
09:58  paissad: !printf
09:58  greybot: The printf command: http://bash-hackers.org/wiki/doku.php/commands/builtin/printf
09:59  pgas: SiegeX: I mean pkill pid is the same thing as pkill -TERM pid
10:38 --- bucetapodre is now known as apophis99942
10:48  hyper_ch: hi there, when I do a ls -al I get the file creation/modification date, right? I thought I could update it using touch file.ext but that won't update it... what command to use instead?
10:55  Bruce_Wayne: hyper_ch: `ls * -dpltr | grep -v "/$" | tail -1` shows you last updated FILE from current working directory
10:56  hyper_ch: Bruce_Wayne: well, I would like to run a command that will update the "creation date" shown by the ls -al command
10:56  hyper_ch: I tought touch would do it but it doesn't
10:56  Sonderblade: hyper_ch: check your mount options or filesystem flags, touch does it for me
10:56  flavius: Hi. Is it possible to hook into bash? Concretely what I want is to send a message via dbus when each command is entered (and if dbus is available)
10:58  hyper_ch: Sonderblade: ext3 with errors=remount-ro
10:59  Bruce_Wayne: hyper_ch: My system terminal shows me last modification time when I execute `ls -al`
10:59  hyper_ch: now it works... strange
11:00  Sonderblade: you're doing something wrong for sure hyper_ch
11:00  lhunath: !ls > Bruce_Wayne
11:00  greybot: Bruce_Wayne: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
11:00  lhunath: !latest
11:00  greybot: Find the latest modified file in a directory: latest() ( shopt -s nullglob; cd "$1"; local file latest; for file in ./*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s "$latest" )
11:01  Bruce_Wayne: lhunath: There was a question in my school exercise to find the last modified file from the current working directory...
11:02  lhunath: what's your point?
11:02  lhunath: that latest() function is overly verbose
11:02  Bruce_Wayne: I could not find any other trick except use a for loop and compare every file with test -nt option...
11:02  lhunath: is that a bad thing?
11:03  lhunath: !forget latest
11:03  greybot: OK, lhunath
11:03  Bruce_Wayne: Well, I was hoping a suggestion from you for any more good trick to find the last modified file from the current working directory.
11:03  lhunath: define good.
11:03  lhunath: you think ls doesn't compare the mtime of each file?
11:04  Bruce_Wayne: I would like to know more about latest() function.. but they are prohibited to use.. and those dumb teachers told me to use ls and parse output...
11:05  Bruce_Wayne: lhunath: what is mtime?
11:06  lhunath: !learn Find the latest modified file in a directory: latest() ( local file latest; for file in "$1"/*; do [[ $file -nt $latest && latest=$file; done; printf %s "$latest" ) ## Usage: latest mydir
11:06  greybot: find is already defined: http://mywiki.wooledge.org/UsingFind
11:06  Bruce_Wayne: Anyways, I would like to know what you do if you'd been asked for making the script to find the last modified file from the current working directory.
11:06  lhunath: !learn latest Find the latest modified file in a directory: latest() ( local file latest; for file in "$1"/*; do [[ $file -nt $latest && latest=$file; done; printf %s "$latest" ) ## Usage: latest mydir
11:06  greybot: OK, lhunath
11:06  lhunath: that.
11:06  lhunath: mtime = modification time
11:07  lhunath: !forget latest
11:07  greybot: OK, lhunath
11:07  lhunath: !learn latest Find the latest modified file in a directory: latest() ( local file latest; for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s "$latest" ) ## Usage: latest mydir
11:07  greybot: OK, lhunath
11:08  Bruce_Wayne: lhunath: unfortunately I don't know how to use functions.. would you give me link how to use them..
11:08  lhunath: same way you use any command in bash
11:09  lhunath: just like you'd write: echo foo, you'd write: latest foo
11:10  lhunath: Bruce_Wayne: http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
11:13  teamcoltra: I found a sh script that uses curl to parse an RSS feed. However, I can't seem to figure out how it is working, I did a "man sed" and "man grep" but the whole "The Actual Work" section just confuses me. Can someone explain to me what is actually going on (I need to modify this script to parse something else) http://paste2.org/p/1105192
11:14  lhunath: !xml
11:14  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
11:15  teamcoltra: If this script is working fine -- and doing its function properly, why should I use something different?
11:16  lhunath: teamcoltra: http://paste2.org/p/1105195 -- annotated.
11:16  lhunath: teamcoltra: because it isn't.
11:17  mkay_: lhunath: for some specific url's bash is enought to parse it
11:18  mkay_: looking at 'actual work' ppart, this site is just pretty simple
11:19  teamcoltra: https://crm.pirateparty.ca/membership_count.php I am repurposing it to grab the first line of this really simple script... Which is why I figured this simplistic approach would be fine
11:19  lhunath: yeah, why not do things in an ugly way, forking 6 processes and piping them together, while also breaking the entire notion of XML being a structured language, as a result, breaking whenever the format of the input XML changes while still being syntactically equivalent
11:19  lhunath: doing things right would be so un-cool.
11:20  lhunath: OTOH; it may require me to know what XML is.
11:21  mkay_: lhunath: ok - it's ugly solution, but don't say that it does not work;)
11:21  lhunath: it doesn't parse XML.
11:22  lhunath: as such; it doesn't parse an RSS feed.  it parses bytes and pretends to give you an answer that happens to most often be what you expect out of an RSS parser.
11:23  teamcoltra: lhunath, but I am not using it to parse an rss feed
11:23  teamcoltra: I am using a script that was intended to parse an RSS feed
11:25  jww: hello.
11:27  jww: I'm trying to create a text file with a * inside, my problem is that it get expanded to files in current directory, here is the code : http://pastebin.ca/1999807. can somebody help please ?
11:27  Naib: !quotes
11:27  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
11:27  Naib: use ' '  instead of " "
11:27  lhunath: !quotewhen > jww
11:27  greybot: jww: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
11:28  lhunath: "" is fine, too.
11:28  jww: I'm checking this, but I already used '' .
11:28  jww: ( with no difference ).
11:28  lhunath: jww: read the quotewhen factoid again.
11:28  lhunath: every sentence of it.
11:28  jww: umm
11:29  jww: situation seems the same to me, I'm already using ' .
11:29  lhunath: drilled it into your skull?  excellent.  now go back to your code and apply it.
11:29  jww: umm
11:30  lhunath: some more hand-holding?  ok.  apply the first sentence of it to your code.
11:30  MTecknology: python planet.py nginx/config.ini 2&> /dev/null  <-- does that look like I'm redirecting correctly?
11:30  Naib: waht abt the echo
11:30  lhunath: and then, apply it to every script you use, because you probably broke them too.
11:30  Naib: MTecknology. no
11:31  MTecknology: !redirect
11:31  greybot: Learn about redirections! Syntax: http://bash-hackers.org/wiki/doku.php/syntax/redirection and http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection ## Illustrated tutorial: http://bash-hackers.org/wiki/doku.php/howto/redirection_tutorial
11:31  lhunath: jww: where in your code do you see an expansion?
11:31  jww: at the last line, **
11:31  lhunath: what does the sentence tell you to do with it?
11:31  Naib: look again
11:31  lhunath: the last line is: echo -e $FILES > /tmp/z
11:31  MTecknology: Naib: thanks
11:31  jww: I mean the last line of FILES.
11:32  jww: there is - ** '
11:32  lhunath: Jesus!
11:32  Naib: the actual file isn't the issue
11:32  lhunath: it friggin tells you with EXAMPLES
11:32  Naib: a file is just data
11:32  lhunath: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`").
11:32  lhunath: ("$foo", "$(foo)", "`foo`")
11:32  lhunath: how much more obvious can we make it?
11:32  MTecknology: lhunath: You need some good tequila - eh?
11:33  jww: lhunath: you just suck.
11:33  lhunath: jww: I beg you pardon?
11:33  jww: it would be better if you even understood what I'm asking.
11:33  lhunath: ...
11:33  Naib: wtf
11:34  lhunath: somebody else deal with this idiot.
11:34  Naib: jww. you have been reading the same IRC as we have right?
11:34  jww: I do Naib .
11:34  Naib: so someone that has told you what needs to be done "sucks" in your words?
11:35  jww: I don't think it's what to be done, exepting being rude with me he wasn't helpfull at all.
11:35  Naib: he has been helpful
11:35  Naib: he only went #bash on yor ass when you were not listening
11:36  jww: I don't need to doublequote anything, since I don't want to expand anything.
11:36  lhunath: you expand $FILES
11:36  Naib: ^
11:36  teamcoltra: Okay one more question for you guys: http://paste2.org/p/1105215 I have that... it works great. Now, lets say I also want to grab something else from line # how do I get more stuff without starting a new curl connection?
11:37  teamcoltra: Do I just strip everything above like is shown, and then just do another head -n under the current head -n ?
11:38  lhunath: also; it looks like you're trying to use echo -e on \n's to fix your wordsplitting issues caused by your failing to quote.
11:38  lhunath: get rid of the -e, get rid of the \n's
11:38  lhunath: !wordsplitting > jww
11:38  greybot: jww: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
11:39  lhunath: on top of that, if you leave $foo unquoted, bash will expand everything that looks like a glob within it into filenames.
11:39  lhunath: hence, your issue.
11:39  jww: lhunath: I try this.
11:39  willgg: Anyone know of a user called Erayd?
11:42  jww: lhunath: I just removed \n and echo -e, I also added double quote at start and end.http://pastebin.ca/1999815
11:43  jww: it's not breaking lines anymore now.
11:43  lhunath: jww: what line does expansions?
11:43  jww: echo ?
11:43  lhunath: yes.
11:43  lhunath: namely, $FILES, is an expansion of the variable FILES.
11:43  lhunath: what did it tell you to do with expansions?
11:44  jww: to double quote em,
11:44  jww: orrr
11:44  lhunath: aye.
11:44  jww: got it.
11:44  nchauvet: hello, when doing a cat > file <<EOF ; how is it possible to avoid $VAR to be evaluated ?  double quote doesn't seems to work
11:44  jww: and everything goes ok.
11:44  lhunath: whenever you see a $something or $(something) or `something`, you ALWAYS want to put "" around it
11:44  lhunath: "$FILES", "$something", "$(command)", "`command`"
11:45  jww: thanks lhunath / Naib .
11:45  lhunath: now that you quoted "$FILES", you can safely put ** in it
11:45  jww: ok lhunath you don't suck, but man you're not friendly at all.
11:45  jww: :)
11:46  lhunath: friendly is what made 95% of the bash code in the world suck.
11:49  Naib: lol
11:50  jww: how arrogant lol, I'll stay here just to see your oppresse other peoples.
11:52  magcius: Is there an easy way to make filename completion use ANSI colors?
11:52  magcius: I swore I had it before.
11:52  teamcoltra: mkay_ / lhunath http://paste2.org/p/1105228 I have tried this, which works for /membercount but the script hangs up on /goal (it will create the file if it doesn't exsist, but it wont fill it with line 4... and the script doesn't end)
11:53  lhunath: magcius: not in bash.
11:53  lhunath: teamcoltra: where should the second head's input come from?
11:53  lhunath: teamcoltra: the first comes from the pipe in front of it.
11:54  teamcoltra: I basically want line 1 to be printed to one file, and line 2 to another
11:54  teamcoltra: err line 4 to another
11:54  jww: line 4 is printed from nothing.
11:54  lhunath: so you want to use the pipe's bytes twice.
11:54  teamcoltra: Sure
11:54  lhunath: put it in a variable and send that variable's bytes to both head's.
11:55  magcius: I *swore* I had filename completion looking the same as ls --color -F
11:55  lhunath: magcius: you probably weren't using bash.
11:56  magcius: I WAS!
11:56  magcius: I'm going crazy
11:56  jww: magcius: googling for color bash completion give some insights.
11:56  jww: http://ubuntuforums.org/showthread.php?t=1579159
11:57  jww: osp
11:57  magcius: maybe I had a custom-built readline or something
11:57  teamcoltra: lhunath, can you point me in the direction to do that?
11:57  lhunath: !faq 2 > teamcoltra
11:57  greybot: teamcoltra: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
11:58  teamcoltra: Thanks
11:58  lhunath: after you've stored it in a variable, pass it to head like so:  head -n1 <<< "$var" > file
11:58  lhunath: also, head is not a tool to "pick line x out of a stream"
11:58  lhunath: if you want line 4, then head -n4 isn't going to give you it.
11:59  lhunath: you may want sed -n 4p
11:59  lhunath: but hey; since you seem to enjoy forking off pointless commands, why not head -n4 | tail -n1
12:00  teamcoltra: lol honestly I was trying to use tail
12:00  teamcoltra: (i know, big surprise to you right?)
12:02  teamcoltra: Why do you have the head as line 4 and tail as line 1 doesn't that need to be backwards?
12:03  Naib: to get the 4th line
12:03  Naib: in a round about way
12:04  Naib: # echo -e "1st\n2nd\n3rd\n4th\n5th" | head -n4 | tail -n1
12:04  evalbot: Naib: 4th
12:04  Naib: or via sed
12:04  Naib: # echo -e "1st\n2nd\n3rd\n4th\n5th" | sed -n 4pecho -e "1st\n2nd\n3rd\n4th\n5th" | sed -n 4p
12:04  evalbot: Naib: sed: -e expression #1, char 23: unknown option to `s'
12:04  Naib: oops
12:04  lhunath: head -n4 means "first four lines", tail -n1 means "last 1 line".  so the last 1 line of the first 4 lines is the fourth line.
12:05  jayeola: how does one grep for a string containing 1+ uppercase chars? ls | grep '[A-Z]{1,}'
12:05  Naib: use +
12:05  magcius: grep '[A-Z]\+' ?
12:06  Naib: [A-Z]+
12:06  magcius: well, you can use grep -e to omit the \
12:06  jayeola: does one need the single quotes?
12:06  magcius: no, but it's recommended
12:07  lhunath: !ls > jayeola
12:07  greybot: jayeola: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
12:07  jayeola: ty!
12:07  lhunath: jayeola: echo *[A-Z]*
12:07  magcius: oh, I figured he was using ls as an example
12:08  Naib: that echo doesn't work btw
12:08  jayeola: so it is better to use find rather than ls when looking at files in a dir?
12:09  lhunath: it all depends on what you want to do with the files
12:10  lhunath: allFilesContainingAnUpperCaseChar=(*[A-Z]*)
12:10  lhunath: Naib: why do you think so?
12:10  Naib: the 1st * is greedy
12:10  lhunath: granted, [[:upper:]] is safer than [A-Z]
12:10  Naib: so words with no uppers are actually captured
12:10  lhunath: Naib: who cares, we're matching files
12:11  lhunath: no, [A-Z] matches 1 uppercase char.
12:11  jayeola: that is what i prefer to use [[:UPPER]] but i think that i am going to use `find`
12:11  lhunath: # touch foO bar; echo *[A-Z]*
12:11  evalbot: lhunath: foO
12:11  teamcoltra: Thanks guys I think I got it.. :) I know my method is "hacky" but it worked. :D Thanks
12:11  lhunath: no bar.
12:12  Naib: # touch foo Foo; echo *[A-Z]*
12:12  evalbot: Naib: Foo
12:12  Naib: how odd, doesn't do that for bash4
12:13  Naib: I get foo and Foo returned
12:13  Naib: touch foo Foo; echo *[A-Z]*
12:13  Naib: foo Foo
12:14  erUSUL: 4# touch foo Foo; echo *[A-Z]*
12:14  shbot: erUSUL: Foo
12:14 * Naib rights a bugzilla report for gentoo
12:15  lhunath: Naib: try [[:upper:]]
12:15  erUSUL: 4# shopt | grep case
12:15  shbot: erUSUL: nocaseglob     	off
12:15  shbot: erUSUL: nocasematch    	off
12:15  lhunath: hmm; do you have those on by default?
12:15  Naib: shopt | grep case
12:15  Naib: nocaseglob      off
12:15  Naib: nocasematch     off
12:15  jayeola: ok, testing a string that contains __all__ uppercase characters
12:16  Naib: ok it must be a setting my end. just ssh to another gentoo box and it is fine there :)
12:18  lhunath: jayeola: !(*[a-z]*)
12:18  lhunath: with shopt -s extglob
12:19  lhunath: *[[:lower:]]*
12:19  lhunath: echo !(*[[:lower:]]*)
12:30 --- [1]The-Bat is now known as The-Bat
12:48 --- [1]The-Bat is now known as The-Bat
12:51 --- Xilent_ is now known as Xilent
12:56 --- h4x0r` is now known as perlNUB
13:02  paissad: !pe
13:02  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
13:10  jayeola: http://pastebin.ca/1999859 what is wrong with this script?
13:11  stockholm: how can i make printf print stuff from stdin?
13:12  koala_man: read it first
13:13  stockholm: you mean with read line ; printf $line ?
13:13  Knirch: jayeola: it seems to imply that it looks for only uppercase characters which is not the case, it will trigger on fOo Foo FOO foO etc
13:13  Knirch: jayeola: it will output the string on screen as well, which might not be what you intend
13:13  koala_man: stockholm: yes
13:14  pgas: stockholm: yes, though maybe consider using awk instead
13:14  jayeola: ty! i took the [[ ]] out and replaced with [ blah ]; seems to work
13:14  Knirch: jayeola: what? that statement did not make any sense at all
13:14  stockholm: pgas: why? i use printf to convert numbers to hex
13:15  pgas: because awk reads from stdin and is fast
13:16  stockholm: pgas: i do this:
13:16  stockholm: IP_LOM_IN_OCTETS=$(echo $IP_LOM | sed --unbuffered  "s/^.*\([0-9]\{1,3\}\)\.\([0-9]\{1,3\}\)\.\([0-9]\{1,3\}\)\.\([0-9]\{1,3\}\).*$/\1 \2 \3 \4/" | read line; printf "%x %x %x %x" $line )
13:16  koala_man: you can do something like  printf "%x\n" "$(head -n 1)"
13:16  pgas: jayeola: use more quotes [ -d "$var" ] and [ will behave just like  [[
13:16  hatten: yo, what is the nicest way to calculate the difference between two 'date's ?
13:16  hatten: eg, a while ago i saved 'date' in a variable
13:17  hatten: and i wanna how how long time it's passed since then
13:17  koala_man: store the time in seconds since the epoch and just subtract
13:17  hatten: s/how/know
13:17  pgas: stockholm: uh oh. you don't eed --unbuffered. use more quotes around "$IP_LOM" else everything will be on one line, whithout a loop,read only reads one line
13:18  stockholm:  ok
13:18  koala_man: and remember that .* is greedy
13:18  stockholm: right, good catch
13:19  stockholm: in this case read *should* only get one line, right?
13:20  pgas: yes, though you cannot do it like that
13:20  pgas: what's in IP_LOM?
13:20  stockholm: IP_LOM=$(getent hosts $HOST.lom.ash.spotify.net)
13:36  the_dark_warrio: I want to run a command conditionally based on the exit code of a command, for instance, `rm /` exits with 1. How can I test this?
--- Log closed Tue Nov 23 13:42:59 2010
--- Log opened Tue Nov 23 13:43:22 2010
13:43 --- Users 521 nicks [0 ops, 0 halfops, 0 voices, 521 normal]
13:44 --- Channel #bash was synced in 83 seconds
13:46 --- perlNUB is now known as h4x0r`
13:47  lhunath: the_dark_warrio: [ is a command you only use if you need to test files or strings.
13:47  lhunath: !tests
13:47  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
13:48  ChoHag: This is more of a tar question than bash but here goes - can you take the stdout of a command and put it as a named file in a tarball?
13:50  lhunath: another person confused as to what tar is.
13:50  lhunath: why would you want to tar a single file?  not even a file, a stream!
13:50  ChoHag: I don't, I want to tar many files.
13:50  ChoHag: But the first (or last) is the output of pg_dump.
13:50  lhunath: then create files and tar them.
13:51  ChoHag: And I don't see the point in an intermediate file if I can avoid it.
13:51  lhunath: mkfifo mydump; pg_dump > mydump & tar ...
13:52  ChoHag: If I'm going to do that I may as well just use a regular file.
13:53  lhunath: uh, not really.
13:53  lhunath: since you have no disk IO.
13:53  lhunath: but it all sort of depends on what you're trying to achieve.
13:54  lhunath: if you don't care about disk IO, sure, create a regular file.  but then what are you complaining about?
13:54  lhunath: syntax?  shrug.
13:59  ChoHag: Laziness mostly.
13:59  ChoHag: Don't want to have to rm at the end of the script.
13:59  ChoHag: Also knowing this place, they'll just get left lying around somehow.
14:00  lhunath: you put your cleanup in a trap on EXIT.
14:00  ChoHag: They'll still manage.
14:01  lhunath: anyhow; if you want that to be implicit, you can use syntax sugar <(pg_dump), but you don't get to choose the filename.  it'll be /dev/fd/63 or something, OS-dependant.
14:01  lhunath: it's the same thing as manually making the fifo; though, only done by bash internally.
14:04  pgas: you don't really need tar for just one file, I guess you only want to compress it
14:05  lhunath: he wants to add it to a tar of other files
14:05  pgas: ah
14:08  ChoHag: Basically it's a website with its configuration and a database dump.
14:08  ChoHag: And also an excercise in learning more things about tar.
14:09  hatten: why doesn't "trap { blah ; blah ; } SIGINT" work?
14:10  pgas: because you need only one argument before the singal
14:12  hatten: but I wanna do several things, do I have to do an alias or smthn then?
14:12  ChoHag: hatten: trap "foo; bar" SIGINT
14:13  lhunath: alias, dear god no
14:13  hatten: but the thing i wanna execute is pkill -f "sleep $1" and I cannot nest "s
14:13  lhunath: don't trap INT
14:13  lhunath: trap cleanup EXIT; cleanup() { pkill -f "sleep $1"; }
14:13  lhunath: also; don't do pkill.
14:13 --- Weust`afk is now known as Weust`
14:13  ChoHag: What's wrong with nesting "s?
14:14  ChoHag: backslash is your friend.
14:14  ChoHag: Except in the toilet.
14:14 --- Weust` is now known as Weust`afk
14:14  lhunath: sleep "$1" & sleepPid=$!; trap cleanup EXIT; cleanup() { kill $sleepPid; }
14:14  hatten: aha, didn't think it was possible to nest "s
14:14  lhunath: backslash is ugly and non-transparent.
14:14  ChoHag: Or use " outside and ' inside.
14:14  lhunath: I'd advice you to avoid it at all cost.
14:15  lhunath: preferably the other way around to avoid expansion gotchas.
14:15  ChoHag: backslash feels offended at being called ugly.
14:15  lhunath: trap "kill $sleepPid" EXIT; sleep 5 & sleepPid=$!    <- error.
14:15  hatten: but if i do sleep& var=$! the rest of the file won't wait for the sleep to finish
14:15  hatten: making it useless
14:15  lhunath: why?  $sleepPid was expanded when it was empty.  not when exiting.
14:16  lhunath: use '' EVERY TIME you need to quote bash code.
14:16 --- Weust`afk is now known as Weust`
14:16  lhunath: injecting variables into bash code is broken anyway
14:16  ChoHag: \$
14:16  ChoHag: There, fixed.
14:17  lhunath: backslashes are ugly and non-transparent.
14:17  ChoHag: With your friendly neighbourhood backslash.
14:17 --- Weust` is now known as Weust`afk
14:17  ChoHag: Your friendly attractive neighbourhood backslash.
14:18  lhunath: trap "kill \$sleepPid; rm \"\$(tempOf \\\"\$var\"\\\")\""
14:18  lhunath: fuck that.  backslashes suck.
14:18  lhunath: bug heaven
14:18  hatten: lhunath, if i background the sleep, the rest of the file won't wait for the sleep to finish
14:18  hatten: which makes it purpose worthless
14:19  lhunath: hatten: add wait.
14:19  hatten: ooh
14:19  ChoHag: Why are you backgrounding a sleep?
14:19  ChoHag: Isn't ALRM good enough?
14:19  lhunath: to get the pid
14:19  ChoHag: Can shell scripts use ALRM?
14:19  hatten: to be able to do 'sleep $1& var=$!'
14:20  lhunath: !pm
14:20  greybot: http://mywiki.wooledge.org/ProcessManagement
14:21  lhunath: ChoHag: I don't know; but I've never seen it done.
14:21  ChoHag: No wait, you're not trying to kill the script after X seconds are you?
14:22  pgas: ChoHag: ALRM doesn't help to sleep does it? backgrounding sleep can sometimes be useful as the shell will run the traps only when the foreground app ends. so if you kill a script that sleeps, the trap will be executed and the script will exit only when sleep has finished
14:22  ChoHag: Ignore me.
14:22  hatten: nope
14:22  hatten: i'm trying to kill the sleep command
14:22  lhunath: why?
14:23  hatten: in case i want to end the script before it have slept to the end
14:23  lhunath: ^C should do that; no need to kill the sleep command.
14:23  hatten: ^C kills the whole script
14:23  lhunath: you asked to end the script.
14:23  lhunath: you did.
14:23  hatten: i want stuff in the end of the script executed
14:23  lhunath: what's the problem?
14:24  hatten:  /\
14:24  hatten: 'stuff;sleep;stuff'
14:24  lhunath: do you mean, "I want to abort the sleep", or "I want to run some stuff when the script ends, no matter how it got ended"
14:24  hatten: when i ^C i want the second stuff executed
14:24  hatten: i want to abort the sleep
14:25  hatten: wait, gotta thikn
14:25  lhunath: trap : INT; echo stuff; sleep 5; echo stuff
14:25  hatten: blah, it's just a simple script to use when i take a nap to keep track of when i got up and when i got to bed, it's not that important
14:26  lhunath: trap : INT; echo stuff; sleep 5; echo stuff
14:26  hatten: it works to kill the sleep in trap
14:27  hatten: don't need anything more fancy than that
14:27  lhunath: yeah, but this is cleaner
14:27  hatten: not when you're gonna execute like 6 lines of code after the sleep
14:27  lhunath: interruptableSleep() ( trap : INT; sleep "$@" )
14:27  lhunath: why not?
14:28  hatten: ooh
14:28  lhunath: echo stuff; interruptableSleep 5; echo more stuff
14:28  hatten:  /me learns loads of stuff every time i go here
--- Log closed Tue Nov 23 14:34:50 2010
--- Log opened Tue Nov 23 14:35:09 2010
14:35 --- Users 527 nicks [0 ops, 0 halfops, 0 voices, 527 normal]
14:35  lhunath: no need for fancy trappery.
14:35  hatten: lol@good knight
14:35  ChoHag: Sorry. night.
14:35  lhunath: though you may want to kill $! after the read to turn off the alarm if you wake up early.
14:35  hatten: haha
14:35  ChoHag: My computer is called knight.
14:35  ChoHag: Bit of a braino there.
14:36 --- Channel #bash was synced in 84 seconds
14:37 --- Weust`afk is now known as Weust`
14:37  hatten: http://pastebin.com/bUG5rCHT
14:37 --- Weust` is now known as Weust`afk
14:41  hatten: I liked your idea lhunath, but there are several things i want to execute, regardless if i nap the time out or not, so it would be a little ugly
14:41  hatten: but thanks for all the help
14:43  catsup: you know you can just run 'date +%y.%m' which of course will work better in case the year changes in between those two commands :p
14:44  catsup: oh, no, you're running date thrice
14:44  hatten: oh, right
14:45  catsup: use read yearmonth logfmt <<<$(date +"%y.%m %e%t%T")
14:45  catsup: to use only one 'date' command
14:46  hatten: ooh
14:46  catsup: because of the third 'date', the script breaks 13 times a year instead of only 1
14:46  hatten: smart stuff
14:46  hatten: uhh, whut?
14:47  hatten: why would it ever break?
14:47  catsup: if the month changes in between the second and third 'date' call
14:47  catsup: or if the year changes in between the first and second 'date' call
14:47  hatten: yeah, then the log will be a little ugly
14:47  hatten: but i want it in the same logfile
14:47  catsup: then the log will be wrong
14:48  hatten: no...i sort after when the nap starts
14:48  catsup: well, the once-yearly breakage is very bad, because you end up going into january of the previous year
14:48  catsup: hatten, i am talking only of the calls to 'date' that are before the nap
14:49  hatten: aha
14:49  catsup: of course i realize these are very unlikely, why would you take a nap at new years?
14:49  hatten: haha
14:50  hatten: and i would have to do it at like 23:59:59 or smthn
14:50  catsup: yes
14:50 --- maxim is now known as Guest25252
14:50  catsup: right when everyone pops the champagne corks
14:50  catsup: which would surely wake you up
14:50  hatten: haha
14:51  consumerism: where could i read more about how this works
14:51  consumerism: : ${RSRC:="/var/www"}
14:51  catsup: consumerism: the 'parameter expansion' section of the bash info page
14:53  consumerism: what does the first : do catsup?
--- Log closed Tue Nov 23 14:59:13 2010
--- Log opened Tue Nov 23 14:59:36 2010
14:59 --- Users 531 nicks [0 ops, 0 halfops, 0 voices, 531 normal]
15:00 --- Channel #bash was synced in 82 seconds
15:04  ChoHag: Is there some mnemonic to help remember what % and # do in variable expansion?
15:04  catsup: ChoHag: #, being the character preceding comments, precedes the match
15:05  catsup: erm, i phrased that poorly, but you see the idea
15:06  catsup: actually % acts more like a comment :p
15:06  catsup: oh, also, % goes at the end of a number, and % matches at the end of the string
15:07  catsup: (i just made those up...)
15:08  catsup: meanwhile, # is what you would use to match an actual number in a percentage :p
15:08  catsup: wait what, no
15:08  catsup: :|
15:08  catsup: erm yeah, it would be, to remove the % sign
15:08  ChoHag: See? SEE?
15:08  ChoHag: Confusing.
15:08  catsup: haha
15:09  Bushmills: what is your keyboard layout?
15:09  catsup: ooh yeah, # is left of % on qwerty
15:09  Bushmills: if suited, you could memorize that ....  yes
15:10  catsup: that may well by why they chose those characters
15:10  ChoHag: Not GB qwerty.
15:10  catsup: 345 #$%  <-- # is at the beinning of $, % is at the end
15:10  ChoHag: And not dvorak.
15:10  Bushmills: still
15:10  catsup: what about your keyboard _labels_?  do they have 345/#$% on them?
15:11  Bushmills: # more to the left, removes from the left of string
15:11  evalbot: Bushmills: to: No such file or directory
15:11  evalbot: Bushmills: the: No such file or directory
15:11  evalbot: Bushmills: etc... ( http://pastebin.com/1qw5wSHK )
15:11  Bushmills: hehe
15:11  ChoHag: £$%
15:11  catsup: holy shit, evalbot pastebins results
15:11  catsup: evalbot++
15:11  ChoHag: # is over by enter, above shift.
15:11  evalbot: ChoHag: bash: is: command not found
15:12  catsup: ChoHag: you're just going to have to memorize them then :)
15:12  ChoHag: # ls /
15:12  evalbot: ChoHag: bin  dev  etc  lib  proc  root	tmp
15:12  ChoHag: tut tut
15:12  catsup: hmm
15:12  ChoHag: <hash> cat /etc/passwd
15:12  catsup: # head /etc/passwd
15:12  evalbot: catsup: root:x:0:0:root:/root:/bin/bash
15:12  ChoHag: Must ... not ... do ... it ....
15:13  catsup: i'm sure that evalbot is quite secure, running in a chroot, without write permissions anywhere, or such
15:14  catsup: # touch /tmp/ASDF; ls -l /tmp/ASDF
15:14  evalbot: catsup: -rw-r--r-- 1 root root 0 Nov 23 14:13 /tmp/ASDF
15:14  catsup: oh my
15:14  tvm: :D
15:14  catsup: # : dd if=/dev/zero of=/tmp/no_more_disk_space
15:14  evalbot: catsup: no output
15:14  steve___: it runs in a vm per session
15:14  ChoHag: Oh that's boring.
15:15  steve___: /msg evalbot to try and break it
15:15  ChoHag: # tail -n1 /etc/shadow
15:15  evalbot: ChoHag: tail: cannot open `/etc/shadow' for reading: No such file or directory
15:15  catsup: # id
15:15  evalbot: catsup: bash: id: command not found
15:15  tvm: # ulimit
15:15  evalbot: tvm: unlimited
15:15  ChoHag: # who is evalbot
15:15  evalbot: ChoHag: no output
15:15  tvm: >:D
15:16  catsup: # echo $EUID
15:16  evalbot: catsup: 0
15:16  tvm: evalbot: i will forkbomb j00!1
15:17  catsup: creating a vm per instance sounds expensive
15:18  steve___: !evalbot
15:18  greybot: evalbot runs each session in a new VM as root. Feel free to play with, or hack, the bot in #evalbot or look at it more closely on http://www.vidarholen.net/contents/evalbot/
15:18  tvm: yesh, but then again, that would be cheap :|
15:18  dagni: tvm: already tried that, it almost crashed :D
15:19  dagni: where almost is big diff ;))
15:19  tvm: yeah, no wonder :>
15:19  tvm: okay.
15:19  catsup: it would be really cool if it created a VM per nick, keeping up to a certain number around
15:19 * tvm pats evalbot and goes back to his mundane work
15:19  catsup: what is almost crashing?
15:20  dagni: the bot printed some kernel dump
15:20  dagni: ;D
15:20  catsup: the VM crashed?
15:20  nDuff: catsup, qemu supports copy-on-write storage (backed by unlinked inodes in throwaway cases like evalbot), so it's very very cheap
15:20  dagni: the bot owner admited that if it have more resources (ram, cpu) it would actually crash
15:20  dagni: ;D
15:21  nDuff: catsup, ...load a small prebooted RAM image and you don't have boot-sequence overhead either.
15:21  catsup: right
15:21  catsup: that reminds me of this OS...
15:22  catsup: http://qubes-os.org/Home.html
15:25 * catsup might start working now, too...
15:25  hatten: blasphemy, procrastinate some more
15:27  catsup: hatten: alright, i'm convinced
15:27  catsup: i wanted to finish this thing before thanksgiving but i think there's no way now
15:28  hatten: haha
15:28  catsup: so why bother doing anything?  :p
15:28  hatten: oh well, you could think like my mom, if you do it now you won't have to do it later
15:28  hatten: though that's no fun
15:51 --- jzacsh is now known as jzacsh_
15:51 --- jzacsh_ is now known as jzacsh
15:51 --- jzacsh is now known as jzacsh_
16:06  julius__: hi
16:07  julius__: ive added PYTHONPATH="somepath" to ~/.bashrc            but when i do source ~/.bashrc && evn |grep PYTH   i dont get any output?
16:08  nDuff: julius__, if you don't export it, it's just a shell variable, not an environment variable
16:09  nDuff: julius__, ...on a different tack, have you considered using virtualenv instead of playing with PYTHONPATH?
--- Log closed Tue Nov 23 16:20:33 2010
--- Log opened Tue Nov 23 16:20:51 2010
16:20 --- Users 541 nicks [0 ops, 0 halfops, 0 voices, 541 normal]
16:20 --- Server: [brown.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
16:22 --- Channel #bash was synced in 80 seconds
16:22  julius__: nDuff, thx
16:22  julius__: nDuff, yeah someone from python already suggested virtualenv.  but the PYTHONPATH solution looks like a very clean seperation
16:24 --- tarik_ is now known as tarik
16:24 --- faitz_ is now known as faitz
16:26  latenite: Hi folks, I have problem saving a variable. Somehow sed pulls an error and I dont know why.  http://pastie.org/1320261
16:27  greycat: "saving a variable" and "sed" can only mean you have a single command of the form   var=$(sed '...')
16:27  greycat: no idea why you'd need a pastebin site for that.
16:29  latenite: greycat, sorry I don't get it. Where does my $backupdir go in that?
16:29  greycat: you're assuming I clicked it
16:29  latenite: greycat, :) hmm ? want me to put it here?
16:29  Naib: var2=`echo ${backupdir} | sed 's/\//\\\//g'` 8 sed: -e expression #1, char 9: unknown option to `s'
16:30  greycat: ("clicked" is such a misleading term here... I'd have to double-click it, then drag the mouse over to the browser on the other display, then hit Ctrl-T on the keyboard to open a new tab, then middle-click on the mouse again to paste the URL)
16:30  greycat: Is he trying to convert all / in $backupdir into \/ ?  And if so, why?
16:30  latenite: greycat, yes thats my goal.
16:31  greycat: var2=${backupdir//\//\\\/}
16:31  greycat: But WHY?
16:31  greycat: Because your goal is probably the wrong goal...
16:31  julius__: while true; do ping -c 1  141.41.92.197; if $?; then date +%X; break; fi; sleep 10; done                why do i get:  -bash: /home/julius/bin/0: Permission denied     ?
16:32  greycat: Hmm, whoops, too many \ there.
16:32  Riviera: julius__: because $? evaluates to 0 and you have a file with the name 0 in your PATH
16:32  Riviera: julius__: which is not executable.
16:32  greycat: var2=${backupdir//\//\\/}
16:32  latenite: greycat, I want to a edit a file where a line looks liek that: snapshot_root	/data/backup/snapshots
16:32  Riviera: julius__: do a "help if" in an interactive bash session to see that if requires commands, not variables or numbers as conditions.
16:32  latenite: greycat, into snapshot_root	/new/path  WITH sed
16:33  greycat: Then use a different fucking DELIMITER!
16:33  julius__: Riviera, your right. everytime the while loop runs it creates the file 0......why?
16:33  greycat: sed "s#$path#$otherpath#"
16:33  greycat: So... fucking... stupid....
16:33  Riviera: julius__: i. e.: while sleep 10; do if ping -c ..; then date +%X; break; fi; done
16:33  Riviera: julius__: no, this loop does not create a file.
16:34  latenite: greycat, not IF path hast # in its name...
16:34  greycat: Then use | or , or ^ or & or WHATEVER THE FUCK YOU NEED
16:34  latenite: greycat, I try to make it most compatible
16:34  greycat: THEN DON'T FUCKING USE SED!
16:34  greycat: !ed
16:34  greybot: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
16:34  latenite: greycat, sane thing ?!!
16:34  greycat: *plonk*
16:34  julius__: Riviera, ah that version looks more sane
16:35  latenite: greycat, <greycat> var2=${backupdir//\//\\/} ?? is there a sed command missing?
16:35  Riviera: !pe > latenite
16:35  greybot: latenite: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
16:37  latenite: Riviera, sorry but I still dont have it right... var2=${backupdir//\//\\/} looks confusing without sed and results in an error here
16:39  Riviera: # var='one/two'; var2=${var//\//\\/}; echo "$var2"
16:39  evalbot: Riviera: one\/two
16:39  greycat: I already gave him that.
16:39  Riviera: greycat: yes, I know, I just wanted to prove that your PE works.
16:39  Riviera: latenite: Do you maybe not use bash?
16:39  greycat: Is he dead set on using sed and a / delimiter and calling it "portable"?  So be it.
16:40  greycat: I wash my hands of it.
16:40  Riviera: greycat: unsure, but he said the PE causes an error :)
16:40  greycat: I can't imagine why anyone would choose to use a / delimiter when working with Unix pathnames.
16:42  Riviera: Of the 1000 times people wanted this, I wonder if at least once it wasn't an attempt to solve problems with filenames containing whitespace.
16:42  latenite: Riviera, greycat, var2=${backupdir_escaped//\//\\/} worked fine Thanks
16:42  latenite: Riviera, what is making that modification if NOT sed? This look like magic
16:43  greycat: I don't think I have EVER written a bash script to "edit a file".
16:43  greycat: I don't understand why so many people are doing that.
16:43  latenite: greycat, to reuse it :)
16:44  latenite: greycat, How does  var2=${backupdir_escaped//\//\\/} work? It does the substitution BUT there is no sed call? how is that done internaly?
16:48  zplinux: how to pass --up "/etc/openvpn/up.sh ${VPNCONF}" in args ?
16:48  zplinux: I try : args="${args} --up \"/etc/openvpn/up.sh ${VPNCONF}\""
16:48  nDuff: zplinux, use an array
16:48  nDuff: !faq complex > zplinux
16:48  greybot: zplinux: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
16:48  greycat: !faq complex > zplinux
16:48  greybot: zplinux: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
16:49  Riviera: latenite: What did I let the bot give you the link to the parameter expansion reference?
16:49  Riviera: +for
16:49 --- pgas` is now known as pgas
16:50  pgas: Riviera! long time no see
16:51  Riviera: hey :)
16:52  KeiKurono: hello
16:52  kristian-aalborg: hi
16:53  KeiKurono: if i do a bash script that launch several processes on background how can i do that when script exit all child zombies are killed automatically? thanks
16:53  greycat: !pm > KeiKurono
16:53  greybot: KeiKurono: http://mywiki.wooledge.org/ProcessManagement
16:53  latenite: Riviera, I am reading it right now. But I still dont get that "expansion thing" *cry
16:53  greycat: If the children are *zombies* at the time the script exits, init will clean them up.
16:53  kristian-aalborg: looking to do another very simple script :)
16:54  greycat: If you mean "How can I take all my living children with me when I die", that's answered in the PM page.
16:54  kristian-aalborg: "when file is clicked, open it with this command"
16:54  greycat: Files can't be clicked.
16:54  greycat: Go talk to your window manager or desktop environment people.
16:54  greycat: (or whatever appliaction you're using that presents files in some sort of graphical context)
16:55  KeiKurono: i guess there isn't a simple command like KillChildrenOnExit ?
16:56  greycat: There is an entire answer in the ProcessManagement page written EXACTLY FOR THIS.
16:56  greycat: Including TWO examples!
16:56  KeiKurono: this? I'm trying  to kill -9 my job but blah blah blah
16:56  greycat: Down farther.
16:57 * nDuff bemoans the fate of the poor people who have to READ to get their answers.
16:57  KeiKurono: ah there it is, many thanks
16:57 * nDuff almost has enough caffeine in him this morning to get up to his regular level of snark.
16:57  kristian-aalborg: greycat: I could make a script that says "do this with file *.*" and then set my DE to associate it with the file, I think... it is the former that I'm trying to figure out
16:58  nDuff: kristian-aalborg, ...the typical way to tell a unixlike operating system what tool to open to deal with a file is with a shebang line
16:58  nDuff: kristian-aalborg, ...that said, you can't use a script itself as an interpreter, so that may not be ideal in this case.
16:59  greycat: kristian-aalborg: Find the support channel for whatever NON-BASH THING you are using.
16:59  greycat: Bash reads characters (lines) from a text stream.  It does not know anything about mouse events.
16:59  kristian-aalborg: hurm
17:02 --- SirLoins is now known as whaley
17:02  consumerism: in getopts, what is the default case? (no flags)
17:03  consumerism: *) ?
17:03  consumerism: doesn't seem to work
17:03  greycat: huh?
17:03  zplinux: in order to format this : args="${args} --up \"/etc/openvpn/up.sh ${VPNCONF}\""
17:03  greycat: zplinux: DO NOT STORE MULTIPLE ELEMENTS IN A SCALAR
17:03  zplinux: how to add the " sign ?
17:03  greycat: zplinux: YOU DON'T!
17:03  zplinux: assuming it is /bin/sh ?
17:03  consumerism: i want to do something if no flags are passed, i have a while getopts loop for all the possible flags, but don't know how to tell if there wre noo flags passed
17:04  greycat: args+=(--up "/blah $bleh")
17:04  consumerism: were no*
17:04  zplinux: greycat: ok ok
17:04  greycat: zplinux: This CANNOT BE DONE in Bourne shell.
17:04  greycat: Switch to Korn shell or Bash.
17:04  zplinux: min, I must use /bin/sh - in order to use array?
17:05  greycat: What part of what I said was unclear?
17:05  zplinux: ok, fine, got you
17:05  zplinux: this is a complex issue that can only be done using arrays
17:06  greycat: Or you could stop trying to put a command in a variable.
17:06  greycat: Just write... the... commmand!
17:06  zplinux: it is not a command
17:06  zplinux: its a var passed as an option
17:06  zplinux: there are arguments for openvpn - which is the command
17:07  greycat: if test -n "$foo" ; then vnpthing --up "/blah $foo" ; else vnpthing ; fi
17:07 * nDuff sighs
17:07  greycat: TA DAA!!
17:07  greycat: JUST.  WRITE.  THE.  COMMAND.
17:07  greycat: No need to fuck around with variables and shit.
17:07  nDuff: zplinux, using an array to pass arguments to OpenVPN works great
17:07  nDuff: zplinux, ...seriously, read the FAQ we linked you to.
17:07  greycat: nDuff: he believes that he needs to do this in Bourne or POSIX shell (he didn't say which)
17:07  zplinux: I did just now
17:08  zplinux: I am runing it in openvrc
17:08  zplinux: in gentoo
17:08  nDuff: Hrm. Still can be done in POSIX sh using set -- to append arguments, evil as that is
17:08  greycat: I have NO FUCKING IDEA why he believes he would be running this script on something that has VNP thingies but no shells from 1988 or later.
17:08  nDuff: greycat, indeed, it's silly -- OpenVPN requires all of SSL, which is not a small library
17:08  greycat: nDuff: hm...
17:08  nDuff: s/SSL/OpenSSL/
17:08  zplinux: ok ok
17:09 --- muellejo__ is now known as muellejo
17:10  nDuff: zplinux, ...and for that matter, you could just build a config file (dynamically or otherwise) were you inclined to do so.
17:10  zplinux: which is plan b for me
17:11  nDuff: ...for that matter, _usually_ the only items which need to be dynamic  in an OpenVPN config are the ones which can be done from hooks or a client-config-dir
17:11  nDuff: but that's getting off-topic here
17:14 --- abstract3d is now known as TzorvasAK
17:16  zplinux: is $# the number of arguments passed to a script?
17:16  greycat: yes
17:17  nDuff: well, it's the number of items in "$@", which is originally the number of arguments passed
17:18  nDuff: taking things off the list with shift, updating it with "set --", doing a function call (within which "$@" is the function's argument list), etc. will impact it.
17:22  _dave_h_d: i have a file with a few lines, these lines are like this ---> string_to_find:replacement_string
17:22  zplinux: well thanks , and bye bye
17:23  _dave_h_d: i want a command which goes through all the lines and uses this information to do string replacement in an arbitrary number of files
17:23  greycat: _dave_h_d: and you're giving this to your students for their homework?  Evil!
17:23  _dave_h_d: greycat:
17:23  _dave_h_d: no
17:23  _dave_h_d: so my question is
17:23  _dave_h_d: is there a command that can do it
17:23  _dave_h_d: like one liner
17:23  _dave_h_d: or
17:23  greycat: Sure, as soon as you write one.
17:23  _dave_h_d: do i need to write a shell script?
17:23  nDuff: _dave_h_d, FWIW, perl is probably the right tool for writing that command
17:24  _dave_h_d: greycat: cool
17:24  _dave_h_d: nDuff
17:24  _dave_h_d: how about using php?
17:24 * nDuff shudders
17:24  greycat: *cry*
17:25  greycat: Although I suppose I can take small comfort in the knowledge that this idea was spawned from a mind that had already been damaged by PHP.
17:25 * nDuff also thinks that a colon-separated file interface is bloody idiotic for that purpose
17:25  nDuff: _dave_h_d, ...how will you deal with strings to be replaced containing colons in them?
17:26  nDuff: _dave_h_d, ...I'd suggest taking the source / destination pairs on argv, since it sounds like the specification involves a fairly small number of them.
17:27  Zathraz: Hi. Given a directorypath /A/B/C/D/E/file how can I strip the first part of that path resulting only in say C/D/E/file please?
17:27  greycat: Zathraz: ${mypath#/*/*/}
17:28  kxsteve: when i run this: http://pastebin.com/uEg6NjVP all of my $OPTARG's are empty, what am I doing wrong? ./script.sh -l optiona -r optionb -s optionc
17:28  nDuff: !.sh > kxsteve
17:28  greybot: kxsteve: Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
17:29  _dave_h_d: nDuff: awk can help
17:29  _dave_h_d: anyway thans
17:29  _dave_h_d: thanks
17:29  kxsteve: nDuff: ok, that helps in a different way
17:29  nDuff: kxsteve, ...there's a FAQ on command-line parsing; I'm hunting for it.
17:29  greycat: !faq easily
17:29  greybot: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
17:30  Zathraz: ty greycat but I am not always sure that C is followed by 2 dir levels. Can I use a regex for that in the construction you provided?
17:30  greycat: !b2
17:30  greybot: bashphorism 2: The questioner will keep changing the question until it drives the helpers in the channel insane.
17:30  greycat: What is your NEW question?
17:31  Zathraz: ok. /A/B/C/D/E/F/file.txt ---> I Know C is always the third directory in the path, but it is variable how many directories will follow
17:31  greycat: Are you stupid?
17:31 * nDuff doesn't see a question there
17:32  Zathraz: so I want everything after C regardless what it is
17:32 * nDuff sighs.
17:32  greycat: It does not MATTER how many path components FOLLOW c.
17:32  nDuff: Zathraz, did you test whether the answer you were already given does that?
17:32  nDuff: # mypath=/A/B/C/D/E/F/file.txt; echo ${mypath#/*/*/}
17:33  evalbot: nDuff: C/D/E/F/file.txt
17:33  greycat: Is there a bashphorism for "The newbie won't accept the answer you give, no matter how right it is" yet?
17:33  Bushmills: # file="/A/B/C/D/E/F/file.txt"; echo ${file#*/C/}
17:33  evalbot: Bushmills: D/E/F/file.txt
17:33  Zathraz: no. I just saw only one variable filled that's why I doubted the correctness of the answer. Sorry for that
17:34  Zathraz: ah. nice one
17:34  Zathraz: ty
17:34  nDuff: Zathraz, the globs in that PE match from the beginning, not from the end
17:34  nDuff: !pe > Zathraz
17:34  greybot: Zathraz: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
17:34  greycat: !learn b18 The newbie will not accept the answer you give, no matter how right it is.
17:34  greybot: OK, greycat
17:35  kxsteve: nDuff: have you seen the pastebin I posted?
17:38  nDuff: kxsteve, "$@" is the arguments to the parseInput function, not the arguments to your script
17:38  nDuff: oh, n/m
17:38  nDuff: hmm.
17:40  nDuff: kxsteve, several things wrong. For one, anything with an argument needs a colon after it
17:40  nDuff: kxsteve, so, since -l, -r and -s all take arguments, your getopts string is wrong
17:40  nDuff: kxsteve, (likewise, since h _doesn't_ take an argument)
17:40  nDuff: !varcap > kxsteve (yes, this is actually part of your problem)
17:40  greybot: kxsteve (yes, this is actually part of your problem): By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
17:41  nDuff: kxsteve, ...don't use $OPTION...
17:41  kxsteve: hah, you've corrected that already; i had the optargs " " section incorrect
17:41  kxsteve: I needed to specify ":l:r:s:h"
17:41  nDuff: between that and switching from OPTION to opt, it works fine for me.
17:43  casualuser: hello for all )
17:43  casualuser: I need help with bash scripting
17:43  greycat: !guide > casualuser
17:43  greybot: casualuser: http://mywiki.wooledge.org/BashGuide
17:43  nDuff: !ask > casualuser
17:43  greybot: casualuser: You need not ask permission to ask a question. Just ask and be patient. http://mywiki.wooledge.org/NetEtiquette
17:44  Bushmills: he didn't actually ask for permission
17:44  Bushmills: he just stated something. like "I'm going to have a cup of tea"
17:45  kxsteve: nDuff: thanks for the help (again)
17:45  casualuser: please suggest me how to cut off filename from string like "c:\program files\internet explorer\iexplorer.exe"
17:45  greycat: !basename
17:45  greybot: basename(1) can strip the directory and extension from a path. (a/b/c.d -> c.d or c). Or you can use a parameter expansion: "${path##*/}" or "${path%.*}"
17:46  casualuser: greycat, basename works well for regular slashes but return just dot with slashes
17:46  greycat: Or you can use a parameter expansion.
17:46  casualuser: I've tried to parce string with awk but stack with some kind of error (
17:47  greycat: We did not recommend awk.
17:47  casualuser: hmmm, let me look closer to parameter expansion
17:47  greycat: !pe
17:47  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
17:55  casualuser: greycat, thx a lot )) finally it became as simple as one char but I've spent about two hours with awk, sed and google making me crazy. thx a lot once again )
18:02 --- Vorpal_ is now known as Vorpal
--- Log closed Tue Nov 23 18:08:13 2010
--- Log opened Tue Nov 23 18:13:34 2010
18:13 --- Users 537 nicks [0 ops, 0 halfops, 0 voices, 537 normal]
18:14 --- Channel #bash was synced in 86 seconds
18:16  VectorX: im trying to find files larger than 5Gb, using "find / -size +5G -ls" but it doesnt seem to be working, is the syntax wrong ?
18:17  greycat: you'd have to check your manual to see if 5G is recognized by your find command
18:17  greycat: it's not standard
18:18  VectorX: what the standard way of saying 5G?
18:19  greycat: 5368709120c
18:19  greycat: Also, maybe your find command can't handle files over 2 GB.  *shrug*
18:20  VectorX: centos 5
18:23  VectorX: im waiting for like 10 mins with no results, just get two /proc.../fd/4's and its sitting there
18:24  Naib: well try with a small filesize 1st to ensure the syntax is correct
18:24  Naib: that or you don't have any files larger than 5G
18:24  greycat: Do not let it recurse into /proc or /sys.
18:24  VectorX: +1368709120c  gives results right away
18:25  greycat: Make a 5.1GB file in /tmp and do it from /tmp.
18:25  VectorX: is there a quick way to make a file that big
18:33  nDuff: VectorX, if your operating system supports sparse files, sure -- tell dd to seek that far in and then write a single block
18:34  Lufti: does anyone have a link to an article about bash variable and naming conventions?
18:35  greycat: !varcaps
18:35  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
18:35  Naib: s/operating system/filesystem/
18:37  Lufti: greycat, thanks!
18:37  Lufti: greycat, what about functions?
18:37  greycat: What's the question?
18:37  Lufti: What is the convention to choose function names.
18:38  greycat: Same as in any other programming language.
18:38  Lufti: upper camel style? ;)
18:39  sPiN: howdy chaps, I want to make a csv file with hostnames and the servers system time.. for starters, is anything morally or ethically wrong about the way I am doing this? >> ssh server 'printf "%s\n" "$(hostname),$(date +%Y,%B,%d,%T,%Z)"'
18:39  Lufti: doAnything(), do_anything()
--- Log closed Tue Nov 23 18:44:46 2010
--- Log opened Tue Nov 23 18:45:10 2010
18:45 --- Users 540 nicks [0 ops, 0 halfops, 0 voices, 540 normal]
18:46  sPiN: sles10 2.6.16
18:46 --- Channel #bash was synced in 85 seconds
18:48 --- Elvashi is now known as Textmode
18:51  sPiN: i see.. i need to watch for exit code 255 from ssh
18:51  greycat: Any non-zero.
18:52  sPiN: well ssh returns 255... anything else would be the error code of whatever cmd i sent
18:56  mehwork_: how do you prompt someone with 'overwrite: [y/n]' and store their answer in a variable?
18:57  mehwork_: i know you use read -p somehow but not sure how it gets in the variable
18:59  erUSUL: read -n 1 -p 'overwrite: [y/n]' var
18:59  mehwork_: thanks
19:07  EvilPhoenix: hey how can I use a timer in a BASH script to run commands for a certain amount of time then kill the script and the process of running the commands?
19:08  cthuluh: !faq timeout > EvilPhoenix
19:08  greybot: EvilPhoenix: http://mywiki.wooledge.org/BashFAQ/068 -- How do I run a command, and have it abort (timeout) after N seconds?
19:15  EvilPhoenix: cthuluh, thanks much
19:19 --- taylanub is now known as taylan
19:21 --- taylan is now known as taylanub
--- Log closed Tue Nov 23 19:44:50 2010
--- Log opened Tue Nov 23 19:45:10 2010
19:45 --- Users 533 nicks [0 ops, 0 halfops, 0 voices, 533 normal]
19:46 --- Channel #bash was synced in 81 seconds
19:55 --- boaz_ is now known as boaz
20:01 --- TzorvasAK is now known as abstract3d
20:11  dyek: Hi! Given a list of file paths in pipe, I want to execute 2 lines of commands. (1) Echo the path name to appear in the final output (2) Execute zcat path name and pipe it to grep and make this output under its file name. What is the most elegant way to do this without a script file?
20:12  greycat: !faq 1
20:12  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
20:13 --- srcerer_ is now known as srcerer
20:14  dyek: greycat: Are you sure that the FAQ addresses the issue of having a pipe between zcat and grep and yet having output from (2) to be synchronized with (1) -- i.e., the grep output is under the file path from (1)?
20:15  greycat: I see too many words.  They make no sense.
20:16  MrWGW-: is there an option for cd whereby if you inadvertantly punch in the name of a file, it will, instead of puking, take you to the directory under that file?
20:17  pgas: no
20:17  greycat: You could write a wrapper function.
20:17  MrWGW-: that would be useful because I'm writing a script that processes filenames
20:18  MrWGW-: but now due to a change in requirements it needs to move those files to another directory below the directory in which they're kept
20:18  MrWGW-: so right now the files it deals with are in /a/b/, i.e. /a/b/1.txt, /a/b/2.txt and so on
20:18  MrWGW-: and it needs to move them to /a/c/
20:19  MrWGW-: what do you think the best way to deal with this is?
20:19  greycat: mv "$f" ../c   # and then check the exit status of mv
20:19  greycat: I'm assuming you're *in* /a/b at the time.
20:19  MrWGW-: right but I'm not in the /a/b directory neccessarily when the script runs
20:19  MrWGW-: I'm rather in my ~
20:19  greycat: You can cd in a script.  I'd strongly recommend it in most cases.
20:19  MrWGW-: right and that takes us full circle back to my initial question
20:20  MrWGW-: because I'm dealing with filenames
20:20  MrWGW-: but I might also be passed a directory
20:20  MrWGW-: I could do some elaborate parsing of the path I'm given but I'd rather write a wrapper for cd
20:20  greycat: if [[ -f "$f" ]]; then cd "${f%/*}"; elif [[ -d "$f" ]]; then cd "$f"; fi
20:20  dyek: MrWGW: Check if the file doesn't exist, take the output of `ls */filename` and hope that you get just one filename, instead of more than one. Then do what you want with the file.
20:20  MrWGW-: whereby it would try to cd to that path and if it failed, it would cd to what was beneath that
20:20  MrWGW-: greycat: awesome
20:21  greycat: You people make this stuff so fucking HARD.  Just do it.
20:28  MrWGW-: hmmm greycat your script does not in fact seem to work I fear
20:28  greycat: I didn't write a script.  I wrote a couple commands that you can adapt as needed.
20:30 * nDuff notes that "does not work" is not particularly useful.
20:30  nDuff: # function c() { if [[ -f "$f" ]]; then cd "${f%/*}"; elif [[ -d "$f" ]]; then cd "$f"; fi; }; mkdir -p foo/bar; touch foo/bar/baz; c foo/bar/baz; echo $PWD
20:30  evalbot: nDuff: /root
20:30  greycat: or if you choose to put it in a function and want that function to be named `cd', you would use `builtin cd' internally.
20:31  MrWGW-: sorry about that I had a phone call
20:31  nDuff: # function cd() { if [[ -f "$1" ]]; then cd "${1%/*}"; elif [[ -d "$1" ]]; then builtin cd "$1"; fi; }; mkdir -p foo/bar; touch foo/bar/baz; cd foo/bar/baz; echo $PWD
20:31  evalbot: nDuff: /root/foo/bar
20:31  MrWGW-: I realize that was rather unhelpful
20:31  MrWGW-: what I tried to do was just call it by itself as a standalone
20:31  MrWGW-: with f=$1
20:31  MrWGW-: I went #!/bin/bash; f=$1; your thhing
20:32  catsup: lol
20:32  greycat: !faq change dir
20:32  greybot: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
20:33  MrWGW-: oh yeah I see how I fucked that up
20:34  MrWGW-: stupid question: is cd a  built in?
20:34  greycat: yes
20:34  greycat: # type cd
20:34  evalbot: greycat: cd is a shell builtin
20:34  MrWGW-: ok
20:35  MrWGW-: so yeah sorry about that
20:45  catsup: i'm reading this old paper by dijkstra where he predicts that by the end of the 70s, computer systems will be 'virtually free of bugs'
20:46  catsup: heheheheh
20:46  mehwork_: how can i have chown not follow symlinks when i use -R
20:46  greycat: it... doesn't
20:47  juanmabcirc: then there is no need for pencils and erasers
20:47  pigdude: mehwork_: also, find . -not -type l will find files that are not links
20:47  catsup: mehwork_: remove the -L option
20:47  catsup: oh
20:47  catsup: you can also add -P
20:48  greycat: chown does NOT follow symlinks with -R, so the question is why does he THINK it does?
20:48  catsup: type 'info coreutils traversing'
20:49  catsup: greycat: i'm not interested in that question
20:49  greycat: Then what question are you answering?
20:49  Aitrus41: I'm trying to write a simple script that checks to see if the entered number is between 1-3 digits long. Can someone help me tweak the line so it works properly?  http://pastie.org/1320893
20:49  greycat: Aitrus41: first check that it's actually all digits.  Then just check whether it's >= 1 and <= 999
20:50  Aitrus41: I'm a noob... can you show me how you'd do it?
20:50  greycat: !faq valid
20:50  greybot: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
20:50  Aitrus41: Please and thank you
20:51  mehwork_: greybot: i dont think it does, i just dont know if it does, man page didnt say
20:51  mehwork_: but thanks for letting me know it doesn't which indeed is the answer. i'd rather not get find involved
20:51  greycat: CHRIST
20:51  greycat: *plonk*
20:52  catsup: mehwork_: type 'info coreutils traversing'
20:52  greycat: !tiaw
20:52  greycat: !tias
20:52  greybot: Try It And See
20:52  greycat: Waste our fucking time... on something he didn't even fucking TRY...
20:52  mehwork_: jeez :(
20:53  catsup: Aitrus41: your script is fine, you just need to use =~ instead of =
20:53  greycat: =~ is *so* overkill for checking for all-digits
20:54  catsup: well, true
20:54  catsup: but it accomplishes what he wants in one line
20:54  greycat: So does the regular = test.
20:54  catsup: huh?
20:55  greycat: And what's so great about single-line programming?  It makes things harder to read.
20:55  greycat: [[ $input = *[^0-9]* ]] && echo "Input must be numeric"
20:55  greycat: ((input < 1 || input > 999)) && echo "Input must be between 1 and 999"
20:56  greycat: With two separate tests, you get to give more USEFUL errors.
20:56  catsup: eh
20:56  catsup: this point is pointless, but anyway i was just confused
20:56  catsup: nm
20:58  matthiasgorgens: hi.  i am trying something like "rm $(find . -iname <some-pattern> -print0)" but I am having problems when the filenames contain whitespace.  what's the solution?  thanks!
20:59 --- Marchitos is now known as Marchino
20:59  catsup: matthiasgorgens: find ... | xargs -0 rm
20:59 --- Marchino is now known as Marchitos
20:59  taylanub: no, -exec
21:00  catsup: exec will call 'rm' for every file
21:00  taylanub: {} +
21:00  matthiasgorgens: ok.
21:00  matthiasgorgens: sounds good.
21:00  greycat: !find > matthiasgorgens
21:00  greybot: matthiasgorgens: http://mywiki.wooledge.org/UsingFind
21:00  matthiasgorgens: and i guess xargs is the common solution.
21:00  taylanub: no
21:00  willdye: !quotes
21:00  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
21:00  greycat: xargs -0 is available on some systems where -exec + is not
21:01  catsup: wow, i didn't know about {} +
21:01  willdye: !quotes > matthiasgorgens
21:01  greybot: matthiasgorgens: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
21:01  taylanub: find ... -exec rm {} +
21:01  taylanub: and i think quotes around {}
21:01  willdye: matthiasgorgens: Details about that sort of issue are discussed in the FAQ, which is referenced in the channel topic.
21:01  matthiasgorgens: ok, thanks.  i guess i'm served. :o)
21:01  Aitrus41: greycat: thank you
21:01  catsup: you don't need quotes around {} in bash
21:01  Aitrus41: greybot that is
21:01  taylanub: catsup: that's so unrelated to bash...
21:01  catsup: taylanub: no, it's bash that parses the quotes
21:02  catsup: # echo {} "{}"
21:02  evalbot: catsup: {} {}
21:02  greycat: Putting quotes around {} is a csh-ism.
21:02  catsup: in some other shell, maybe you need quotes around {}
21:02  taylanub: i meant that 'find' might field-split what {} turns into, but that was stupid from me...
21:03  taylanub: double quotes wouldn't change a thing either in that case
21:03  taylanub: (in fact it was totally senseless, sorry)
21:04  willdye: taylanub: FWIW, anymore I just use xargs instead of -exec.  xargs is the better option in certain cases, and in the remaining cases -exec offers few advantages.
21:05  taylanub: why is xargs better?
21:05  willdye: I feel the same way about '[['.  There's not much reason to even bother with '[', IMO.
21:05  ManDay: What is the diff between   echo abc | ( cat )   and   echo abc >( cat ) ?
21:05  greycat: that's hardly a comparable case
21:05  greycat: ManDay: the former has redundant parentheses, and the latter sets up a named pipe or a /dev/fd/* thingy, plus a background job
21:06  taylanub: willdye: when and how is xargs better?
21:06  greycat: maybe he means GNU xargs's parallel thing
21:06  ManDay: greycat: so the former pipes to cat and the latter sets up a named pipe and thats all?
21:07  willdye: taylanub: look at the man page of xargs, and think of what it would take to do the same thing with exec.  --interactive and the GNU parallel thing (as greycat noted) are both good examples.
21:07  greycat: Jesus.
21:07  willdye: yes it can be done with -exec, but since i'm using xargs a lot anyway, it's easier for me to just forget about the proper usage of -exec, and use xargs for everything.
21:08  greycat: The former sets up a pipe, and two child processes, and in the second one, your explicit and stupid use of ( ) may force a *third* child for no reason... or maybe bash is smart enough to optimize them away.  In any case, you have a class anonymous pipe between two procs.
21:08  greycat: The latter sets up a named pipe OR uses a kernel /dev/fd/* thingy, and runs cat in the background as a child, then runs echo in the *foreground* (in the current shell context, NOT in a child), with redirections applied.
21:08 * catsup hugs greycat 
21:08  geirha: willdye: Also, you limit yourself to GNU systems.
21:08  catsup: greycat: you don't have to answer every question you know :)
21:08  geirha: -exec + is posix
21:09  willdye: catsup: no touchie the kitty.  he has claws.  and teeth.  and nukes...
21:09  greycat: *new* posix
21:09  greycat: OpenBSD 4.8 still doesn't have it...
21:09  catsup: but surely the first thing one does after logging into an openbsd box is always to install gnu coreutils
21:10  geirha: Yeah that sux
21:10  geirha: s/x/cks/ #yikes
21:11  catsup: (erm, xargs is in findutils, but i'm just trolling^Wjoking)
21:22  sgfgdf: hello guys, what tool should i use to get the matches of regular expression? e.g. have file with text and want to find every . in the file and then count how many are they.
21:22  hatten: grep?
21:22  greycat: tr -dc . < file | wc -c
21:22  catsup: grep -c
21:23  hatten: though grep -c will fail if there are several per row
21:23  catsup: grep -c counts matching lines, not total matches, which nothing will count for regexes
21:23  catsup: since in general there may be infinite matches of a regex
21:24  sgfgdf: i should apply regular expression. i actually will not search for dot.
21:24  greycat: !b1
21:24  greybot: bashphorism 1: the questioner's first description of the problem/question will be misleading.
21:24  greycat: Fuckers.
21:24  catsup: sgfgdf: a regex like ".*" will match every substring in a line, you know...
21:25  sgfgdf: the dot was an example.
21:25  greycat: Of course he won't tell us what he IS doing, so that we can't POSSIBLY answer the question.
21:25  sgfgdf: another find each digits.
21:25  catsup: i figured he didn't want to match .
21:25  greycat: tr -dc 0-9 | wc -c
21:26 * greycat waits for !b2
21:26  catsup: omg
21:26  sgfgdf: greycat: because it is a bit complicated and i thought that it will look like i want everything done by someone else. thats why i asked the question simplified.
21:26 * catsup can't wait
21:26  catsup: !b2
21:26  greybot: bashphorism 2: The questioner will keep changing the question until it drives the helpers in the channel insane.
21:26  catsup: lol!
21:27  greycat: sgfgdf: well, I've answered your first two.
21:27  hatten: poor sgfdgf :D
21:27  sgfgdf: greycat: does the tr supports regular expressions?
21:27  greycat: No.
21:28  greycat: NOW ASK THE *REAL* FUCKING QUESTION OR SHUT UP.
21:28  rsca: Given a variable t that would match the regexp /^\d+.*?/, how could one get at the numeric part with bash string tinkering (${t##...}, ${t%...} etc) only?
21:29  greycat: !learn cult The Cult Of The Regex.  This eldritch brotherhood is dedicated to the dogma that Every Problem Must Be Solved By A Regular Expression, Preferably A PCRE.  They will invent ludicrous problems whose only feasible solution is a regular expression, driving all men mad.
21:29  greybot: OK, greycat
21:30  greycat: rsca: number=${variable%%[^0-9]*}
21:30  rsca: Cool, thanks :)
21:31  sgfgdf: greycat: i should count how many time i found three identical characters that are word. e.g. "example text fff, from me hhh. tttm." should match "fff", "hhh". and then i should count the results.
21:32  greycat: This is homework, rightr?
21:32  matthiasgorgens: "catsup: since in general there may be infinite matches of a regex" -> really?  i can see how there are many matches, but an infinite number?
21:32  greycat: Fuck, you can't even solve that with classical REs anyway.  You need backreferences.
21:33  greycat: matthiasgorgens: if the input length is unbounded...
21:33  matthiasgorgens: greycat, ok.  but that's cheating. ;o)
21:33  greycat: matthiasgorgens: no, it's actually the standard way of expressing things in computer science, which is at its heart a branch of mathematics
21:34  greycat: sgfgdf: Your teacher's in that Cult.
21:34  gniourf_gniourf: please don't inslut mathematicians
21:34  ska: Is there a clever way to get exit status of command into varialbe? Do I have to use $?
21:34  matthiasgorgens: greycat, you should use asymptotics then. ;o)
21:34  gniourf_gniourf: *insult
21:34  greycat: ska: if you need the actual value, as opposed to simply *acting* on whether it's >=0 then yes, you must use $?
21:35  sgfgdf: greycat: is it possible to do it?
21:35  ska: I just need to act: if [ some command ] then
21:35  greycat: sgfgdf: Your teacher has invented one of those ludicrous problems with no feasible solutions except ones involving PCREs/.
21:35  greycat: ska: remove the [ ]
21:35  greycat: if some command; then ...
21:37  sgfgdf: greycat: the problem is of the repeating character or that the match should be a word?
21:37  greycat: The repeating-character part is what forces you out of the realm of classical regular expressions.
21:38  cham: Hi all, can anyone help me ? i'd like to extract the kbps values from this output. Please help http://pastebin.com/FW03iGY3
21:38  ska: ok.. i see it now.. thanks.
--- Log closed Tue Nov 23 21:44:41 2010
--- Log opened Tue Nov 23 21:45:01 2010
21:45 --- Users 546 nicks [0 ops, 0 halfops, 0 voices, 546 normal]
21:45 --- Server: [holmes.freenode.net] [freenode-info] channel flooding and no channel staff around to help? Please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
21:46 --- Channel #bash was synced in 86 seconds
21:46  sgfgdf: greycat: will try to find something to do it. thanks for the help!
21:47  TiCPU__: what is the best method to output a link's location, like $(stat -c '%N' /proc/1/exe)  or $(ls -l /proc/1/exe )   I want to get "/sbin/init" as output without using sed if possible (I know how to do it already, just not readable)
21:47  greycat: readlink
21:47  TiCPU__: oh wow.
21:47  greycat: (not a standard command; it's a standard syscall)
21:48  greycat: !faq target
21:48  greybot: http://mywiki.wooledge.org/BashFAQ/029 -- How can I display the target of a symbolic link?
21:48  TiCPU__: /bin/readlink exists here:)
21:48  sgfgdf: thanks to the others taht helped too!
21:48  TiCPU__: thank you greycat
21:48  geirha: You can do it without regex of course; iterate each word, then check with an extglob + length of word.
21:49  geirha: err no, rather length of word + remove all occurances of first char and check length of that.
21:50  greycat: huh?
21:50  greycat: Even with an extglob, how are you going to match hhh but not fffq?
21:51  greycat: Anyway, I told him every step of the solution except actually writing the PCRE.
21:57  ska: Can I add an item to a list of words?
22:00  geirha: greycat: Yeah, I didn't think the extglob through, but removing all occurances of the first char and then test if it's empty should work
22:01  nDuff: ska, list+=( "item" )
22:01  nDuff: ska, presuming that by "list" you mean "array"
22:03  peque: hi there :)
22:05  peque: how can I copy the user folders (documents, desktop, public, music, images, etc.) excluding those which are empty and not copying other hidden folders as ~/.config and so...?
22:05  peque: thanks in advance for your help :)
22:05  greycat: cp */ /destination; rmdir /destination/*/ 2>/dev/null
22:05  greycat: The rmdir will remove all the empty ones.
22:06  peque: and */ will exclude empty folders?
22:06  greycat: Unless you enabled dotglob or similar.
22:06  greycat: echo */   and see.
22:06  peque: thanks for your help greycat :)
22:06  nDuff: peque, rmdir will fail against nonempty folders
22:06  nDuff: peque, so it's not that the */ excludes them, but that rmdir won't actually follow through
22:07  peque: hmmmmm
22:07  peque: I get it
22:07  pozican: what's the best way to append a string to the end of a file only if it doesn't already exist in that file? is it a for with a $(cat file | grep)??
22:07  pozican: an if* rather
22:07  nDuff: pozican, why would you want to substitute in output from grep as part of your command, rather than checking its return status?
22:07  greycat: grep || echo
22:08  nDuff: !uuoc > pozican (also)
22:08  greybot: pozican (also): Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
22:08  pozican: grep returns 1 if it doesn't find anything?
22:08  pozican: nDuff: it's a bad habit
22:08  nDuff: pozican, correct.
22:08  pozican: nDuff: I know better >.< really
22:08  nDuff: pozican, ...also see grep -q, which returns early if it finds a match rather than needing to scan the rest of the file
22:08  pozican: thanks
22:08  pozican: I'll investigate
22:13  pozican: !if
22:13  greybot: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
22:16  pozican: nDuff: Looks like redhat's grep's -q is for quiet, but this isn't going to be a huge file anyway
22:17  nDuff: pozican, yes, it _is_ for quiet
22:17  pozican: nDuff: when we talk about the 'standard' grep, that's the posix grep?
22:17  nDuff: pozican, why would a grep that isn't going to emit any output read past the first match?
22:17  nDuff: pozican, ..."quiet" enables optimizations. :)
22:17  pozican: nDuff: doens't that just supress the output? not stop searching when it finds one?
22:17  pozican: oh
22:17  pozican: I see
22:17  greycat: -q is in POSIX
22:17  pozican: nDuff: don't I feel like the dolt
22:18  pozican: nDuff: if it's not printing anything; just doing return codes, of course it won't read the whole file
22:22 * hashashin nas
22:23  crubovich: ку
22:23  crubovich: ку ку
22:23  greycat: English, please.
22:24  crubovich: hello)
22:27  crubovich: all death?
22:28  stockholm: no, all dead
22:29  crubovich: am from Togliatti
22:34 --- Muzer is now known as MuzerAway
22:48  sven_oostenbrink: Bash keeps a log of commands, which I can recall with the arrow keys, CTRL-R, etc... Im going to execute various rm filename commands and I don't want them in the command history.. is there a command, key combination, or whatever, with which I can disable the history?
22:49  poisonbit: !HIST_IGNORE
22:49  sven_oostenbrink: poisonbit: I type that?
22:50  misaochankun: No, I think the bot is asleep on the job.
22:50  greycat: The bot ignores any factoids it doesn't know.
22:50  misaochankun: That too.
22:50  poisonbit: export HISTIGNORE='ignorespace'   # then start commands by a space
22:51  sven_oostenbrink: poisonbit: ah! gottit!
22:51  poisonbit: and hope the sysadmin doesn't use other logging tools
22:51  tvm: as the history file isn't considered as a 'logging tool' at all
22:51  tvm: ;)
22:52  greycat: !faq losing
22:52  greybot: http://mywiki.wooledge.org/BashFAQ/088 -- How can I avoid losing any history lines?
22:52  misaochankun: locking the history file from writes works too in a pinch.
22:52  poisonbit: i mean things like snoopy
22:53  sven_oostenbrink: poisonbit: Im the admin on this machine (its my own laptop)
22:53  sven_oostenbrink: the idea is not to have rm filename commands in the history which I might accidentally execute
22:53  tvm: heh.
22:53  poisonbit: :)
22:53  misaochankun: Seems like a broad solution for that.
22:54  sven_oostenbrink: Not something that really happens or anything, more of a "just to be sure"
22:54  tvm: that wouldn't help me.
22:54  tvm: i just installed debian on this laptop i got from my work.
22:54  tvm: and ALMOST rm'd /
22:54  tvm: like 20 minutes after install
22:55  sven_oostenbrink: almost...
22:55  tvm: turned out that there is some stupidity override
22:55  gniourf_gniourf: I thought this kind of operation was blocked on Debian
22:55  tvm: yeah, i didn't know
22:55  poisonbit: ${1[${#1[@]}]}: bad substitution   # how can I emulate "last" ?
22:55  greycat: huh?
22:55  poisonbit: the last element of an array
22:56  greycat: !penultimate
22:56  greybot: The penultimate (second-to-last) argument of your script is "${@:(-2):1}". The ultimate (final) argument is "${@:(-1)}".
22:56  poisonbit: thanks
22:57  tvm: well, but i felt quite stupid as i proceeded to "ls /"
22:57  sven_oostenbrink: tvm: thats why its called a stupidity override :)
22:57  tvm: yeah, i guess so.
22:57  sven_oostenbrink: Anyway, works flawlessly! thanks all!
22:58  sven_oostenbrink: exit
22:58  RAWRjar: How do I properly "echo" to stderr? I tried 1>&2 but it's not working
22:58  MrWGW-: hey there
22:58  MrWGW-: got one more question; how do I put double quotes within double quotes?
22:58  MrWGW-: here's what I'm specifically trying to write
22:58  nDuff: RAWRjar, echo foo >&2 does work.
22:59  MrWGW-: "sourcepath=$sourcepath; mv '$sourcepath $(dirname ($dirname $sourcepath))/holding'"
22:59  yitz_: RAWRjar: echo blah 1>&2   and if it doesn't work you're testing it wrong
22:59  greycat: 1>&2 and >&2 both work.
22:59  nDuff: RAWRjar, ...if it doesn't work for you, be more specific about what you're trying and how you know it doesn't work.
22:59  MrWGW-: but the part in between ' ' obviously needs double quotes
22:59  MrWGW-: I just need to figure otu how to put it in double quotes, in double quotes
22:59  greycat: MrWGW-: What you've written makes NO sense at all.
22:59  nDuff: !faq complex > MrWGW
22:59  greybot: MrWGW: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
22:59  MrWGW-: err that's cuz it got truncated
22:59  MrWGW-: hang on
22:59  greycat: MrWGW-: mv "$s" "$(dirname "$(dirname "$s")"/holding)"   perhaps?
23:00  MrWGW-: ssh $SOURCEHOSTUSER@$SOURCEHOST "sourcepath=$sourcepath; mv '$sourcepath $(dirname ($dirname $sourcepath))/holding'"
23:00  RAWRjar: ytiz: I am writing a subversion hook, and stuff echoed to STDERR is sent back to the client. The hook is working, but stuff to stderr is not going through.
23:00  greycat: OH GOD IT'S SSH
23:00  greycat: !faq cflags > MrWGW-
23:00  greybot: MrWGW-: http://mywiki.wooledge.org/BashFAQ/096 -- ssh eats my word boundaries!  I can't do ssh remotehost make CFLAGS="-g -O"!
23:00  RAWRjar: echo "Commit failed" 1>&2
23:00  RAWRjar: Does not work.
23:00  greycat: RAWRjar: YES, IT DOES.
23:00  greycat: RAWRjar: Get the FUCK out of (t)csh.
23:00  RAWRjar: Ignored :/
23:04  nDuff: RAWRjar, can you describe a means to reproduce the bug you're seeing outside the context of of a subversion hook? I can visibly demonstrate the command in question working here using evalbot; this being an extraordinary claim (that something we all use daily is in fact broken), you need to provide some evidence or context.
23:04  nDuff: # (echo "this is on stderr" >&2; echo "this is on stdout") >/dev/null
23:04  evalbot: nDuff: this is on stderr
23:04  RAWRjar: nDuff: Hmm. Then perhaps it is a Subversion error.
23:05  RAWRjar: Which is strange because I had it working fine with a different type of script.
23:05  nDuff: RAWRjar, ...and by the way, putting greycat on ignore is not necessarily good policy -- abrasive or not, he's the best source we have for help with hard problems.
23:05  RAWRjar: nDuff: Unfortunate. Thanks for advice :)
23:06  greycat: I need to learn how to say "you're full of shit" so nicely that they thank me.
23:06  tvm: heh.
23:08  RAWRjar: Thanks for your help, I think this is a Subversion issue. Redirecting output is always weird which is why I assumed it was that.
23:08  stockholm: greycat: its not hard. people do it all the time.
23:18  RAWRjar: nDuff: figured it out, it was a combination of several things. Many thanks!
23:32  null: greybot: I just told someone in real life that you're awesome
23:35  RAWRjar: Bye folks, have a good one :)
23:40  istevenmon: hi guys is there any way to shell redirect some output to a socket ?
23:41  nDuff: istevenmon, if you have the support compiled in, you can redirect to /dev/tcp/<host>/<port>
23:41  nDuff: istevenmon, if not, there's netcat, and socat, and similar tools
23:41  zooz: how can I call a defined function while doing "for" loop?
23:41  zooz: ie: for n in defined_function
23:42  nDuff: zooz, the same way you'd call a command
23:42  nDuff: oh
23:42  nDuff: so the function's output should be string-split?
23:42  nDuff: then yes, the same you'd call a command: for n in $(your_function); do ...; done
23:42  zooz: yeah, function gives multiple lines output
23:42  istevenmon: nDuff: problem is the machine i am connecting to, has everything firewalled the only port open is the one i am connecting through, and i wont be able to see the output of /dev/tcp/host/port
23:42  nDuff: zooz, that said, a FAQ 1 read loop might make more sense
23:42  nDuff: !faq 1 > zooz
23:42  greybot: zooz: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
23:43  nDuff: zooz, while read line; do ...; done < <(your_function)
23:44  zooz: nDuff, thanks, first answer help
23:55  mehwork_: should bash only scripts have .sh extensions or .bsh?
23:55  erUSUL: !.sh
23:55  greybot: Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
23:56  istevenmon: is elf the denotation for binary files?
23:56  mehwork_: i agree
23:57  erUSUL: istevenmon: elf is the executable standar in modern unix ... ( well at least linux and *bsd's afaik )
23:58  istevenmon: erUSUL: so it means compiled programs right?
23:58  mehwork_: file $(which ls)
--- Log closed Wed Nov 24 00:00:02 2010
