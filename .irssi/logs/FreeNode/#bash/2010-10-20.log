--- Log opened Wed Oct 20 00:00:31 2010
00:08  sente: i'm assuming it makes zero difference, but is there a preferred style when defining functions? fun(){ .. } vs fun { .. } vs fun () { .. }, etc etc
00:09  taylanub: you missed the paranthesis in one
00:09  taylanub: there's "function foo { ..." but "foo () { ..." is the same, and will also work in posix sh
00:10  retrospectacus: sente: you must write them exactly as you prefer.
00:10  taylanub: the whitespace with the () doesn't matter (but you _need_ a space after { and before })
00:12  sente: thanks
00:12  poisonbit: can the same effect that  (( ! BASH_LINENO )) && exit  (avoid file execution, only sourcing) be made with posix syntax ?
00:13  twkm: if it could i doubt the effect in bash would depend on a variable named BASH_*
00:22 --- taylanub0 is now known as taylanub
00:25  knob: Good evening everyone =)
00:26  eboyjr: Is there a way to make the functions parseua() and parseplatform() shorter and/or faster? http://pastebin.com/hCsjX7PW
00:28  eboyjr: I'd imagine some kind of for loop and/or goto statements?
00:29 --- JmZ is now known as JmZ_
00:31  geirha: Using globs instead of regexes would probably help
00:31  eboyjr: If bash has associative arrays, then I know what to do, since I ported it from php
00:31  eboyjr: I thought globs were for files.. lemme see
00:32  manizzle: if i have a binary file, how can i extract ever other byte in bash?
00:34  geirha: bash4 has associative arrays
00:35  geirha: manizzle: Odd thing to do ...
00:36  manizzle: geirha, im an odd guy
00:36  eboyjr: GNU bash, version 4.1.5(1)-release (i686-pc-linux-gnu)
00:37 --- e-DI0-t is now known as e-DIO-t
00:37  geirha: manizzle: Use some other language. Bash doesn't do well with binary files.
00:37  manizzle: k
00:37  geirha: !assoc > eboyjr
00:37  greybot: eboyjr: Associative Arrays map strings to strings (Bash 4): http://mywiki.wooledge.org/BashGuide/Arrays#Associative_Arrays
00:37  eboyjr: thanks geirha
00:40  geirha: manizzle: The major issues you'd encounter with bash is that it can't store null bytes since it uses C-strings internally, and you'd have to make sure it didn't use a multi-byte charset.
00:41 --- drizztbsd_ is now known as drizztbsd
00:41  geirha: You might be able to hack around it, but it would be ugly. Therefore, use a more suited language.
00:42  Barnerd: How can I un-"export" a variable?
00:42 * eboyjr can just use normal arrays... one for the keys and one for the values
00:42  saac: export VAR=
00:42  geirha: Barnerd: ''help export''
00:42  Barnerd: Was looking at declare -x
00:42  Barnerd: help export
00:43  Barnerd: !help export
00:43  marvin: Barnerd: help does not take arguments
00:43  geirha: Barnerd: Run it in a bash shell
00:43  Barnerd: Wow!
00:43  Barnerd: Never seen that :D That's gonna be a whole lot of usefullness!
00:43  saac: unset VAR
00:44  geirha: Barnerd: For info on shell builtins and keywords, use the help builtin.
00:45  saac: declare +x VAR ?
00:46  saac: geirha: to export means making it global to be used in other functions right?
00:47  geirha: saac: No, it means to make it an environment variable.
00:47  geirha: # var=1; bash -c 'echo "$var"'
00:47  evalbot: geirha: no output
00:48  geirha: # export var=1; bash -c 'echo "$var"'
00:48  evalbot: geirha: 1
00:51  saac: Understood, sorry for the mistake.
00:53  k-man: why does   sudo ( somecommand; someothercommand ) not work as expected?
00:54  pibarnas: k-man: have you tried &&?
00:54  k-man: yes
00:54  cthuluh: sudo bash -c 'some command; some other command'
00:55  geirha: k-man: Because parenthesis are not special to sudo ... they are to bash though.
00:55  k-man: geirha: ah, i see
00:55  k-man: cthuluh: yeah, i know that method, i was trying to understand why the subshell idea does not work
00:56  eboyjr: I can do a for loop to iterate through arrays, but I want to get the index of the array value, not the actual value. Is that possible?
00:56  geirha: Now you know. sudo is not a shell, thus can't spawn a subshell.
00:57  cthuluh: !faq indirection > eboyjr
00:57  greybot: cthuluh: No matches found at http://mywiki.wooledge.org/BashFAQ
00:57  k-man: so bash will execute anything in the () if its on its own on a line, but not if the brackets are paramaters to another command?
00:57  cthuluh: !indirection > eboyjr
00:57  greybot: eboyjr: See !faq variable variable -- http://bash-hackers.org/wiki/doku.php/syntax/pe#indirection
00:57  geirha: eboyjr: for key in "${!array[@]}"; do ...
00:58  eboyjr: Oh so that's what they were saying about inderection and assoc. arrays, thanks
00:59  geirha: k-man: Yeah, if the parenthesis aren't used in the way the syntax allows, you'll get a syntax error
01:02  k-man: geirha: thansk
01:02  geirha: So either  sudo bash -c 'foo;bar'  or  sudo foo; sudo bar
01:03  k-man: geirha: where is the subshell syntax in the  bash man page? I can't seem to find it
01:04  AndroidLoverInSF: i know this is crazy but is there such a thing as a bash shell debugger or ide?
01:04  geirha: k-man: Well, there's more than () that starts a subshell, but it is mentioned under Compound Commands
01:05  geirha: !subshell > k-man
01:05  greybot: k-man: http://mywiki.wooledge.org/SubShell
01:05  k-man: thanks geirha
01:05  Ward|: if i wanna do something 100 times do i really have to specify it like 1 2 3 4 5 6 7 8 9 10 11 12 ... in a for loop?
01:06  geirha: for i in {1..100}; do
01:06  retrospectacus: of course not
01:06  pibarnas: cant u use seq 4 it?
01:06  The-Compiler: !seq
01:06  greybot: seq(1) is a highly nonstandard external command used to count to 10 in silly Linux howtos. Use one of these instead: for x in {1..10} (bash3.x) or for ((x=1; x<=10; x++)) (bash 2.04+) or i=1; while [ $i -le 10 ]; do ...; i=$(($i+1)); done (ksh/POSIX)
01:06  geirha: for ((i=0;i<100;i++)); do
01:07  k-man: pibarnas: you mentioned the s word ;)
01:07  Ward|: thanks geirha
01:07  Ward|: geirha, i had no idea the last line works in bash :-D very nice thats kindof like what im used to
01:09  geirha: Ward|: It's generally referred to as a c-style for-loop. Double-parenthesis generally allows you to do the stuff you can do with ints in C.
01:09  geirha: !((
01:09  greybot: ((...)) is an arithmetic command, which returns an exit status of 0 if the expression is nonzero, or 1 if the expression is zero. Also used as a synonoym for "let", if side effects (assignments) are needed. See <http://mywiki.wooledge.org/ArithmeticExpression>.
01:09  eboyjr: Any reason why I should get this? $ echo hey
01:09  eboyjr: echo hey
01:09  eboyjr: hey
01:10  geirha: eboyjr: set -v ?
01:10  eboyjr: Ohh whoops I ran bash -v trying to get the version number :p
01:10  eboyjr: Thanks
01:10  Ward|: geirha, and if i wanna span on multiple lines? can i use brackets?
01:11  Ward|: geirha, also the stuff i want to execute can jsut be placed after do right? just to make sure
01:12  geirha: bash allows you to do  for ((i=0;i<100;i++) { echo "$i"; }   if that's what you mean
01:13  cthuluh: wow, nice, geirha
01:13  Ward|: yep :) thanks again
01:14  Ward|: it makes way more sense to me then the other style
01:14 --- bluethundr_ is now known as bluethundr
01:15  geirha: Well actually that would give a syntax error ... unless you add the missing ) to the right place ;)
01:16  eboyjr: How do I property escape this? name="$(printf '${platformnames[$i]}' '${BASH_REMATCH[1]}')"
01:17  geirha: Use " instead of '.  '' inhibits all expansions
01:18  geirha: Also, you forgot the format string..!
01:18  eboyjr: I can do: name="$(printf "${platformnames[$i]}" "${BASH_REMATCH[1]}")" ??
01:18  eboyjr: The %s is in the platformnames array
01:18  geirha: eboyjr: Yes, the $() starts a new quoting context
01:18  eboyjr: Ah very neat
01:18  geirha: eboyjr: You still need a format string though
01:19  eboyjr: So what is a format string?
01:19  eboyjr: It works without it I noticed though
01:20  geirha: '%s\n'  for example.   ''help printf''
01:21  geirha: # printf '%02d %02d\n' 1 2 3 4
01:21  evalbot: geirha: 01 02
01:21  evalbot: geirha: 03 04
01:22  eboyjr: I'm confused ${platformnames[$i]} translates to my format string that may or may not have %s in it
01:22  eboyjr: # printf "Testing" "Disregardme"
01:22  evalbot: eboyjr: Testing
01:23  yeah44: basically I still dont have any reason to use perl
01:23  yeah44: since I know da bash
01:23  geirha: eboyjr: Which means you might get unexpected output ....
01:24  eboyjr: geirha: What can I expect to not expect from my output then?
01:25  eboyjr: http://eboyjr.ath.cx:8080/scripts/webaccess.sh This is how I am using printf
01:25  geirha: eboyjr: backslash escapes will be replaced, and format specifiers will be replaced with corresponding arguments.
01:27  eboyjr: Ohh okay.. I can expect printf to parse escape sequences.. I know the strings ahead of time since its hard coded into my script
01:28  geirha: eboyjr: Only in the first argument (the format)... also notice how your Disregardme wasn't printed ...
01:29  geirha: You probably want:  printf "%s %s\n" "${platformnames[$i]}" "${BASH_REMATCH[1]}"
01:29  eboyjr: Yeah I only use %s if I want to include the matching regex
01:30  geirha: Oh, I see.
01:30  eboyjr: http://pastie.org/1234081
01:30  eboyjr: Thanks a lot btw
01:34  Gokhlayeh: Hi guys, I have a problem to solve and need some help. What I want to do is something like the debian testing/sid way of moving packages. I have a text list of packages which depends on each other; they are in an "incoming" repo - with some other which are not in the list. I want to know how old they are: precisely, I want to get the timestamp of the oldest. Then, if all packages are older than x days (stored in a variable), I move them to my main repo. El
01:38  geirha: Your line got split at:  my main repo. El
01:39  geirha: s/split/truncated/
01:47  Gokhlayeh: [...] I move them to my main repo. Else, I want to output how much time I need to wait to reach the x days cap. Note I use ash, I've commons tools like awk, stat, find, date,... from busybox.
01:52  eboyjr: Is it easy with bash to take some thing like 19/Oct/2010:16:47:09 -0700 and convert it to "+%l:%M%P" format? I don't need exactly how to do it, just what commands I need to use, thanks :)
01:54  The-Compiler: eboyjr: maybe "date" can parse this, no idea.
01:54  eboyjr: Yeah I was just about to ask.. I'll try it
01:54  The-Compiler: date -d '19/Oct/2010:16:47:09 -0700' '+%l:%M%P'
01:55  The-Compiler: # date -d '19/Oct/2010:16:47:09 -0700' '+%l:%M%P'
01:55  evalbot: The-Compiler: date: invalid date `19/Oct/2010:16:47:09 -0700'
01:55  eboyjr: date: invalid date `19/Oct/2010:16:47:09 -0700'
01:55  eboyjr: ah hrm
01:57  eboyjr: What if I know the format string used to create the date string?
01:57  The-Compiler: eboyjr: I think that won't help, sadly
01:58  geirha: # timestamp='19/Oct/2010:16:47:09 -0700'; date -d "${timestamp#*:}" "+%l:%M%P"
01:58  evalbot: geirha: 11:47pm
01:58  aaron01: is it possible to negate the 'from' option of "chown --from=owner"?
01:58  geirha: Requires GNU date of course
01:59  galaxywatcher: Can i redirect standard output to a file after the process has started?
01:59  eboyjr: # timestamp='19/Oct/2010:16:47:09 -0700'; echo "${timestamp#*:}"
01:59  evalbot: eboyjr: 16:47:09 -0700
01:59  eboyjr: geirha: The timezone is off, but I guess it will be okay
02:00  geirha: galaxywatcher: Only from the process itself
02:00  The-Compiler: aaron01: I guess just use find instead of chown only
02:00  The-Compiler: aaron01: with -not, -group and -user
02:00  The-Compiler: (and -exec of course)
02:00  galaxywatcher: geirha: Not sure I follow....
02:01  aaron01: The-Compiler: thanks, I'll give that a try
02:01  The-Compiler: galaxywatcher: I don't think so... what exactly are you trying to do?
02:01  geirha: eboyjr: Depends on what your timezone is ...
02:02  galaxywatcher: The-Compiler: I began a batch process an hour ago and I realize now that there will be about 30k thousand lines output, so my original plan of copying the output is now in question. I thought initially there would only be several hundred lines output.
02:03  galaxywatcher: I obviously should have redirected to a file and am about to restart the process and do just that, but thought I would ask you guys first. It
02:03  galaxywatcher: It's an interesting question to me....
02:03  geirha: eboyjr: Consult the man and/or info page
02:04  eboyjr: The -0700 should be a specifier for what timezone it is though
02:04  The-Compiler: galaxywatcher: Hmm I don't think that's possible, but I might be wrong
02:05  geirha: eboyjr: Yes, but then it is adjusted to your timezone ...
02:05  eboyjr: geirha: Forget what I said, oh okay
02:05  eboyjr: lol
02:07  mar77i: hey, writing a pseudo parser, a global that is defined after it is used is "backward blah"? what's the right word?
02:10  geirha: "bad coding"? :P
02:10  The-Compiler: :D
02:10  mar77i: heard of jump labels? :P
02:12  eboyjr: I'm using if [[ $str =~ $regex ]] inside of a function of another regex.. is there a way to make it so that the $BASH_REMATCH variable that is set doesn't affect the one in the function that called it?
02:12  eboyjr: Stupid bash and everything being global
02:13  eboyjr: If there is no way to do it, I know of a way around it
02:13  geirha: Just save it to a different variable
02:14 --- muzer is now known as MuzerAway
02:14  geirha: I don't think there's a way around it, other than running it in a subshell.
02:15  eboyjr: Okay I'll just designate one function to do all the regex
02:15  geirha: Hm. Though after reading your question a second time ... I'm not sure what you're asking.
02:16  mar77i: eboyjr: if you make it a function, use the "local" keyword with it.
02:16  eboyjr: Well when I use the =~ operator, it sets a global $BASH_REMATCH array of the matches _by itself_
02:16  eboyjr: And it's interfering with the $BASH_REMATCH set in another function
02:16  mar77i: !CAPS
02:16  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
02:16  geirha: Yet another reason not to use regex :P
02:17  geirha: mar77i: BASH_REMATCH is an internal shell variable
02:18  eboyjr: Can I get text within a string between [ and ] characters with plain bash?
02:18  geirha: Yes
02:18  mar77i: ...which is issue to the factoid I just posted. Making this clear is my intention. :)
02:18  eboyjr: Oh wow
02:19  geirha: var='foo [some stuff] bar'; IFS='[]' read _ result _ <<< "$var"; echo "result: $result"
02:19  geirha: # var='foo [some stuff] bar'; IFS='[]' read _ result _ <<< "$var"; echo "result: $result"
02:19  evalbot: geirha: no output within the time limit
02:19  geirha: err
02:19  geirha: # var='foo [some stuff] bar'; IFS='[]' read _ result _ <<< "$var"; echo "result: $result"
02:19  evalbot: geirha: result: some stuff
02:20  eboyjr: geirha: Wow is that a feature of `read`?
02:20  Gokhlayeh: about my problem : how can I convert a timestamp into a number of days/hours/minues/seconds. If I use something like awk '{print strftime("%c",$timestamp)}' it start the count of days to 1 -which is normal- but it's not what I want
02:20  geirha: eboyjr: Yes. ''help read''
02:20  eboyjr: K great
02:20  Gokhlayeh: I subtstract a timestamp to another then want to know the difference between them in human readable format
02:21  mar77i: do these relate, and if, how?
02:21  eboyjr: Gokhlayeh: See the date command
02:23  eboyjr: # var='foobar'; IFS='[]' read _ result _ <<< "$var"; echo "result: $result"
02:23  evalbot: eboyjr: result:
02:25  geirha: # IFS=: read -r username passwd uid gid gecos home shell; do echo "$username likes $shell"; done < /etc/passwd
02:25  eboyjr: Wow this script is the coolest script I have written with help here, with or without help
02:25  evalbot: geirha: bash: syntax error near unexpected token `do'
02:25  geirha: # while IFS=: read -r username passwd uid gid gecos home shell; do echo "$username likes $shell"; done < /etc/passwd
02:25  evalbot: geirha: root likes /bin/bash
02:25  geirha: heh
02:27  mar77i: # echo $(( ( $(date -d"2010/10/20" +%s) - $(date -d"1980/10/11" +%s) ) / ( 60 * 60 * 24 * 365 ) ))
02:27  evalbot: mar77i: no output within the time limit
02:27  mar77i: O_o
02:28  geirha: Try it again
02:28  eboyjr: # cat /etc/passwd | while IFS=: read -r u p u g ge h s; do echo "$u likes $s"; done
02:28  evalbot: eboyjr: no output within the time limit
02:28  eboyjr: So is the time limit 3ms?
02:28  eboyjr: lol
02:28  mar77i: # echo $(( ( $(date -d"2010/10/20" +%s) - $(date -d"1980/10/11" +%s) ) / ( 60 * 60 * 24 * 365 ) ))
02:28  evalbot: mar77i: 30
02:29  geirha: ''no output within the time limit'' means: I didn't manage to start the vm, read the image and run the command fast enough ... which typically means IO was too slow at that particular time.
02:29  aaron01: manpage for find gives this example for pruning a directory: " find . -path ./src/emacs -prune -o -print" ... however, this doesn't seem to work, in my test: "find . -path ./foo/bar -prune -o -print" it still shows the ./foo/bar dir and all sub-files/dirs. Any ideas?
02:30  geirha: !find > aaron01
02:30  greybot: aaron01: http://mywiki.wooledge.org/UsingFind
02:33  aaron01: geirha: perfect, thanks.
02:36  mar77i: lol, I'm just reading about goto and comefrom, and dont loops xD
02:38  eboyjr: # uptime
02:38  evalbot: eboyjr: bash: uptime: command not found
02:39  geirha: !evalbot
02:39  greybot: evalbot runs each session in a new VM as root. Feel free to play with, or hack, the bot in #evalbot or look at it more closely on http://www.vidarholen.net/contents/evalbot/
02:42  Gokhlayeh: # timestamp=0 && echo "$(($(date -d @$timestamp +%d)-1)) Days, $(($(date -d @$timestamp +%H)-1)) Hours, $(date -d @$timestamp +%M) Minutes, $(date -d @$timestamp +%S) Seconds"
02:42  evalbot: Gokhlayeh: no output within the time limit
02:42  Gokhlayeh: thats not really simple...
02:42  eboyjr: Heres a list of evalbot binaries http://pastebin.com/hk3X8Fup
02:42  Gokhlayeh: # timestamp=0 && echo "$(($(date -d @$timestamp +%d)-1)) Days, $(($(date -d @$timestamp +%H)-1)) Hours, $(date -d @$timestamp +%M) Minutes, $(date -d @$timestamp +%S) Seconds"
02:42  evalbot: Gokhlayeh: 0 Days, -1 Hours, 00 Minutes, 00 Seconds
02:43  Gokhlayeh: It's weird but my terminal give me 0 hours with this...
02:45  Gokhlayeh: why the busybox date start hour count at 1...
02:45  Gokhlayeh: I got it it's the timezone
02:47  Gokhlayeh: # timestamp=0 && echo "$(($(date -u -d @$timestamp +%d)-1)) Days, $(date -u -d @$timestamp +%H) Hours, $(date -u -d @$timestamp +%M) Minutes, $(date -u -d @$timestamp +%S) Seconds"
02:48  evalbot: Gokhlayeh: no output within the time limit
02:48  Gokhlayeh: # timestamp=0 && echo "$(($(date -u -d @$timestamp +%d)-1)) Days, $(date -u -d @$timestamp +%H) Hours, $(date -u -d @$timestamp +%M) Minutes, $(date -u -d @$timestamp +%S) Seconds"
02:48  evalbot: Gokhlayeh: 0 Days, 00 Hours, 00 Minutes, 00 Seconds
02:48  Gokhlayeh: OK it's the way I've found to convert a timestamp difference in human-readable format but I'm pretty sure that something simplest exists
02:54  geirha: !faq epoch
02:54  greybot: http://mywiki.wooledge.org/BashFAQ/070 -- How do I convert Unix (epoch) timestamps to human-readable values?
02:57  grepper: is there a better way of testing for a match of 2 patterns in a multiline string (matching BOTH) than doing:  if grep -q -w '^overlay' <<< "$filters" && grep -q -w '^crop' <<< "$filters"; then ...  ?
03:37  crankharder: this might seem weird.... if I have cd in a script the script finishes and I'm still where i was when the script was executed.  Is there any way to make the cd persistent even after the script finishes?
03:37 --- And1` is now known as And1
03:37 --- k-man_ is now known as k-man
03:38  eboyjr: !faq cd
03:38  greybot: eboyjr: No matches found at http://mywiki.wooledge.org/BashFAQ
03:38  TheBonsai: y0
03:38  TheBonsai: grepper: remove newlines and grep it, or hack something with PE/pattern matching
03:39  eboyjr: grepper: Bash 3.0+ has regex features
03:39 --- bekks_ is now known as bekks
03:39  eboyjr: !=~
03:39  greybot: Binary operator, uses the expression on the right hand side as an extended regular expression and returns true if the expression on the left hand side matches the pattern. USE A VARIABLE to hold your regexes: if [[ $var =~ $r ]]; then echo Match; else echo 'No match'; fi
03:39  grepper: ^pattern might be important , so I guess I'll just leave it as is
03:54  eboyjr: The =~ factoid should probably talk about the $BASH_REMATCH array
03:55  grepper: I think it would not really be much succinct than the 2 greps, though it would of course avoid calling an external twice
04:01  plwert: is there something along the lines of alt-t but that only works on things considered as arguments? (ie the things separated by non-escaped space characters)
04:02  plwert: alt-t *almost* does what I want except it will turn "foo bar_b" into "foo b_bar" instead of "bar_b foo"
04:02 --- srcerer_ is now known as srcerer
04:03  plwert: srcerer: needs more consonants to sound web 2.0. How about srcrr?
04:03  fwelda23: i created the folder "My functions" in the /home/myuser directory and add it to the PATH variable.
04:03  fwelda23: Now, i have a bash script in that folder, that makes: echo "My script name is `basename $0`" and instead of outputing the script name, the output of the script is: My
04:04  fwelda23: how can i make the script output the name os the script, like it suposely would do'
04:04  fwelda23: how can i make the script output the name of the script, like it suposely would do'
04:05  fwelda23: does anyone know
04:05  fwelda23: in on debian/ubuntu
04:07  eboyjr: # uname
04:07  eboyjr: # uname -a
04:07  evalbot: eboyjr: no output within the time limit
04:07  evalbot: eboyjr: Linux bunnies 2.6.27.6 #9 Sat Nov 15 16:44:53 CET 2008 i686 Pentium II (Klamath) GenuineIntel GNU/Linux
04:08  eboyjr: fwelda23: What is the output of your script?
04:09  fwelda23: eboyjr, My
04:09  eboyjr: Just my?
04:09  fwelda23: :(
04:09  plwert: that's awfully odd
04:09  eboyjr: pastebin your whole code
04:10  eboyjr: # echo "My name is $(basename $0)"
04:10  evalbot: eboyjr: My name is bash
04:10  fwelda23: yes, its the first word of the directory of the the script
04:11  plwert: it's also the first word of the string you're passing to echo
04:11  yitz_: !basename
04:11  greybot: basename(1) can strip the directory and extension from a path. (a/b/c.d -> c.d or c). Or you can use a parameter expansion: "${path##*/}" or "${path%.*}"
04:11  eboyjr: fwelda23: That doesn't make sense what you say.. Please paste your source
04:11  plwert: does it out put "My" or "My script name is My"?
04:11  eboyjr: ^
04:12  plwert: way to make this vague
04:12  fwelda23: yes
04:12  eboyjr: lol
04:12  yitz_: fwelda23: Quote $0
04:12  eboyjr: hahaha
04:12  plwert: that wasn't a binary question
04:12  fwelda23: My script name is My
04:12  fwelda23: srry :/
04:12  yitz_: !quotes > fwelda23
04:12  greybot: fwelda23: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
04:12  yitz_: That should fix it all nicely
04:12  eboyjr: fwelda23: Also I think you should use $() instead of ``
04:13 --- rohith is now known as hitman47
04:13  yitz_: eboyjr: Yes and no. POSIX isn't very definite on that
04:13  eboyjr: # echo "fwelda23: for example, My name is $(basename "$0")"
04:13  evalbot: eboyjr: no output within the time limit
04:14  eboyjr: Oh okay.. I think it makes things like quotes, etc easier though
04:14  eboyjr: !$()
04:14  greybot: Command Substitution: "$(foo bar)" causes the command 'foo' to be executed with the argument 'bar' and "$(..)" will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
04:14  eboyjr: that greybot is a great bot
04:15 --- kisisten is now known as magyar
04:15  yitz_: I use $( when I can but the specs don't really push for them
04:15  eboyjr: I'd recommended it for beginners
04:15  eboyjr: !`
04:15  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
04:16  fwelda23: ok
04:16  fwelda23: im gonna try thanks eboyjr
04:16  eboyjr: no problem
04:16  fwelda23: the script is actually longer
04:16  yitz_: What POSIX actually says is "Because of these inconsistent behaviours, the backquoted variety of command substitution is not recommended for new applications that nest command substitutions or attempt to embed complex scripts."
04:18  eboyjr: Ah
04:20  eboyjr: So I created a program that lets you add parameters to a command (tail -f) that the script runs with $@... I want to add another argument that only the main script should read and not get passed to tail. Is there a really good way to do that?
04:21  yitz_: !getopts
04:21  greybot: Tutorial: http://wiki.bash-hackers.org/howto/getopts_tutorial Examples: http://mywiki.wooledge.org/BashFAQ/035
04:21  eboyjr: Here is the raw script to view with wget http://eboyjr.ath.cx:8080/scripts/webaccess.sh
04:21  yitz_: !.sh
04:21  greybot: Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
04:21  eboyjr: yitz_: I am using the while $1 and shift method for help
04:22  eboyjr: yitz_: I have /usr/bin/webaccess symlinked to /var/www/main/scripts/webaccess.sh
04:22  eboyjr: for --help*
04:22  yitz_: !quotes > eboyjr
04:22  greybot: eboyjr: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
04:23  yitz_: That includes quoting $@
04:24  eboyjr: I don't think tail will appreciate being run with tail -f "-c 0 --something=else" file.txt, but I'll try it
04:24  yitz_: Probably not. It's a good thing bash wouldn't do that with "$@", though
04:25  tmr: !$@
04:25  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
04:26  fwelda23: eboyjr,  # echo "fwelda23: for example, My name is $(basename "$0")" did the job ;) thanks :)
04:26  eboyjr: great :)
04:27  eboyjr: tmr: Do I want $@ in this case?
04:27  eboyjr: tail -f $@ /var/log/apache2/access.log
04:28  yitz_: eboyjr: ou almost always want "$@".
04:28  yitz_: *You
04:28  tmr: Didn't look at your script, but if you're parsing/passing arguments you most likely want it.
04:28  yitz_: And I already told you that you do...
04:28  eboyjr: $ tail "-f -n 10" /var/log/apache2/access.log
04:28  eboyjr: tail: invalid option -- ' '
04:28  eboyjr: Try `tail --help' for more information.
04:28 * yitz_ gives up 
04:29  yitz_: I want greg's *plonk*
04:30  tmr: # set -- -n 10 /etc/passwd; tail "$@"
04:30  evalbot: tmr: no output within the time limit
04:30  tmr: # set -- -n 10 /etc/passwd; tail "$@"
04:30  evalbot: tmr: no output within the time limit
04:31  tmr: Meh.
04:31  eboyjr: Okay
04:31  tmr: What happened to shbot?
04:31 * eboyjr is sorry for not listening to yitz_ and not believing "$@" would work
04:39  eboyjr: !read
04:39  greybot: help read <ENTER> read http://wiki.bash-hackers.org/commands/builtin/read
04:42 --- mar77i_ is now known as mar77i
--- Log closed Wed Oct 20 05:01:46 2010
--- Log opened Wed Oct 20 05:02:09 2010
05:02 --- Users 495 nicks [0 ops, 0 halfops, 0 voices, 495 normal]
05:02  Ward|: and the best way of replacing a char or piece of string with something else?
05:02  yitz_: Pardon?
05:03  Ward|: of the output
05:03 --- Channel #bash was synced in 75 seconds
05:03  Ward|: i want to reformat it
05:03  Ward|: but i dunno what i need
05:03  yitz_: What sort of "reformatting"?
05:04  Ward|: "/" should become "of"
05:04  Ward|: that sort of stuff
05:04  Ward|: actually it should become " of "
05:05  yitz_: sed can do that
05:05  Ward|: ok thanks
05:08  Ward|: yitz_, how do i use sed with stdin please?
05:09  yitz_: cmd | sed 's_/_ of _g'
05:11 --- mingdao_ is now known as mingdao
05:16  Ward|: yitz_, that keeps giving me >
05:16  Ward|: liek its waiting for more
05:16  Ward|: dunno the proper term
05:16  yitz_: The prompt
05:16  Ward|: yep
05:16  yitz_: # echo '1/8' | sed 's_/_ of _g'
05:16  evalbot: yitz_: 1 of 8
05:17  Ward|: echo '1/8' | sed 's_/_ of _g
05:17  Ward|: >
05:17  yitz_: Probably some other component of your scrupt
05:17  Ward|: lol seriously
05:17  yitz_: Close the quote
05:17  skered: blah _ as a seperator?
05:17  skered: Now that's just ugly
05:17 * yitz_ sighs
05:17  Ward|: same with closed quote
05:17  yitz_: cmd | sed 's|/| of |g'
05:17  Ward|: was a copypaste error...
05:18  skered: |.. even worse
05:18  yitz_: @?
05:18  Ward|: that does the job
05:18  skered: I'm a fan of # and !
05:18  yitz_: I'll take | over !
05:18  yitz_: 0x01 works, too
05:19  Ward|: thanks
05:20  Ward|: now its not line buffered anymore :s
05:21  Ward|: i use grep in the same line with --line-bufered
05:21  Ward|: *buffered
05:21  Ward|: now it waits untill the first command is finished and then reads everything again
05:22  yitz_: That turns buffering on, so you won't get output until the first command closes
05:22  Ward|: damn, i kindof need the output lol
05:22  Ward|: before the command closes
05:23  Ward|: is there any other way?
05:23  yitz_: I don't know. I would just read that FAQ and tell you what it says
05:24  Ward|: the one you linked?
05:24  yitz_: Yeah
05:24  yitz_: !faq buffer
05:25  greybot: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
05:25  yitz_: !buffer
05:25  Ward|: "sed (e.g. GNU version 4.0.6)
05:25  Ward|: 	
05:25  Ward|: -u,--unbuffered"
05:25  Ward|: thats all about it there
05:25  yitz_: If the command producing the output buffers, you can't do much about it...
05:25  Ward|: well with grep alone it works
05:26  Ward|: if i add sed into the chain it messes up
05:26  yitz_: Try the sed -u ?
05:26  Ward|: i thought unbuffered was the opposite of line-buffered lol
05:26  yitz_: Yes
05:26  yitz_: buffering is "bad"
05:26  Ward|: do i didnt try with -u
05:27  Ward|: -u works
05:27  Ward|: thanks
05:28  Ward|: i thiought -u did the oposite of what it does
05:28  Ward|: which is why i didnt try it before
05:28  Ward|: i did read the faq
05:37  sente: what's the correct way to prompt for user input within a loop? random example to demonstrate what I want: some_command | while read line; do echo $line; read decision; if [[ $decision = "delete" ]]; then rm "$line"; fi; done
05:38  Aniar: sente: what are you trying to *do*
05:39  Aniar: as in, back out, and explain the root problem
05:39  Aniar: you might be stuck in : http://mywiki.wooledge.org/BadQuestions
05:40  sente: i want to prompt for user input for each line that is outputted by 'some_command'
05:40  sente: and depending on the input, take a certain action
05:41  yitz_: while read line ; do read </dev/tty ; done < file
05:41  yitz_: Or play with filehandles...
05:42  yitz_: exec 1>&3 ; while read line ; do read input <&3 ; done < file
05:42  sente: yeah i was trying to use read -u's [fd]
05:42  sente: but i couldn't specific /dev/stdin apparently
05:43  sente: s/specific/specify
05:43  sente: yitz_: thank you
05:43  yitz_: np. Hope you get it to work
05:44  sente:  yeah, your example works
05:44  yitz_: :) I love when untested code that you're not remotely confident about actually works...
06:13  manizzle: what does cat <(echo Hey) really do?
06:14  manizzle: i have seen this but i dont know exactly what is going on with the parenthesis and redirection operatore
06:19  go|dfish: !<(
06:19  greybot: Process Substitution -- <(cmd) and >(cmd) -- see http://mywiki.wooledge.org/ProcessSubstitution , or http://mywiki.wooledge.org/BashFAQ/024 for a common use
06:21  manizzle: thanks dude
06:41  Kharec: Good morning guys!
06:58  Josay: +
--- Log closed Wed Oct 20 07:19:51 2010
--- Log opened Wed Oct 20 07:20:11 2010
07:20 --- Users 493 nicks [0 ops, 0 halfops, 0 voices, 493 normal]
07:21  fluter: cthuluh: that works great, thanks a lot
07:21  fluter: greybot: thank you too
07:21 --- Channel #bash was synced in 78 seconds
07:24 --- sash__ is now known as sash_
07:24  Kharec: greybot is a bot?
07:27  cthuluh: !greybot > Kharec
07:27  greybot: Kharec: I'm written in perl using POE::Component::IRC, and my source is at http://wooledge.org/~greg/greybot/
07:28  Kharec: thanks :)
07:28 * Kharec is a perl programmer :)
07:28 * cthuluh is late
07:37  fluter: greybot is lovely
--- Log closed Wed Oct 20 08:37:01 2010
--- Log opened Wed Oct 20 08:37:25 2010
08:37 --- Users 498 nicks [0 ops, 0 halfops, 0 voices, 498 normal]
08:37  pgas: "kill -s sigspec" "klll -sigspec" SIGSPEC refers to the argument to pass to kill
08:38  pgas: it means if you pass no argument then it uses SIGTERM
08:38  fluter: nahh, I thought SIGSPEC is one of singals, ...
08:38 --- Channel #bash was synced in 79 seconds
08:38  fluter: thanks pgas,
08:39  fluter: it should not use captial form 'SIGSPEC', looks like a singal :|
09:12  Linex: I telnet to port 25 of my server. Now it hang. How do I get out. Ctrl-C does not work.
09:14  pgas: C-] ?
09:14 --- trash_ is now known as trash
09:16  stockholm: ctrl-5
09:26  k-: !lindbohm
09:48  Varazir: hello if I lik eto echo/printf a # in to a text file do I need to \ it ?
09:49  Varazir: Linex: ctrl+d
09:49  koala_man: Varazir: you can do that, or you can quote it
09:49  Varazir: koala_man: okay thanks
09:56 --- JmZ_ is now known as JmZ
09:58 --- JmZ is now known as JmZ_
10:07 --- streuner_ is now known as streuner
10:12 --- ^silence^ is now known as snL20
10:16  Sashi: does anyone have a command, where i can search in a bunch of different folders, and it searches for a certain extension, and if it doesnt have that extension, it delets the folder
10:19  pgas: !find > Sashi
10:19  greybot: Sashi: http://mywiki.wooledge.org/UsingFind
10:19  k-: !find > Sashi
10:19  greybot: Sashi: http://mywiki.wooledge.org/UsingFind
10:20  Sashi: yea i know how to use find to delete files within a dir
10:20  Sashi: but im not sure how to use it in order to delete the folder containing the extension
10:21  pgas: Sashi: you want to delete a directory if it contains a file with a certain extension?
10:21  Sashi: correct
10:22  pgas: I would write a little script what checks if a dir contains such a file and delete the dir if yes, then call it with find . -type d -exec script {} \;
10:22  pgas: !faq empty
10:22  greybot: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
10:33  JackWinter: how do i check to the existence of a directory?
10:33  koala_man: test -d
10:37  JackWinter: koala_man: ah the same as for a file, but with a -d parm instead of a -f ?  thanks
10:38  geirha: JackWinter: run ''help test''
10:41 --- Evanlec_ is now known as Evanlec
10:52  mnemoc: hi, what's the command line option to ask bash to check if a file is syntacticly correct for sourcing it?
10:53  mnemoc: -n
10:56  auscompgeek: mnemoc: help test
10:56  mnemoc: test?
10:56  auscompgeek: test is [
10:56  pgas: well, mnemoc seems to look at the right place by himself
10:57  auscompgeek: oh right, whoops
10:57  mnemoc: yes, test is [, but `sh -n script` shouldn't be described there.... i think
10:57  pgas: auscompgeek: he wanted "help set" not "help test"
10:57  auscompgeek: you meant like sh -n script, silly me
10:57  auscompgeek: man bash :)
10:58  cousteau`work: I'm trying to implement tab-completion for a custom command
10:58  mnemoc: pgas: you are actually right about the search for a place, but i was searching 30m for the  '-n' thing (before the coffee) before joining the channel ... and drinking my first coffee
10:58  cousteau`work: (any good manual or something? I'm a bit lost)
10:59  pgas: cousteau`work: google for bash-completion, there is a channel on another irc server
11:00  mnemoc: cousteau`work: http://tldp.org/LDP/abs/html/tabexpansion.html
11:04  mnemoc: pgas: having 33 irc channels open is probably a good proof, but having idled several times in #bash i know this is not "the right place" for me
11:04  mnemoc: thanks! bye ;-)
11:04  cousteau`work: mnemoc: thanks for the link
11:04  cousteau`work: oops
11:09  neekers_: can someone please look at this page and tell what is being linked to, http://sites.google.com/site/olipion/cross-compilation/zbar-bar-code-reader
11:09  neekers_: ln -s /Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator3.0.sdk/usr/include/crt_externs.h config/
11:09  neekers_: it's just over halfway down and I don't understand the what the config/ is
11:11  pgas: it's a directory in your current path
11:16  neekers_: i'm actually not installing imagemagick, i'm installing glib and getting the same error, after googling, it was the only thing i could find that addressed the problem, i'm just not sure what to link to in my path to fix the problem
11:17  neekers_: do you think it would be a good idea to try the imagemagick install to try and figure out where config/ is and what it's significance might be?
11:20  cousteau`work: I have a script that loads some env variables (PATH among them) and runs a command. Would this be ok?   xpath=$(./myscript bash -c 'echo "${PATH//:/ }"' 2>/dev/null); for i in $xpath; do ...
11:22  cousteau`work: ./myscript bash -c 'echo "${PATH//:/ }"' 2>/dev/null   returns space-separated directories in $PATH (which I'll assume don't have spaces or newlines or other strange characters in the name)
11:23 --- Weust`afk is now known as Weust`
11:23  koala_man: IFS=:; for x in $PATH; do echo "$x"; done
11:24  cousteau`work: ok... yes, it's better
11:25  neekers_: ok, well, you got me one step further, thanks pgas
11:30  neekers_: time to install imagemagick...
11:36  cousteau`work: koala_man: so something like   oldifs="$IFS"; IFS=:; for i in $PATH; do...done; IFS="$oldifs"
11:37  cousteau`work: (in case I'm going to use IFS later)
11:38  lesshaste: hi all
11:38  cousteau`work: I could also use a (...) subshell, but since the for loop is going to store the output on a varable, it would remain local
11:39  lesshaste: I am writing a simple bash script which I want to call as
11:39  lesshaste: "submit X Y" and have it cp X to /dir/Y
11:39  lesshaste: well actually scp
11:39  lesshaste: but in any case, is that just cp $1 /dir/$2 ?
11:41  cousteau`work: ...I think I'm gonna use the ${PATH//:/ } trick rather than messing with IFS
11:42  cousteau`work: lesshaste: yes... or better   cp "$1" "/dir/$2"
11:42  cousteau`work: in case $1 or $2 contain spaces
11:42  lesshaste: cousteau`work, thanks
11:43  cousteau`work: you almost always want to use quotes when you do $...
11:43  lesshaste: thanks, sounds sensible
11:44  lesshaste: so here is the tricky part, I would like to backup Y so I don't just overwrite it
11:44  lesshaste: is there a way to copy it to something with a unique name?
11:45  geirha: while read -d: -r; do stuff_with "$REPLY"; done <<< "$PATH:"
11:46  lesshaste: and, one last thing, how do I get the bash script to check it has the right number of arguments and print out the instructions otherwise?
11:46  cousteau`work: geirha: hmm... maybe... but is there any bash builtin that expands 'foo:bar:baz' to 'foo' 'bar' 'baz'?
11:47  geirha: # IFS=: read -r -d '' -a array <<< "$PATH:"; echo "${array[@]}"
11:47  evalbot: geirha: no output within the time limit
11:47  geirha: 4# IFS=: read -r -d '' -a array <<< "$PATH:"; echo "${array[@]}"
11:48  geirha: Hm.
11:49  geirha: 4# IFS=: read -r -d '' -a array <<< "$PATH:"; echo "${array[@]}"
11:49  shbot: geirha: /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin
11:50  geirha: lesshaste: if (( $# != 2 )); then echo "Usage: blah blah"; exit 1; fi
11:50  lesshaste: thanks!
11:51  Adman65_: how can I move all torrent files into a new directory?
11:51  geirha: mkdir -p newdir/ && mv *.torrent newdir/
11:52  Adman65_: mv /Users/adam/Downloads/*.torrent /Users/adam/Desktop/watch/ is no good
11:52  lesshaste: argh... my script has
11:53  lesshaste: scp "$1" "user@foo.com:/dir/secure/$2"
11:53  lesshaste: but when I call it with submit x y it does
11:53  lesshaste: scp x user@foo:/dir/secure x
11:53  lesshaste: !
11:53  lesshaste: any ideas why?
11:53  lesshaste: I mean  scp x user@foo:/dir/secure/x
11:53  lesshaste: y is not used
11:55  lesshaste: oh my fault :(
11:55  lesshaste: ignore me
12:01  cousteau`work: do arrays "survive" a while loop, or they can only be set locally?
12:01  chron_: how can i write a literal '&' in bash?
12:01  cousteau`work: '&'
12:01  chron_: what if i'm trying to sed that character?
12:01  cousteau`work: or \&
12:01  chron_:  \& doesn't seem to work
12:02  cousteau`work: what regexp?
12:02  cousteau`work: sed 's/foo&bar/baz/'
12:02  chron_: nevermind it does, thanks
12:03  cousteau`work: however, & is a special character for the 2nd half... so:   sed 's/foo/bar\&baz/'
12:04  cousteau`work: and use always '...' around the regex, so bash doesn't interpret it
12:04  cousteau`work: (otherwise, you'd have to do   sed s/foo/bar\\\&baz/   ...yuck)
12:06  phretor: is it possible to save the PID of a process I run via su foouser -c "command_that_launches_the_process" _without_ putting it in background?
12:08  pgas: if you don't put it in the background you can't do anything
12:08  koala_man: no, but you can run it, write the pid, and then wait on it
12:10 --- Weust` is now known as Weust`afk
12:11  cousteau`work: is there something that expands to the content of a directory (like dir/*) but doesn't include the path?
12:12  pgas: cd dir;echo *
12:13  phretor: I am so pissed at Upstart, which doesn't support the "pid" stanza anymore/yet.
12:16  lil_cain: What version of upstart?
12:26 --- Weust`afk is now known as Weust`
12:27  avinashhm: hi, can i kill any process from its name .. till now i do , " ps | grep pname and kill pid ".. is it possible to combine somehow .. i want to use kill with pname ..
12:27  Naib: avinashhm. killall or kill $(pgrep foo)
12:28  erUSUL: pkill processname
12:30  avinashhm: Naib, erUSUL ... thank you ... both of these worked .. thanks ...
12:46  shai: Hi :) I need to create a file (content is not important) that after being compressed with zip (not gzip etc.), will be approx. 12k ... how can I do that?
12:47  koala_man: shai: head -c 12000 /dev/urandom > file
12:48  koala_man: zip it and it'll be somewhat over 12k bytes
12:48  Naib: dd if=/dev/urandom of=file count=12000
12:53  taylanub: shai: just wondering, why exactly is that?
12:53  avinashhm: hi, how can we check if a command executed correctly in bash ??? .. ex- i have untarred big file .. need to check if there was any error in that operation ??
12:53  taylanub: avinashhm: the variable $?
12:54  taylanub: shows the exit status of the last executed pipeline
12:54  avinashhm: taylanub, thanks buddy ... did 'echo $?' .... luckily no error 0 ....
12:54  taylanub: well it would probably tell you if there's an error, eh?
12:55  avinashhm: taylanub, yep .. nonzero value .. error ..
13:47  twkm: gzip -9c < /dev/zero | dd of=file count=1 bs=24b
14:37  hegemoOn: moin
14:42  ksk: hello guys
14:43  ksk: i do "time $command" > file - i want the output of time redirected - is there a way to do it?
14:43  pgas: !faq time
14:43  greybot: http://mywiki.wooledge.org/BashFAQ/032 -- How can I redirect the output of 'time' to a variable or file?
14:43  ksk: thanks
14:43  ksk: a lot
14:44  twkm: why is it people ignore the faq?
14:44  lyhana8: hi, how could I manipulate (mv, cp, rm) files output by a grep command?
14:44  pgas: we don't want to be like everybody else and we refuse to think that our questions are faq
14:45  pgas: lyhana8: faq 1
14:45  lyhana8: or should I use another command?
14:45  twkm: mostly, don't use grep's output.
14:45  ksk: twkm: i didnt know there is an article for time, just looked for redirection
14:46  twkm: ahh.  horrible skimming abilities.  well, at least you looked.  thanks.
14:49  lyhana8: pgas: thanks (Apologize, I didn't think about the FAQ)
14:49  twkm: hmm, new "feature" k looks ripe for exploitation.  i think i'd prefer it truncate there.
15:25 --- jzacsh is now known as jzacsh_
15:26  lyhana8: do you know a software to find similarities between files? I found `psame` but doesn't seem to exist anymore
15:27  lhunath: diff.
15:27 --- pager is now known as rpage
15:29  lyhana8: lhunath: I was looking for something more like fdupes
15:29  lhunath: explain what you want in English.
15:30  lyhana8: I got a bunch of messed up files (restored with testdisk) and It seem lot of them are redundant
15:31  lhunath: define "redundant".
15:31  lhunath: do you want to find all files that have the same content?
15:32  lyhana8: so I want a software to find similar (like 90% similar)
15:32  greycat: Good luck with that.
15:32  lyhana8: lhunath: I use fdupes to find exactly similar, now I want something more fuzzy
15:32  greycat: Sounds like a PhD project.
15:33  lhunath: best I can think of is GIT (the SCM) having something that detects similarity between files.
15:33  lhunath: so as to track file renames (with content changes) purely on content.
15:34  lyhana8: this feature exists in many photomanager, I reckoned it was simpler for text file
15:34  sedrik: Hi guys, why do I get redirection unexpected when I do this http://pastebin.org/332712 (... is substituted for my own command)
15:35  greycat: mosty likely quoting failure
15:35  greycat: or some kind of syntax error
15:35  sedrik: well, there are only two quotes..
15:35  lhunath: lyhana8: define similar.
15:36  greycat: Maybe he means something incredibly brutish like "90% of the bytes in A are identical to the same-position bytes in B".
15:36  greycat: *shrug*
15:36  greycat: Write a C program to do that, and then run it.
15:36  lhunath: sedrik: try bash.
15:37  greycat: Ah, I forgot about the shebang-failure likelihood.
15:38  lyhana8: lhunath: http://dictionary.reference.com/browse/similar :P
15:38  sedrik: aa, bash was not my default shell :S
15:39  greycat: Oh, so a file whose content is 'c' is similar to a file whose content is 'e'.  Because 'c' and 'e' look alike.
15:40  lyhana8: lhunath: differences represent less than x% of the file content
15:40  greycat: if cmp <(tr c e < file1) <(tr c e < file2); then echo similar; fi
15:40  greycat: lyhana8: write a program to implement your chosen definition of 'similar' and run it
15:40  lhunath: lyhana8: you seem to think that means anything.
15:43  lhunath: "similar" is vague.  and until you determine what kind of similarity your ACTUAL CASE is interested in, stop trying to look for answers and figure out the question first.
15:43  greycat: He seems to think there will be some standard tool to do whatever-the-fuck-it-is.  There isn't.
15:43  greycat: He could have written the fucking C program in the time he's wasted here.
15:43  lhunath: I recall PHP has a set of functions that implement different types of "similar".
15:43  greycat: oh, good, then we can kick him off to ##php!
15:46  lyhana8: greycat: could you be a little more polite?
15:46  greycat: No.
15:46  lyhana8: isn't IRC channel a place to talk and solve one's issue?
15:47  greycat: *plonk*
15:47  greycat: There.  My issue is now solved.
15:50  lyhana8: lhunath: by similarity I was thinking of something like a Levenshtein distance
15:51  lhunath: lyhana8: excellent. http://de2.php.net/manual/en/function.levenshtein.php
15:53  lhunath: bash cannot solve this issue; without you implementing the algorithm in bash.  so either take it to ##php or implement it in some other language.  there certainly isn't any "standard" tool for this, I'm afraid.
15:54  lyhana8: lhunath: ok~
15:58  lyhana8: I'm wondering if there is some kind of hash that could reduce the length of the string but maxime the ressemblance with original string? I'm not sure if gzip compression could be use
15:59  lyhana8: something like PCA (Principal component analysis)
16:02  evelyette: hi
16:02  evelyette: how can I replace every occurance of text1 with text2 in all the files in current directory ?
16:02  greycat: !faq replace
16:02  greybot: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
16:08  evelyette: ok I did this: ed -s c++.tex <<< $'s/lstlisting/verbatim/g\nw'
16:08  evelyette: but ed just printed out '?' and everything is the same ... no change was made to the c++.tex
16:08  evelyette: any ideas ?
16:09  greycat: imadev:~$ echo 'blah lstlisting blah' > foo
16:09  greycat: imadev:~$ ed -s foo <<< $'s/lstlisting/verbatim/g\nw'
16:09  greycat: imadev:~$ cat foo
16:09  greycat: blah verbatim blah
16:09  greycat: Are you sure you spelled it right?
16:10  evelyette: what do you mean ?
16:10  greycat: "lstlisting" is the correct spelling?
16:10  evelyette: yes
16:11  evelyette: it works on foo
16:11  evelyette: in the file I have this
16:11  evelyette: \begin{lstlisting}
16:11  evelyette: and
16:11  lyhana8: evelyette: you could Perl: perl -p -e 's/XXX/YYY/g' ./*
16:11  evelyette: \end{lstlisting}
16:11  lyhana8: add -i to actually do the replace
16:12  evelyette: lyhana8, it works, thanks
16:12  evelyette: let me now check if everything is correct :)
16:13  evelyette: I'm crossing my fingers
16:13  Shapeshifter: What's the simplest way of checking if a variable is equal to one of many strings? as in if [[ "$foo" == "foo" || "$foo" == "bar" ]]; then but without repeating "$foo" == all the time. Like, say, python's: if foo in ["foo", "bar", "baz"]:
16:14  greycat: case
16:14  greycat: there's a FAQ for it, too...
16:14  lyhana8: evelyette: you need to be extra careful with this kind of batch processing as a tiny mistake can have terrible consequences!
16:14  greycat: !faq ||
16:14  greybot: http://mywiki.wooledge.org/BashFAQ/066 -- I want to check if [[ $var == foo || $var == bar || $var == more ]] without repeating $var n times.
16:14  taylanub: maybe not bash related; can i tell an app (e.g. sed) not to buffer its output? it seems to put out in chunks of bytes (unless stdout is a terminal)
16:14  greycat: !faq 9
16:14  greybot: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
16:14  Shapeshifter: greycat: thanks
16:15  taylanub: thanks, greycat
16:15  lhunath: isin foo foo bar baz
16:15  lhunath: !isin
16:15  greybot: See if a value is in an array: inarray() { local tofind=$1 element; shift; for element; do [[ $element = "$tofind" ]] && return; done; return 1; } # Usage: inarray "$value" "${array[@]}"
16:15  lhunath: is an alternative
16:16  greycat: that one only makes sense if the list of choices is dynamic
16:28  Ward|: if a program chain would normally output 1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n , and i want the output to become 5\n10\n , what should i use?
16:29  Ward|: something with modulus i'm guessing
16:29  pgas: awk '!NR%5'
16:29  Ward|: nice
16:30  sedrik: What might be the problem when I follow the seconds example here http://mywiki.wooledge.org/BashFAQ/001 but bash only operates on one line of the file?
16:30  sedrik: I want to loop to apply for each line in the file
16:30  greycat: !faq first
16:30  greybot: http://mywiki.wooledge.org/BashFAQ/089 -- I'm using a loop which runs once per line of input but it only seems to run once; everything after the first line is ignored?
16:31  greycat: Either that, or you simply did something wrong.
16:32  sedrik: greycat: I just linked to the faq
16:32  sedrik: so I have read it
16:32  greycat: I know.  Therefore we can't see what you WROTE.  Your actual code.
16:32  Ward|: pgas, can i use awk unbuffered ?
16:32  greycat: !faq 9 > Ward|
16:32  greybot: Ward|: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
16:33  Ward|: thank
16:33  Ward|: s
16:33  sedrik: greybot: http://pastebin.org/332762
16:33  sedrik: any help would be appreciated
16:34  greycat: !faq first > sedrik
16:34  greybot: sedrik: http://mywiki.wooledge.org/BashFAQ/089 -- I'm using a loop which runs once per line of input but it only seems to run once; everything after the first line is ignored?
16:34  greycat: AGAIN
16:34  greycat: People piss me off.
16:34  greycat: I need to change the title of that question so people actually SEE THAT IT IS RELEVANT TO THEM.
16:35  Ward|: greycat, awk: vacuous option: -W !NR%2
16:35  sedrik: greycat: oh sorry, missed that one :(
16:37  Ward|: greycat, any ideas? if i'm not pissing you off that is :-p
16:38  greycat: The page says
16:38  greycat: awk (some GNU versions)
16:38  greycat: 	
16:38  greycat: -W interactive, or use the fflush() function
16:38  greycat: Those are my ideas.  Enjoy.
16:38  pgas:  system("") is also an alterntive to fflush() if your awk doesn't have it
16:39  greycat: There is also #awk.
16:39  sedrik: greycat: thanks, sorry for the disturbance
16:48  taylanub: sourcing (.) a file is exactly the same thing as putting the code in the sourced file into the script, yes?
16:49  greycat: The 'return' command inside a sourced file causes the sourcing to stop.
16:49  taylanub: other than that, no difference then?
16:49  taylanub: oh, posix
16:50  pgas: hmm, I think you can pass arguements and have different $1 etc ...not too sure
16:50  greycat: some of those BASH_* variables might also change
16:50  greycat: possibly the 'caller' command
16:51  taylanub: using posix sh, can i ". file" and not worry about the positional parameters? ($0 is not used...)
16:51  greycat: What do you mean by "worry"?
16:51  taylanub: they won't change and such, would they?
16:51  greycat: only if you change them
16:51  taylanub: used inside the sourced file
16:52  pgas: try and see it
16:52  greycat: used != changed
16:52  taylanub: ok, i'll try.  thanks
16:53  paxl: why this don't work : expr match $t ':' where t="install:"
16:53  evelyette: hi, I have this example: echo "<pre> testing the test|   </pre>|" | sed -e 's/<\/pre>//g'
16:54  evelyette: but I want to delete all the empty characters before the </pre> too .. how can I do that ?
16:54  greycat: Nobody in this channel uses expr except heiner.
16:54  greycat: Ever.
16:54  Kharec: hi here
16:54  taylanub: what i exactly do:  put the contents of the main infinite-loop (which pretty much defines what the script does) inside another file, and source it inside the loop in the actual script, so i can do dynamic changes.   it's probably quite a stupid thing to do, and a race condition might brake it, but it's a crazy project altogether: irc bot using socat in sh
16:54  greycat: !html > evelyette
16:54  greybot: evelyette: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
16:54  taylanub: break*
16:55  paxl: greycat, then the answer is to use sed ?
16:55  Shapeshifter: well damn bash for not having nested arrays.
16:55  greycat: paxl: what are you DOING?  We literally can't even answer the question because we don't even know what the expr command you're using is attempting to DO.
16:56  greycat: Is it trying to determine (true/false) whether something matches something else?  Is it trying to modify a string?
16:56  hallucynogenyc: Hello!
16:56  Kharec: hello hallucynogenyc
16:56  poisonbit: can this be written in a single test?
16:56  adac: can someone give me an example of hwo to define a string that is more then one line?
16:56  poisonbit:             [[ $file = */.  ]] && continue
16:56  poisonbit:             [[ $file = */.. ]] && continue
16:56  greycat: string=$'line one\nline two\n'
16:56  paxl: greycat, I just try to see if there is a ':' in a string.
16:56  paxl: that all
16:56  greycat: !faq || > poisonbit
16:56  greybot: poisonbit: http://mywiki.wooledge.org/BashFAQ/066 -- I want to check if [[ $var == foo || $var == bar || $var == more ]] without repeating $var n times.
16:56  greycat: paxl: if [[ $string = *:* ]]; then ...
16:57  greycat: paxl: or 'case'.
16:57  poisonbit: thanks
16:57  paxl: and to extract what before the : ?
16:57  greycat: !faq 100 > paxl
16:57  greybot: paxl: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
16:57  adac: greycat, and it is not possible to write line by line within the bash code?
16:57  greycat: !b2
16:57  greybot: bashphorism 2: The questioner will keep changing the question until it drives the helpers in the channel insane.
16:57  greycat: adac: You can do that too.
16:57  greycat: You said AN example, not EVERY example.
16:58  adac: greycat, heeh I meant that
16:58  adac: sory
16:58  adac: ;)
16:58  hallucynogenyc: I have a file in which I have two columns of data. I need to insert a string "abcd" in each line as a first column, moving the initail 2 columns to the 2nd and 3rd position
16:58  hallucynogenyc: any ideas?
16:58  paxl: greycat: I didn't wanted you to be insane.. I just wanted to get every info before thanking you out :D
16:58  paxl: thanks a lot Greycat
16:58  Ward|: how can i echo something on multiple lines?
16:58  greycat: hallucynogenyc: sed 's/^/abcd /'
16:58  greycat: Ward|: printf
16:58  Ward|: thanks greycat
16:59  hallucynogenyc: greycat, can you tell me what does that solution consist in?
16:59  hallucynogenyc: I've never heard about "sed"
16:59  greycat: man sed
16:59  hallucynogenyc: ok ;)
17:00  mcl0vin: howdy folks
17:01  mcl0vin: how can i grep crontab -l to show me which script is sending email with handler "foo@bar.com"
17:01  Ward|: greycat, strange printf "bla\nbla\nbla\n" | awk -W interactive '!NR%3' outputs nothing
17:01  Ward|: i mean %2
17:02  hallucynogenyc: so, sed reads a file and applies the script 's/^/abcd /'
17:02  greycat: Ward|: if the -W interactive changes the output, then go straight to #awk, because we won't know
17:02  hallucynogenyc: now, what does 's/^/abcd /' mean?
17:02  greycat: !sed
17:02  greybot: sed is a Stream Editor, used to filter output. It's NOT primarily useful for editing files (use ed or perl instead). Ask sed questions in ##sed.
17:02  Naib: mcl0vin. crontab -l | grep "foo@bar.com"
17:02  greycat: If you don't even know what s/foo/bar/ means you are in for a LOT of reading.
17:02  Naib: doesn't that work?
17:03  greycat: Naib: I think he wants to grep each individual program that crontab invokes, but maybe I'm misunderstanding.
17:03  Naib: oh
17:03  Naib: ok
17:03  hallucynogenyc: but, I see sed is for filtering
17:03  Naib: guess it is iterative over the list then
17:03  hallucynogenyc: and what I need is to create a column and to concatenate it to an existing file
17:04  hallucynogenyc: can't see how sed 's/^/abcd /' is matching my needs
17:04  adac: greycat, Well its a combined thingy. On eon hand I'd like to have \n and others in ym string and also my string should be not only one line but more lines in bash code
17:04  mcl0vin: Naib: that will not work right...
17:05  mcl0vin: am thinking about it now. crontab will only have the path to the script
17:05  mcl0vin: hmmm how would i do that, then
17:06  greycat: hallucynogenyc: perhaps you wanted 'paste', then
17:07  greycat: mcl0vin: there is no guarantee that a line of a crontab will end with a fully qualified pathname.  Many crontabs have the actual shell code directly inside them.
17:07  hallucynogenyc: greycat, I've already thought on paste
17:07  greycat: mcl0vin: I suppose you could check whether field 6 is an executable file.
17:07  Ward|: greycat, the solution was awk -W interactive 'NR%2==0'
17:07  hallucynogenyc: but then, I need to create the first column before "pasting" it to the file
17:07  Ward|: in case you eant to know
17:08  greycat: !wayttd > hallucynogenyc
17:08  greybot: hallucynogenyc: What Are You Trying To Do?
17:08  adac: On echo thsi piece of script does not echo me the newline: http://pastie.org/1235618 any ideas what I do wrong?
17:10  hallucynogenyc: I have a file named "year" which contains a list of" months" on the first column and a list of "temperatures" on the second column. I need to create a file which has the "year" in the first column, the "month" on the second column and the "temperature" on the third column
17:10  greycat: If the name is "year" and not "2009" then how do you know which year to put at the start of each line?
17:11  hallucynogenyc: year is the name of the file
17:11  hallucynogenyc: I already have this on a variable named year
17:11  hallucynogenyc: anyway
17:11  greycat: sed "s/^/$myvariable /" year > newyear
17:13  hallucynogenyc: can you point me into the bashguide page where I can find the s/foo/bar explanation?
17:13  greycat: /topic #sed
17:13  greycat: man sed
17:13  greycat: google sed
17:13  greycat: GRRRRR.   Make that first one /topic ##sed
17:13  greycat: Stupid freenode.
17:13  hallucynogenyc: I've read the man sed page, however it says that it uses the script you put in it to edit a file
17:14  greycat: *plonk*
17:14  lumpy4565: http://en.wikipedia.org/wiki/Sed
17:14  hallucynogenyc: now what I want to know is how to interpret this kind of script
17:14  hallucynogenyc: gonna read that wikipedia page then
17:17  hallucynogenyc: If I don't need to keep that first file
17:17  hallucynogenyc: I guess I can just use sed -i "s/^/$myvariable /" year
17:19  lumpy4565: Yes, sed "s/^/$myvariable /" -i year  will overwrite "year"
17:19  greycat: !sed-i
17:19  greybot: A common request is how to write to the same file as the one you read. "sed -i" is a potential solution, but keep in mind the -i flag to sed is nonstandard and not portable. If in doubt, use a temp file. See !faq 21 and ask me about ed.
17:20  cthuluh: hallucynogenyc: while read -r; do printf '%s %s\n' "$myvariable" "$REPLY"; done < file > file.new && mv file.new file
17:20  cthuluh: this way you can have anything in myvariable
17:21  hallucynogenyc: and can't I have it with greycat's solution?
17:24  cthuluh: hallucynogenyc: you can, of course, but sed is driven by what's in the commands you give it. consider  myvariable='foo/bar' in your example. it would fail
17:24  hallucynogenyc: aha
17:24  hallucynogenyc: so, analyzing your script
17:24  hallucynogenyc: I seem to understand most of it, except the reply -r part
17:25  cthuluh: ''help read''
17:25  greycat: !guide
17:25  greybot: http://mywiki.wooledge.org/BashGuide
--- Log closed Wed Oct 20 21:13:12 2010
--- Log opened Wed Oct 20 21:13:32 2010
21:13 --- Users 556 nicks [0 ops, 0 halfops, 0 voices, 556 normal]
21:15 --- Channel #bash was synced in 105 seconds
--- Log closed Wed Oct 20 21:21:39 2010
--- Log opened Wed Oct 20 21:22:01 2010
21:22 --- Users 558 nicks [0 ops, 0 halfops, 0 voices, 558 normal]
21:23 --- Channel #bash was synced in 91 seconds
21:28  Matuku: What do the 1% and underscore in that command do/can someone point me to the page in the FAQ that discusses their usage here?
21:29  erUSUL: !find > Matuku
21:29  greybot: Matuku: http://mywiki.wooledge.org/UsingFind
21:29  erUSUL: Matuku: ${1%.avi} this is parameter expansion of $1
21:29  erUSUL: !pe > Matuku
21:29  greybot: Matuku: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
21:30  Matuku: erUSUL: ah and trims it I see; thanks for the links, been looking through the FAQ and couldn't find the right section
21:30 --- abstract4d is now known as abstract3d
21:31  greycat: FAQ 73 and 100 for PE stuff
21:31  erUSUL: Matuku: no problem
21:33  Matuku: Is the use of the underscore in the same FAQ pages?
21:33  greycat: if you're referring to find ... _ {} \; then it's on UsingFind
21:33  erUSUL: Matuku: in the using find page
21:33  Matuku: kk, thanks
21:40 --- progma_ is now known as progma
21:40  Matuku: I'm trying to run a command first of all to make convert all the avi into mkv
21:41  Matuku: I have: find . -name "*.avi" -execdir HandBrakeCLI -i {} -o {}.mkv -f mkv -e x264 -S 450 -N eng
21:41  Matuku: But this of course gives the output foo.avi.mkv; PE looks to be able to trim the avi off just as i'd want but there's no parameter as such to use, is there?
21:42  greycat: If you want to do ANYTHING other than {} as an argument (e.g. {}.mkv) then you must use -exec bash -c '...' or -exec sh -c '...'
21:42  Matuku: And do it that way; kk
21:43  greycat: imadev:~$ find .bashrc -exec echo {}.foo \;
21:43  greycat: {}.foo
--- Log closed Wed Oct 20 21:49:15 2010
--- Log opened Wed Oct 20 21:49:37 2010
21:49 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
21:51 --- Channel #bash was synced in 91 seconds
21:58  Matuku: find ./ -type f -name "*.avi" -exec bash -c '[[ -f "${1%.avi}.mkv" ]]' _ {} \; -exec echo rm {} \;
21:58  Matuku: In this does the second command not get executed if the first comes back false?
21:58  greycat: correct
21:59  greycat: personally I would've combined them into the same bash -c '...'
21:59  Matuku: Is that the case for all find commands or just ones containing an evaluation?
21:59  greycat: all
22:00  greycat: e.g. if -type f fails (not a regular file) then it doesn't go on to try -name *.avi
22:02  Matuku: Sorry I meant the ' [[ ... ]] ' bit
22:02  Matuku: If that comes back false it doesn't execute the "echo rm"?
22:02  greycat: [[ is a bash command, not a find command
22:03  greycat: if [[ returns false, then the find's -exec "evaluates" as false, and therefore it won't do the next -exec
22:03  greycat: I skipped a step there.
22:03  Matuku: Cool, that's what I meant
22:03  greycat: If [[ returns false, then bash returns false, and therefore the first -exec evaluates as false...
22:04  Matuku: Is it only if it evaluates as false or, for example, if the command within -exec failed?
22:04  greycat: [[ is a bash command and returns true or false
22:05  greycat: If the -exec command fails to run, that will also return a non-successful exit status, which means "false"
22:05  Matuku: Excellent :)
22:07  Matuku: find . -name "*.avi" -exec bash -c 'if [[ -f "${1%avi}.mkv ]]; do HandBrakeCLI -i "$1" -o "${1%.avi}.mkv" -f mkv -e x264 -S 450 -N eng; done' _ {} \;
22:07  greycat: then, not do
22:07  greycat: and fi rather than done
22:07  Matuku: Ah, mixing up if and while
--- Log closed Wed Oct 20 22:15:49 2010
--- Log opened Wed Oct 20 22:16:13 2010
22:16 --- Users 548 nicks [0 ops, 0 halfops, 0 voices, 548 normal]
22:16 --- Server: [hubbard.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
22:16  greycat: it ignores new files by default...
22:16  floh79: greycat: Oh?
22:16  floh79: Well let me try.
22:17 --- Channel #bash was synced in 92 seconds
22:17  greycat: well, I guess it says one line ("Only in new: ...") but it doesn't list out the contents
22:20  floh79: greycat: Well you're right. Thank you.
22:26  enzotib: from which version of bash 'read' has the -p option?
22:27  erUSUL: !faq features
22:27  greybot: http://mywiki.wooledge.org/BashFAQ/061 -- Is there a list of which features were added to specific releases (versions) of Bash?
22:27  greycat: Somewhere between 1.14 and 2.05
22:27  enzotib: thank you erUSUL and greycat
22:28  greycat: 2.04 also has it
22:28  greycat: I don't have anything between 1.14.7 and 2.04 to test with
22:29  erUSUL: enzotib: http://wiki.bash-hackers.org/scripting/bashchanges claims bash 2.0
22:30  enzotib: erUSUL: I see
22:30  greycat: wouldn't surprise me
22:36  Nezmer: hi, I've been told already today that ${!name[@]} wouldn't work. Is there another way to achieve this, I mean arrays where a variable is a part of their name
22:36  greycat: Why wouldn't it work?  You're in bash 2.x?
22:36  greycat: Oh.  Because you left out part of the question.
22:36  greycat: Because you're actually asking about INDIRECT arrays.
--- Log closed Wed Oct 20 22:42:28 2010
--- Log opened Wed Oct 20 22:42:52 2010
22:42 --- Users 546 nicks [0 ops, 0 halfops, 0 voices, 546 normal]
22:43  gintek: hi folks, i have problem with this  for i in {1..5};do echo {1..$i};done, when use echo {1..5} it`s ok but when use variable $i its error any idea ?
22:43  greycat: !faq ..$
22:43  greybot: greycat: No matches found at http://mywiki.wooledge.org/BashFAQ
22:43  greycat: !pf ..$
22:43  greybot: http://mywiki.wooledge.org/BashPitfalls#pf32 -- Don't do this! -- for i in {1..$n}
22:44 --- Channel #bash was synced in 89 seconds
22:46  erUSUL: gintek: use a c style for?
22:46  erUSUL: !cfor
22:46  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
22:46  greycat: Too damned long.
22:46  greycat: "C-style for" should not have to say anything about the NON-C-style for loop.
22:47  greycat: !forget cfor
22:47  greybot: OK, greycat
22:48  greycat: !learn cfor C-style for loop: for (( expr; expr; expr )); do COMMANDS; done # Each expr is done in a math context.  Example: for ((i=i; i<=n; i++)); do echo "$i"; done
22:48  greybot: OK, greycat
22:49  gintek: first i read the manula, but what witch echo {1..5}, in bash its work, in scripts dont
22:49  greycat: !sh > gintek
22:49  greybot: gintek: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
22:50  greycat: Brace expansion is a Bash feature.  It's not in POSIX or Bourne, and therefore it's available when you write for sh.
22:50  greycat: ... NOT available when you write for sh.
22:52  Bushmills: !#!
22:52  greybot: Jargon, from "hash bang", or "#!". The shebang line is read by the kernel when a script is executed. See http://www.in-ulm.de/~mascheck/various/shebang/
22:53  greycat: Oh, FUCK.  greybot's metadata is overwriting instead of appending....
22:54  pragma_: FUCK!
22:54 --- taylanub0 is now known as taylanub
22:55  greycat: Missing one > on the learn command.....
22:56  greycat: !version
22:56  greybot: greybot 2010-10-20
22:56  greycat: !forget foo
22:56  greybot: OK, greycat
22:56  greycat: !learn foo not bar
22:56  greybot: OK, greycat
23:02  pragma_: !learn FUCK FUCK FUCK
23:02  greybot: fuck is already defined: nobody has ever been able to fuck over the internet (yet). Stop using that word
--- Log closed Wed Oct 20 23:11:06 2010
--- Log opened Wed Oct 20 23:11:27 2010
23:11 --- Users 536 nicks [0 ops, 0 halfops, 0 voices, 536 normal]
23:11 --- Tramp_ is now known as Tramp
23:12 --- Channel #bash was synced in 92 seconds
23:20  dagni: how i can display only lines, that are present im both files ?
23:21  pgas: !faq subtract
23:21  greybot: http://mywiki.wooledge.org/BashFAQ/036 -- How can I get all lines that are: in both of two files (set intersection) or in only one of two files (set subtraction).
23:22  dagni: pgas: i see, but i what if i want to display only second lines, that have identical only word in the line ?
23:22  dagni: let me try to ask again ;P
23:23  dagni: i need to display only lines, that have identical second collumn ? (collumns are separated by space)
23:24  pgas: join can probably do what you want or awk in #awk....good night
23:25  dagni: n8 ;)
23:25 --- muzer is now known as MuzerAway
23:26  nDuff: ...if the FAQ doesn't cover that scenario, uniq -d on the column alone, then join with the rest of the file
23:26 --- jzacsh_ is now known as jzacsh
23:27  dagni: thank you nDuff
23:30  wuffi600: hi.
23:32  wuffi600: ps shows me a stopped task that i would like to continue running. How can i change it's status to running? Can i continue this task as with nohup? The task is a subtask of a non accessible shell. Wold be very nice if you could help.
--- Log closed Wed Oct 20 23:38:43 2010
--- Log opened Wed Oct 20 23:39:06 2010
23:39 --- Users 535 nicks [0 ops, 0 halfops, 0 voices, 535 normal]
23:40  nDuff: wuffi600, ...so, the behavior depends on details you haven't provided. Why do you believe the shell is no longer accepting output just because there's no user connected?
23:40 --- Channel #bash was synced in 90 seconds
23:40  nDuff: wuffi600, (it may be true if there's a more serious bug somewhere, but if so, you're in a bad place short of tools like retty)
23:41  yoritomo: hello all
23:42  yoritomo: i would like to insert a file comparison on a condition, like a test  a cmp or a diff , failing always
23:42  wuffi600: is there a "renohup" command in addition to "nohup" in analogy to "renice" and "nice"?
23:43 --- caemir_ is now known as caemir
23:43  yoritomo: my purpose is to test between 2 ini file, if second one is newer need to do an action
23:43  wuffi600: yoritomo: if test diff foo bar ; then ...
23:43  cthuluh: wuffi600: gdb as root, perhaps
23:44  cthuluh: wuffi600: no
23:44  yoritomo: wuffi600 that is more a syntax problem
23:44  cthuluh: yoritomo: ''help test'', look for -N
23:44  cthuluh: !if > yoritomo
23:44  greybot: yoritomo: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
23:44  nDuff: knowing if they're different and knowing if one is newer are two different questions
23:45  yoritomo: i was ready ubuntu doc and some other page but i don't understand well about bash syntax
23:45  nDuff: (and there are very different performance implications depending on which you want)
23:45  cthuluh: ok then, yoritomo, please read this...
23:45  cthuluh: !guide > yoritomo
23:45  greybot: yoritomo: http://mywiki.wooledge.org/BashGuide
23:46  yoritomo: c = test /home/yoritomo/capture001.avi -nt /home/yoritomo/capture002.avi       if [c]; then      echo different
23:46  yoritomo: thanks
23:46  cthuluh: no, no
23:46  tsolox: cat somefile|grep -v name1|grep -v name2|grep -v name3 > resultfile   <---------- how can i put name1,name2, name3 and so on into an array or list in order to make the code generic...
23:47  cthuluh: yoritomo: you're trying to guess syntax. please read the guide and the links about the if clause
23:47  yoritomo: ok
23:47  wuffi600: ok, i try a kill -CONT an the rsync task (if the task will end up failed, i will be of about 45 Minutes of handwork to prepare things to be able to restart the rsync again as continuing the failed task.)
23:47  nDuff: tsolox, egrep -v 'name1|name2|name3' somefile; to generate that string from an array, see how some_array[*] works
23:48  nDuff: tsolox, ...mind you, if the set of characters which can legitimately be found in that array isn't restricted, some quoting is called for.
23:48  nikola: dont bash me, people, but i like gui more :DD (sorry i had to)
23:48  geirha: array=( -e name1 -e name2 -e name3 ); grep -v "${array[@]}" somefile
23:49  geirha: !faq intersect > tsolox
23:49  greybot: tsolox: http://mywiki.wooledge.org/BashFAQ/036 -- How can I get all lines that are: in both of two files (set intersection) or in only one of two files (set subtraction).
23:49  tsolox: the array could be empty, the trouble is , grep won't work in this situation?!!?
23:50  geirha: Then test it first
23:50  helo: yoritomo: after reading up on the if syntax, try just "if ! diff /home/yoritomo/capture001.avi /home/yoritomo/capture002.avi; then echo different; fi"
23:50  geirha: ((${#array[@]})) && grep -vF "${array[@]}" somefile
23:50 * helo electocutes nikola
23:51  geirha: cmp is more suited than diff for that one
23:51 * nikola is newbie, i have respawn time protection 
23:51  helo: ahh, yeah
23:52  poisonbit: http://paste.debian.net/plain/97388
23:52  yoritomo: wow thanks helo, it works
23:52  helo: yoritomo: if ! cmp -s /etc/hosts /etc/hostname; then echo different; fi
23:52  helo: that's better...
23:52  cthuluh: !questions > poisonbit
23:52  greybot: poisonbit: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
23:52  yoritomo: of course i will not use it with the echo that will serve to launch ncftp to download files from a ftp
23:53  geirha: !faq indirect > poisonbit
23:53  greybot: poisonbit: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
23:53  poisonbit: cthuluh, sorry, I'm getting bad substitution, I don't know the right syntax
23:53  geirha: poisonbit: Also, declare will make a variable local to the function.
23:53  poisonbit: thanks geirha
23:53  poisonbit: ok
23:54  geirha: You cannot declare a global associative array from whitin a function.
23:54  poisonbit: errr if was for testing purposes, to get a variable array name
23:57  poisonbit: mmm i don't see the syntax for what i'm trying in that faq
23:57  caotic: hi I was thinking of making a script that echoes lines of a file only when they match at least one regular expression of a given set, to be able to run it multiple times with different regexp sets. and most likely something like this already exists, any ideas or suggestions ?
23:58  nakkor: simple q: I am trying to delete files matching a regex, but I can't seem to git it to work
23:58  helo: caotic: awk script?
23:58  yoritomo: helo if i pass many arguments to execute in the if , i use [] ?
23:58  nakkor: my statement: find . -regex '^((?!@2x).)*$' --exec rm {} \;
23:58  wuffi600: thanx you for your help.
23:58  caotic: helo: sund about right :)
23:59  Cyber_Beast: I have just learned using inbuilt temporary variable into bash "$$"... well that was just a one. I amaze, what if i want to use multiple temporary variables? Any idea, guys?
23:59  prince_jammys: nakkor: explain what files you want to delete.
23:59  nDuff: nakkor, one quick obvious thing: --exec is wrong; it should be only -exec
23:59  nDuff: nakkor, ...and you probably want + rather than ;
23:59  nakkor: delete everything that doens't have a @2x in the file name
--- Log closed Thu Oct 21 00:00:03 2010
