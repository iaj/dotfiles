--- Log opened Tue Dec 14 11:47:24 2010
--- Log closed Tue Dec 14 11:47:24 2010
--- Log opened Tue Dec 14 11:52:47 2010
11:52 --- Users 502 nicks [0 ops, 0 halfops, 0 voices, 502 normal]
11:54 --- Channel #bash was synced in 99 seconds
11:56  hendry: anyone care to review my shell script for style issues? http://greptweet.com/hgweb.cgi/file/tip/fetch-tweets.sh
11:59 --- Unknown[OFF] is now known as Unknown[NF]
12:12  leo2007: wow, there are so many users here.
12:12  leo2007: What exactly is the use of dirs?
12:13  jww: hi leo2007 .
12:13  lhunath: leo2007: sorry?
12:13  koala_man: leo2007: shows the list of dirs you have pushd
12:13  leo2007: hi jww and lhunath.
12:14  lhunath: !varcap > hendry
12:14  leo2007: I see. thanks, koala_man.
12:14  kotique: guys!
12:14  kotique: I've got a problem with subprocess sending sighup
12:14  lhunath: hendry: use lower-case vars. quote your PEs.
12:14  kotique: error: %post(nginxcp-1.6-2.x86_64) scriptlet failed, signal 1
12:14  kotique: for:  sh -c 'trap "" SIGHUP; nohup /usr/local/cpanel/whostmgr/bin/whostmgr2 --updatetweaksettings > /dev/null 2>&1'
12:15  kotique: anyone knows why it slips through?
12:15  hendry: lhunath: what does !varcap mean? I don't think I got the message, unless it was "use lower-case vars. quote your PEs"
12:15  lhunath: hendry: the bot is dead
12:16  pgas: hendry: using lower case variable names you avoid conflict with the environment variables
12:16  hendry: lhunath: why lowercase variables?
12:17  hendry: pgas: ah thanks, good to know :)
12:17  hendry: pgas: so $temp instead of $TEMP, okaiz
12:18  hendry: lhunath: which line am I using an unquoted PE for example?
12:18  pgas: yes, for instance variables like SECONDS TMPDIR or even PATH are likely to cause trouble if you use them in scripts
12:19  pgas: hendry: almost everywhere: "$var"
12:19  pgas: also you use expr and $(()) since you use $(( )) you don't need expr
12:21  hendry: pgas: i wonder if $(()) is faster than expr. I find expr easier to read... hmm
12:21  pgas: sh# echo $RANDOM
12:21  shbot: pgas: 32623
12:21  pgas: I'm not sure if RANDOM is supported by all the sh
12:22  hendry: pgas: so what do ppl use instead for RANDOM?
12:22  hendry: is there a shell bueatifier to quote my variables? I am reluctant to go quote everything painstakingly
12:22  lhunath: no
12:23  TheBonsai: one could use AWK to get some pseudo random value
12:23  TheBonsai: iirc it has some rand() or similar
12:24  TheBonsai: omg
12:24  kotique: shell must be interactive for signal trap to work.
12:24  TheBonsai: found below an article about bash for loops:
12:24  TheBonsai: "Thanks for writing this article Vivek - it is very useful. In particular, I didn't know about bash's built-in 'help' command and was getting frustrated with the lack of detail in 'man for'"
12:25  TheBonsai: what the... :)
12:25  Riviera: kotique: 8)
12:25  ferret: lack of detail?
12:25  ferret: Surely it doesn't exist at all?
12:25  Riviera: TheBonsai: congratulations Vivek.
12:25  Riviera: 8)
12:25  TheBonsai: <-- not vivek :)
12:25  Riviera: That's why I thought it was funny ;P
12:26  TheBonsai: http://www.cyberciti.biz/faq/bash-for-loop/
12:26  TheBonsai: vivek is the cyberciti guy
12:28  ferret: TheBonsai: Vivek is a name in this channel
12:29  pgas: I think vivek is a quite common
12:30  ferret: Article implies that for loop can only iterate over integers.
12:31  TheBonsai: which is effectively wrong since it can loop over any string :D
12:32  eboyjr: whats a vivek?
12:33  TheBonsai: eboyjr: ask Vivek :P
12:34  Riviera: at least bonsai has now a rough idea how the for loop works
12:34  ferret: I hope that means I won't have to explain it to him ever again
12:34  eboyjr: lol
12:34  TheBonsai: yea, i always wondered. i always did "for fucks sake", and bash answered with weird messages
--- Log closed Tue Dec 14 12:41:36 2010
--- Log opened Tue Dec 14 12:52:01 2010
12:52 --- Users 500 nicks [0 ops, 0 halfops, 0 voices, 500 normal]
12:52  hendry: no
12:52  hendry: :)
12:53 --- Channel #bash was synced in 103 seconds
12:55  alez{xmb{bottz}}: superalez
12:55  TheBonsai: that cheap raid controllers cause trouble by design isn't an argument against raid, imho. for now, there's no alternative (i.e. no monolithic big and self-redundant disks)
12:55  alez{xmb{bottz}}: heyasai
12:55  alez{xmb{bottz}}: self repaeiring
12:55  alez{xmb{bottz}}: and regenerating
12:56  alez{xmb{bottz}}: bunsai did ya check the def.koud.sch url
12:56  hendry: TheBonsai: do you recommend consumer raid solutions for backup? QNAP and the sort?
12:57  alez{xmb{bottz}}: just for some examples written, natural language to koud in ... laik inglisch
12:59  TheBonsai: hendry: i work in IT, i may have unrealistic opinions about it. it would be a great start if (end-)consumers make backups at all :) [instead of whining when data is gone]
13:06 * poisonbit purchased 2TB to make home backups, only one home machine has raid
13:15  davidlt: A="/usr/bin/sqlite3 -column /www/pages/emeter/recess/sqlite/default.db 'SELECT count(*) FROM measurements'"
13:15  davidlt: B=$($A)
13:16  davidlt: I get: /usr/bin/sqlite3: Error: too many options: "count(*)"
13:16  TheBonsai: !faq complex
13:16  cthuluh: !complex > davidlt
13:16  cthuluh: wow
13:16  TheBonsai: grey.....damn
13:16  davidlt: am?
13:16  cthuluh: davidlt: use an array to store your command
13:16  davidlt: example?
13:16  TheBonsai: http://mywiki.wooledge.org/BashFAQ/050
13:17  cthuluh: (or don't try to store commands in variables at all)
13:17  davidlt: Thanks
13:24  Worf: i have a csv table, every field with double quotes, semicolon seperated ( "a";"b";"c";... ). any tips on handling such files? i guess converting to some tab-seperated file would ease handling that with shell scripts, or are there some tricks handlin such 3-char seperators ?
13:31  piti: Worf: awk may help with that kind of files
13:32  cthuluh: Worf: http://awk.freeshell.org/AwkTips#toc6
13:32  Worf: cthuluh: oooh ... thanks!
13:40  TheBonsai: Worf: the Klingon's Empire drives its ships with AWK operating systems? that explains much :)
13:45  Worf: TheBonsai: no, but i currently have to work for Federation people ... and you don't want to know what they use ...
13:46  alez{xmb{bottz}}: 7xmb
13:46  TheBonsai: Worf: :)
13:48  alez{xmb{bottz}}: smileicsz
13:50  alez{xmb{bottz}}: mightynecsz:
13:50  alez{xmb{bottz}}: ruleset walkthru runwayscz
13:51  ferret: Haven't you been banned yet?
13:51  alez{xmb{bottz}}: i give u a ban in yer mouth
13:52  alez{xmb{bottz}}: seems u forgot that i own all
13:52  alez{xmb{bottz}}: eh
13:52  alez{xmb{bottz}}: im the " ownowman"
13:52  TheBonsai: ferret: minimum 1000 times in the last 10 years :)
13:52  alez{xmb{bottz}}: nada
13:52  alez{xmb{bottz}}: lies
13:53  alez{xmb{bottz}}: ill take over freenode
13:53  alez{xmb{bottz}}: then ull know
13:53  alez{xmb{bottz}}: what own is
13:53  TheBonsai: and he works on his next ban, it seems
13:53  TheBonsai: some people just don't evolve
13:53  alez{xmb{bottz}}: u need better wording
13:53  alez{xmb{bottz}}: and more validnecsz
13:54  alez{xmb{bottz}}: so god and xmb and alez and bottz: thebonsai is not walid
13:54  alez{xmb{bottz}}: k
13:54  TheBonsai: whatever
13:54  alez{xmb{bottz}}: k
14:00  thnee_: is there any easy way to get the canonical path for either a file or a dir? for a dir, i can do cd $path and pwd and cd -, but isnt there some program/command that does these things for me?
14:00  thnee_: or do i have to take out the dir-part of the path, if it is a file??
14:00  TheBonsai: there is no unique canonical path for a given location
14:01  poisonbit: # readlink -f .bashrc
14:01  evalbot: poisonbit: /root/.bashrc
14:01  thnee_: TheBonsai ofcourse there is =)
14:01  poisonbit: # mkdir music; readlink -f music
14:01  evalbot: poisonbit: /root/music
14:02  TheBonsai: thnee_: whatever you say
14:02  TheBonsai: http://mywiki.wooledge.org/BashFAQ/028
14:02  alez{xmb{bottz}}: there are inodes
14:02  TheBonsai: what an idiot.
14:02  poisonbit: # mkdir music; ln -s music k; readlink -f k    # OUCH
14:02  evalbot: poisonbit: /root/music
14:02  alez{xmb{bottz}}: self j00
14:03  alez{xmb{bottz}}: wendeta
14:03  TheBonsai: lol. you are the same kid you have been in the last years. when do you grow up?
14:04  thnee_: TheBonsai im sure youre right, there are tons of relative things going on. but what does `pwd` do in that case?
14:05  thnee_: because it seems to do exactly what i want..
14:05  TheBonsai: the builtin (shell's) pwd follows a "virtual path"
14:05  TheBonsai: it tracks all the cd's and stuff
14:05  alez{xmb{bottz}}: for the rekord: {alekchsczx} {xmb} {bottz} {ouwhn} {n l o} {lab} {rapktschevf} {a} {!i} {o} {evf em bi} {fucked microsuxx bot} {x{ch{i{k{csz}}}} {e{m}} {b{e|i}}}
14:06  alez{xmb{bottz}}: ouwn
14:06  thnee_: based on what assumption to produce a presumed canonical path?
14:06  TheBonsai: # mkdir dir1; ln -s dir1 dir2; cd dir2; pwd; /bin/pwd
14:06  evalbot: TheBonsai: /root/dir2
14:06  evalbot: TheBonsai: /root/dir1
14:06  thnee_: because the output is not realtive to the cd's? its realative to / ?
14:07  thnee_: TheBonsai ok so you were only referring to the fact that there can be symlinks?
14:07  TheBonsai: it's about the difference between the shell's "tracked cwd" and getcwd()
14:08  thnee_: because thats not a problem, i just need the canonical path to whatever the user specified, its up to the user to know if it is a symlink or not
14:08  TheBonsai: that's the point
14:08  TheBonsai: the "the"
14:09  TheBonsai: i never said there is no canonical path
14:09  TheBonsai: i said there is no UNIQUE canonical path
14:09  thnee_: i said i need A canonical path
14:09  TheBonsai: <thnee_> is there any easy way to get the canonical path for either a file or a dir? for a dir, i can do cd $path and pwd and cd -, but isnt there some program/command that does these things for me?
14:09  thnee_: oh ok
14:10  thnee_: so youre a magic marker
14:10  thnee_: thanks!
14:11  thnee_: so now that we are on the same page, is there something that does what i want, for both files and dirs?
14:12  koala_man: why is there no unique canonical path?
14:15  TheBonsai: because a file location is not unique per se. if it was, ksh, zsh and bash wouldn't need a special pwd builtin instead of just calling getcwd()
14:17  koala_man: a file location is not unique, that's why you separate paths and canonical paths
14:17  TheBonsai: btw
14:18  TheBonsai: i mean this
14:18  TheBonsai: > pwd; ls -l ../ftp/
14:18  TheBonsai: /home/ftpservice/ftp
14:18  TheBonsai: /bin/ls: ../ftp/: No such file or directory
14:20 --- Unknown[NF] is now known as Unknown[OFF]
14:23 --- jzacsh is now known as jzacsh_
14:30 --- gintek_ is now known as gintek
14:41 --- eric-atl_ is now known as eric-atl
14:49 --- shai_ is now known as shai
14:52  act_as_c1der: how can i source file from a script so that that environment is available outside of that script (in the calling terminal) ?
14:55  strull_: you can't (unless you already sourced the calling script)
14:56  thnee_: how can i feed input programatically to 'read' ?
14:57  thnee_: i have a distributed script that i dont want to modify, that asks for a password using 'read', and i want to call this multiple times, feeding the password string from script
14:58  Riviera: thnee_: by writing to where read reads from
14:58  Riviera: thnee_: which usually is stdin
14:58  thnee_: Riviera yeah
14:58  Riviera: thnee_: you might use a pipe | or the redirection operator <
14:58  thnee_: so i can just .. ok
14:59 * bintut waves
14:59  thnee_: even though the other script doesnt call 'read' until later?
--- Log closed Tue Dec 14 15:03:14 2010
--- Log opened Tue Dec 14 15:13:38 2010
15:13 --- Users 520 nicks [0 ops, 0 halfops, 0 voices, 520 normal]
15:14  Riviera: jetole: I don't feel like guessing what you would mean with "curses style" and I am not sorry for it.
15:15 --- Channel #bash was synced in 101 seconds
15:16  bintut: dialog?
15:16  jetole: Riviera: perhaps I mis spoke. I mean a script with a completely interactive cursor so for example I can display a static page with information fields changing or create virtual/terminal windows if I wanted with prompts etc all in the console.
15:18 * bintut is going to take a nap. good night to all. thanks Riviera..
15:18  jetole: Riviera: For example I'm writing a script at the moment which displays network data that scrolls line by line but instead I am thinking I can create a non scrolling display where I can just update segments of the display to show different data without scrolling a line
15:19  Riviera: yes well
15:20  Riviera: jetole: that would actually be fairly easy even,
15:21  Riviera: jetole: but I'd say everything that you cannot do with dialog is idiotic to do with bash;
15:21 --- Guest29273 is now known as Nemphilis
15:22  Riviera: jetole: try tput csr 10
15:22  Riviera: jetole: what you might experience is the first 10 lines on the terminal being static
15:22  jetole: Riviera: thanks for the tput reference
15:22  Riviera: jetole: while the rest would scroll
15:23  Riviera: jetole: so with that you could keep static information in the first 10 lines, showing your network data in the rest
15:23  jetole: Riviera: well that doesn't sound like much but I think it's a start
15:23  Riviera: jetole: also, dialog offers tail features, i believe
15:23  Riviera: jetole: yes, it does not sound like much, but that's what your example asked for
15:25  jetole: Riviera: I have to lookup dialog the term tail doesn't sound promising. I would like to write a script that can look more like a C application using ncurses where I can change specific sections of the screen, for example, I can have a section in the top left that show packets per second my machine is receiving and update that part without having to clear the screen or scroll a line.
15:25  seyz: hi, it's possible to escape all characters in a variable with bash ?
15:25  jetole: I wrote a C script years ago that did this well. I'd be surprised if someone hasn't taken that power to a terminal app
15:26  Riviera: ..
15:27  Riviera: seyz: what do you mean? To backslash-escape all of the characters? Or to protect everything in the variable to be treated specially through expansions of the shell?
15:28  koala_man: seyz: do you mean "my script breaks when filenames have spaces, how can I fix it?"?
15:29  seyz: Riviera yes, I want to add a backslash to escape some characters (like ")
15:29  seyz: koala_man no
15:29  Riviera: seyz: try this: printf -v var %q "$var"
15:32  Perun_: it is possible to done it better: POOL=`basename $i` | sed 's/db.ippool.//g' | sed 's/_pool//g', I need FOO from /bla/bup/db.ippool.FOO_pool
15:32  Perun_: s/done/do
15:34  Riviera: # var=/bla/bup/db.ippool.FOO_pool var=${var##*db.ippool.} var=${var%_pool}; echo "$var"
15:34  evalbot: Riviera: FOO
15:35  Perun_: Riviera: danke :)
15:35  Riviera: :)
15:36 --- fddfoo is now known as fdd
15:44  lostern: In bash 3.1 if I have something like case "$foo" in *[A-Z]*) exit 1; ;; esac; exit 0; why do I reach the "exit 0" but not in bash 3.2?
15:46  TheBonsai: what is your test value for $foo?
15:46  lostern: TheBonsai: FOO
15:46  lostern: TheBonsai: Actually I should add that the case is in a loop
15:47  lostern: (while read $foo; do)
15:47  lostern: works in bash 3.2 but not in bash 3.1
15:47  TheBonsai: while read foo
15:47  TheBonsai: not $foo
15:48  TheBonsai: and: what is [A-Z] meant to match?
15:48  lostern: TheBonsai: Any uppercase char in string
15:48  TheBonsai: then use [[:upper:]]
15:48  lostern: yes while read foo
15:49  TheBonsai: [A-Z] is wrong
15:49  lostern: it works. I wanted to avoid bashisms
15:49  lostern: (not sure if that is)
15:49  pgas: it's not, and the behaviour should not be different between 3.1 and 3.2
15:49  TheBonsai: it's wrong.
15:50  TheBonsai: A-Z in ABCD...abcd... does what you want, but not in AaBbCcDd...Zz
15:54  lostern: TheBonsai: Still doesn't work with :upper:
15:54  lostern: [[:upper:]]
15:54  pgas: set -x is your friend
15:54  TheBonsai: i didn't say it fixes your current problem, i just meant it fixes a bug you don't even know you made :)
15:54  pgas: run you script with 'sh -x yourscript' and see what's really executed
15:54  TheBonsai: can you give me complete example code to run? (pastebin!)
15:54  lostern: TheBonsai: sort of. It is a svn commit hook which makes debugging a bit complicated
15:54  Fatal: lostern: try us
15:54  lostern: one sec
15:56  knob: Good mornign =)
15:56  knob: *morning
15:56  lostern: pgas, TheBonsai, Fatal: http://pastebin.com/AJw81Eun
15:57  lostern: Again, it works for me one machine with bash 3.2, not on another with bash 3.1
15:57  lostern: so "works for me" wouldn't be that helpful
15:58  pgas: lostern: run you script with bash -x yourscript and see what's really executeed
15:58  lostern: /tmp/foo.log contains "not-lower" and got-here
15:58  pgas: can you paste the few line of stderr where the case is executed?
15:59  lostern: pgas: stderr?
15:59  lostern: I don't see anything on stderr
16:00  pgas: set -x should print the commands executed on stderr
16:00  pgas: + echo  foo
16:00  pgas: and things like that
16:00  lostern: pgas: It's running as an svn hook so those things are suppressed. Is there a way to get set -x to redirect to a file?
16:01  pgas: exec 2>/tmp/logfile
16:02  daveb_: what am I doing wrong here? { /some/command; }  2>| { logger -t stderr; } | { logger -t stdout; }
16:02  Fatal: daveb_: insane stuff
16:02  daveb_: :(
16:03  pgas: 2>| doesn't redirect stderr to the pipe
16:03  pgas: >|  is like >
16:03  Fatal: it looks like you think that will redirect stderr to the pipe, which it won't, you probably want 2>&1 to send it to stdout
16:04  lostern: pgas: + read f + ext=TXT + case "$ext" in + echo not-lower + exit 1 + echo got-here + exit 0
16:04  lostern: wtf?
16:04  lostern: why does exit 1 exit?
16:04  lostern: doesn't*
16:04  pgas: lostern: "$ext" is fishy, it should be expanded
16:04  alez{xmb{bottz}}: sekc
16:05  pgas: if you want to send stderr to one command and stdout to another command, it's a bit more involved unless you use 2> >(command) > >(command2)
16:05  lostern: pgas: I have echoed it to a file if that is any comfort
16:05  lostern: pgas: nonetheless exit 1 should exit, no?
16:05  poisonbit: faq 3 external url is broken I think this is the same file: http://sed.sourceforge.net/sed1line.txt
16:06  pgas: lostern: if you se "$ext" it means you have "$ext" literally in the variable
16:06  Fatal: lostern: would it be possible to see the log and not your interpretation of it?
16:06  lostern: Fatal: That was the log
16:06  pgas: or you have pasted something wrong
16:07  lostern: pgas: I don't think so. Why do you say that?
16:07  lostern: I added exec 2>/tmp/logfile. but that is all
16:08  virus_found: Hello. Is it possible to send some string to a stdin of a $pid process?
16:08  pgas: lostern: because set -x shows the command as they are executed after all the expansions occur
16:08  daveb_: pgas: thanks, that syntax works for me
16:09  TheBonsai: virus_found: no. input comes from its input files
16:09  lostern: pgas: I haven't edited anything
16:09  pgas: # set -x ; var=foo;echo "$var" > /dev/null
16:09  evalbot: pgas: + var=foo
16:09  evalbot: pgas: + echo foo
16:09  evalbot: pgas: etc... ( http://pastebin.com/aKfDJtiy )
16:09  virus_found: TheBonsai: I see, thank you.
16:09  lostern: pgas: I believe you but I don't know why mine is not expanding in the log
16:10  lostern: pgas: I can echo it to a file which shows me the correct file extension
16:10 --- oskie_ is now known as oskie
16:10  TheBonsai: lostern: i didn't follow. did pgas make clear why the exit 0 occurs?
16:10  lostern: pgas: But still: If I reach "exit 1" I should exit
16:10  lostern: TheBonsai: No
16:10  TheBonsai: ok, so no
16:10  lostern: TheBonsai: Can you enlighten me?
16:10  TheBonsai: well, it exits the implicit subshell opened by the pipe
16:11  TheBonsai: the right side of the | is a subshell
16:11  pgas: hmm ok , sorry my bad , it actually doesn't expand in case....strange
16:11  lostern: TheBonsai: Okay, good to know
16:11  TheBonsai: # echo foo | exit 1; echo bar
16:11  evalbot: TheBonsai: bash: echo: write error: Broken pipe
16:11  evalbot: TheBonsai: bar
16:12  lostern: TheBonsai: Is this behaviour different between 3.1 and 3.2?
16:12  lostern: TheBonsai: And second, what is the idiomatic way to fix this?
16:12  bashman: why doesnt this work ?  test $? -eq 0  &&  (echo 'files equal' ; exit)
16:12  TheBonsai: lostern: this behaviour didn't change since ages, maybe in 4.3 or above, it's discussed
16:12  TheBonsai: lostern: while read ....; done < <(some command)
16:13  TheBonsai: lostern: (bashism!)
16:13  pgas: bashman: ( ) creates a subshell
16:13  TheBonsai: !faq disappear
16:13  greybot: http://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop. Why do they suddenly disappear after the loop terminates? Or, why can't I pipe data to read?
16:13  TheBonsai: this is your problem
16:13  TheBonsai: well, better: your problem and the FAQ entry have the same root
16:13  pgas: kill $$ instead of exit is a workaround ...
16:14  TheBonsai: yes, too
16:14  pgas: using a named pipe  is another one
16:14  lostern: pgas: I need to return a non-zero exit code
16:14  TheBonsai: or tempfiles
16:14  raikd1: heya guys ... a small help to 'find' something ? :)
16:14  TheBonsai: !find
16:14  greybot: http://mywiki.wooledge.org/UsingFind
16:15  raikd1: ok let me check the link to see if my problem is solved. ... brb ..thx :)
16:16  lostern: TheBonsai: What does <(some command) achieve?
16:16  TheBonsai: it expands to a filename that can be opened and read. it contains the output stream of the command as data
16:17  TheBonsai: # echo <(echo)
16:17  evalbot: TheBonsai: /dev/fd/63
16:17  bashman: i want both commands to be executed after &&
16:17  lostern: TheBonsai: I see, thanks
16:17  bashman:   test $? -eq 0  &&  echo 'files equal' ; exit
16:17  TheBonsai: { ...; }
16:17  bashman: how do i encapsulate a command seq ?
16:18  bashman: ok ill try that, thx
16:19  bashman: TheBonsai,  nope doenst work
16:19  bashman: test $? -eq 0  &&  {echo 'files equal' ; exit}
16:19  bashman: dont work
16:20  TheBonsai: this is a syntax error
16:20  bashman: yep
16:20  TheBonsai: i included spaces and the semicolon for some reason
16:20  TheBonsai: not because i wanted you to ignore them
16:21  bashman: wont work either
16:21  poisonbit: # trap 'echo exiting' EXIT; touch file{1,2}; cmp file1 file2; test $? -eq 0  && { echo 'files equal'; exit; }
16:21  evalbot: poisonbit: files equal
16:21  evalbot: poisonbit: logout
16:21  evalbot: poisonbit: etc... ( http://pastebin.com/8HvZmUZr )
16:22  bashman: wont work eitherok thx poison, with last ; it works
16:22  bashman: ok thx poison, with last ; it works
16:22  TheBonsai: ...
16:22  TheBonsai: what the...
16:22  TheBonsai: <TheBonsai> { ...; }
16:22  TheBonsai: <TheBonsai> i included spaces and the semicolon for some reason
16:22  TheBonsai: <TheBonsai> not because i wanted you to ignore them
16:31  lhunath: your reverse psychology will not work on me!
16:35  TheBonsai: they call me bon"mind trick"sai
16:38  Haegin: hi, this isn't strictly bash related (or at least I don't think it is) but how can I get the destination of a symlink? I want to find items in a directory that aren't symlinked to from another directory.
16:39 --- pixie__ is now known as cyberfairy
16:39  ferret: !../
16:39  ferret: hmmm
16:40  TheBonsai: Haegin: what do you want to do if you found missing entries? create them?
16:40  ferret: Good question :P
16:40  ferret: I had this factoid only yesterday, wtf
16:41  TheBonsai: !meta ../
16:41  Haegin: TheBonsai: kinda, I have a load of files with human unreadable names that I need to keep, but I'm providing symlinks with readable names that point to them in another location so I'm trying to find out which unreadable files don't have a readable version
16:41  ferret: !canonical
16:41  ferret: :/
16:41  Haegin: TheBonsai: so yes, I would be creating them but I'd need the list so I could rename them to be readable after creating an unreadable version in the 'readable dir'
16:41  ferret: !dotdot
16:41  greybot: .. refers to the parent directory. Relative pathnames like ../foo/bar cannot be converted into absolute pathnames in the general case -- see http://www.cs.bell-labs.com/sys/doc/lexnames.html to understand why. Also see http://mywiki.wooledge.org/BashFAQ/028
16:42  TheBonsai: Haegin: ah, and the readable name isn't deterministic, so you can't just blindly create links for all files (without checking if links already exist)?
16:42  ferret: Ahh!  Faq 28
16:42  Haegin: TheBonsai: unfortunately not
16:43  TheBonsai: Haegin: but knowing the target of a given symlink will not help much, too, no? or do you want to get a list of all symlink targets, a second list of all files (potential targets) and diff it?
16:43  Haegin: TheBonsai: that was my plan, yeah
16:44  TheBonsai: GNU or linux stuff?
16:44  Haegin: the symlinks are the readable files, so if i get the list of unreadable files they link to I can work out the unlinked to files
16:44  Haegin: TheBonsai: eh?
16:45  TheBonsai: okay, rephrasing
16:45  TheBonsai: are you able to use 'readlink -f /path/to/symlink'
16:45  Haegin: aha! yes, thanks
16:46  Haegin: I wasn't aware of readlink, that looks rather handy. thanks
16:46  TheBonsai: far better than parsing ls or something like that
16:47  Haegin: yeah, thanks
16:47  TheBonsai: you could do it reversed, i guess
16:47  TheBonsai: for every potential target you could find(1) symlinks to it
16:47  f0ster: I'm trying send mail from my script using mail, is there any easy way to send to multiple recipients specified externally? a little unfamilliar but I'm reading the man page now
16:48  Haegin: TheBonsai: that could work, any idea what the find syntax for finding symlinks to a given file is or should I consult the man pages?
16:48  TheBonsai: f0ster: my mail(1) can take multiple adresses
16:48  f0ster: TheBonsai: what is that?
16:49  TheBonsai: f0ster: maybe i misunderstand you, rephrase your question
16:50  TheBonsai: Haegin: GNU find has -lname, but it takes a "pattern", not sure how it works. lemme test
16:50  f0ster: Im unsure if this ability to send to multiple recipients, from a file somehow, is already built into mail, or if ill have to use bash to read my recipients from a file manually and build them as arguments to the mail command
16:50  cthuluh: just read the manpage. there are multiple "mail" versions out there
16:51  cthuluh: (alternatively, you could just make a test...)
16:51  f0ster: okay
16:52  TheBonsai: Haegin: ah, it basically scans the content of the symlink, the text. -lname "*/foo/bar/*.txt" is possible. if you give the real filename (or the filename how it appears in the symlink), it should be clear
16:56  raikd1: greybot: thanks guys ... the FIND link helped :)
16:56  raikd1: -print0 | xargs -0 .. was the thing I was looking for ;)
16:56  TheBonsai: not -exec ?
16:57  TheBonsai: well, -0 is safe, so... never mind
16:57  raikd1: yup .. http://mywiki.wooledge.org/UsingFind
16:57  Haegin: TheBonsai: oh cool, thanks again
16:57  nDuff: (perhaps raikd1 isn't running a new enough GNU find to have -exec {} +?)
16:59  raikd1: well I got exec at my end nDuff, but still unsure of the adv and disadv, of using xargs as well as exec. !
17:00  TheBonsai: Haegin: maybe it's as easy as    for target in /n/files/*; do [[ ! $(find /n/links/ -type l -lname "$target") ]] || echo "$target"; done    # or thelike
17:00  nDuff: raikd1, if you're using -exec {} +, then you have no need for xargs
17:00  TheBonsai: raikd1: prefer -exec ... [;+] unless you can tell why not :)
17:01  knob: Hello... I'm trying to "consolidate" many similar crontabs, into one script.  Would this be a good way to do it? >> http://pastebin.com/tT0FtbDz
17:01  nDuff: find . -type f -exec foo {} + does the same thing as find . -type f -print0 | xargs -0 foo, except for being a bit less efficient on account of needing a pipeline, serialization, deserialization, etc.
17:01  nDuff: !ls > knob
17:01  greybot: knob: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
17:02  raikd1: ok thanks for the tip :)
17:02  nDuff: !quotewhen > knob
17:02  greybot: knob: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
17:02  nDuff: !` > knob
17:02  greybot: knob: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
17:03  Psi-Jack: I need an sh-compatible means to check: if [ "$IFACE" == lo -o .... ], where the or part can be lo:X, X being a number.
17:03  nDuff: Psi-Jack, only one =, not ==
17:03  Psi-Jack: nDuff: Correct, my typo. ;)
17:03  Psi-Jack: But the problem is trying to also catch lo:X where X can be 0 to 99, or so.
17:04  nDuff: ahh.
17:04  knob: Wow! Thanks for the help... checking all those things out now.
17:04  the_horrible: howdy
17:04  the_horrible: i need to run a bash command about 8,000 times
17:05  the_horrible: im doing this frmo a java app
17:05  Psi-Jack: Will something like "$IFACE" =~ lo:?[0-9] do that?
17:05 --- EqS is now known as EgS
17:05  Psi-Jack: Not sure =~ is even sh-compatible or bash-compatible for that matter.
17:05  the_horrible: im wondering if its possible to open a stream to the bash command, and write command after command?
17:05  nDuff: Psi-Jack, =~ is certainly not available in core POSIX (and that's not quite the proper way to use it)
17:05  the_horrible: or if bash can accept a giant string to run multiple commands
17:06  nDuff: Psi-Jack, I'd use a case statement to check for that match
17:06  Psi-Jack: Hmmm
17:06  Psi-Jack: Well, both will have the same outcome, the result is to exit 0 if either match.
17:07  nDuff: # iface=lo:3; case iface in lo:[0-9]|lo) echo "yes" ;; *) echo "no"; esac;
17:07  evalbot: nDuff: no
17:07  Psi-Jack: In short, I'm trying to fix a broken ubuntu open-iscsi init.d script that's also used in if-up/if-down but only checks of lo is starting/stopping, not lo:aliases
17:07  nDuff: Psi-Jack, ...replace the echo's with exit statements, and there you are.
17:08  TheBonsai: the_horrible: what about a loop?
17:08  nDuff: Psi-Jack, ...that said, is there a reason you're checking for numbers after the colon?
17:08  the_horrible: TheBonsai: im using a loop and javas Runtime.exec() currently, and it takes forever
17:08  nDuff: Psi-Jack, ...it'd be easier just to match lo:*; that way you don't need to deal with lo:13
17:08  Psi-Jack: nDuff: Hmm, specifically, no, not really, but it's proper for interface aliases.
17:08  cthuluh: 4# exec 3> >(bash); echo 'echo "$USER"' >&3 # the_horrible
17:08  shbot: cthuluh: no output
17:08  the_horrible: TheBonsai: i could have the app write a bash script
17:08  cthuluh: ?
17:08  TheBonsai: the_horrible: i mean a loop in the shell
17:08  the_horrible: TheBonsai: but its run as root, i was worried about race condition
17:09  the_horrible: can i have bash take a whole script as a command line arg
17:09  the_horrible: so i dont have to write it to the file system then run
17:09  the_horrible: sorry if that sounds retarded lol
17:09  nDuff: Psi-Jack, ...granted, for now, it's enforced that aliases (when named at all, which is optional) are named with the interface name followed by a colon and then a number, but that restriction is a backwards-compatibility thing, and I personally hope for it to eventually be dropped.
17:09  nDuff: the_horrible, you can feed a whole script on stdin
17:10  TheBonsai: the_horrible: what do you need to execute?
17:10  Psi-Jack: nDuff: It's already dropped, for distros already updated to use iproute2, since it doesn't use those kind of interface aliases. ;)
17:10  the_horrible: i need to run ifconfig to bring up about over 1K virtual interfaces
17:10  nDuff: Psi-Jack, iproute2 allows unnamed secondary interfaces, but IF they're named, then they still need to follow that restriction.
17:10  Psi-Jack: Unfortunately, Debian or debian-derivatives like Ubuntu, still use net-tools's ifconfig.
17:11  nDuff: Psi-Jack, ...last I checked, anyhow; I'd be glad to hear if that's no longer the case.
17:11  the_horrible: nDuff: ok, ill see if i can figure out how to do that
17:11 --- gwz2 is now known as gwz
17:11  nDuff: s/secondary interfaces/secondary addresses/
17:11  Psi-Jack: nDuff: iproute2 /can/ use the same convention, but doesn't have to.
17:12  TheBonsai: the_horrible: then run for ifname in ... ... ... ... ...; do ifconfig "$ifname" up; done, unless you want to give additional parameters
17:12  TheBonsai: the_horrible: or just pump the handful commands (just 1K, shouldn't hurt) into stdin, yes
17:13  the_horrible: ok thank you both
17:13  the_horrible: looks like piping in from stdin will be the easiest
17:13  Psi-Jack: nDuff: Otherwise, the case iface in lo:[0-9]|lo)... , iface doesn't need the $ in front of the variable for an existing defined variable, I presume?
17:14  lhunath: you presume wrong
17:14  nDuff: Psi-Jack, that's not what a bit of testing demonstrates.
17:14  nDuff: # ip addr del 127.0.0.201/32 dev lo label foobar
17:14  nDuff: "dev" (lo) must match "label" (foobar).
17:14  evalbot: nDuff: bash: ip: command not found
17:14  nDuff: err
17:14  nDuff: same error with an "add"
17:14  lhunath: $ expands the parameter.  without a $, you're testing the string 'iface', not the string inside a variable called 'iface'
17:15  Psi-Jack: lhunath: So I do need it to be case $IFACE in lo:[0-9]|lo)   then, eh?
17:16  lhunath: no, case $iface
17:16  nDuff: !varcap > Psi-Jack
17:16  greybot: Psi-Jack: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
17:16  lhunath: variable names are case sensitive.
17:16  Psi-Jack: I don't fricken case about varcap! This is in existing code that's not changing. grr
17:16  Psi-Jack: if-up/if-down uses IFACE as the variable passed.
17:17  lhunath: you said iface earlier.
17:17  nDuff: Psi-Jack, ...so, the earlier example I gave with the case statement actually worked for me
17:17  Psi-Jack: No.
17:17  Psi-Jack: I said $IFACE earlier.
17:17  nDuff: Psi-Jack, ...was there a bug somewhere I missed?
17:17  lhunath: Psi-Jack | nDuff: Otherwise, the case iface in lo:[0-9]|lo)... , iface ..
17:17  ferret: Why would you say "no" when it is so easy to check?
17:17  nDuff: that was my example
17:18  Haegin: TheBonsai: thanks for the help, in the end I got it working with readlink and comm
17:18  nDuff: or, rather, him working off my example
17:18  nDuff: he did indeed use $IFACE in the early discussion
17:19  TheBonsai: Haegin: fine
17:19  nDuff: # iface=lo:3; case $iface in lo:[0-9]|lo) echo "yes" ;; *) echo "no"; esac;
17:19  Psi-Jack: Okay, so case "$IFACE" in lo:[0-9]|lo) exit0;; esac, but that would only determine if it's 0 - 9, not 0 - 99
17:19  evalbot: nDuff: yes
17:19  nDuff: and indeed, so make it lo:*
17:19  Haegin: TheBonsai: I might play more with the find command to see if I can get that working in a bit, it does seem a nicer solution
17:20  nDuff: or even lo* if you want to cover names given by iproute2
17:21 * nDuff personally prefers leaving the colon in the test -- less ambiguity, and folks using iproute2 in a distro with ifconfig-based scripts have a responsibility to know what they're doing.
17:21  Psi-Jack: nDuff: Exactly, hence why I'd prefer to keep to numerics checking only as well
17:21  Psi-Jack: Rather than *
17:22  nDuff: Psi-Jack, ...can you name a case where permitting non-numerics after the colon would lead to an erroneous result?
17:23  TheBonsai: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaah
17:23  TheBonsai: it begins
17:23  TheBonsai: we're doomed
17:24  alez{xmb{bottz}}: haahahah
17:24  alez{xmb{bottz}}: net.*.split
17:24  greycat: I didn't do it.  I swear.
17:24  alez{xmb{bottz}}: wownowman
17:24  raikd1: wats that ? net.*.split ??
17:24  Psi-Jack: nDuff: On the contrary, can you name any case in the reverse?
17:25  alez{xmb{bottz}}: thats the better netsplit leave msg
17:25  nDuff: Psi-Jack, absolutely -- cases where a user or software they run has created an interface "lo:vip" (or such) using iproute2. Certainly, on an ifconfig-centric distro there's no *obligation* to support such cases, but that doesn't mean they should be broken both knowingly and needlessly.
17:26  nDuff: Psi-Jack, ...so, it's a rare case, and an unimportant one, but can you name even a rare or unimportant case in favor of your preferred implementation?
17:27 * nDuff believes that the rule of being "liberal in what you accept and conservative in what you generate" applies here.
17:29  TheBonsai: <nitpick>"be conservative in what you do, be liberal in what you accept from others"</nitpick>
17:29  TheBonsai: ;)
17:35 --- emma is now known as em
17:36  TheBonsai: nDuff: you ignorant. i expected a "that was not very liberal" :/
17:37  nDuff: the thought did cross my mind :)
17:39  TheBonsai: nDuff: :)
17:40  mr_daniel: I want to copy+paste some source code, but it is not that easy, because I need to delete line numbering
17:40  TheBonsai: er.. what?
17:40  greycat: delete what?
17:41  alez{xmb{bottz}}: dat
17:41  greycat: and, uh, what language is this?
17:41  mr_daniel: For example this copy+paste here: http://pastebin.com/ib3zMt5X
17:41  nDuff: mr_daniel, pastebins generally have "raw" links which exclude numbering and such
17:41  mr_daniel: how can I can rid of the first two characters in every line (that is the line numbering), without to use gedit
17:41  greycat: Try NOT putting line numbers in front of the code when you cat the damned file, then.
17:41 * nDuff is also unclear on why this is a bash problem
17:41  greycat: E.g. use 'cat' instead of 'cat -n'.
17:42  nDuff: ...ahh, right, yup, that's silly.
17:42  nDuff: !ed > mr_daniel
17:42  greybot: mr_daniel: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
17:42  nDuff: mr_daniel, ...should be a very short ed script.
17:42  greycat: vi file, :%s/^.. // Enter ZZ
17:42  mr_daniel: nDuff: well, if you want it "raw", this is the original source code http://docs.jboss.org/netty/3.2/xref/org/jboss/netty/example/http/snoop/HttpResponseHandler.html
17:42  mr_daniel: but also here: line numbersings...
17:43  greycat: So the line numbers are being produced by the HTML interface you're using in place of 'cat'?
17:43  greycat: See if there's a "no numbers" option.
17:43  nDuff: heck, their SCM will support raw download
17:45  nDuff: ...oh, it's git now.
17:45  mr_daniel: xref seems to be some sort Javadoc enhancer
17:45  nDuff: still, a git clone isn't the most awful thing in the world
17:45  mr_daniel: you found the git repo? link?
17:46  mr_daniel: I guess you  mean this here, right nDuff? https://github.com/netty/
17:50  raikd1: daniel I got an idea ... from the code in http://pastebin.com/raw.php?i=ib3zMt5X ... you can clip of like [BEGINNING + 2digits + SPACE] using sed .. try that
17:50 --- kizoku_ is now known as kizoku
17:50  raikd1: clip off*
17:50  greycat: 11:42  greycat> vi file, :%s/^.. // Enter ZZ
17:50  greycat: yes, you can trivially convert that to sed.
17:51  raikd1: yes right greycat :)
17:51  greycat: The real question, though, is how to get the code without the fucking numbers added in the first place.  And that is not a #bash question.
17:51  raikd1: exactly ..
17:54 --- Martinp24 is now known as Martinp23
17:55  envirocbr: Hello everyone
17:55  envirocbr: I am stuck on this:
17:56  envirocbr: I Have a file that I need to pull out *.com/net/org and feed it into a variable and then that variable wll be used against whois which will send the output to a text file for later processing
17:56  envirocbr: My problem is how can I tell bash when to stop or will it reach EOF by itself once there are no more entries to be filtered out?
17:56  TheBonsai: !faq 1
17:56  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
17:57  greycat: That's the problem?  Jeez, I'd think the problem would be isolating the bits you want....
17:57  trash: Your guess-o-meter needs adjustment.
17:57  trash: The level of intelligence dropped since the last time you needed to use it here.
17:58  greycat: envirocbr: what does the line of input look like, and what part of that line do you want to extract?
17:59  stVKukus: irssi is still compiling on osx
18:02 --- bohl is now known as moff_guru
18:04 --- moff_guru is now known as bohl
18:07  f0ster: nice it!
18:07  f0ster: ahha
18:07  f0ster: did you set your core count when compiling on osx
18:10  envirocbr: greycat: SOrry for slow repsonse, dealing with a BIG idiot
18:11  envirocbr: greycat: It is a list of websites
18:11  envirocbr: line by line
18:12  greycat: If the part you want to isolate has ALREADY been isolated, then just read FAQ 1.
18:12  envirocbr: so a simple cat file | grep *.com
18:12  greycat: Oh, there's filtering?  Show the line you don't want, and the line you do want.
18:13  nDuff: !uuoc > envirocbr
18:13  greybot: envirocbr: Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
18:14  envirocbr: greycat: Thanks a million my friend
18:14  envirocbr: greycat: I know it is useless
18:14  envirocbr: I used to do it ALL the time to grep for something, it was how I was taught
18:15  ss0: Hi greycat :D
18:27  dvsxutact: how would you call a function and echo the functions results?
18:27  greycat: !function
18:27  greybot: To define: funcname() { your code here; } ## To use: funcname arg1 arg2 ... ## function http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
18:27  dvsxutact: ty
18:27  greycat: If the function writes to stdout, you don't need to add an echo.  Just call it.
18:28  dvsxutact: so if the function has an echo already basically
18:33  nDuff: dvsxutact, ...well, what do you mean by "results"? If the result is an exit status, you need to do something with it; if the result is emitted on stdout, then... well... it's on stdout already.
18:46  deathnote[]: Hello
18:46  deathnote[]: How do you echo newlines ?
18:46  ferret: echo
18:46  greycat: you probably want printf or a here document
18:47  deathnote[]: hmmm?
18:47  deathnote[]: printf "\n" ?
18:47  ferret: That might do what you want, yes.
18:47  greycat: If you just want a single newline and nothing else, ferret's answer is more concise.
18:48  ferret: Hey greycat, we forgot the likelihood he's just put some lines in a variable and not quoting it properly
18:48  deathnote[]: echo "\n" doesn't appear to work
18:48  ferret: deathnote[]: it'd really help if you could go into more detail as to what you're trying to do
18:48  deathnote[]: Only, I'm doing is printing text to the screen
18:48  greycat: Nobody said that echo "\n" would work.  He said echo.
18:48  deathnote[]: that's all
18:48  taylanub: !echo
18:48  greycat: echo "text to the screen"
18:49  deathnote[]: heh
18:49  sente: which options prevents '.' and '..' for being returned by the expansion: for d in /some/path/.*/; do...
18:49  deathnote[]: I need to echo two newlines before echoing text
18:49  deathnote[]: So, just echo and echo
18:49  Dieterbe_: yeah
18:49  crimeboy: printf "\n\n"
18:49  greycat: sente: err, ./ and ../ *are* returned by .*/ by default.  You must have set something...
--- Log closed Tue Dec 14 21:42:32 2010
--- Log opened Tue Dec 14 21:42:55 2010
21:42 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
21:44 --- Channel #bash was synced in 99 seconds
21:45  f0ster: why use printf instead of echo ?
21:46  f0ster: err, sorry, i coudl see why you'd use it for arguments, but they both goto the same file descriptor right ?
21:46  nDuff: f0ster, several reasons; which one applies depends on the circumstance
21:47  nDuff: f0ster, ...but to start, printf gives you much more control over formatting, and doesn't have a syntax which allows data to be misinterpreted as arguments.
21:47  greycat: !printf
21:47  greybot: The printf command: http://bash-hackers.org/wiki/doku.php/commands/builtin/printf
21:48  An_Ony_Moose: how can I test if a variable is empty?
21:48  f0ster: I have a function that outputs a result using printf. How can I call the function and store the output in a nother variable?
21:48  greycat: The classic example of why you use printf instead of echo is:  n='-n'    Now print the contents of $n to stdout.
21:48  greycat: !faq 2 > f0ster
21:48  greybot: f0ster: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
21:48  greycat: (Or in bash 3.1 and higher you could use printf -v varname ...)
21:49  f0ster: okay
21:49  f0ster: thank you
21:51  f0ster: greycat: hmm thats what I've been trying, I have a function latest() (...) that finds the latest file in a directory passed as a argument and prints it out via printf.  I want to store the result of this in a variable.  I'm trying result=$(latest "$DIR") but it just hangs.  When I do $(latest "$DIR") it outputs the proper result to the screen however
21:52  greycat: if you literally type $(latest "$DIR") you should get something like bash: /foo/bar.013: not executable
21:52  greycat: or "Permission denied"
21:53  f0ster: because it would be trying to excute the result of latest "$DIR"
21:53  greycat: right
21:53  f0ster: any idea why it might be hanging?
21:53  greycat: No.  We'd need to know what "latest" does.
21:53  nDuff: !set-x > f0ster
21:53  greybot: f0ster: Setting the -x option on bash enables a debugging mode that makes bash output the command name and arguments that it will run (after all parsing and expansion has been applied). Set it by starting a script with ''bash -x ./myscript'' or putting ''set -x'' before the code you want to debug. ''set +x'' turns this behaviour off.
21:54  f0ster: gracias
21:54  f0ster: latest() ( for file in "$1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s latest" )
21:55  greycat: looks like you lost a { at least
21:55  f0ster: whoops, a { in front of the 1
21:55  greycat: and you probably wanted printf '%s\n' "$latest"
21:55  f0ster: latest() ( for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s latest" )
21:55  greycat: and { ... ; } is the more common syntax for function definitions.  No point forcing a subshell.
21:56 * f0ster scratches his head
21:56  nDuff: f0ster, you more likely want printf %s "$latest"
21:56  nDuff: f0ster, or printf %s\n "$latest" if the output should be newline-terminated
21:56  f0ster: oh dear, thats another typo. thats what it is
21:56  greycat: Heh, it's probably recursing infinitely.
21:56  nDuff: heh.
21:56  f0ster: i didnt want to copy and paste it because its on multiple lines but
21:57  greycat: latest() { echo latest; }; $(latest)  # weak fork bomb?
21:57  f0ster: latest()( local file latest; for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s "$latest" )
21:57  f0ster: i've been looking at it for a while, I now read it as La Test lol
21:58  greycat: !latest
21:58  greybot: Find the latest modified file in a directory: latest() ( local file latest; for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf %s "$latest" ) ## Usage: latest mydir
21:58  f0ster: thats where I got it from
21:58  greycat: Woah... who put ( ...) on that?
21:58  f0ster: Not sure
21:58  f0ster: but I was basically jsut trying to use that function and store the result in another variable
21:58  greycat: lhunath.  his is the only name in the entire history.
21:59  greycat: !forget latest
21:59  greybot: OK, greycat
21:59  An_Ony_Moose: how can I test if a variable is empty?
21:59  geirha: Was also missing a ;
21:59  geirha: err, nvm. Not necesasry with ()
21:59  f0ster: it seems to be working in a different function i'm using it with
21:59  greycat: !learn latest Find the latest modified file in a directory: latest() { local file latest; for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf '%s\n' "$latest"; } ## Usage: latest [dir]
21:59  greybot: OK, greycat
21:59  raikd1: neat fork bomb -->    :( ){ :| : & };:
21:59  greycat: An_Ony_Moose: if [[ $foo ]]
22:00 * nDuff doesn't think there's anyone here who hasn't seen that one, raikd1
22:00  raikd1: hehe
22:00  An_Ony_Moose: thanks greycat , as you can tell, I'm a noob :P
22:01  raikd1: refreshing mem :)
22:01  geirha: An_Ony_Moose: The BashGuide (see /topic) teaches you these basics.
22:01  An_Ony_Moose: ah thanks geirha
22:04  f0ster: so how can I redirect what latest prints into a variable ?
22:04  greycat: var=$(latest foo)
22:04  f0ster: even if foo is variable right?
22:05  greycat: var=$(latest "$var")
22:05  greycat: err, not necessarily the same variable name
22:05  f0ster: right
22:05  f0ster: hmmm thats what I've been trying and it just hangs on that line
22:06  geirha: set -x
22:06  greycat: imadev:~$ latest() { local file latest; for file in "${1:-.}"/*; do [[ $file -nt $latest ]] && latest=$file; done; printf '%s\n' "$latest"; }
22:06  greycat: imadev:~$ var=$(latest /tmp)
22:06  greycat: imadev:~$
22:07  f0ster: hmmm
22:08 --- rbronosky is now known as richardbronosky
22:09  f0ster: yeah sorry, so dumb, it was hanging somewhere else once I used set -x
22:09  f0ster: thanks for helping me along the stupidity
22:12  silicong: I have a directory of 120000 pictures is there away using the command line to organize them by image dimensions?
22:13  greycat: imagemagick.  identify.
22:13  silicong: ok - I will check into that
--- Log closed Tue Dec 14 22:21:34 2010
--- Log opened Tue Dec 14 22:36:57 2010
22:36 --- Users 537 nicks [0 ops, 0 halfops, 0 voices, 537 normal]
22:37  greycat: body+="$(latest whatever)"
22:37  greycat: As I *already said*.
22:37  greycat: Not $body+=...
22:37  greycat: Not body += ...
22:37  greycat: Not $body += ...
22:37  f0ster: Sorry, what is the difference between $body += and body += ?
22:37  f0ster: no $ ever on LHS ?
22:37  greycat: !guide > f0ster
22:37  greybot: f0ster: http://mywiki.wooledge.org/BashGuide
22:38 --- Channel #bash was synced in 93 seconds
22:43  kakashi_: hi, how can I use sort --> such that it sorts these kind of numbers too --> 9.94538e-07 ?
22:43  kakashi_: is there a way ?
22:43  greycat: isn't that what -g does?
22:44  greycat: hmm, -g isn't on the POSIX page.  must be a GNUism.
22:45  kakashi_: greycat: thanks a lot 
22:49  roue: hello
22:50  sp_otaku: hdllo
22:50  csabo: herro
22:50  f0ster: onyoung
22:51  roue: I'm trying to capture the output of diff into a variable, but I'm doing something wrong. FOO=$(diff a b) . When a and b differ FOO remains empty. I can do FOO=$(ls) and echo $FOO shows me a directory listing. I'm missing something. Any tips? Thanks.
22:51  sp_otaku: Am following a basic bash script tutorial on arrays and copied exactly and get an "{" unexpected error
22:51  greycat: !faq 5 > sp_otaku
22:51  greybot: sp_otaku: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
22:51  greycat: And make sure you are in BASH, not sh.
22:52  nDuff: sp_otaku, we support the FAQ and guide given in the topic; other random reference materials, not so much.
22:52  greycat: sp_otaku: at least show us what command you tried to run.
22:52  sp_otaku: unix and linux system admin handbook 20 anniversary edition
22:52  sp_otaku: ok
22:53 --- cyberone is now known as pixie__
22:54  sp_otaku: http://pastebin.com/XiLDie7i
22:55  nDuff: !varcap >roue (not your bug, but as a style note)
22:55  greybot: roue (not your bug, but as a style note): By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
22:55  greycat: sp_otaku: and you type ./foo to run this?
22:55  sp_otaku: sh foo
22:55  greycat: !sh > sp_otaku
22:55  greybot: sp_otaku: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
22:55  greycat: 16:51  greycat> And make sure you are in BASH, not sh.
22:56  nDuff: # delta=$(diff <(echo "foo") <(echo "bar")); if [[ $delta ]]; then echo "yup, roue, output received"; fi
22:57  evalbot: nDuff: bash: diff: command not found
22:57  nDuff: ...well, that doesn't help so much...
22:57  nDuff: roue, but see the above line.
22:57  nDuff: roue, ...I'm unable to replicate the behavior you report.
22:57  greycat: Or use cmp(1) if all you care about is a binary "they match" answer.
22:57  sp_otaku: WOW awsome, THANKS! Have been getting various help all day on IRC. Can't wait to be the one that actually helps someone (sooner then later)
--- Log closed Tue Dec 14 23:02:17 2010
--- Log opened Tue Dec 14 23:07:41 2010
23:07 --- Users 533 nicks [0 ops, 0 halfops, 0 voices, 533 normal]
23:08  wayneeseguin: Is there a way to drop from root user to a normal user for the duration of a shell script
23:09 --- Channel #bash was synced in 99 seconds
23:09  \malex\: wayneeseguin: su
23:10  \malex\: wayneeseguin: you'd have to use su to re-execute your script, and you'd have to have the script check to see if it's running under su. or something.
23:10  wayneeseguin: I tried 'su - username' however the rest of the script did not execute as it dropped into that user and was waiting for exit before running the rest of the script.
23:11  wayneeseguin: so likely it cannot be done?
23:11  \malex\: wayneeseguin: read what i just said
23:11  wayneeseguin: ok
23:12  wayneeseguin: thanks.
23:13  lazyliberal:  I have a small 'backup a file' bash script and I want to change the permission of the backup file, not sure how:
23:13  lazyliberal: /bin/cp $1 BACKUPS/$1_`date +%Y%m%d%H%M`
23:14  nDuff: roue, ...erm. If you want to do a recursive comparison, diff -r is going to be very inefficient.
23:14  nDuff: roue, also, if you don't need the output, you shouldn't be collecting it at all
23:15  nDuff: roue, ...as an example of not collecting the output: if diff -r dirA dirB >/dev/null; then ...; fi
23:15  nDuff: roue, ...doing that also avoids the need for a || true
23:15  retrospectacus: lazyliberal, you should create a variable with the backup file name and use it for both the CP command and then for chmod
23:16 * lazyliberal thank you  retrospectacus
23:16  nDuff: roue, (again, I don't endorse that example; diff does a lot of time-consuming work to come up with an actual delta, which you don't need)
23:17  nDuff: ...heck, even computing a recursive checksum of the tree would be less expensive than using diff...
23:27  roue: nDuff thanks for the suggestions. What I'm doing is writing a script that copies just a few files and directories from a much larger directory. Then I want to confirm that all the files actually made it intact. I thought about rsync, but a cp and then diff seemed simpler. Not sure if there's a better way to approach the problem.
23:28  nDuff: roue, I'd use rsync, with the -i argument to get machine-parsable output (which you can easily read with FAQ 1)
23:29  nDuff: roue, ...right-tool-for-the-job and all; rsync goes to a lot of effort to be efficient and flexible at what it does.
23:37  jymere: hi in a sh script, I use the command : exec 3> "$file" and then : echo "blabla" >&3. But the problem is that I want to write at the end of the file "$file". What is the syntax ? thanks
23:38  nDuff: jymere, you mean you want to append rather than overwriting? Use >>
23:39  nDuff: s/overwriting/truncating/
23:40  jymere: nDuff : exactly
23:41  jymere: so i have to put echo "blabla" >>&3 ? that's all ?
23:41  nDuff: exec 3>>"$file"
23:41  jymere: or may be exec 3>> "$file" ?
23:41  jymere: ok
23:41  jymere: thanks
23:41  nDuff: exactly; it's on open when the truncation occurs
23:42  nDuff: (literally a question of whether O_TRUNK is passed to the open() call)
23:44  bakers: Can someone tell me what the heck this does. I found it in a shell script
23:44  bakers: ${SHELL:-/bin/sh} << `(dd if=/dev/urandom count=200 bs=1 2>/dev/null|LC_ALL=C tr -d -c '[:alnum:]')`
23:45  nDuff: bakers, ...so, how much of it do you understand already? Do you understand what dd does, what /dev/urandom is, what tr does?
23:45  bakers: send 200 random bytes to /bin/sh ??? what's the part after the LC_ALL
23:45  nDuff: bakers, well, it filters those bytes first
23:45  nDuff: bakers, ...taking out the parts which aren't alphanumeric (that's what the tr does)
23:45  bakers: nDuff: I get the dd part I'm and the redirect to /dev/null, not sure...
23:46  bakers: nDuff: Ahhhh ok... so it's sending 200 random alphanumeric bytes to whatever shell?
23:47  nDuff: less than 200
23:47  nDuff: it's 200 before they're filtered
23:47  nDuff: it's going to be a smaller, random number after that
23:47  nDuff: I'm curious -- what's the context of this script?
23:47  retrospectacus: could be zero
23:49  bakers: nDuff: when I schedule an at job on my fedora box
23:49  bakers: the /var/spool/at/0we9i40w9e file is that
23:49  bakers: nDuff: Here is the whole script: http://pastebin.com/tszFgwJS
23:49  nDuff: bakers, what it looks like it's doing to me is doing a heredoc with a random signifier
23:49  nDuff: !<< >bakers
23:49  greybot: bakers: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
23:50 * nDuff thinks that's a damned stupid way to come up with a sigil; if you wanted something random, it'd be better to feed the output from urandom through base64 or md5sum or such.
23:50  bakers: What's a sigil?
23:50  retrospectacus: hehe "Call Mom"
23:50  bakers: retrospectacus: That was just my test string to see what it would do :)
23:51  nDuff: bakers, the sigil is the random string used to end the heredoc; see the factoid (and the BashGuide, the bash manual page, and whatnot)
23:51  bakers: So in this case when I do "echo 'call mom' | at -t 3pm" it generates that file
23:51  bakers: in /var/spool/at/
23:51  nDuff: ahh, I get it!
23:52  nDuff: it's using a heredoc with a random end sigil to read everything until EOF
23:52  bakers: then I'm assuming cron or something else comes along and runs these scripts
23:52  nDuff: that's... really damned silly.
23:52  bakers: nDuff: Ahhh that does make sense... and does seem like a very silly way to do things
23:52  nDuff: especially with a sigil of unknown length
23:54  bakers: nDuff: That is really odd... Why not use MD5 or SHA1 so you know the length and don't need any fancy tr to convert it
23:54  bakers: nDuff: maybe so there isn't a dependency on md5/sha1?
23:54  bakers: All this solution needs is dd and tr
23:54  nDuff: yar, but you could just use $RANDOM and have it all inside the shell if  your goal was to minimize dependencies
23:55  bakers: nDuff: so true!
23:56  bakers: nDuff: So looking at the script I posted... line 1 - 28 just set a bunch of ENV vars, and then line 33 says pass everything from here to until you see the sigil (EOF) to /bin/sh?
23:56  nDuff: well, the sigil is the random string, but EOF also appears to work. (I don't know if that's documented / standardized / guaranteed behavior)
23:57  bakers: oh so line 33 could read "${SHELL:-/bin/sh} << EOF"
23:57  bakers: and it would have the same function?
23:57  nDuff: well, <<EOF would mean that having a line with literal "EOF" would end the part of the script that's getting run
23:57  nDuff: if you were running a script which nested its own heredoc, and did the common thing of using "EOF", that wouldn't be ideal.
--- Log closed Wed Dec 15 00:00:31 2010
