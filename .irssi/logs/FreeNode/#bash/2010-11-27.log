--- Log opened Sat Nov 27 00:05:28 2010
--- Log closed Sat Nov 27 00:10:29 2010
--- Log opened Sat Nov 27 00:10:54 2010
00:10 --- Users 517 nicks [0 ops, 0 halfops, 0 voices, 517 normal]
00:12 --- Channel #bash was synced in 110 seconds
00:14  plopix: why doesnt `command 2> /dev/null` work in  script when command 2> /dev/null in a shell works
00:15  gniourf_gniourf: what is your script plopix ?
00:17  plopix: it just executes a command in backticks with stderr redirected to /dev/null
00:21  gniourf_gniourf: plopix, pastebin your script
00:27 --- Muzer is now known as MuzerAway
00:27  steve___: plopix: Not that this has anything to do with your problem but...
00:28  steve___: !` > plopix
00:28  greybot: plopix: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
00:30  plopix: steve___: you are right. It has  nothing to do with my problem :-)
00:44  micols: !&>
00:44  greybot: &> is a bash-specific feature, unportable to other shells. command &> file is equivalent to command > file 2>&1. There is no &>> until Bash4. Use command >> file 2>&1 instead.
00:56  steve___: plopix: the output from your subshell is then executed in the current shell.
00:56  steve___: # $(echo foo 2> /dev/null)
00:56  evalbot: steve___: bash: foo: command not found
00:56  steve___: Do you want the output to be stored in a file or as a variable?
00:58  geirha: In other words
00:58  geirha: !wayttd
00:58  greybot: What Are You Trying To Do?
00:59  steve___: geirha: you have a trigger for that and not the portability url?  ;)
01:00  geirha: !portability
01:00  greybot: Portability is important. Your script should, if at all possible, run on as many different platforms as possible. Avoid Linux-specific commands like seq(1), GNU-specific command flags like "find ... -or", and so on.
01:01  geirha: That factoid is large enough as it is, and I don't know what else to use as trigger.
01:02  plopix: no, no. the answer is: { command; } 2> /dev/null works
01:02  steve___: hmm, i vote the url should be squeezed in there.
01:03  steve___: plopix: is there more than one command?
01:03  plopix: using backticks of  course.
01:03  plopix: steve___: there is one pipe
01:04  steve___: ahh
01:04  geirha: !forget portability
01:04  greybot: OK, geirha
01:04  geirha: !learn portability Portability is important. Your script should, if at all possible, run on as many different platforms as possible. Avoid Linux-specific commands like seq(1), GNU-specific command flags like "find ... -or", and so on. See http://www.gnu.org/software/hello/manual/autoconf/Limitations-of-Usual-Tools.html
01:04  greybot: OK, geirha
01:05  steve___: hooray!
01:05  geirha: !portability
01:05  greybot: Portability is important. Your script should, if at all possible, run on as many different platforms as possible. Avoid Linux-specific commands like seq(1), GNU-specific command flags like "find ... -or", and so on. See http://www.gnu.org/software/hello/manual/autoconf/Limitations-of-Usual-Tools.html
01:05  Riviera: Hm.
01:05  Riviera: IMHO it'd be better to suggest POSIX.
01:07  Riviera: And if not, then also/better http://www.gnu.org/software/hello/manual/autoconf/Limitations-of-Builtins.html#Limitations-of-Builtins
01:07  Riviera: But this stuff goes too far for every day portable use.
01:08  Riviera: !posix
01:08  greybot: The POSIX standard defines what any modern unix should supply. Sticking to the commands and options in http://www.opengroup.org/onlinepubs/9699919799/utilities/contents.html will do wonders for the portability of your scripts.
01:09  geirha: Maybe do !exremeportability instead? :)
01:10  Riviera: yes, or !scriptlikeheiner ;)
01:11  geirha: Who's heiner?
01:11  Riviera: The guy behind shelldorado and the "original bot in here"
01:12  geirha: But the bot is written in perl ...
01:12  Riviera: ah, nmarvin/marvin was the bot's name. Yes, but heiner's style is to try to be as portable as possible.
01:12  Riviera: Sticking to ``, etc.
01:13  infinitux: how do I kill a process only if it's running by testing, and do nothing in the case that it is not? what would be the syntax of the command?
01:14  Riviera: infinitux: how to you refer to the process?
01:15  infinitux: it could be refered to by the process name.
01:15  Riviera: So, you would search the process list for that name, killing the found processes?
01:16  infinitux: ps -aux | grep name && killall -9 name
01:16  infinitux: is that what you're thinking?
01:16  Riviera: No ..
01:16  Riviera: Until now I rather wanted to understand you :)
01:17  infinitux: :D
01:17  Riviera: Because I hardly see a problem, if there's no process with the name you're looking for,
01:17  Riviera: nothing would be found for killing.
01:17  Riviera: So ... why decide whether that nothing should be killed or not :)
01:17  Riviera: anyway,
01:17  Riviera: you might want to check pkill (and maybe pgrep)
01:17  infinitux: i do have a reason why.
01:18  infinitux: i'm calling an app up from a script to do a motd for it.
01:18  Riviera: Okay, you have a reason :) That reason I wanted to understand and to find out.
01:18  Riviera: I failed.
01:18  Riviera: But, well, still, check pkill :)
01:18  infinitux: I want the motd to come up clean without an error message saying the process isn't running, but I also don't want to run multiple copies of the app i'm calling up.
01:19  Riviera: It might also be useful to know that you can test whether there is a particular PID running with killing ("sending the signal") 0
01:19  infinitux: that's the reason i'm killing it first if it's running before calling it up.
01:19  Riviera: okay, so, would pkill and pgrep help?
01:19  infinitux: yeah i suppose.
01:19  Riviera: well, find out and complain if not! :)
01:19  geirha: !pm > infinitux
01:19  greybot: infinitux: http://mywiki.wooledge.org/ProcessManagement
01:19  infinitux: i'll just do that with the boolean operator &&
01:20  infinitux: if ps -aux | grep name produces results the && operator would kill it if it exists.
01:20  geirha: infinitux: So what you really want is pkill
01:21  Riviera: well, yes, if you are lucky that grep will not find itself
01:21  infinitux: what's the difference between pkill and kill?
01:21  Riviera: or something else you don't want to match
01:21  geirha: infinitux: But please, PLEASE, read the ProcessManagement page
01:22  geirha: infinitux: difference between kill and pkill? quite alot. The ProcessManagement page will explain ... as will their manpages.
01:22  infinitux: okay...
01:22  Riviera: infinitux: do as geirha says (please). [pkill and pgrep make the whole ps | grep business reasonable.]
01:22  krzie: when scripting, you likely want pkill
01:23  krzie: i used to do that ps|grep stuff, but i was shown the right way in here =]
01:23  Riviera: only if you don't want extreme portability ;P
01:23  krzie: ahh thats true
01:23  infinitux: okay. lol
01:25  infinitux: so if I want to copy it from a linux, to a bsd, to a solaris, to a darwin, to a irix, I should use pkill and pgrep? lol
01:25  Riviera: no, I rather meant the opposite. :)
01:25  Riviera: but nevermind that.
01:25  Riviera: before worrying about decisions, first understand what's going on
01:25  Riviera: (reading the processmanagement page is a good start for that;)
01:25  infinitux: okay.
01:29  infinitux: I'm learning C right now, so I'm not really thinking along the lines of bash scripts...
01:29  infinitux: I'm reading the page though.
01:34  steve___: .clr
01:34  steve___: oop
01:39 --- Natch is now known as Natch|
01:40  infinitux: thanks folks.
--- Log closed Sat Nov 27 16:37:05 2010
--- Log opened Sat Nov 27 16:37:25 2010
16:37 --- Users 525 nicks [0 ops, 0 halfops, 0 voices, 525 normal]
16:38 --- Channel #bash was synced in 101 seconds
16:40  ManDay: WHat does {} mean in setenv PATH {$PATH}:/usr/local/share/OpenSceneGraph/bin
16:40  ManDay: ?
16:41  ManDay: ${PATH} = {$PATH} ?
16:41  twkm: looks like a mistake.
16:41  ManDay: ok thanks
16:41  twkm: {$PATH} would replace $PATH with PATH's value, surrounded by braces.  ${PATH} would be entirely replaced with PATH's value.
16:45  micols: damn now you got me confused, what is the difference between $PATH and ${PATH} , ${PATH} is mostly SH isn't it?
16:46  twkm: no.
16:46  taylanub: # var=foo; echo ${var}bar
16:46  evalbot: taylanub: foobar
16:47  taylanub: that's where you need ${}
16:47  micols: ah, makes good sense, thanks
16:47  micols: # var=foo;echo $var\bar
16:47  evalbot: micols: foobar
16:48  micols: I usually did that heh
16:49  ManDay: # var=foo ; echo $var"bar"
16:49  evalbot: ManDay: foobar
16:50  ManDay: "that's where you *need* ${}"
16:50  ManDay: ^ i dont think so
16:50  ManDay: # var=foo ; echo "$var"bar
16:50  evalbot: ManDay: foobar
16:51  ManDay: # var=foo ; echo "$var""bar"
16:51  evalbot: ManDay: foobar
16:51  ManDay: # var=foo ; echo -n $var; echo bar
16:51  evalbot: ManDay: foobar
16:54  taylanub: it at least saves you from hacks like that
16:55  twkm: yay for ignoring conversations via bot.
16:56  ManDay: hacks?
16:56  ManDay: what is hack about $foo\bar or "$foo"bar ?
16:57  ManDay: its just another chapter in the arbitrarity of bash logic
16:58  twkm: perhaps some punctuation makes hir eyes cross.
16:58  taylanub: "$foo"bar  might actually be wanted, but in the case of \b and similar, you basically use a syntax element that's meant to do something else, if you get what i mean
16:59  twkm: no, but it looks like it could be something else, if only the grammar were different.
16:59  ManDay: nope
16:59  ManDay: # var=foo ; echo $foo\nbar
16:59  evalbot: ManDay: nbar
17:00  ManDay: # var=foo ; echo $var\nbar
17:00  evalbot: ManDay: foonbar
17:00  ManDay: thats no linebreak ^
17:00  ManDay: of what did you mean by "misusing a syntax element"?
17:00  taylanub: you're making use of the fact that \ has no effect with certain letters
17:00  ManDay: # echo \n
17:00  evalbot: ManDay: n
17:00  ManDay: erm
17:00  ManDay: my bad
17:00  taylanub: i didn't say "misuse"; you use it for something it's not meant for
17:01  ManDay: # var=foo ; echo $var\'bar
17:01  evalbot: ManDay: foo'bar
17:01  twkm: do you imagine that $foo\new would put a newline between foo's value and "ew"?  only in certain places, not all.
17:01  ManDay: taylanub: so whats the case that you arefering to where the letter after the \ HAS a special meaning?
17:01  taylanub: the point of \ is to escape characters with special meaning
17:01  twkm: not really.
17:02  ManDay: taylanub: IF it is interpreted as an escape!
17:02  ManDay: and only then
17:02  twkm: not any more than "foo" is special.
17:02  ManDay: in    echo $var\foo  the \ is not an escape
17:03  twkm: it is being used "to prevent parameter expansion."
17:03  taylanub: you're making use of the fact that '\' does nothing in the case of a letter that needs no escaping, to achieve a totally unrelated goal
17:04  ManDay: taylanub: no im not!
17:04  ManDay: look at
17:04  ManDay: # var=foo ; echo $var\'bar
17:04  taylanub: that's a different case
17:04  ManDay: it doesnt matter what comes after the \
17:04  ManDay: it fulfils the job
17:04  ManDay: # var=foo ; echo $var\
17:04  ManDay: # var=foo ; echo $var\ ;
17:04  taylanub: there you go
17:04  ManDay: hm
17:04  ManDay: # var=foo ; echo $var\; echo abc
17:05  ManDay: # var=foo ; echo $var\; echo abc ; echo def
17:05  ManDay: ?
17:05  taylanub: even if it would work in all cases, that's just not what '\' is supposed to be used for
17:05  twkm: sigh.
17:05  twkm: oh well.
17:05  taylanub: yeah, not the most meaningful debate i guess :P
17:29  argos-void: in .bash_profile i put: "if[$(tty) = /dev/pts/0]; then screen fi "but it didnt work.whats going on?
17:30  erUSUL: argos-void: lack of spaces, commas ? if [ $(tty) = /dev/pts/0 ]; then screen; fi
17:31  erUSUL: ![[
17:31  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
17:31  argos-void: ok
18:08  argos-void: "if[[$(tty) = /dev/pts/0]]; then screen; fi" didnt work.
18:08  Fatal: you need spaces
18:08  argos-void: where?
18:08  Fatal: you normally type ls/tmp/ ?
18:08  argos-void: err no :)
18:09  argos-void: oh
18:10  Fatal: treat [[ as a command as well and ]] as the last argument and you'll do fine
18:10  argos-void: ok
--- Log closed Sat Nov 27 18:16:08 2010
--- Log opened Sat Nov 27 18:16:32 2010
18:16 --- Users 529 nicks [0 ops, 0 halfops, 0 voices, 529 normal]
18:17  argos-void: it dont work
18:18 --- Channel #bash was synced in 106 seconds
18:18  Fatal: what did it output
18:19  argos-void: strange things
18:19 --- juanmabc is now known as juanmabcirc
18:19  argos-void: it does nothing, seriously
18:19  argos-void: it dont echo nothing
18:19  Fatal: where did you put it?
18:20  Fatal: replace the code with echo HELLO, see if you get HELLO echoed, if you do, then start trying to figure out why it won't do anything
18:21 --- juanmabcirc is now known as juanmabcirc_vamo
18:21  argos-void: nothing
18:21 * argos-void getting mad
18:22 --- juanmabcirc_vamo is now known as jmbc_vamos_rafa
18:22  Fatal: argos-void: where are you trying to run this code? how are you trying to run it? where did you put the code?
18:23  argos-void: in .bash_profile
18:23  argos-void: something idiot?
18:23  Fatal: !dotfiles > argos-void
18:23  greybot: argos-void: http://mywiki.wooledge.org/DotFiles or - for a technical explanation - the INVOCATION section of man bash.
18:23  Fatal: (got call, read that page)
18:24  argos-void: ok T_T
18:25 * argos-void 
18:26  argos-void: much thanks
18:29 --- nadir is now known as n1adir
--- Log closed Sat Nov 27 18:46:09 2010
