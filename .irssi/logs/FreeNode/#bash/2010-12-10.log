--- Log opened Fri Dec 10 00:00:09 2010
00:04  kristian-aalborg: hi ppl
00:04  kristian-aalborg: the ssh/mpd thing works wonderfully :)
00:19  manizzle: how do you say
00:20  manizzle: foo1.jpg foo2.jpg foo3.jpg
00:20  manizzle: with a glob?
00:20  manizzle: like foo[1-3].jpg
00:20  manizzle: ?
00:20  yitz_: Yes
00:21  manizzle: k cool
00:21  manizzle: is there any quick way to change a pictures orientation?
00:22  mar77i: manizzle: foo{1,2,3}.jpg that is
00:22  Bushmills: yes: use a suitable program to do it.
00:22  mar77i: manizzle: you're looking for imagemagick convert
00:22  manizzle: mar77i, does the [ and { make a difference? the [ wotrked for me
00:23  mar77i: no idea about the [ part, I guess it should be on the manpage.
00:24  Bushmills: makes a difference.  try either, with only foo1 and foo2, but not foo3 in the directory
00:25  yitz_: The [ does pathname expansion and only matches existing files
00:25  yitz_: { is a brace expansion and doesn't consider files. It just expands
00:26  mar77i: oh. <3 braces. analogous permutation ftw
00:29  Bushmills: # echo foo{1..3}{a..c}
00:29  evalbot: Bushmills: foo1a foo1b foo1c foo2a foo2b foo2c foo3a foo3b foo3c
00:31  Bushmills: 4# echo foo{1..19..6}{a..z..10}
00:31  shbot: Bushmills: foo1a foo1k foo1u foo7a foo7k foo7u foo13a foo13k foo13u foo19a foo19k foo19u
00:33  \malex\: and you can nest them
00:42 --- pyoor_ is now known as pyoor
01:01  jsz`: can you use read instead of cat <<-EOF ?
01:04  dragos240: Hi.
01:05  dragos240: Does anyone know how to remove something from an echo.
01:05  dragos240: For example, anything after a certain character?
01:05  retrospectacus: the backspace key
01:06  dragos240: I'm doing a for loop right now, and I've run into this problem where I need to simultaniously remove extentions from files.
01:06  dragos240: Any command that can do this?
01:06  dragos240: What would I need to do.
01:07  retrospectacus: lots. try `cut' or `sed'
01:07  jsz`: !pe > dragos240
01:07  greybot: dragos240: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
01:09 --- jzacsh_ is now known as jzacsh
01:10  dragos240: So should I check the man pages of cut and sed? Or is there a better reference?
01:12  dragos240: Hmm. Cut seems to be what I need. Thank
01:12  dragos240: *Thanks
01:15  krisfremen: ummm
01:15  krisfremen: i'm stumped
01:16  krisfremen: how can i do something like echo "test" | somebashscript.sh ?
01:16  krisfremen: what do i sue to read the pipe?
01:16  Riviera: read
01:16  Riviera: !faq 1 > krisfremen
01:16  greybot: krisfremen: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
01:20 --- mac- is now known as mac`u
01:27  mac_a: hello
01:27 --- mac_a is now known as mac-
01:29  ss0: !quotes
01:29  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
01:41 * poisonbit just discovered that {} is optional declaring a function :o
01:41  mac-: I wish to execute command $(ls -1)
01:41  Riviera: mac-: maybe you don't
01:41  Riviera: mac-: why do you want to? :)
01:41  poisonbit: # funcky() if (( 1 )); then echo hola; fi; funcky
01:41  evalbot: poisonbit: hola
01:42  Riviera: poisonbit: more useful is to know that () work too
01:42  mac-: but when do that, it takes only ls and ommit -1
01:42  Riviera: mac-: no
01:42  mac-: when do $("ls -1") returns error
01:43  CaT[t3]: mac: what do you have against using * ?
01:43  Riviera: mac-: the problem is rather when you use its output again
01:43  Riviera: mac-: so
01:43  Riviera: mac-: please tell the whole story, because you most likely do something you might not want to do
01:43  mac-: k
01:44  mac-: its little complicated
01:45  mac-: base scpript is: http://pastebin.com/sWd72YaY
01:45  mac-: where script is /home/mac/temp/bash05_02.1
01:45  CaT[t3]: you want to be using * instead
01:45  mac-: asterisk ?
01:46  Riviera: mac-: as I said, the issue is not the ls, but the lack of quotes,
01:46  CaT[t3]: yes
01:46  mac-: quotes ?
01:46  mac-: which ?>
01:46  Riviera: mac-: but; what's that bash_05_02.1 thing?
01:46  Riviera: mac-: please wait first
01:46  Riviera: mac-: what kind of input does bash_05_02.1 need?
01:46  mac-: bash_05_02.1 is the name of this scirpt
01:47  Riviera: mac-: you let it call itself?
01:47  mac-: yep
01:47  mac-: its recursive
01:48  Riviera: mac-: why?
01:48  Riviera: mac-: why don't you use a function instead
01:48  Riviera: mac-: that calls itself
01:48  Riviera: mac-: also, okay:
01:48  Riviera: mac-: let's start with some more fundamental things:
01:48  Riviera: !ls
01:48  greybot: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
01:48  Riviera: mac-: don't use ls, ls -1 anyway is pointless, ls will anyway write one file per line if the output is not a terminal device,
01:48  poisonbit: # touch f{1..3}; files=(*); printf '[%s]\t' "${files[@]}"
01:49  evalbot: poisonbit: [f1]	[f2]	[f3]	
01:49  Riviera: mac-: but, as I said, don't use ls. You cannot reliably parse it.
01:49  Riviera: mac-: next issue:
01:49  Riviera: !quotes > mac-
01:49  greybot: mac-: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
01:49  Riviera: mac-: pay attention to that, please:
01:49  Riviera: # touch file1 file2; echo $(ls -1)
01:49  evalbot: Riviera: file1 file2
01:49  Riviera: # touch file1 file2; echo "$(ls -1)"
01:49  evalbot: Riviera: file1
01:49  evalbot: Riviera: file2
01:49  mac-: ahh
01:49  Riviera: mac-: so, see, you missed the quotes. There are missing at other places in your script too,
01:49  mac-: quotes outside of variable
01:50  Riviera: mac-: everywhere where you used $parameter_expansions
01:50  Riviera: mac-: but again,
01:50  Riviera: mac-: don't do that $(ls -l) crap
01:50  mac-: not -l, but -1
01:50  Riviera: mac-: it's not a variable, it's command substitution, but yes, embed variables like that too
01:50  Riviera: mac-: yes, i know, sorry about that,
01:50  Riviera: mac-: but as you earlier read, -1 is useless anyway, as ls is.
01:51  mac-: hm
01:51  Riviera: mac-: so, what do you actually want to program?
01:51  Riviera: mac-: I doubt that it is a broken recursive directory lister :)
01:52  CaT[t3]: it could be a fork bomb if you think about bind mounts :)
01:56 --- Unknown[NF] is now known as Unknown[OFF]
02:00 --- studyurnm3 is now known as misnix
02:09  mac-: Riviera: this scrpit should enter to all subdirectories in given path and print all file names
02:09  Riviera: mac-: this you can do with find
02:09  zambaboo: like find ./
02:09 * zambaboo chuckles
02:10  Riviera: mac-: find path -type f -print
02:10  Riviera: mac-: or just what zambaboo said, if it's about all the files, like also directories
02:12  mac-: but when we assume, that I don`t have any files which names do not contain newline characters
02:12  Riviera: mac-: why would we do such thing?
02:12  zambaboo: mac-, man find
02:13  Riviera: mac-: there's still globbing
02:13  Riviera: mac-: for a in ./*; do if [[ -d $a ]]; then ( cd -- "$a" && some_recursive_function_call ); fi; done
02:13  Riviera: mac-: or whatever
02:14  Riviera: mac-: you can even less ask for assuming anything if the task isn't even clear, the motivation, the problem
02:14  Riviera: :)
02:16  retrospectacus: almost definitely an XY problem we have here
02:20  zambaboo: !faq 50
02:20  greybot: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
--- Log opened Fri Dec 10 02:27:36 2010
02:27 --- Users 534 nicks [0 ops, 0 halfops, 0 voices, 534 normal]
02:28 --- Channel #bash was synced in 89 seconds
02:48  ss0: If I wanted to pipe the results of a command into an email would mailx be my best choice to receive the results? Is it better to do that in the cron job itself in the script?
02:48  ss0: If I wanted to pipe the results of a command into an email would mailx be my best choice to receive the results? Is it better to do that in the cron job itself in the script?
02:50  ss0: !mail
02:50  ss0: !mail
03:07  tharkun: ss0: depending on the format you have a miriad of programs that can do that, It ends up on which one you are most comfortable with.
03:07  tharkun: ss0: depending on the format you have a miriad of programs that can do that, It ends up on which one you are most comfortable with.
03:10  harpal: I had created bash script, when I try to run it using ./script.sh then it works fine, but if I give /home/admin1/script.sh then its throwing errors :(
03:10  harpal: I had created bash script, when I try to run it using ./script.sh then it works fine, but if I give /home/admin1/script.sh then its throwing errors :(
03:10  ss0: tharkun:  Thanks, the way im doing it currently is "/opt/dell/srvadmin/bin/omreport storage pdisk controller=0" | mailx -s "disk problem" "ss0@domain.com";
03:10  ss0: tharkun:  Thanks, the way im doing it currently is "/opt/dell/srvadmin/bin/omreport storage pdisk controller=0" | mailx -s "disk problem" "ss0@domain.com";
03:10  harpal: what could be the problem with script
03:10  harpal: what could be the problem with script
03:11  ss0: But the body of the email comes up blank.
03:11  ss0: But the body of the email comes up blank.
03:12  ss0: If I run it directly from the command line i get the expected result… so im confused why it doesn't work in the script.
03:12  ss0: If I run it directly from the command line i get the expected result… so im confused why it doesn't work in the script.
03:13  ss0: ah it was a quoting issue.
03:13  ss0: ah it was a quoting issue.
03:14  Bushmills: harpal:  "...then its throwing errors" <- those might give you a hint what the problem could be
03:14  Bushmills: harpal:  "...then its throwing errors" <- those might give you a hint what the problem could be
03:15  harpal: Bushmills: I am in /root and running it from there. so it says /root/home/admin1/script.sh not found
03:15  harpal: Bushmills: I am in /root and running it from there. so it says /root/home/admin1/script.sh not found
03:15  Bushmills: the problem is:  /root/home/admin1/script.sh not found
03:15  Bushmills: the problem is:  /root/home/admin1/script.sh not found
03:16  harpal: Bushmills: but my script is at /home/admin1/script.sh and I am running it from /root directory
03:16  harpal: Bushmills: but my script is at /home/admin1/script.sh and I am running it from /root directory
03:16  Bushmills: check the paths you're referring to. use absolute, not relative paths
03:16  Bushmills: check the paths you're referring to. use absolute, not relative paths
03:16  harpal: so why its appending current directory
03:16  harpal: so why its appending current directory
03:17  harpal: Bushmills: ok
03:17  harpal: Bushmills: ok
03:29  k[t: bugga: that beep coming from bash -x "file" was my prompt... =\
03:29  k[t: bugga: that beep coming from bash -x "file" was my prompt... =\
03:32  k[t: i don't think i should have "'\[\033]0;[`tty`]=\w\007\]" at the beginning of PS4
03:32  k[t: i don't think i should have "'\[\033]0;[`tty`]=\w\007\]" at the beginning of PS4
--- Log closed Fri Dec 10 03:40:32 2010
--- Log closed Fri Dec 10 03:41:08 2010
--- Log opened Fri Dec 10 03:46:04 2010
03:46 --- Users 525 nicks [0 ops, 0 halfops, 0 voices, 525 normal]
--- Log opened Fri Dec 10 03:46:31 2010
03:46 --- Users 526 nicks [0 ops, 0 halfops, 0 voices, 526 normal]
03:47 --- Channel #bash was synced in 89 seconds
03:47 --- Channel #bash was synced in 85 seconds
--- Log closed Fri Dec 10 04:21:49 2010
--- Log closed Fri Dec 10 04:22:15 2010
--- Log opened Fri Dec 10 04:27:11 2010
04:27 --- Users 521 nicks [0 ops, 0 halfops, 0 voices, 521 normal]
--- Log opened Fri Dec 10 04:27:40 2010
04:27 --- Users 522 nicks [0 ops, 0 halfops, 0 voices, 522 normal]
04:28 --- Channel #bash was synced in 87 seconds
04:28 --- Channel #bash was synced in 89 seconds
05:09  tsolox: is there a way to change the value of an exported variable, so that all other terminals will see this change?
05:09  tsolox: is there a way to change the value of an exported variable, so that all other terminals will see this change?
05:10  tmr: All currently open terminals? No other way than changing it in all current shells.
05:10  tmr: All currently open terminals? No other way than changing it in all current shells.
05:10  tsolox: first, I put 'export n=1' in .bash_profile. Then open up aterm, and echo $n shows 1. I open another terminal, and do 'n=2'. But this change is not visible in the other terminal, still seeing is as 1
05:10  tsolox: first, I put 'export n=1' in .bash_profile. Then open up aterm, and echo $n shows 1. I open another terminal, and do 'n=2'. But this change is not visible in the other terminal, still seeing is as 1
05:11 05:11  tmr: Of course. tmr: Of course.

05:12  tsolox: i guess, i'll just use the filesystem then to write these settings..
05:12  tsolox: i guess, i'll just use the filesystem then to write these settings..
05:38  terrorpup: can some one point me to a good link on how to do math in bash, I like to be able to take $a + $b + $c = $x
05:38  terrorpup: can some one point me to a good link on how to do math in bash, I like to be able to take $a + $b + $c = $x
05:46  yitz_: !(( > terrorpup
05:46  yitz_: !(( > terrorpup
05:46  greybot: terrorpup: ((...)) is an arithmetic command, which returns an exit status of 0 if the expression is nonzero, or 1 if the expression is zero. Also used as a synonoym for "let", if side effects (assignments) are needed. See <http://mywiki.wooledge.org/ArithmeticExpression>.
05:46  greybot: terrorpup: ((...)) is an arithmetic command, which returns an exit status of 0 if the expression is nonzero, or 1 if the expression is zero. Also used as a synonoym for "let", if side effects (assignments) are needed. See <http://mywiki.wooledge.org/ArithmeticExpression>.
05:47  terrorpup: greybot,  thanks
05:47  terrorpup: greybot,  thanks
05:47  terrorpup: or yitz, why am I saying thanks to a bot
05:47  terrorpup: or yitz, why am I saying thanks to a bot
05:52  k[t: i have just been officially pawned by "#!/bin/bash and $PATH=/bin:/usr/bin:/usr/sbin"
05:52  k[t: i have just been officially pawned by "#!/bin/bash and $PATH=/bin:/usr/bin:/usr/sbin"
05:53  k[t: since i don't code much-- i always think of myself... but for this certain script to work for all users.... well, you get the point..
05:53  k[t: since i don't code much-- i always think of myself... but for this certain script to work for all users.... well, you get the point..
05:54 * k[t rm -f <script>
05:54 * k[t rm -f <script>
06:05  flaccid: hmm, what was that uber cool way to chop off trailing and leading whitespace ?
06:05  flaccid: hmm, what was that uber cool way to chop off trailing and leading whitespace ?
06:07  yitz_: read
06:07  yitz_: read
06:07  flaccid: how about sed 's/^[ \t]*//'
06:07  flaccid: how about sed 's/^[ \t]*//'
06:08  yitz_: Ugh
06:08  yitz_: Ugh
06:08  flaccid: hehe
06:08  flaccid: hehe
06:08  yitz_: # var=' abc  '; read var <<< "$var" ; echo "[$var]"
06:08  yitz_: # var=' abc  '; read var <<< "$var" ; echo "[$var]"
06:08  evalbot: yitz_: [abc]
06:08  evalbot: yitz_: [abc]
06:10  flaccid: danke
06:10  flaccid: danke
06:14  flaccid: ok sweet, now how about removing tags? foo="<bar>foooby</bar>"
06:14  flaccid: ok sweet, now how about removing tags? foo="<bar>foooby</bar>"
06:19  yitz_: !pe
06:19  yitz_: !pe
06:19  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
06:19  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
06:24 --- streuner__ is now known as streuner
06:24 --- streuner__ is now known as streuner
06:25  flaccid: hmm yitz_ can you give me an example
06:25  flaccid: hmm yitz_ can you give me an example
06:26  yitz_: # var="<bar>foooby</bar>" ; var="${var#*>}" ; var="${var%<*}" ; echo $var
06:26  yitz_: # var="<bar>foooby</bar>" ; var="${var#*>}" ; var="${var%<*}" ; echo $var
06:26  evalbot: yitz_: foooby
06:26  evalbot: yitz_: foooby
06:27  flaccid: danke!
06:27  flaccid: danke!
06:52  flaccid: sweet. going well. how about the shortest/best way to do this if ! "$1"; then exit
06:52  flaccid: sweet. going well. how about the shortest/best way to do this if ! "$1"; then exit
06:55  flaccid: ok, i guess i'm looking at shortening if [ ! "$1" ]; then exit 1; fi
06:55  flaccid: ok, i guess i'm looking at shortening if [ ! "$1" ]; then exit 1; fi
06:56  yitz_: [[ $1 ]] && exit
06:56  yitz_: [[ $1 ]] && exit
06:56  twkm: why did you write two different things?
06:56  twkm: why did you write two different things?
06:56  flaccid: danke
06:56  flaccid: danke
06:57  flaccid: um
06:57  flaccid: um
06:57  flaccid: always forget syntax
06:57  flaccid: always forget syntax
06:57  flaccid: is this ok to say msg before exit?
06:57  flaccid: is this ok to say msg before exit?
06:57  flaccid: [[ $1 ]] && echo bye && exit
06:57  flaccid: [[ $1 ]] && echo bye && exit
06:58  twkm: yeah, fuck syntax ... then ask about something that requires using syntax to decide if it is 'ok'.  sheesh.
06:58  twkm: yeah, fuck syntax ... then ask about something that requires using syntax to decide if it is 'ok'.  sheesh.
06:58  flaccid: i'm learning twkm
06:58  flaccid: i'm learning twkm
06:58  twkm: but whatever.  echo can fail, but probably won't.
06:58  twkm: but whatever.  echo can fail, but probably won't.
06:59  yop129: hey, does anyone know of a solution where I can have a list of words defined automatically using a dictionary?
06:59  yop129: hey, does anyone know of a solution where I can have a list of words defined automatically using a dictionary?
07:00  yitz_: Yeah. Store an array definition in a file and source it
07:00  yitz_: Yeah. Store an array definition in a file and source it
07:02  yop129: yitz_: sorry, I don't know how to script, mind explaining that in laymans terms?
07:02  yop129: yitz_: sorry, I don't know how to script, mind explaining that in laymans terms?
07:02  yitz_: What exactly are you trying to do?
07:02  yitz_: What exactly are you trying to do?
07:02  yop129: Like I have a list of words and I want a script or something to automatically go through the words and define them
07:02  yop129: Like I have a list of words and I want a script or something to automatically go through the words and define them
07:03  snappy: do you have a list of definitions?
07:03  snappy: do you have a list of definitions?
07:04  yop129: no
07:04  yop129: no
07:04  yop129: just the words
07:04  yop129: just the words
07:06  snappy: where do you expect to get the definitions?
07:06  snappy: where do you expect to get the definitions?
07:08  yop129: snappy: either dictionary.com or the builtin dictionary utility in Ubuntu
07:08  yop129: snappy: either dictionary.com or the builtin dictionary utility in Ubuntu
07:17  ik: hi there.
07:17  ik: hi there.
07:18  lsingh: I have a program which produces very large output info stdout. The bash terminal stores the end of the output upto a 'limit' so that we can scroll up to see output upto the limit. But my output is even bigger than this limit, hence only the end part is displayed.
07:18  lsingh: I have a program which produces very large output info stdout. The bash terminal stores the end of the output upto a 'limit' so that we can scroll up to see output upto the limit. But my output is even bigger than this limit, hence only the end part is displayed.
07:18  lsingh: How to increase this *limit*
07:18  lsingh: How to increase this *limit*
07:18  ik: That's up to your terminal emulator, not bash
07:18  ik: That's up to your terminal emulator, not bash
07:18  ik: but forget that, just redirect your output to a file
07:18  ik: but forget that, just redirect your output to a file
07:18  ik: or pipe it to a pager (ie 'less')
07:18  ik: or pipe it to a pager (ie 'less')
07:20  lsingh: but how to increase the limit.. what config of terminal emulator'
07:20  lsingh: but how to increase the limit.. what config of terminal emulator'
07:20  ik: don't worry about the limit
07:20  ik: don't worry about the limit
07:20  ik: that's solving the wrong problem
07:20  ik: that's solving the wrong problem
07:20  ik: Do you know how to redirect stdout?
07:20  ik: Do you know how to redirect stdout?
07:20  lsingh: ya i know
07:20  lsingh: ya i know
07:20  ik: So do that.
07:20  ik: So do that.
07:20  ik: pipe it to less and you can scroll through it as you wish
07:20  ik: pipe it to less and you can scroll through it as you wish
07:21  ik: or send it to a file and view that any way you like
07:21  ik: or send it to a file and view that any way you like
07:21  lsingh: but bit painful to redirect everytime to a new file or 'less' because it starts from the beginning
07:21  lsingh: but bit painful to redirect everytime to a new file or 'less' because it starts from the beginning
07:21  ik: you can jump straight to the end with a keystroke.
07:21  ik: you can jump straight to the end with a keystroke.
07:22  lsingh: hmm.. will have to do away with it
07:22  lsingh: hmm.. will have to do away with it
--- Log closed Fri Dec 10 07:41:05 2010
--- Log closed Fri Dec 10 07:41:35 2010
--- Log opened Fri Dec 10 07:46:27 2010
07:46 --- Users 511 nicks [0 ops, 0 halfops, 0 voices, 511 normal]
--- Log opened Fri Dec 10 07:47:01 2010
07:47 --- Users 512 nicks [0 ops, 0 halfops, 0 voices, 512 normal]
07:47 --- Channel #bash was synced in 83 seconds
07:48  pgas: flaccid: hmm, should we assumen that bar is in fact a patern?
07:48  pgas: flaccid: hmm, should we assumen that bar is in fact a patern?
07:48  pgas: do you have a real example instead of a fake one?
07:48  pgas: do you have a real example instead of a fake one?
07:48 --- Channel #bash was synced in 90 seconds
07:48  pgas: because so far it's quite trivial...: foo=bar
07:48  pgas: because so far it's quite trivial...: foo=bar
07:49  flaccid: <href>https://mysite.com/api/acct/1254/servers/8587/current</href>
07:49  flaccid: <href>https://mysite.com/api/acct/1254/servers/8587/current</href>
07:49  flaccid: i actually want to get the server id which is after servers/
07:49  flaccid: i actually want to get the server id which is after servers/
07:50  pgas: do it in 2 steps: var=${var#*servers/} var=${var%%/*}'
07:50  pgas: do it in 2 steps: var=${var#*servers/} var=${var%%/*}'
07:50  flaccid: wow thanks
07:50  flaccid: wow thanks
07:51  pgas: !faq 100
07:51  pgas: !faq 100
07:51  greybot: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
07:51  greybot: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
07:54  pyoor_: flaccid did you grep that string from a file?
07:54  pyoor_: flaccid did you grep that string from a file?
07:54  flaccid: ok cool thanks. this might sound silly but how do i loop through each line of a variable?
07:54  flaccid: ok cool thanks. this might sound silly but how do i loop through each line of a variable?
07:54 --- pyoor_ is now known as pyoor
07:54 --- pyoor_ is now known as pyoor
07:54  flaccid: i did grep it out yet
07:54  flaccid: i did grep it out yet
07:55  flaccid: basically the xml returned there can be more than 1 element of href
07:55  flaccid: basically the xml returned there can be more than 1 element of href
07:58  flaccid: !for
07:58  flaccid: !for
07:58  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
07:58  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
07:59  flaccid: !while
07:59  flaccid: !while
07:59  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
07:59  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
08:00  flaccid: for a var do i use << or <<<< with a while hmm
08:00  flaccid: for a var do i use << or <<<< with a while hmm
08:00  flaccid: like done <<<< $(hrefs_xml)
08:00  flaccid: like done <<<< $(hrefs_xml)
08:01  pgas: i'd use an xml parse or maybe awk rather than bash
08:01  pgas: i'd use an xml parse or maybe awk rather than bash
08:01  pgas: !faq 1 > flaccid
08:01  pgas: !faq 1 > flaccid
08:01  greybot: flaccid: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
08:01  greybot: flaccid: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
08:01  flaccid: yeah i'm just doing some doing examples
08:01  flaccid: yeah i'm just doing some doing examples
08:03  k[t: pgas: personly inquiry..: if you were to read line by line say -- by opening fd6 as rw, would you just end up rewriting the original file to a comletely new one with the modifications in the loop construct? or somehow replace (sed like) during the read/write ?
08:03  k[t: pgas: personly inquiry..: if you were to read line by line say -- by opening fd6 as rw, would you just end up rewriting the original file to a comletely new one with the modifications in the loop construct? or somehow replace (sed like) during the read/write ?
08:03  k[t: s/personly/personal/
08:03  k[t: s/personly/personal/
08:06  k[t: s/comletely/completely/
08:06  k[t: s/comletely/completely/
08:06  pgas: k[t: typically, you don't read from and write in the same file at the same time, sed use a temp file internally and so do most editors
08:06  pgas: k[t: typically, you don't read from and write in the same file at the same time, sed use a temp file internally and so do most editors
08:06  flaccid: when i do the while read loop, it seems to remove the line breaks, i end up with 1 line instead of 2
08:06  flaccid: when i do the while read loop, it seems to remove the line breaks, i end up with 1 line instead of 2
08:07  pgas: use more quotes
08:07  pgas: use more quotes
08:07  pgas: <<< "$hrefs_xml"
08:07  pgas: <<< "$hrefs_xml"
08:07  flaccid: i see, thanks
08:07  flaccid: i see, thanks
08:08  k[t: ok, great. so now my answer has a path, thanks..
08:08  k[t: ok, great. so now my answer has a path, thanks..
08:11  pyoor: I apologize if this isn't suited for #bash.  Others have suggested awk and sed solutions but I'm curious what you guys think.  Is there anyway I can all occurences of string from a file except between 2 delimeters, with multiple occurences of those delimeters?  I.e: several-lines-of-text...start...data...end...more-lines...start...data...end..even-more-lines
08:11  pyoor: I apologize if this isn't suited for #bash.  Others have suggested awk and sed solutions but I'm curious what you guys think.  Is there anyway I can all occurences of string from a file except between 2 delimeters, with multiple occurences of those delimeters?  I.e: several-lines-of-text...start...data...end...more-lines...start...data...end..even-more-lines
08:12  pyoor:  /I can all/I can replace all/
08:12  pyoor:  /I can all/I can replace all/
08:14  flaccid: dang, is there any way to remove duplicate lines of a variable or file in bash?
08:14  flaccid: dang, is there any way to remove duplicate lines of a variable or file in bash?
08:15  twkm: yes.
08:15  twkm: yes.
08:15  \malex\: flaccid: uniq
08:15  \malex\: flaccid: uniq
08:15  flaccid: !uniq
08:15  flaccid: !uniq
08:15  greybot: uniq is a utility for removing or reporting repeated lines. uniq will only work effectively with sorted input (sort | uniq). awk '!s[$0]++' is an order-insensitive alternative.
08:15  greybot: uniq is a utility for removing or reporting repeated lines. uniq will only work effectively with sorted input (sort | uniq). awk '!s[$0]++' is an order-insensitive alternative.
08:15  twkm: though i'd use a utility instead of bash.
08:15  twkm: though i'd use a utility instead of bash.
08:15  flaccid: danke
08:15  flaccid: danke
08:15  twkm: e.g., awk, perl, sort, uniq, ...
08:15  twkm: e.g., awk, perl, sort, uniq, ...
08:17  flaccid: hmm cool, is there a better way to do this statement, hrefs=$(echo "$hrefs" | uniq)
08:17  flaccid: hmm cool, is there a better way to do this statement, hrefs=$(echo "$hrefs" | uniq)
08:19  twkm: do it when you creat hrefs.
08:19  twkm: do it when you creat hrefs.
08:19  flaccid: okies thanks
08:19  flaccid: okies thanks
08:28  kingsley: Is there a concise and simple way to collect N lines at a time from a file, and forward each bunch of N lines for further processing?
08:28  kingsley: Is there a concise and simple way to collect N lines at a time from a file, and forward each bunch of N lines for further processing?
08:34  kingsley: 4# seq 3
08:34  kingsley: 4# seq 3
08:34  shbot: kingsley: bash4: seq: command not found
08:34  shbot: kingsley: bash4: seq: command not found
08:34  kingsley: 4# echo {1..3}
08:34  kingsley: 4# echo {1..3}
08:34  shbot: kingsley: 1 2 3
08:34  shbot: kingsley: 1 2 3
08:38  k[t: !shellcode
08:38  k[t: !shellcode
08:38  kingsley: 4# printf "%s\n" {1..3}
08:38  kingsley: 4# printf "%s\n" {1..3}
08:38  shbot: kingsley: 1
08:38  shbot: kingsley: 1
08:38  shbot: kingsley: 2
08:38  shbot: kingsley: 2
08:38  shbot: kingsley: 3
08:38  shbot: kingsley: 3
08:49  flaccid: count how many times string in string ?
08:49  flaccid: count how many times string in string ?
08:50  Fatal: not word?
08:50  Fatal: not word?
08:57  SiegeX: 42 times
08:57  SiegeX: 42 times
09:00  geirha: i=0; while [[ $string = *"$foo"* ]]; do ((i++)); string=${string#*"$foo"}; done
09:00  geirha: i=0; while [[ $string = *"$foo"* ]]; do ((i++)); string=${string#*"$foo"}; done
09:01  Fatal: nice one
09:01  Fatal: nice one
09:03  kingsley: Does anyone here happen to know how to read N lines at a time from a file, and pipe each group of N lines to something like the "tac" command, until all lines have been read and forwarded?
09:03  kingsley: Does anyone here happen to know how to read N lines at a time from a file, and pipe each group of N lines to something like the "tac" command, until all lines have been read and forwarded?
09:03  twkm: mapfile in a loop?
09:03  twkm: mapfile in a loop?
09:04  kingsley: twkm: Your clever suggestion seems plausible.
09:04  kingsley: twkm: Your clever suggestion seems plausible.
09:04  kingsley: twkm: I'd love to see it concisely implemented
09:04  kingsley: twkm: I'd love to see it concisely implemented
09:07 * SiegeX cheats with awk
09:07 * SiegeX cheats with awk
09:07  SiegeX:  awk -v foo="$foo" '{print gsub(foo,"")}'
09:07  SiegeX:  awk -v foo="$foo" '{print gsub(foo,"")}'
09:08  geirha: awk -v RS="$foo" 'END{print NR-1}'
09:08  geirha: awk -v RS="$foo" 'END{print NR-1}'
09:09  twkm: #awk might have comments on either of those.
09:09  twkm: #awk might have comments on either of those.
09:10  SiegeX: oh snap, we have ourselves an awk-off!
09:10  SiegeX: oh snap, we have ourselves an awk-off!
09:12  SiegeX: except short of renaming '$foo' to '$f' I think we have a winnar
09:12  SiegeX: except short of renaming '$foo' to '$f' I think we have a winnar
09:13  pgas: using more than one char for RS is not standard
09:13  pgas: using more than one char for RS is not standard
09:13  flaccid: thanks geirha
09:13  flaccid: thanks geirha
09:15  SiegeX: heh, flag on the play
09:15  SiegeX: heh, flag on the play
09:16  Perun_: re
09:16  Perun_: re
09:16  Fatal: except that geirhas bash implementation is the fastest :)
09:16  Fatal: except that geirhas bash implementation is the fastest :)
09:19  Perun_: I have a such data file: http://paste.debian.net/102025/ 1 line: index 2: line flag..., I want to reformate it to one line 'index flag'.. how can I do it? sed?
09:19  Perun_: I have a such data file: http://paste.debian.net/102025/ 1 line: index 2: line flag..., I want to reformate it to one line 'index flag'.. how can I do it? sed?
09:20  Fatal: (for sane sized strings :))
09:20  Fatal: (for sane sized strings :))
09:21  geirha: while read -r line1; read -r line2; do printf '%s %s\n' "$line1" "$line2"; done < file
09:21  geirha: while read -r line1; read -r line2; do printf '%s %s\n' "$line1" "$line2"; done < file
09:21  pgas: paste -d ' ' - -  < file
09:21  pgas: paste -d ' ' - -  < file
09:22  geirha: sed 'N;s/\
09:22  geirha: sed 'N;s/\
09:22  geirha: //' file
09:22  geirha: //' file
09:25  geirha: awk 'ORS=NR%2?FS:RS'
09:25  geirha: awk 'ORS=NR%2?FS:RS'
09:26 --- omnoms is now known as KittyKatt
09:26 --- omnoms is now known as KittyKatt
09:30  SiegeX: a=($string); b=(${a[@]//$foo/}); echo $((${#a[@]} - ${#b[@]}))
09:30  SiegeX: a=($string); b=(${a[@]//$foo/}); echo $((${#a[@]} - ${#b[@]}))
09:30  SiegeX: mine gets bonus points for looking like perl
09:30  SiegeX: mine gets bonus points for looking like perl
09:32  SiegeX: although I wonder if ${a[@]//$foo/} is a 4.x
09:32  SiegeX: although I wonder if ${a[@]//$foo/} is a 4.x
09:32 * [gnubie] waves
09:32 * [gnubie] waves
09:33 * [gnubie] needs your advice..
09:33 * [gnubie] needs your advice..
09:33  SiegeX: # string="foo foo foo bar foo foo foo baz foo foo"; foo="foo"; a=($string); b=(${a[@]//$foo/}); echo $((${#a[@]} - ${#b[@]}))
09:33  SiegeX: # string="foo foo foo bar foo foo foo baz foo foo"; foo="foo"; a=($string); b=(${a[@]//$foo/}); echo $((${#a[@]} - ${#b[@]}))
09:33  evalbot: SiegeX: 8
09:33  evalbot: SiegeX: 8
09:33  SiegeX: guess not
09:33  SiegeX: guess not
09:33  [gnubie]: what is the best way to add into an array variable for all the directories listed in bash?
09:33  [gnubie]: what is the best way to add into an array variable for all the directories listed in bash?
09:33  geirha: array=(*/)
09:33  geirha: array=(*/)
09:34  SiegeX: yep
09:34  SiegeX: yep
09:35  SiegeX: If you want more than a depth of 1 and have Bash 4.X -->    shopt -s globstar; a=(**/);
09:35  SiegeX: If you want more than a depth of 1 and have Bash 4.X -->    shopt -s globstar; a=(**/);
09:36  [gnubie]: i want to ls a directory that contain some directories.. all the directories that has been recognized by the ls command or similar to that, will be added in an array
09:36  [gnubie]: i want to ls a directory that contain some directories.. all the directories that has been recognized by the ls command or similar to that, will be added in an array
09:36  [gnubie]: right now, i explicitly/manually added the directories into the array to a variable in my bash script
09:36  [gnubie]: right now, i explicitly/manually added the directories into the array to a variable in my bash script
09:37  SiegeX: # a=(/etc/*/); echo ${a[@]}
09:37  SiegeX: # a=(/etc/*/); echo ${a[@]}
09:37  evalbot: SiegeX: /etc/*/
09:37  evalbot: SiegeX: /etc/*/
09:39  geirha: [gnubie]: Don't use ls in scripts
09:39  geirha: [gnubie]: Don't use ls in scripts
09:39  [gnubie]: geirha: what do you recommend?
09:39  [gnubie]: geirha: what do you recommend?
09:39  SiegeX: <geirha> array=(*/)
09:39  SiegeX: <geirha> array=(*/)
09:40  geirha: [gnubie]: Using the shell ...
09:40  geirha: [gnubie]: Using the shell ...
09:40 09:40  SiegeX: just a hunch, but I'm pretty sure he recommends that SiegeX: just a hunch, but I'm pretty sure he recommends that

09:41  [gnubie]: for example, my /data/backup/ directory contains the sub-directories dir1, dir2, dir3.. right now in my script, i declare it as:  dir_names=([0]=dir1 [1]=dir2 [2]=dir3)
09:41  [gnubie]: for example, my /data/backup/ directory contains the sub-directories dir1, dir2, dir3.. right now in my script, i declare it as:  dir_names=([0]=dir1 [1]=dir2 [2]=dir3)
09:42  [gnubie]: and i call the "${dir_names[@]}" in my for loop statement
09:42  [gnubie]: and i call the "${dir_names[@]}" in my for loop statement
09:42  SiegeX: cd /data/backup/ && dir_names=(*/)
09:42  SiegeX: cd /data/backup/ && dir_names=(*/)
09:43  [gnubie]: SiegeX: i'm declaring it as a bash variable
09:43  [gnubie]: SiegeX: i'm declaring it as a bash variable
09:44  SiegeX: cool
09:44  SiegeX: cool
09:46  geirha: cd /data/backup/ && for dir in */; do ...
09:46  geirha: cd /data/backup/ && for dir in */; do ...
09:46  geirha: or  for dir in /data/backup/*/; do ...
09:46  geirha: or  for dir in /data/backup/*/; do ...
09:47  geirha: That is, if you just want to loop through those dirs, you don't need them in an array.
09:47  geirha: That is, if you just want to loop through those dirs, you don't need them in an array.
09:47  [gnubie]: currently, this is how i do it => http://www.pastie.org/1364550
09:47  [gnubie]: currently, this is how i do it => http://www.pastie.org/1364550
09:48  geirha: Right, but that doesn't explain what you need it for
09:48  geirha: Right, but that doesn't explain what you need it for
09:49  [gnubie]: currently, my script works. but the problem is, later, the sub-directories may be added or removed and i have to manually modify the script by hand again by adding and removing them in the array
09:49  [gnubie]: currently, my script works. but the problem is, later, the sub-directories may be added or removed and i have to manually modify the script by hand again by adding and removing them in the array
09:51  [gnubie]: it's going to traverse all the project repositories to perform mirroring to another machine or slave
09:51  [gnubie]: it's going to traverse all the project repositories to perform mirroring to another machine or slave
09:51  [gnubie]: svn repositories
09:51  [gnubie]: svn repositories
09:51  geirha: So, try SiegeX's solution?
09:51  geirha: So, try SiegeX's solution?
09:52  [gnubie]: geirha: which one? the first one or the second?
09:52  [gnubie]: geirha: which one? the first one or the second?
09:53  geirha: < SiegeX> cd /data/backup/ && dir_names=(*/)
09:53  geirha: < SiegeX> cd /data/backup/ && dir_names=(*/)
09:54  [gnubie]: can i just do a:
09:54  [gnubie]: can i just do a:
09:54  [gnubie]: for x in $(/data/backup/*/); do ...  ?
09:54  [gnubie]: for x in $(/data/backup/*/); do ...  ?
09:54  [gnubie]: and removing the array declaration?
09:54  [gnubie]: and removing the array declaration?
09:55 09:55  geirha: Yes, just lose the $( and ) geirha: Yes, just lose the $( and )

09:55  geirha: for dir in /data/backup/*/; do
09:55  geirha: for dir in /data/backup/*/; do
09:55  [gnubie]: geirha: ok. thanks. i will try it now here.. ;)
09:55  [gnubie]: geirha: ok. thanks. i will try it now here.. ;)
09:56  geirha: # for dir in /*/; do printf '<%s>' "$dir"; done
09:56  geirha: # for dir in /*/; do printf '<%s>' "$dir"; done
09:56  evalbot: geirha: </bin/></dev/></etc/></lib/></proc/></root/></tmp/>
09:56  evalbot: geirha: </bin/></dev/></etc/></lib/></proc/></root/></tmp/>
10:05  Amnesia: hi quick question here
10:05  Amnesia: hi quick question here
10:05  Amnesia: I want to get my system load in xsetroot
10:05  Amnesia: I want to get my system load in xsetroot
10:05  Amnesia:  so I use Load: $(uptime | awk '{ print $8, $9, $10 }'
10:05  Amnesia:  so I use Load: $(uptime | awk '{ print $8, $9, $10 }'
10:05  Amnesia:  but after a couple min it shifts up
10:05  Amnesia:  but after a couple min it shifts up
10:06  Amnesia: 09:53:07 up 4 min,  2 users,  load average: 0.04, 0.16, 0.08
10:06  Amnesia: 09:53:07 up 4 min,  2 users,  load average: 0.04, 0.16, 0.08
10:06  Amnesia: 11:50:18 up  2:00,  2 users,  load average: 0.07, 0.02, 0.00
10:06  Amnesia: 11:50:18 up  2:00,  2 users,  load average: 0.07, 0.02, 0.00
10:06  Amnesia: does anyone have an idea how to filter on everything after average: ?
10:06  Amnesia: does anyone have an idea how to filter on everything after average: ?
10:06  geirha: If you're on linux, use /proc/loadavg instead
10:06  geirha: If you're on linux, use /proc/loadavg instead
10:07  Amnesia: awesome nice:D
10:07  Amnesia: awesome nice:D
10:07  Amnesia: thx geirha
10:07  Amnesia: thx geirha
10:08  geirha: read avg1 avg2 avg3 _ < /proc/loadavg
10:08  geirha: read avg1 avg2 avg3 _ < /proc/loadavg
10:09  geirha: meh
10:09  geirha: meh
10:33  [gnubie]: geirha: i have a different output of my 2 scripts. the diffs are at http://www.pastie.org/1364611
10:33  [gnubie]: geirha: i have a different output of my 2 scripts. the diffs are at http://www.pastie.org/1364611
10:34  geirha: Why did you change "${dir_names[@]}" to $dir_names?
10:34  geirha: Why did you change "${dir_names[@]}" to $dir_names?
10:35  geirha: The former correctly expands the array, the latter expands only the first element, and without quotes.
10:35  geirha: The former correctly expands the array, the latter expands only the first element, and without quotes.
10:39  [gnubie]: geirha: ok. thank you very much for pointing that out.. ;)
10:39  [gnubie]: geirha: ok. thank you very much for pointing that out.. ;)
10:40  geirha: [gnubie]: Also, always test the exit status of cd. Otherwise, if cd fails, you'll be running commands in the wrong directory.
10:40  geirha: [gnubie]: Also, always test the exit status of cd. Otherwise, if cd fails, you'll be running commands in the wrong directory.
10:40  geirha: cd /data/backup || exit
10:40  geirha: cd /data/backup || exit
10:41  [gnubie]: ok. thanks again. ;)
10:41  [gnubie]: ok. thanks again. ;)
10:49  mamooth: hi there
10:49  mamooth: hi there
10:50  richiefrich: go|dfish: you around
10:50  richiefrich: go|dfish: you around
10:55  mamooth: I have a variable scoping problem in an sh script. Here's the the code : http://pastie.org/private/t10xvwphqfgnxefvafnga . When I source the script containing the function, it effectivelmy always return me the same result. But When I call it through the test script, the two successive call to the function return me different results
10:55  mamooth: I have a variable scoping problem in an sh script. Here's the the code : http://pastie.org/private/t10xvwphqfgnxefvafnga . When I source the script containing the function, it effectivelmy always return me the same result. But When I call it through the test script, the two successive call to the function return me different results
10:56  mamooth: In fact, I'm trying to do a kind of lazy getter. The first call to the function compute a result and store it in a global variable. Then, the later calls should return the content of the stored result.
10:56  mamooth: In fact, I'm trying to do a kind of lazy getter. The first call to the function compute a result and store it in a global variable. Then, the later calls should return the content of the stored result.
10:56  trash: mamooth: $(...) opens a subshell.
10:56  trash: mamooth: $(...) opens a subshell.
10:57  mamooth: trash, ok
10:57  mamooth: trash, ok
10:57  mamooth: so I would export it before, or is there a better way to get the echoed result without opening a subshell?
10:57  mamooth: so I would export it before, or is there a better way to get the echoed result without opening a subshell?
10:57 10:57 * mamooth is really a shell n00b
* mamooth is really a shell n00b
10:58  ik: mamooth: it's when you're calling db_filename
10:58  ik: mamooth: it's when you're calling db_filename
10:59  trash: exporting doesn't help, exporting variables just declares variables as environment variables which can be seen by childs of your process.
10:59  trash: exporting doesn't help, exporting variables just declares variables as environment variables which can be seen by childs of your process.
10:59  mamooth: So how could I achieve this at least? Is there any way?
10:59  mamooth: So how could I achieve this at least? Is there any way?
10:59  ik: mamooth: you create _DB_FILENAME in the first subshell, then it exits and that goes away, then you create another subshell to call db_filename again..
10:59  ik: mamooth: you create _DB_FILENAME in the first subshell, then it exits and that goes away, then you create another subshell to call db_filename again..
11:00  mamooth: ik, ok, so it can't work as it is...
11:00  mamooth: ik, ok, so it can't work as it is...
11:01  mamooth: I have problems thinking in the shell way, I can't help having references to object oriented programming
11:01  mamooth: I have problems thinking in the shell way, I can't help having references to object oriented programming
11:01  mamooth: and I'm tempted to think in return values ...
11:01  mamooth: and I'm tempted to think in return values ...
11:02  ik: I might get shunned for saying this in this channel, but if you end up doing something like "programming" in a shell script, you're probably better off using a programming language
11:02  ik: I might get shunned for saying this in this channel, but if you end up doing something like "programming" in a shell script, you're probably better off using a programming language
11:03 11:03  mamooth: ik, in fact, I've choosen to lead this in shell in the aim to learn shell scripting ... mamooth: ik, in fact, I've choosen to lead this in shell in the aim to learn shell scripting ...

11:03  ik: fair enough
11:03  ik: fair enough
11:04  mamooth: I could have do this in ruby of course, but I tired to be so n00b in sh
11:04  mamooth: I could have do this in ruby of course, but I tired to be so n00b in sh
11:04  mamooth: *I'm*
11:04  mamooth: *I'm*
11:05  ik: all I can think of really is to call the function normally (ie just a function call, not a subshell), and have it set an environment variable instead of echoing the result
11:05  ik: all I can think of really is to call the function normally (ie just a function call, not a subshell), and have it set an environment variable instead of echoing the result
11:05  mamooth: ok
11:05  mamooth: ok
11:05  ik: but that makes the programmer in me want to find a nice quiet spot in a forest somewhere to curl up and die
11:05  ik: but that makes the programmer in me want to find a nice quiet spot in a forest somewhere to curl up and die
11:05  mamooth: :)
11:05  mamooth: :)
11:06  mamooth: functional programing is some kind of sweet poisoning...
11:06  mamooth: functional programing is some kind of sweet poisoning...
11:06  ik: Maybe there is a better way to do it, I don't know. I'm just some jackass who wandered in here to ask an obvious question about the history mechanism
11:06  ik: Maybe there is a better way to do it, I don't know. I'm just some jackass who wandered in here to ask an obvious question about the history mechanism
11:06  mamooth: huhu :)
11:06  mamooth: huhu :)
11:06  ik: Alternatively, see if there is a way you can structure your program so you don't have to do this
11:06  ik: Alternatively, see if there is a way you can structure your program so you don't have to do this
11:06  mamooth: thank you anyway, you've been helpfull
11:06  mamooth: thank you anyway, you've been helpfull
11:07  ik: sometimes the best way to solve a problem like this is to get rid of the problem
11:07  ik: sometimes the best way to solve a problem like this is to get rid of the problem
11:07  mamooth: :) got it
11:07  mamooth: :) got it
11:07  mamooth: thanks
11:07  mamooth: thanks
11:07  ik: sure
11:07  ik: sure
11:08  CyberDomovoy: how could i delete the last char from an output?
11:08  CyberDomovoy: how could i delete the last char from an output?
11:09  TheBonsai: where is the output stored?
11:09  TheBonsai: where is the output stored?
11:10  CyberDomovoy: to be clear: "host ftp.fr.debian.org | head -n 1 | awk '{print $6}'", gives me "debian.proxad.net.", i need to get rid of the last '.' of course
11:10  CyberDomovoy: to be clear: "host ftp.fr.debian.org | head -n 1 | awk '{print $6}'", gives me "debian.proxad.net.", i need to get rid of the last '.' of course
11:11  Naib: url=$(host ftp.fr.debian.org | head -n 1 | awk '{print $6}')
11:11  Naib: url=$(host ftp.fr.debian.org | head -n 1 | awk '{print $6}')
11:11  Naib: then PE
11:11  Naib: then PE
11:11  TheBonsai: why? this is a fqdn
11:11  TheBonsai: why? this is a fqdn
11:11  hemu: sed
11:11  hemu: sed
11:11  mamooth: CyberDomovoy, echo bob. | sed 's/.$//'
11:11  mamooth: CyberDomovoy, echo bob. | sed 's/.$//'
11:11  mamooth: output bob
11:11  mamooth: output bob
11:11  Naib: TheBonsa has a point tho
11:11  Naib: TheBonsa has a point tho
11:12  CyberDomovoy: mamooth: ok, sed it is then
11:12  CyberDomovoy: mamooth: ok, sed it is then
11:13  CyberDomovoy: TheBonsai, Naib: this is in order to wget http://ftp.fr.debian.org/debian/project/trace/debian.proxad.net
11:13  CyberDomovoy: TheBonsai, Naib: this is in order to wget http://ftp.fr.debian.org/debian/project/trace/debian.proxad.net
11:13  TheBonsai: and? it is a VALID hostname
11:13  TheBonsai: and? it is a VALID hostname
11:13 11:13  TheBonsai: "debian.proxad.net." is a valid hostname TheBonsai: "debian.proxad.net." is a valid hostname

11:13  CyberDomovoy: and that should work on another mirror too, so no hardcoding it
11:13  CyberDomovoy: and that should work on another mirror too, so no hardcoding it
11:14  TheBonsai: wget http://ftp.fr.debian.org./debian/project/trace/debian.proxad.net will work
11:14  TheBonsai: wget http://ftp.fr.debian.org./debian/project/trace/debian.proxad.net will work
11:14  CyberDomovoy: TheBonsai: wget http://ftp.fr.debian.org/debian/project/trace/debian.proxad.net. won't work
11:14  CyberDomovoy: TheBonsai: wget http://ftp.fr.debian.org/debian/project/trace/debian.proxad.net. won't work
11:14  TheBonsai: aaah
11:14  TheBonsai: aaah
11:14  TheBonsai: i got it
11:14  TheBonsai: i got it
11:14  TheBonsai: it's not the hostname
11:14  TheBonsai: it's not the hostname
11:14  CyberDomovoy: :)
11:14  CyberDomovoy: :)
11:14  CyberDomovoy: so, sed then
11:14  CyberDomovoy: so, sed then
11:15  TheBonsai: host ftp.fr.debian.org | awk 'NR == 1 { gsub (".$", "", $6); print $6; }'
11:15  TheBonsai: host ftp.fr.debian.org | awk 'NR == 1 { gsub (".$", "", $6); print $6; }'
11:15  TheBonsai: if you use AWK, then use it for everything
11:15  TheBonsai: if you use AWK, then use it for everything
11:16  CyberDomovoy: TheBonsai: nice, i'm not really into awk yet, was about to do it all with sed as i know it better, but now that i know how to awk it, let's go :) thx
11:16  CyberDomovoy: TheBonsai: nice, i'm not really into awk yet, was about to do it all with sed as i know it better, but now that i know how to awk it, let's go :) thx
11:16  TheBonsai: y0
11:16  TheBonsai: y0
11:18  geirha: read -r host < <(dig +short ftp.fr.debian.org); echo "http://.../${host%.}"
11:18  geirha: read -r host < <(dig +short ftp.fr.debian.org); echo "http://.../${host%.}"
11:20  geirha: Or maybe dig +short ftp.fr.debian.org CNAME
11:20  geirha: Or maybe dig +short ftp.fr.debian.org CNAME
11:20  tuxcrafter: hi all
11:20  tuxcrafter: hi all
11:20  tuxcrafter: i want date to return the the hour before the current one
11:20  tuxcrafter: i want date to return the the hour before the current one
11:21  tuxcrafter: date +%H -1 or something
11:21  tuxcrafter: date +%H -1 or something
11:21  tuxcrafter: i can convert it to unix date en extract the seconds and convert it back
11:21  tuxcrafter: i can convert it to unix date en extract the seconds and convert it back
11:21  Fatal: gnu date can do stuff like date -d "last hour"
11:21  Fatal: gnu date can do stuff like date -d "last hour"
11:21  tuxcrafter: or take the output of date and -- the result
11:21  tuxcrafter: or take the output of date and -- the result
11:22  tuxcrafter: but i beleve there was a date trick
11:22  tuxcrafter: but i beleve there was a date trick
11:22  tuxcrafter: Fatal: thx lets see
11:22  tuxcrafter: Fatal: thx lets see
11:22  tuxcrafter: date -d "last hour" +%H
11:22  tuxcrafter: date -d "last hour" +%H
11:22  tuxcrafter: perfect
11:22  tuxcrafter: perfect
11:22  tuxcrafter: Fatal: thx
11:22  tuxcrafter: Fatal: thx
11:23  Perun_: is there a function in bash to count lines in a multiline var?
11:23  Perun_: is there a function in bash to count lines in a multiline var?
11:23  Fatal: tuxcrafter: be warned that it's GNU date specific, so if you need to deploy that script elsewhere, you might have to rethink it
11:23  Fatal: tuxcrafter: be warned that it's GNU date specific, so if you need to deploy that script elsewhere, you might have to rethink it
11:23  trash: Perun_: multiline vars are wrong by design. Use an array.
11:23  trash: Perun_: multiline vars are wrong by design. Use an array.
11:23  tuxcrafter: Fatal: it will only be used on debian and redhat based systems
11:23  tuxcrafter: Fatal: it will only be used on debian and redhat based systems
11:42 --- Weust`afk is now known as Weust`
11:42 --- Weust`afk is now known as Weust`
11:51 --- Unknown[OFF] is now known as Unknown[NF]
11:51 --- Unknown[OFF] is now known as Unknown[NF]
11:56  CyberDomovoy: when to use awk? when to use sed? are the two able to do the same stuff? if so, how would i do "sed 's/.*\([1-2]\?[0-9]\):[0-2][0-9]:.*/\1/'" with awk? should i? why?
11:56  CyberDomovoy: when to use awk? when to use sed? are the two able to do the same stuff? if so, how would i do "sed 's/.*\([1-2]\?[0-9]\):[0-2][0-9]:.*/\1/'" with awk? should i? why?
11:57  Riviera: CyberDomovoy: standard awk does not have back-references and match groups
11:57  Riviera: CyberDomovoy: standard awk does not have back-references and match groups
11:57  Riviera: CyberDomovoy: often you can work-around that, but equally often those tasks are easier to do with sed
11:57  Riviera: CyberDomovoy: often you can work-around that, but equally often those tasks are easier to do with sed
11:58  CyberDomovoy: Riviera: ok, got my answers :) thx
11:58  CyberDomovoy: Riviera: ok, got my answers :) thx
11:58  Riviera: CyberDomovoy: while sed is a complete scripting language, sed only should be used for what's easy in sed
11:58  Riviera: CyberDomovoy: while sed is a complete scripting language, sed only should be used for what's easy in sed
11:59  edgy: Hi, I want to trap the INT signal sent to ls -R command e.g so I tried: touch /tmp/traptest; trap 'rm /tmp/traptest; echo signal testing' 2. Now I expected ls -R and Ctrl+c should rm that file and echo the message
11:59  edgy: Hi, I want to trap the INT signal sent to ls -R command e.g so I tried: touch /tmp/traptest; trap 'rm /tmp/traptest; echo signal testing' 2. Now I expected ls -R and Ctrl+c should rm that file and echo the message
12:02  grid_: hey
12:02  grid_: hey
12:02  grid_: i have a html file on my hdd, i want to copy text inside this file to a new empty document from the cli, how would i do that? i want to copy a part of line 340 and 341 to the empty text file
12:02  grid_: i have a html file on my hdd, i want to copy text inside this file to a new empty document from the cli, how would i do that? i want to copy a part of line 340 and 341 to the empty text file
12:03  grid_: this text will usually change inside the html file, but the location will remain the same on the html file
12:03  grid_: this text will usually change inside the html file, but the location will remain the same on the html file
12:04  grid_: i could start with the full line, and then i could strip the other parts that will not change
12:04  grid_: i could start with the full line, and then i could strip the other parts that will not change
12:04  grid_: but maybe i could do it more quick
12:04  grid_: but maybe i could do it more quick
12:15  pgas: grid_: well, to get the line 340 and 341 is easy with sed or awk or perl..
12:15  pgas: grid_: well, to get the line 340 and 341 is easy with sed or awk or perl..
12:16  pgas: which is best depends on what you mean by "part of the line"
12:16  pgas: which is best depends on what you mean by "part of the line"
12:17  grid_: i want to get from line 340 <td class="name">*</td>
12:17  grid_: i want to get from line 340 <td class="name">*</td>
12:17  grid_: so * could be anything
12:17  grid_: so * could be anything
12:20  pgas: only one <td> on line 340?
12:20  pgas: only one <td> on line 340?
12:21  grid_: thats all there
12:21  grid_: thats all there
12:21  pgas: awk -F'</?td[^>]*>' 'NR==340{print $2}'
12:21  pgas: awk -F'</?td[^>]*>' 'NR==340{print $2}'
12:22  pgas: awk -F'</?td[^>]*>' 'NR==340{print $2}' file > newfile
12:22  pgas: awk -F'</?td[^>]*>' 'NR==340{print $2}' file > newfile
12:23  grid_: thnx, i will use it
12:23  grid_: thnx, i will use it
12:23  edgy: Hi, can I trap signals passed to commands invoked from my shell?
12:23  edgy: Hi, can I trap signals passed to commands invoked from my shell?
12:25 --- Skaag_ is now known as Skaag
12:25 --- Skaag_ is now known as Skaag
12:25  pgas: if you ignore a signal, the commands will ignore too.
12:25  pgas: if you ignore a signal, the commands will ignore too.
12:26  pgas: is it enough?
12:26  pgas: is it enough?
12:29  edgy: pgas: no, I want to trap INT e.g
12:29  edgy: pgas: no, I want to trap INT e.g
12:29  pgas: and do what? execute something and leave the command running?
12:29  pgas: and do what? execute something and leave the command running?
12:30  edgy: pgas: trap 'rm /tmp/test; echo removing test file' 2
12:30  edgy: pgas: trap 'rm /tmp/test; echo removing test file' 2
12:31  edgy: pgas: e.g when i use Ctrl-C after ls -R I want it to trap 'rm /tmp/test; echo removing test file; exit' 2
12:31  edgy: pgas: e.g when i use Ctrl-C after ls -R I want it to trap 'rm /tmp/test; echo removing test file; exit' 2
12:31  grid_: pgas: yeah, exactly the answer to my question, it works
12:31  grid_: pgas: yeah, exactly the answer to my question, it works
12:35  grid_: pgas: how would i copy the output to the new text file to line 1 after the first ; or the second etc? because i make a .csv file
12:35  grid_: pgas: how would i copy the output to the new text file to line 1 after the first ; or the second etc? because i make a .csv file
12:37  edgy: pgas: is my question clear?
12:37  edgy: pgas: is my question clear?
12:41  geirha: edgy: Makes more sense to make an EXIT trap for removing temporary files
12:41  geirha: edgy: Makes more sense to make an EXIT trap for removing temporary files
12:42  edgy: geirha: my point is not removing temp files, my point is can I trap INT signal sent to ls -r command?
12:42  edgy: geirha: my point is not removing temp files, my point is can I trap INT signal sent to ls -r command?
12:43  edgy: -R
12:43  edgy: -R
12:44  geirha: No, only signals sent to the shell
12:44  geirha: No, only signals sent to the shell
12:50  pgas: edgy: you can cause the command to ignore the signal, you can find out with what signal a command has been killed with, but you cannot install a signal handler for the command
12:50  pgas: edgy: you can cause the command to ignore the signal, you can find out with what signal a command has been killed with, but you cannot install a signal handler for the command
12:50  pgas: greybot:  >>file
12:50  pgas: greybot:  >>file
12:50  pgas: err grid_ ^^
12:50  pgas: err grid_ ^^
12:52  geirha: trap 'echo trap' INT; command & while ! wait; do :;done
12:52  geirha: trap 'echo trap' INT; command & while ! wait; do :;done
--- Log opened Fri Dec 10 13:05:28 2010
13:05 --- Users 523 nicks [0 ops, 0 halfops, 0 voices, 523 normal]
13:06  edgy: what's the man option to display all man pages of a command, e.g all man passwd?
13:06 --- Channel #bash was synced in 83 seconds
13:07  snappy: maybe: man -k passwd
13:08  snappy: ah, actually: man -f passwd
13:11  hexer: What :;; means?
13:11  grid_: pgas: you can still help?
13:11  grid_: thnx again
13:14  geirha: edgy: man -a passwd;  Though you're probably after  man 5 passwd
13:15  CyberDomovoy: when i "cat > file << EOF blabla on multiple lines EOF", do i have to test $?, or can i do like "some_command || action_on_error"? What's the syntax?
13:15  Bushmills: || tests $?
13:16  hexer: CyberDomovoy: Why? It doesn't work?
13:17  pgas: grid_: awk -F'</?td[^>]*>' 'NR==340{printf "%s", $2 >> "output.txt"}' index.html
13:17  pgas: CyberDomovoy: but everything on the line with cat
13:17  geirha: if ! cat > file << EOF <multiple lines> EOF <newline> then ...; fi
13:17  pgas: s/but/put
13:18  pgas: hexer: in a case, in bash4 it might be a fallthrough case...though I'm not completely sure about that
13:19  CyberDomovoy: pgas: thx
13:20  geirha: The "fallthrough" syntax is ;&
13:21  pgas: oh right,  it's just a dummy case that execute the command :  which does nothing
13:23  hexer: pgas: Fallthrough case? What you mean?
13:26  hexer: pgas: just returning 0? but why they are two semicolons, instead of one?
13:26  CyberDomovoy: if i don't use exit or return, the exit code of a script is the one of the last command, right?
13:26  hexer: pgas: I'll give you whole expression.
13:27  hexer: pgas: case $? in 0) :;; *) (exit "$?");; esac
13:28  hexer: pgas: I think I get it. ^^
13:29  hexer: pgas: it checks returning value and if is 0 it do nothing except returning 0 if there is something else returning something else?
13:30  geirha: Heh, that's a convoluted way of doing  command || exit
13:30  geirha: Oh wait, no a subshell
13:30  geirha: It's actually completely useless
13:31  hexer: geirha: It's in cross compilation script.
13:31  geirha: Still useless
13:32  hexer: hmm, Thomas Tschwinge wrote that. ^^
13:32  hexer: *Schwinge
13:32  pgas: well it's still does nothing except waisting some time
13:33  hexer: geirha: Actualy he borowed code from prjlibs.
13:33  hexer: pgas: I don't know why that's over there.
13:33  pgas: ah no!
13:33  pgas: hmm, no pointless
13:34  poisonbit: is like a return(less)  ?
13:34  poisonbit: over_returning
13:34  geirha: Over returning, yeah, you coined it there :)
13:34  pgas: # false;case $? in 0) :;; *) (exit "$?");; esac;echo $?
13:34  evalbot: pgas: 1
13:35  pgas: # true;case $? in 0) :;; *) (exit "$?");; esac;echo $?
13:35  evalbot: pgas: 0
13:35  pgas: yup nothing
13:35  geirha: # false; echo $?
13:35  evalbot: geirha: 1
13:35  geirha: # true; echo $?
13:35  evalbot: geirha: 0
13:35  geirha: Same result :)
13:36  pgas: maybe there was some more code in the first part before...
13:36  geirha: Yeah, that : must've been something else at some point
13:37  pgas: but then it would have been prettier to do: if ! command;then blah;fi
13:37  hexer: # prj_set() { eval "$1=\${2?} }
13:37  evalbot: hexer: Missing terminating quote, bracket or keyword
13:39  CyberDomovoy: nice bot :)
13:41  hexer: pgas: http://pastebin.com/m0Y1G5Tg
13:42  hexer: pgas: There's entire script.
13:43  pgas: hexer: ...it still does nothing
13:44  hexer: pgas: So the question is, why it's over there if it does nothing.
13:45  pgas: sometimes it's explained on this site: http://thedailywtf.com/
13:46  hexer: pgas: haha, nice name for the site. It's so self explantatory. ^^
13:47  hexer: Maybe I'll ask someone on #hurd
13:48  edgy_: snappy: exactly this is what I am after
13:48  edgy_: ls -R / & > output still output to screen, why?!
13:49  pgas: & > and &> are different
13:49  edgy_: pgas: which one should I use?
13:49  pgas: ls -R & execute the command in the background
13:50  pgas: > output redirect the output
13:50  pgas: &>output redirect both stdout and stderr
13:51  edgy_: ppgI want to redirect only output but run the cmd in bg
13:51  edgy_: pgas: ^
13:51  pgas: put the & at the end
13:51  edgy_: pgas: so why cmd & > output doesn't redirect ouput only?
13:51  pgas: because >output is for the next command
13:52  edgy_: pgas: aha!
13:52  pgas: (>output is a special bash trick that truncate the file without any command)
13:54  edgy_: pgas: yes, it's clear now. thanks a lot
13:55  tydeas: I have a loop like for file in "$@" how can i change this loop to have from $3 to the end of the params?
13:56  pgas: you can use shift 2 before the loop, or in bash "${@:3}"
13:57  tydeas: thanks a lot
13:58 --- emma is now known as em
14:02  csabo: morn
14:02  tydeas: morn
14:03  flashingpumpkin: hey guys. quicky question, what's the reason for this failing? http://dpaste.org/mxK4/
14:04  flashingpumpkin: i'm just trying simple string comparison :(
14:04  erUSUL: !ls
14:04  poisonbit: !quotes
14:05  erUSUL: flashingpumpkin: no enough spaces ... [ a = b ]
14:05  poisonbit: and spaces
14:05  erUSUL: the bot is gone ... :(
14:05  flashingpumpkin: oh. duh... thanks :)
14:05  greybot: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
14:05  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
14:19  grid_: pgas: yeah, this works, pgas: awk -F'</?td[^>]*>' 'NR==340{printf "%s", $2 >> "output.txt"}' index.html this works, how would you set a ; at the end of the output with this same command?
14:20  pgas: "%s;"
14:20  grid_: :)
14:20  grid_: whow fast :)
14:20  grid_: thnx
14:28  Perun_: I have a multiline var: MESSAGES=`/bin/cat /tmp/$SELF/$FILE.old /tmp/$SELF/$FILE | /bin/sort | /usr/bin/uniq -c | /bin/grep -F "1 "` and I want to read this data into an array... how can I do it?
14:29  dowxp: stupid question: what is the best way to extract link.php? <a href="link.php">
14:31  pgas: !faq 1 > Perun_
14:32  greybot: Perun_: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
14:34  fruight: how can i rename subdirectories in a s/foo/bar/ manner? ie. i want to replace certain patterns
14:35  csabo: im looking for some docs/info on how i would create a loop that would allow me to run commands against elements in an array
14:35  csabo: i've never done this before, in any language, and having a hard time coming up with the logic
14:36  csabo: if that makes sense :-\
14:37  csabo: i've got 2 arrays that i made from 2 columns in a doc.. i need to go down through the arrays doing "cmd $array1[1] $array2[1]" and continue down until the entire array has been done
14:43  Perun_: pgas: this site is offline :(
14:43  Perun_: why does this not work?: http://paste.debian.net/102048/
14:43  pgas: < needs a file name
14:43 --- Unknown[NF] is now known as Unknown[OFF]
14:44  Perun_: aaha
14:44  pgas: done < <(grep ....)
14:44 --- Unknown[OFF] is now known as Unknown[NF]
14:45  mamooth: How could I retrieve the last called command from within a function? Is it possible?
14:45  mattcen: So I'm trying to find the bit of documentation that says "colon is the null command, equivalent to true", but can't see it in the manpage. Anybody know where it is?
14:45  geirha: mamooth: What do you mean by retrieve?
14:46  mar77i: !faq 5 > csabo
14:46  greybot: csabo: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
14:47  mar77i: # a=(1 2 3) b=(4 5 6); for (( i=0; i<${#a}; i++ )); do echo hello "${a[i]} ${b[i]}"; done
14:47  evalbot: mar77i: hello 1 4
14:47  geirha: mattcen: http://www.opengroup.org/onlinepubs/7990989775/xcu/true.html
14:47  mamooth: I've made a checking errors function, wich check a given status code. If the status code is not 0, I'd want to log a message, informaing which command as returned which status code. By command, I mean either a binary or a function
14:47  pgas: mattcen: in man bash or help :
14:47  pgas: # help :
14:47  evalbot: pgas: :: :
14:47  evalbot: pgas:     No effect; the command does nothing.  A zero exit code is returned.
14:47  mar77i: this would run through all elements :) --- # a=(1 2 3) b=(4 5 6); for (( i=0; i<${#a[@]}; i++ )); do echo hello "${a[i]} ${b[i]}"; done
14:48  geirha: command || echo "command failed with exit code $?" >> logfile
14:48  csabo: :o
14:48  pgas: mamooth: maybe look for the DEBUG trap in man bash
14:48  mamooth: geirha, that's pretty much what the actual function does, but I would like to have it returning the command name
14:48  mar77i: umm I'd go for command 2>>logfile || echo "failed w/ ec $?" >> logfile ...
14:49  csabo: mar77i:  would that work if the number of elements is unknown?
14:49  csabo: mar77i: the length of each will be random
14:49  mar77i: csabo: well, make sure that b is at least as long as a.
14:49  mar77i: csabo: if b is longer, what do you do with the rest?
14:50  csabo: mar77i:  they will always be the same length
14:50  csabo: or, same number of elements if arr1 is 23 so is arr2
14:51  mar77i: csabo: look at this: will it work? for (( i=0; i<${#a[@]}; i++ ))
14:51  geirha: mamooth: No can do.
14:51  mar77i: csabo: see the faq 5 link I gave you
14:51  mamooth: Ok, thanks
14:52  pgas: maybe with a wrapper function: log command
14:54  geirha: Ah, yeah. log() { "$@" || echo "$1 failed with exit status $?" >> logfile; }
14:58  dowxp: stupid question: can i do something like: for i in wc -l filename ?
14:58  koala_man: what's it supposed to do?
14:58  dowxp: well i want it to run based on the # of linesi n the file
14:59  dowxp: wc -l filename | cut -d " " -f 1
14:59  dowxp: probably a retarded way of doing it, but i'm just starting out
14:59  dowxp: i'm trying to get that value into the for loop as the limiter
14:59  koala_man: !for
14:59  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
14:59  pgas: for loop? delimiter?
15:00  koala_man: sounds like you want the numeric range loop
15:00  pgas: are you trying to read a file line by line?
15:03  dowxp: sorry, yes i am
15:03  dowxp: let me read your responses first
15:04  dowxp: what i want to do, in psuedo code, is
15:04  dowxp: for (i = 0; i < lines in file; i++)
15:04  dowxp: 	echo $i;
15:06  poisonbit: while read -r l; do ((lines++)); done < .bashrc ; echo $lines
15:07  dowxp: hm
15:09  poisonbit: dowxp, or if you dont like that syntax/implementation, maybe:  lines="$(wc -l .bashrc | cut -d' ' -f1)"
15:10  mar77i: !faq 1 > dowxp
15:10  greybot: dowxp: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
15:11  dowxp: man bash really is just another monster. thanks, i'll read it all up
15:13  fruight: how could i rename all subdirectories so that spaces get replaced by _ ?
15:13  poisonbit: using rename
15:15  dowxp: uhm, what does this do?     done < "$file"
15:15  Fatal: passes the contents of file line by line to the loop
15:15  poisonbit: a redirection
15:15  dowxp: i'm used to >, not < hmm
15:15  dowxp: okay
15:15  fruight: poisonbit: ok thx, didnt know that command yet... would "rename ' ' '_' *" be correct?
15:17  fruight: ok obviously not, that doesnt work, tried it.
15:18  poisonbit: rename -v "s/ /_/" *
15:18  poisonbit: then remove -v
15:18 * mar77i puts a pipe '|' into dowxp's bedroom
15:19  poisonbit: errr  "s/ /_/g"
15:19  geirha: y/ /_/
15:19  fruight: poisonbit: what does the -v do? its not in the man page
15:19  dowxp: do ((lines++)) , why two (( ?
15:19  poisonbit: print what it does (verbose)
15:19  fruight: ok thx
15:19  nicofs: How can i check if a file exists? "if [[ /folder/file exists ]]; then ..."
15:20  poisonbit: -e
15:20  geirha: fruight: If -v isn't in the man-page, then you don't have perl rename and that rename command won't work.
15:20  poisonbit: help test when in doubt
15:21  geirha: dowxp: Because that's the syntax
15:21  dowxp: hmm
15:21  dowxp: i understand
15:21  dowxp: (sort of)
15:21  geirha: single parenthesis is used for subshell
15:21  fruight: geirha: thanks, i was already wondering what i was doing wrong :P
15:22  fruight: are there other ways to accomplish the same?
15:22  geirha: for file in *\ *; do mv "$file" "${file// /_}"; done
15:22  geirha: for file in ./*\ *; do mv "$file" "${file// /_}"; done
15:22  geirha: !faq rename > fruight
15:22  greybot: fruight: http://mywiki.wooledge.org/BashFAQ/030 -- How can I rename all my *.foo files to *.bar, or convert spaces to underscores, or convert upper-case file names to lower case?
15:23  fruight: geirha: thanks, i'll read through that :)
15:24  mar77i: dowxp: [[ is for strings, (( is for arithmetic stuff and :) is for everyone with an open parenthes in his heart '(' ;)
15:26  mar77i: dowxp: more specifically, [[ ]] also does file tests better in bash.
15:27  greycat: Not really better at doing tests... it just suppresses word-splitting, which means you can omit some quotes.
15:27  mar77i: ...and how does that qualify for "not better"?
15:28  greycat: It doesn't perform the tests faster.  It doesn't have any more powerful tests.
15:30  fruight: geirha: could you please explain why you added the './' ?
15:30  greycat: In case a file name starts with -
15:30  geirha: fruight: In case one of the files start with a -
15:31  geirha: mv would thing it was options
15:31  geirha: *think
15:31  fruight: ah ok, so if i use 'mv -- ...' its not necessary, right?
15:31  greycat: correct
15:32  fruight: i love it how i can actually feel my brain learn new stuff all the time since i use linux :D
15:39  nicofs: how can i download a file from a server and copy it to a folder?
15:40  Fatal: with a program that can download from that kind of server
15:40  greycat: fruight: I can actually feel my brain cells die every time a question like nicofs's is asked.
15:40  Fatal: popular alternatives are scp, wget, curl, lftp, firefox, chrome
15:40  Riviera: nicofs: That is not really a bash question. Maybe #wget or a channel related to the operating system you use can help.
15:40  greycat: If it's NFS-mounted, you could also use cp.
15:40  Fatal: or cat
15:40  nicofs: i want a shell script i just write to fetch the conf file from my server...
15:41  Fatal: nicofs: I suggest you use one that works with your server
15:41  greycat: nicofs: define "server".
15:41  Fatal: he's going to say fileserver and still not specify what protocol he'd like to use
15:42  nicofs: standart issue http or ftp server with... the file would be "http://www.myserver.de/folder/config.conf"
15:42  greycat: nicofs: HTTP, then.  Try wget, curl, etc.
15:42  Fatal: nicofs: wget, curl are popular alternatives
15:47  admin0: hi guys .. if i have a string such as  a,b,c,d,e,f,g,h,i  .. how do I count the total number of , in the string ?
15:47  greycat: tmp=${string//[^,]/}; echo ${#tmp}
15:48  admin0: greycat: string is the variable?
15:48  admin0: which one is the variable ?
15:49 * greycat reminds himself that there is typically a jail penalty for stabbing people in the eyeballs
15:49  admin0: ABC="a,b,c,d,e,f,g" ; tmp=${ABC//[^,]/} ; echo ${#tmp}  ; GOT IT
15:49  admin0: thanks
15:58  paissad: !redirect
15:58  greybot: Redirections: http://bash-hackers.org/wiki/doku.php/syntax/redirection http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection http://bash-hackers.org/wiki/doku.php/howto/redirection_tutorial
16:01  fruight: what is this ${} magic called, so i can read more about it? :P
16:01  texasmynsted1: speaking of redirection... I have seen <<< used but never documented.
16:01  Fatal: !pe > fruight
16:01  greybot: fruight: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
16:02  fruight: thanks a lot :)
16:03  jk4: Hi
16:03  jk4: A script I'm reading has lines starting with :
16:03  jk4: like
16:03  jk4: : file_tmp
16:03  jk4: what does it do?
16:04  greycat: That line does nothing.
16:04 --- maxim is now known as Guest61043
16:04  greycat: Are you sure you didn't misrepresent it?
16:07  jk4: he must be using it as a kind of comment
16:07  jk4: I'll pastie it for you
16:10  jk4: greycat: here's a part of EasyBashGui script: http://pastebin.com/By1Usp66
16:11  greycat: Your guess is as good as mine why it was written that way.
16:11 --- Unknown[NF] is now known as Unknown[OFF]
16:12  jk4: Is `:' an alias for `true'
16:12  jk4: I can't find in in the info page
16:13  greycat: yes, it is
16:13  greycat: ''help :''
16:13  jk4: lol `No effect; the command does nothing.'
16:13  Eiler: how can i do: if arguments == 0 then do something else if arguments == 1 do something?
16:13  rapid: !faq easily > eiler
16:13  greybot: eiler: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
16:14  greycat: Eiler: if (($# == 0)); then ...
16:14  greycat: Eiler: or you could use case.
16:14  pgas: jk4: in prehistoric times, before bourne, you could not use # to comment the script, but you could abuse :. maybe the author is nostalgic? (check v6shell.org)
16:14  Eiler: and then, can i get my current directory somehow?
16:15  geirha: It's in the PWD variable
16:15 --- Vorpal_ is now known as Vorpal
16:15  Eiler: ok
16:15  geirha: # echo "$PWD"
16:15  evalbot: geirha: /root
16:16  greycat: pgas: my guess is he wanted two types of comments, so one would "stand out".
16:17  greycat: One should understand that : is NOT identical in function to #, though.  In particular, side effects of substitutions still occur.
16:17  greycat: A la the classic   : ${var:=default}
16:22  geirha: : $dir_tmp   would've made some remote sense if used with set -u
16:22  pgas: greycat: ah perhaps if he uses # also, I haven't checked the pastebin
16:22  greycat: he does, yes
16:25  geirha: Oh, it doesn't appear to be the whole script. He might have a : function defined somewhere, maybe some sort of logging function.
16:25  greycat: Oh GODS... that would be truly, truly evil.
16:26  geirha: :D
16:30  Eiler: how can i check if a directory exists?
16:30  greycat: ''help test'', you want -e and/or -d
16:30  Eiler: are there any example of those?
16:31  greycat: Approximately 12 billion.
16:31  csabo: Eiler: if [ -d <DIR>  ]
16:31  Eiler: csabo ah
16:31  csabo: Eiler: if [ -f <FILE> ] (regular file)
16:32  csabo: Eiler: and -e for a file, that is not a regular file
16:32  Eiler: what do you mean with a regular file?
16:32  greycat: HOLY SHIT *PLONK*
16:32  Eiler: "regular"?
16:32  csabo: Eiler:  he just put you ignore
16:32  ASGR: or if [ ! -d <DIR>  ] to check if it dosn't exist
16:32  csabo: haha
16:32  greycat: There, now BOTH halves of that conversation are silent.  Bliss.
16:32  csabo: hes like 12 years old, dont worry about it
16:33  csabo: ASGR: 's way will work too
16:33  Eiler: yes i've already notices that before
16:33  ASGR: depends how you want the logic to work
16:33  csabo: its freenode, you get childish antisocial types
16:33  csabo: Eiler:  what are you trying to do?
16:34  saml: how do you test if user passed "$2"  ?
16:34  greycat: if (($# >= 2))
16:34  saml: i see. i wasn't sure if that was correct way
16:34  Eiler: csabo im creating a script to automate the creation of symfony projects
16:35  ASGR: i use the if [ -z "STR" ] format
16:36  Eiler: can i break out or exit a bash script somehow?
16:36  greycat: ASGR: that "fails" if it's legitimate to pass an empty argument
16:36  ASGR: ahhh]
16:36  greycat: (Not that most scripts accept empty arguments.)
16:37  ASGR: badly planned scripts ;-)
16:37  ASGR: include the keyword 'exit' to exit a script
16:37  Eiler: badly planned?
16:38  Perun_: it is possible to do this: http://paste.debian.net/102053/ with case/esac?
16:38  csabo: Eiler:  id ont know what symfony is, aside from probobly spelled wrong
16:38  Eiler: csabo aha it is a php framework
16:38  csabo: explain what you need from a logic standpoint
16:38  ASGR: got to get the relevant information into scripts and use function to avoid bloat
16:39  csabo: !faq sorting
16:39  greybot: csabo: No matches found at http://mywiki.wooledge.org/BashFAQ
16:40  Perun_: I think about something like case in case...
16:40  saml: with curl, can I upload  a file using heredoc?  should I create a file first with heredoc?
16:40  greycat: A here doc is just stdin.  If curl can "upload" the contents it reads from stdin, then yes.
16:41  saml: greycat, ah thanks. /me reads up man curl
16:41  vinnova: Is it possible to declare a number of variables in one go with   export   instead of putting export A=B  on every line, i.e.   export << "     " or similar, a block?
16:41  greycat: export foo=bar baz=quux
16:42  greycat: One might ask WHY you are exporting so many variables to the environment.
16:43  Eiler: how can get the name of the subdirectory of a directory? like: if PWD is /home/<user>/x i just want x?
16:44  poisonbit: # var='/home/<user>/x'; echo ${var##*/}
16:44  evalbot: poisonbit: x
16:45  Eiler: or CWD might work?
16:47  poisonbit: # mkdir d; cd d; echo "$PWD => ${PWD##*/}"
16:47  evalbot: poisonbit: /root/d => d
16:48  Eiler: http://paste.pocoo.org/?reply_to=303166 does something like this look okay?
16:48  TheBonsai: and "hes like 12 years old" is what? a serious statement? heh
16:48  TheBonsai: why do all think this is ##linux?
16:49  greycat: You know the answer to that one, TheBonsai.
16:49  greycat: (1) we actually KNOW stuff, and (2) they think anything that involves text on a terminal-like interface is "bash", even though most of it is not.
16:51  vinnova: greycat, yes but over more than one line?
16:51  greycat: You can use \ to continue a command on the next line.
16:52  vinnova: aha, not possible to use curly braces for a block or list?
16:52  greycat: Braces allow you to make multiple commands work in place of one command.  What would be the POINT of it?
16:52  greycat: You already only have one export command.
16:52 --- pixie__ is now known as tinker
16:53  vinnova: to avoid adding \ everywhere and instread pass a string with linebreaks in it, to export
16:53  vinnova: e.g. export -f < $string
16:53  greycat: what in the FUCKING HELL are you trying to do?!
16:53  vinnova: oops, echo $string
16:53  vinnova: :-) simplify
16:53  greycat: LIAR!
16:54  vinnova: i have a huge number of assignment of ANSI COLOR NAMES
16:54  vinnova: sorry accidental upper case
16:54  vinnova: I suppose there is no way to do it better .
16:54  greycat: *sigh*
16:54  greycat: Nothing like mind-reading on a Friday morning.
16:54  greycat: Are they in a FILE?
16:55  vinnova: They could well be!
16:55  vinnova: Good idea!
16:55  greycat: Jeeeeeesuss....
16:56  vinnova: I thought the << command was used sometimes or similar?
16:56  vinnova: (Trying to learn something while doijng this!)
16:56  greycat: If you would actually STATE what you are attempting to do, we might be able to assist.
17:00  TheBonsai: greycat: i guess i know it, yea
17:09  Perun_: whats the difference between echo $foo and echo ${foo} ?
17:09  greycat: They're both wrong.  Use echo "$foo" instead.
17:10  Perun_: aha
17:11  Perun_: and waht about echo "$foo" and echo "${foo}"?
17:11  greycat: No difference in that case.  You need to consider something like "${foo}x" to see the difference.
17:12  Perun_: greycat: I have something like echo "blabup $foo blabla" is there still no diff to echo "blabup ${foo} blabla"?
17:13  greycat: correct
17:13  Perun_: aha
17:13  ket: nvm, silly statement..
17:19  csabo: file with 3 txt columns, single space delimiter, 3rd column is integers.. i want to sort by the 3rd column
17:19  krisfremen: csabo: use awk
17:19  csabo: i was looking at sort, i dont think it would work right
17:20  tvm: csabo: cat file | cut -d" " -f3 | sort
17:20  tvm: oh, hmm.
17:20  csabo: tvm: what does that do mate?
17:20  tvm: yes, you will have to use awk.
17:20  csabo: W00084L4 TAPEPOOL 15.1
17:21  csabo: thats an exact line out of the file, i've already used sed to remove all unneeded data
17:28  Eiler: http://paste.pocoo.org/?reply_to=303166 i get DIRECTORY: command not found (line 3) and syntax error $DIRECTORY=($PWD) on line 6, why?
17:28  csabo: nevermind mine
17:28  Bushmills: csabo: check out the -k parameter of sort
17:28  csabo: i used ORDER BY in my inital SQL query :)
17:29  csabo: it was alot easier that way
17:29  Bushmills: and -n, for numeric sort
17:29  csabo: i will check it out, i will need it in the future when theres no SQL  :)
17:29  csabo: ty mate
17:31  Bushmills: for example, sort password file according user id (3rd column too, numeric, delimited by :)  :  sort -n -k3 -t: /etc/passwd
17:32  greycat: -k3,3
17:32  Bushmills: asumption that no uid is used twice
17:36  jetole: Hey guys. Does anyone know if there is a command, proc file, or a quick method I can find out either what mount a file is on or what block device a file is on? Thanks in advance.
17:36  Bushmills: that's OS specific
17:36  greycat: df /pathname
17:36  jetole: ah
17:36 --- Mike1_ is now known as Mike1
17:37  jetole: Bushmills: Linux in my case. Let me take a look at what greycat recommended
17:38  jetole: greycat: that works well. Thank you.
18:03  jetole: greycat: do you know any other ways I can also find either the mount point or the block device?
18:04  greycat: fuser, lsof, fstat, etc.
18:04  nicofs: how do i generate random characters?
18:05  greycat: For what purpose?
18:05  greycat: If you want passwords, use pwgen.
18:05  nicofs: nope... i want to print (echo) random characters...
18:05  Eiler: how can i append some text to a file?
18:06  greycat: Why?  What characters?  How many?  How often?  Where?
18:06  greycat: Give us fucking SOMETHING to work with!
18:06  pigdude: haha
18:08  nicofs: i want to read the width in characters of my console and fill it with random characters (0-9, a-z, ...)...
18:09  nicofs: basically a command to generate a random char would be enough. the rest is loop...
18:09  jetole: greycat: I know I can print an ascii char based on it's hex using: echo $'\x41'
18:09  jetole: greycat: do you know if I can do that in decimal somehow?
18:10  Bushmills: # char=({a..z}); echo "${char[RANDOM%26]}"
18:10  evalbot: Bushmills: u
18:10  Zathraz: Is the following correct: exec 3>/tmp/out.txt ; echo "some stuff"; echo "some more stuff"; exec 3?&- ---? all output is send to /tmp/out.txt
18:10  greycat: nicofs: x=""; while ((${#x} < $COLUMNS)); do x+=$(openssl sha1 <<< $RANDOM); done; echo "${x:0:COLUMNS}"
18:11  Zathraz: *--->
18:11  greycat: Zathraz: you forgot to use >&3 on the echo commands.  And your close syntax is fucked.
18:12  greycat: nicofs: or did you need the output to range over 0-9a-z?  If so, you can check the openssl man page and choose some other output.
18:13  greycat: nicofs: or you could write your own damned programs.
18:13  Zathraz: ah. ok. Basically what I want is to write a script with on some line "command that forces all further stdio to go to a certain file" "have lines that produce output" "have a line which restores stdio to go to screen as normal"
18:13  greycat: Zathraz: then you should be using exec >foo not exec 3>foo
18:13  greycat: !logging
18:13  greybot: faq75
18:14  greycat: !faq 75
18:14  greybot: http://mywiki.wooledge.org/BashFAQ/075 -- How do I use 'find'?  I can't understand the man page at all!
18:14  greycat: what the fuck...
18:14  Zathraz: without the need that of issuing a redirect on all lines generating output
18:14  greycat: Zathraz: USE WHAT YOU WERE TOLD
18:14  greycat: Jesus.
18:15  Zathraz: I followed the "closing the files descriptors". Hence the syntax
18:15  Zathraz: ok. ty
18:15  Zathraz: in: http://wiki.bash-hackers.org/howto/redirection_tutorial
18:15  greycat: I can't search a bot and a FAQ and answer all these fucking quesitons!
18:15  greycat: Can't SOME of you demonstrate a MINUSCULE amount of intelligence?
18:16  greycat: Hmm, FAQ 106 is CLOSE to what he wants, except it's too *advanced*.  It *assumes* the basic knowledge he's seeking and then goes on to the harder stuff that it's actually answering.
18:16 --- Unknown[OFF] is now known as Unknown[NF]
18:16  greycat: !forget logging
18:16  greybot: OK, greycat
18:17  greycat: !learn logging To log all of the script's subsequent stdout and stderr in a file: exec >mylogfile 2>&1
18:17  greybot: OK, greycat
18:31 --- jzacsh is now known as jzacsh_
18:32  admin0: hi .. open(MYINPUTFILE, "</root/cpu.csv");  ..  that file is what is created when we give the command   grep * > /root/cpu.csv  .. how do I get the contet directly without creating the file
18:33  admin0: open(MYINPUTFILE, ` cmd ` ) ;  would work ?
18:33  greycat: Looks like perl.
18:33  alek{xmb}{bottz}: sup
18:33  alek{xmb}{bottz}:    era
18:33  alek{xmb}{bottz}: admin
18:33  alek{xmb}{bottz}: <inputf kmd
18:33  alek{xmb}{bottz}: btw im way beter nowadays
18:34  admin0: i have  a sh file that does    cd /some/directory ; grep $someting * > filename  ..  that filename is passed to perl script
18:35  greycat: and...?
18:35  admin0: i want to skip bash altogether and file creation also
18:35  greycat: Then ask #perl.
18:35  admin0: oh
18:35  admin0: sorry
18:35  admin0: i thought it was perl :D
18:35  admin0: sorry
18:35  alek{xmb}{bottz}: hum
18:39  ss0: Hello greycat
18:40  ss0: No questions just saying hi.
18:58  consumerism: i'm using $() inside a command issued via ssh, like ssh me@server "ls $(junk)" but the $(junk) is being executed on my local machine and not the remote host...how can i fix that?
18:59  consumerism: this is in a bash script if it matters
19:00  tuxdev_: It's not a good idea to do fancy stuff when executing things remotely
19:03  gallon: consumerism: if you really wanted to do it, try single quotes
19:05 --- Unknown[NF] is now known as Unknown[OFF]
19:11 --- Unknown[OFF] is now known as Unknown[NF]
19:12  lupinstein: yitz_: thanks, for the link last night.
19:12  yitz_: My pleasure?
19:13  csabo: any ideas why this is outputting the proper value, then the filepath to which the file resides? : mvlines=$(wc -l $mvlog)
19:14  yitz_: Because that's how wc is expected to behvare?
19:14  yitz_: *behave
19:14  csabo: oh, makes sense then
19:14  yitz_: read lines _ <<<$(wc -l "$mvlog")
19:15  csabo: whats with the underline
19:16  yitz_: It's a placeholder for "no var" for the "extra" output
19:17  csabo: ah
19:17  taylanub: $_ normally holds the last argument to the previous command. it's dynamically changed, so modifying it has no effect
19:17  greycat: It's easier just to use lines=$(wc -l < "$mylog")
19:17  greycat: Note the '<'.
19:18  yitz_: Oh. No "-" like md5sum uses
19:25  lex: Say guys, I want to do a bash script that appends a crontab line... any "safer" way you guys know off? Ive a gazillion boxes to update
19:26  greycat: crontab -l > foo && echo whatever >> foo && crontab foo
19:26  greycat: && rm foo
19:28  lex: greycat: thank you mighty greycat
19:29  The-Compiler: (crontab -l; echo whatever) | crontab
19:29  The-Compiler: why not like that?
19:29  greycat: Dangerous.  What if the left hand side fails for some reason?
19:30  The-Compiler: I don't see why it would, but yeah.
19:33  Offlein: Any ideas why a bash script I wrote, with an IF statement, would return "FALSE" when I run it manually, but "TRUE" when cron runs it?
19:34  yitz_: Different environment
19:34  tsaavik: Offlein: diffrent env variables. Perhaps a path issue?
19:34  yitz_: Different shell
19:34  greycat: The most obvious answer would be "your if statment is if [ -t 0 ]"
19:35  greycat: Or, with ! in it.  Whichever.
19:35  Offlein: Hrm, I did change the commands to use exact paths. It's a relatively simple statement, may I paste here?
19:35  Offlein: Yes! It does use a !
19:35  greycat: *sigh*
19:35  Offlein: if ! /bin/ps ax | /usr/bin/grep -v grep | /usr/bin/grep bot_start > /dev/null
19:35  complete: Hello! I used CTRL
19:35  complete: ups..
19:35  yitz_: !pm > complete
19:35  greybot: complete: http://mywiki.wooledge.org/ProcessManagement
19:35  yitz_: Erm. Offlein ^^
19:35  csabo: I'm running an app in a script, and I found the command will only run if i have it in double quotes.. however, I now need to provide variables within that command, can i put them in single quotes to make it work? I can _NOT_ test this, its a movedata command on our backup system
19:36  complete: Hello! I used CTRL+Z and then fg for the first time. nice. what does CTRL+Z do?
19:36  Offlein: yitz_ I'm sorry, I don't understand what that meant.
19:36  yitz_: complete: Suspend
19:36  greycat: I'm not aware of any systems where cron's environment would break ps any worse than it's normally broken.
19:36  yitz_: Offlein: Read that link
19:36  Offlein: Oh, okay.
19:36  complete: yitz_: well... what IS "suspend"?
19:36  greycat: complete: it's for job control.  You can read about job control in the manual, or 17 billion other places.
19:36  csabo: Heres the cmd: /usr/tivoli/tsm/client/ba/bin/dsmadmc -id=$tsmuser -pa=$tsmpass "move data '$col1' '$col2'"
19:37  complete: greycat: ok
19:37  csabo: will that work?
19:37  tsaavik: To grep without getting the grep statement:  |grep [p]rogram_name
19:37  Offlein: Oh. This first paragraph makes me think this is exactly what I'll need. Thank you yitz_.
19:37  greycat: !pm > tsaavik
19:37  greybot: tsaavik: http://mywiki.wooledge.org/ProcessManagement
19:37  yitz_: complete: http://manpages.courier-mta.org/htmlman7/signal.7.html -> search for susp
19:38  yitz_: csabo: That looks "safe"
19:38  csabo: yitz_: This will move data, and i dont know what would happen if i provided bad info
19:38  csabo: yitz_:  IIRC single quotes, it should process it not just treat as a str right?
19:38  yitz_: You can test the values provided. "Sanity checking"
19:39  csabo: how would i do that?
19:39  yitz_: I have no idea what sort of arguments dsmadmc expects...
19:39  yitz_: !faq valid > csabo
19:39  greybot: csabo: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
19:40  complete: about CTRL+Z/fg when i did cd to another dir meanwhile... could that break stuff? for example when editing a file in vim, then wandering around the file system and returning... will vim save the file in the wrong place next time?
19:40  csabo: ty, ill take a look
19:41  csabo: yitz_:  i only ask because in echo, its displaying the single quotes
19:41  greycat: Once you start a job, it has its own copy of the environment, its own FDs, its own current working directory, etc.
19:41  greycat: Changing dir in the parent shell won't affect those.
19:41  yitz_: csabo: dsmadmc will see the single quotes, too
19:41  complete: greycat: "job"=process?
19:41  csabo: yitz_: yikes
19:42  greycat: All jobs are processes, yes.   (But not all processes are jobs.)
19:42  csabo: yitz_:  im not gonna lie, that URL FAQ is TMI, i cant even read all that right now, but i think i get the idea
--- Log closed Fri Dec 10 19:46:41 2010
