--- Log opened Tue Dec 21 00:00:37 2010
00:01  TheMusicGuy: Ah...sorry, there was a power outage.
00:01  karakuri: In diesem Jahre haben wir zwei Sonnenfinsternissen
00:05  TheMusicGuy: Anyway, thanks for pointing out the .* thing. I was about to try your suggestions when I lost power.
00:05  TheMusicGuy: (I really need to get a UPS)
00:08  e36freak: well worth the money
00:10  TheMusicGuy: I would guess so. But at least he outage didn't happen during the transfer.
00:26  ruckerz: I'm piping the stdout to a file, how do I tell bash to wait until the command is done before proceeding?
--- Log closed Tue Dec 21 09:20:17 2010
--- Log opened Tue Dec 21 09:25:40 2010
09:25 --- Users 514 nicks [0 ops, 0 halfops, 0 voices, 514 normal]
09:25 --- Server: [gibson.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
09:26 --- Channel #bash was synced in 85 seconds
09:34  infid: with bash do you use [[ str = 'foo' ]] or [ str = 'foo' ]? i've seen both single and double brackets
09:34  e36freak: double is better
09:34  TheBonsai: heh
09:34  TheBonsai: ![[
09:34  e36freak: unless it has to be POSIX compliant
09:34  TheBonsai: greybot?
09:34  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
09:35  TheBonsai: ah
09:35  TheBonsai: *snor*
09:35  e36freak: heh
09:35  e36freak: also you dont need quotes for foo, i dunno which faq that is
09:36  infid: thanks
09:38  TheBonsai: i guess 31
10:02  samfisher: hi. do you know how i could use bash to access this site http://weather.noaa.gov/weather/metar.shtml and put in the search field a string?
10:02  twkm: yes.
10:02  hemanth: /dev/tcp ?
10:03  twkm: so they allow you to do so?
10:03  hemanth: curl rather, he he ;)
10:03  samfisher: curl, but how
10:04  lhunath: samfisher: if you buy a tool and can't figure it out, read its manual.
10:04  lhunath: man curl
10:05  hemanth: samfisher, -d maybe, as lhunath said man it
10:05  samfisher: ok, thank you
10:06  lkthomas: hey guys
10:06  pgas: or just look at the howtos on the curl website, also #curl
10:06  lkthomas: what command can I use to list all subdirectory files in physical path ?
10:06  koala_man: lkthomas: echo /path/*/
10:07  lkthomas: also files ?
10:11  koala_man: lkthomas: echo /path/*
10:11  lkthomas: find `pwd` -maxdepth 1 ?
10:14  hemanth: !` > lkthomas
10:14  hemanth: !`
10:14  hemanth: ` is removed from the factoids??
10:14  hemanth: !(
10:14  tmr: No bot.
10:15  hemanth: o ya! bot is asleep ;) ?
10:26  lhunath: lkthomas: quotes.  and don't use ``, use $().  and don't use pwd, use $PWD.
10:27 --- streuner__ is now known as streuner
10:27  lhunath: or . like a sane person
10:28  lkthomas: but it works
10:28  lhunath: don't make me pummel you.
10:29  lhunath: broken code only works in broken test cases.  it's not because your test case is broken and passes that your code is good.
10:29 --- Unknown[OFF] is now known as Unknown[NF]
10:30  lhunath: additionally; many of the issues I just raised are more performance and style related.
10:31  pgas: lkthomas: it doesn't always work
10:31  lhunath: good translation.
10:31  lkthomas: what situation it wouldn't work ?
10:32  lkthomas: and how could I transfer the current command ?!
10:32  pgas: transfer?
10:32  lhunath: it wouldn't work in every situation where your path contains whitespace or glob characters.
10:32  pgas: lkthomas: what's wrong with echo path/* ?
10:32  lkthomas: find `pwd` -maxdepth 99999999999 -> find $(PWD) -maxdepth 99999999999 ?
10:33 * lhunath dies a little.
10:33  pgas: so you want a recursive solution?
10:33  lkthomas: echo does not show line by line
10:33  lhunath: I said $PWD, not $(PWD).  SYNTAX IS IMPORTANT.  GET IT RIGHT.
10:33  lhunath: $() is NOT THE SAME AS $
10:33  lhunath: and QUOTE the damn expansions.
10:34  lkthomas: don't use ``, use $().  and don't use pwd, use $PWD. <== ?
10:34 * lhunath wanders off.
10:35 --- Ionic is now known as Guest35137
--- Log closed Tue Dec 21 12:10:49 2010
--- Log opened Tue Dec 21 12:11:11 2010
12:11 --- Users 523 nicks [0 ops, 0 halfops, 0 voices, 523 normal]
12:12 --- Channel #bash was synced in 85 seconds
12:23  latenite: Hi folks, I have this script that I on a remote box in a chroot environment. The script has a while loop in it. But the last line of the loop causes an error: http://pastebin.com/M8C62fJ2 . When I comment out the while loop the script runs fine: http://pastebin.com/8SJ6pCS0
12:24  latenite: Now the weird thing is, that if I run the script manualy ON the remote box it works fine with the while loop turned on.
12:25  lhunath: < <(cat file) ?  wtf.
12:26  latenite: lhunath, ? what s wrong about that?
12:26  lhunath: oh, packagelist is not one thing. /me facepalms and wanders off.
12:26  lhunath: or, it is.
12:26  lhunath: latenite: it's a really weird and convoluted way of writing < file
12:26  latenite: lhunath, noonoo please...what s my fault here? I dont see it
12:26 --- taylanub0 is now known as taylanub
12:28  latenite: lhunath, All I want to do is process files named "package*.txt" by a loop.  So I can install some packages.
12:29  erUSUL: latenite: 12:26 < lhunath> latenite: it's a really weird and convoluted way of writing < file
12:30  dagni: i wonder if there is some way to make the bash_history being logged on remote machine ? something like syslog remote logging feature ?
12:30  lhunath: "process files named package*.txt by a loop": for file in package*.txt; do process "$file"; done
12:30  latenite: erUSUL, It works localy. Oh well how is it done "better" ?
12:30  lhunath: latenite: < <(cat foo)   is the same thing as  < foo
12:30  lhunath: latenite: you decide which one is simpler.
12:31  erUSUL: latenite: maybe the remote version of bash does not support <(); i do not understand the german? error message
12:31  skydrome: how do i reference $@ but exclude $1 or $2
12:32  erUSUL: skydrome: "help shift"
12:34  latenite: lhunath, < foo worked fine now. Sorry my approach realy was "twisted".
12:35  poisonbit: skydrome, there is also set --
12:35  poisonbit: # fun(){ set -- "${@:3}"; printf '%s ' "$@"; }; fun a b c d e
12:35  evalbot: poisonbit: c d e
12:36  poisonbit: # fun(){ shift 2; printf '%s ' "$@"; }; fun a b c d e
12:36  evalbot: poisonbit: c d e
12:37  skydrome: ah excellent, thanks
12:37  latenite: lhunath, hey man thanks. That realy helped a lot. Now clue why < <(cat file)  vs. < file is "not the same"??? There must be a difference I am not aware of?!
12:38  mr_daniel: ctrl+] works, thanks koala_man and lhunath. But why should I use nc? What are the advantages?
12:39  poisonbit: latenite, cat is not bash, is /bin/cat (or wherever),  < file,  is just bash, and is already in ram when your script starts.
12:40  koala_man: mr_daniel: the question is rather, "why should you use telnet"?
12:41  latenite: poisonbit, ok so there is a performance hit that make me want to use < . BUT why is cat failing?  Its not supposed to fail? right
--- Log closed Tue Dec 21 12:43:37 2010
--- Log opened Tue Dec 21 12:44:59 2010
12:44 --- Users 527 nicks [0 ops, 0 halfops, 0 voices, 527 normal]
12:45  bianchi: hi everybody
12:47  bianchi: .. when I try to hide output of command in a script I do like: ls "/tmp/test" 2>/dev/null 1>/dev/null < /dev/null, and there is no output (which is good), but when I put it in condition like: if 'ls "'/tmp/test'" 2>/dev/null 1>/dev/null < /dev/null'; I always get output of ls (no such file)
12:47  bianchi: how to hide output when is in if statement?
12:49  pgas: # touch foo; if ls  foo doesnotexist 2>/dev/null  1>/dev/null;then :;fi
12:49 --- Channel #bash was synced in 323 seconds
12:49  evalbot: pgas: no output
12:50  pgas: the usual way.
12:50  erUSUL: bianchi: ls > /dev/null 2>&1
12:50  erUSUL: bianchi: maybe the problem is the input redirect? "< /dev/null"
12:51  erUSUL: dunno why you use it there
12:51  zxd: how do I increase the history buffer
12:51  bianchi: I still get output
12:51  pgas: set HISTFILESIZE and/or HISTSIZE
12:52  bianchi: if is in function :/
12:52  bianchi: let me pastebin
12:52  erUSUL: zxd: man bash search "HIST"
12:56  bianchi: ok: http://pastebin.com/z6jXd0Ak
12:56  bianchi: question is, how to hide output of ls in this script
12:59  Ammler: bianchi: or use test
13:00  bianchi: Ammler, test? don't get it
13:01  pgas: if ssh test -e file;then echo file exist;fi
13:01  erUSUL: well if ssh is involved can be a eated quotes problem ...
13:01  erUSUL: !faq 96
13:02  bianchi: hm.. thanks
13:02  erUSUL: http://mywiki.wooledge.org/BashFAQ/096
13:02  pgas: sure, but that's something else
13:05  zxd: not history buffer scroll buffer
13:05  zxd: page up page down
13:05  zxd: I got confused
13:22  pgas: zxd: this is not bash, it depends on your terminal
13:26  skydrome: which is generally better to do, su <user> -c || sudo -u <user> ?
13:28  grop: skydrome, sudo -u <user> <command>
13:32 --- Unknown[NF] is now known as Unknown[OFF]
13:33  Lunar_Lamp: I am trying to generate a random number between 1 and 100.  I was going to use ${RANDOM:0:2} but it doesn't seem to be generating numbers >10 very often.  I'd expect that to happen in 1/10 numbers, but I've tested it many times with the following snippet, and it does not seem to hold true.
13:33  Lunar_Lamp: n=0; while true; do (( n++ )) ; foo=${RANDOM:0:2}; echo $foo $n; (( foo < 10 )) && break; done
13:34  grop: Lunar_Lamp, {1..100}
13:34  pgas: echo $((RANDOM%100+1))
13:35  Lunar_Lamp: pgas: using your way, it seems to take hundreds or thousands of iterations to hit a number below 10.
13:35  Lunar_Lamp: (as with mine)
13:37  koala_man: # n=0; for f in {1..100}; do ((RANDOM%100+1 < 10)) && let n++; done; echo "$n% under 10"
13:37  evalbot: koala_man: 7% under 10
13:37  koala_man: # n=0; for f in {1..100}; do ((RANDOM%100+1 < 10)) && let n++; done; echo "$n% under 10"
13:37  evalbot: koala_man: 9% under 10
13:38  grop: # printf '%s\n' {1..100} | sort -R | head -1 # …
13:38  evalbot: grop: 45
13:38  pgas: # for i in {1..500} ;do echo $((RANDOM%100+1));done | awk 'length <2' | wc -l
13:38  evalbot: pgas: 34
13:39  pgas: ah koala_man had another version :D
13:40  pgas: Lunar_Lamp: it's indeed a bit biased because bash random number are between 1 and 32000 something but not so much
13:40  Lunar_Lamp: OK, so I should actually look to take the last two digits.
13:40  pgas: (between 0 and 32767)
13:41  pgas: well taking the last 2 digit or %100 is probably similar yes
13:42  Lunar_Lamp: Hmm
13:42  pgas: hmmm though you need to add 1 and you'll have problems with 09
13:42  Lunar_Lamp: I'm not sure that I'm getting what I expect here.
13:42  Lunar_Lamp: Because 00 shows, as does 09 etc etc. All well and good.
13:42  Lunar_Lamp: But if I'm picking the last two numbers, how can I get a single digit?
13:43  pgas: 09 is considered octal by bash
13:43  Lunar_Lamp: Ah, of course, because the RANDOM number isn't zero padded.
13:43  pgas: just use modulo
13:43  Lunar_Lamp: I think there is a logic error in what I was doing originally.
13:44  pgas: ah yes, you are taking the first 2 digits, modulo would be the last 2
13:44  Lunar_Lamp: # (( 08 < 10 )) && echo works
13:44  evalbot: Lunar_Lamp: bash: ((: 08: value too great for base (error token is "08")
13:45  pgas: so you are getting a lot of 1X and 2X an a bit of the rest
14:13  poisonbit: reading http://www.opengroup.org/onlinepubs/000095399/utilities/dirname.html    dirname '../foo' should return '.'  or what am I misreading ¿?
14:14  MrHeavy: How do I insert a null character into a string in bash? I have something like:
14:14  MrHeavy: args="$args"$'\0'"$line"
14:14  MrHeavy: $args and $line get concatenated but I don't end up with a null in the output
14:15  pgas: you cannot
14:16  pgas: poisonbit: I'd say you are misreading it.
14:17  poisonbit: pgas, I got to step 4
14:17  pgas: poisonbit: 1 2 3 4 don't apply,
14:18  pgas: then 5 removes foo  6 removes / and it leaves ..
14:18 --- Unknown[OFF] is now known as Unknown[NF]
14:18  poisonbit: ah i passed 1.. hehe my fail
14:20  pgas: err, 6 doesn't apply, and 7 removes /
14:21  poisonbit: s/||/&&/ fixed it ... http://paste.debian.net/plain/102917
14:21  poisonbit: I'm testing more usage cases... then i will benchmark  :D dirname vs dirname
14:21  poisonbit: when i fix remaining bugs
14:24  pgas: poisonbit: try "help return"
14:24  pgas: ah no sorry
14:25  poisonbit: mmm should be  [[ "$string" != // ]] && {   but if i use that as step 1) I get ../foo => .
14:25  pgas: but you probably need to initialize string
14:25  poisonbit: for string; do
14:25  pgas: err no i see
14:25  poisonbit: takes "$@"
14:25  pgas: yup
14:26  pgas: well posix dirname  only takes one argument that's what mislead me
14:35  poisonbit: well
14:35  poisonbit: for i in {1..1000}  gives  real	0m0.882s    and   bash only dirname gives real	0m0.095s
14:36  poisonbit: whitout using "$2" instead of "$1", maybe that could be faster
14:36  poisonbit: instead of "$@" i mean
14:36  poisonbit: using just local string="$1"
14:37  poisonbit: then will come someone that will remove the variable. Will not be /me   :)
14:39  bianchi: Ok, me again. Just this line in sh script, and I get output, how to make script that have no output:  test -e "/tmp/testfile.txt" > /dev/null 2>&1
14:39  pgas: test doesn't produce any output
14:39  Lunar_Lamp: OK, I'm an idiot.  I want to perform a command, and if it fails echo some output and exit the script.  `foo || echo "failed" && exit 1` breaks as it does the exit in all circumstances, but I'm not sure what I should do instead.  If I do something like putting the echo and exit in (), obviously the exit only exits the subshell...
14:40  pgas: well, unless you use it incorrectly, which is not hte case, and then your redirection will remove that output
14:40  pgas: Lunar_Lamp: what about using if?
14:41  pgas: if ! command;then echo foo; exit;fi
14:41  Lunar_Lamp: pgas: well, yeah, I was using if [[ $? -ne 0 ]] ; ... but I thought it would be nicer to read if I did it as it was.
14:41  Lunar_Lamp: But, obviously, it's not quite what I intended.
14:41  paxl: What is the easyest way to execute a script as a user will be run as root withing the same script that do things as root ?
14:42  grop: ![[ > Lunar_Lamp
14:42  greybot: Lunar_Lamp: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
14:42  pgas: Lunar_Lamp: what people use is die () { echo "$1";exit 1; };command || die foo
14:42  grop: !test
14:42  greybot: help test <Enter> http://mywiki.wooledge.org/BashGuide/TestsAndConditionals | http://bash-hackers.org/wiki/doku.php/commands/classictest
14:42  grop: Hmm don't remmeber which one…
14:42  pgas: Lunar_Lamp: the solution to your problem was to use  || { echo foo;exit 1; }
14:42  lhunath: ![$?
14:42  greybot: Don't do this: mycommand; if [ $? -eq 0 ] -- You're running the [ command and checking its exit code to test whether "mycommand"'s exit code is 0. That's a pointless operation, test mycommand directly: if mycommand
14:43  Lunar_Lamp: Ah, the curly braces!
14:43  grop: lhunath, yeah ^^
14:43  grondilu: How do I redirect only stderr to a pipe ?
14:43  lhunath: you cannot.
14:43  grondilu: oh
14:43  lhunath: pipes redirect stdout.
14:43  grondilu: ok
14:43  pgas: paxl: err, not sure to understand but the answer is probably sudo
14:43  lhunath: if you want your command's stdout piped; redirect the fds first.
14:44  bianchi: pas: this produces output:  if 'test -e "'$1'" > /dev/null 2>&1'; then
14:44  poisonbit: 2>&1 |
14:44  poisonbit: ^^^ grondilu
14:44  lhunath: move your command's stdout to some fd and your command's stderr to stdout
14:44  grondilu: I want to display stdout and process stderr
14:44  lhunath: poisonbit: I think he said "only" for a reason.
14:44  poisonbit: aps
14:45  lhunath: grondilu: process how?
14:45  grondilu: (I'm trying ot parse output of "gpg -d")
14:45  pgas: bianchi: your quotes are wrong
14:45  lhunath: maybe the answer is to not use a pipe.
14:45  grondilu: hum
14:45  bianchi: pgas, what is the right way
14:45  paxl: pgas, It's the inverse, I'm dooing a script that will run as root and create users on a machine and then I want those user to run another script.. answer would proabably be to use "su user -c" but I was wondering if it would not be possible with a HEREDOC or someting like this...
14:45  grondilu: I redirect to temp file and I process it
14:45  grondilu: ?
14:45  lhunath: what do you mean with "process it"?
14:45  grondilu: some greps, sed and stuffs...
14:45  lhunath: what do you want to do with gpg's error output?
14:46  grondilu: I want to find out from who the message was signed.
14:46  grondilu: gpg gives all usefull info on stderr
14:47  grondilu: (which is weird imo)
14:47  lhunath: gpg -d 2> >(...)
14:47  grondilu: hum... loog cleaver
14:48  grondilu: looks*
14:48  pgas: paxl: sudo -u user bash << EOF
14:48  lhunath: redirect fd 2 to a file which is a named pipe that is read y the command ...
14:48  lhunath: by*
14:48  grondilu: lhunath: works ;)
14:48  lhunath: not sure why gpg's standard message is insufficient
14:49  grondilu: maybe the -d option is not what I need...  but this is a discussion for #gnupg
14:49  grondilu: thks anyway
14:49  pgas: cmd 3>&1 1>&2 2>&3  |
14:50  bianchi: pgas, that's for me?
14:50  pgas: nope
14:51  pgas: bianchi: your command doesn't produce error messages, it 's bash that prints something because the syntax is wrong
14:52  bianchi: pgas, same command out of script produces no output
14:52  pgas: what's your code?
14:53  bianchi:  if "test -e $1 > 2>/dev/null 1>/dev/null"; then
14:53  pgas: this just doesn't work
14:53  bianchi: line 26: test -e /pgdata/data90.C/pg_xlog > 2>/dev/null 1>/dev/null: No such file or directory
14:53  pgas: bianchi: can your run  "echo foo" ?
14:53  pgas: no, you run : echo foo
14:53  pgas: # "echo foo"
14:53  evalbot: pgas: bash: echo foo: command not found
14:54  Mmike: I want to truncate a file to last 5 lines. Something like "tail -5 somefile > somefile", but so it works :)
14:54  pgas: if you put quotes around bash will consider the whole thing as 1 word, the name of your command
14:54  lhunath: bianchi: learn the meaning of the quote character before putting it somewhere.
14:54  pgas: !pf > Mmike
14:54  greybot: pgas: No matches found at http://mywiki.wooledge.org/BashPitfalls
14:55  pgas: number 13
14:55  pgas: Mmike: you need a temp file, or use ed, ex, gnu sed
14:56  pgas: ed,ex is probably the easiest
14:56  lhunath: bianchi: the meaning of "" is: All the text within " is one single thing.  the following statement has two words:  echo foo.  This one has only ONE: "echo foo", now bash will search PATH for a porgram named "echo foo".  it won't find one, because the program is named "echo", not "echo foo".
14:56  heiner: Mmike: tail -f somefile > tmp.$$ && mv tmp.$$ somefile
14:57  bianchi: lhunath, got it
14:57  lhunath: bianchi: the thing you want to keep together as one argument is the result from the $1 thing.
14:57  lhunath: test -e "$1"
14:57  pgas: lhunath: he needs the faq about ssh and quotes
14:57  Mmike: heiner, yea, but I'm not allowed to use temp file :)
14:57  lhunath: in case $1 contains spaces and stuff.
14:57  Mmike: pgas, i'll investigate ed/ex, thnx
14:58  lhunath: !ssh
14:58  greybot: Secure SHell (See #openssh, http://mywiki.wooledge.org/CategorySsh) - To run bash code remotely; adapt: ssh user@host bash <<< "$(printf 'echo %q' "$localVar")"
14:58  lhunath: is there a faq about this?  if so; should be added to that factoid
14:58  pgas: I don't know, I just know that you know the correct !invocation ;)
15:01  kneferilis: Hello!
15:02  kneferilis: How do I count number of files in a directory and its subdirectories? What is the command?
15:02  lhunath: recursively?
15:02  kneferilis: yep, I guess so
15:03  lhunath: find dir/ -printf . | wc -c
15:03  lhunath: if you don't have -printf, -exec printf . \;
15:03  lhunath: if you actually want to do something useful with the files too, then use a loop instea.d
15:05  kneferilis: thanks, but the command didn't work
15:05  kneferilis: find dir/ -printf . | wc -c
15:05  kneferilis: find: dir/: No such file or directory
15:05  kneferilis: this is what I got
15:08  grop: kneferilis, dir/ is *your* directory called whatever…
15:10  kneferilis: yep, I figured it out
15:10  kneferilis: problem is, I run it for a directory that has 3 files in it, and the command outputs 9!
15:10  kneferilis: I know there are files . and .., but still I got 9 not 5
15:10  grop: kneferilis, wc -l
15:11  pgas: probably want -type f
15:11  pgas: find dir/ -type f -printf . | wc -c
15:11  kneferilis: pgas with that I got 8
15:11  grop: pgas, why wc -c? not wc -l?
15:12  grop: kneferilis, try with  find example/ -type f -printf . | wc -l
15:12  Fatal: grop: -printf . does not output any newlines
15:13  kneferilis: grop I tried that, but now I get 0
15:14  grop: kneferilis, find example/ -type f | wc -l
15:14  pgas: grop: it's a trick, -printf is not standard but it prints only one . for each file. you could use -print | wc -l, but it 's a bit less robust as it fails for filenames containing a newline
15:17  grop: pgas, ok… it sounds strange
--- Log closed Tue Dec 21 15:40:20 2010
--- Log opened Tue Dec 21 15:40:39 2010
15:40 --- Users 544 nicks [0 ops, 0 halfops, 0 voices, 544 normal]
15:41  lhunath: nothing about what I said was hostile.
15:41  cheater2: you're not in a position to decide about what i find hostile
15:41  cheater2: srakin, ok
15:41  cheater2: srakin, i wonder if there's some way to simulate files or something like that..
15:41  cheater2: maybe that could work
15:41 --- Channel #bash was synced in 80 seconds
15:41  lhunath: I have an idea.  process substitution.
15:42  lhunath: try reading the advice you're given.
15:43  srakin: lhunath: lazy() { cat "$1"; return; this code will never be executed; cat "$2"; < this file will never be opened;}; lazy <(one) <(this command shouldn\'t be started) # <- if bash had support of LE, 'this' command shouldn't be started until output of it should be really needed (by cat in function, for example)
15:43  lhunath: correct.  but pipes don't do that.
15:43  cheater2: srakin, what i mean is this: i have two very big files. i want diff to start outputting immediately, and i want to break the execution when i've seen enough
15:44  lhunath: that's what happens by default.
15:45  cheater2: however, the input to diff would be from two programs that process those files line by line
15:45  dark: lhunath, process trying to write on a pipe will block (if using blocking I/O). they will continue execution when the other side read it. with a | b syntax, if b quits, a is also stopped. so a output is, in a sense, lazy: it only gets to output what b needs
15:45  skered: pgas: There might be a better way or doing this but I'm using trap DEBUG and ERR report to report to a log as far as what's happening when a script is running.. using set -x's output is a little to verbose for someone that doesn't know sh/bash.
15:45  lhunath: if by 'files' you mean 'output of another program' and by 'execution' you mean 'execution of the other program' then, no, that's not what happens.
15:45  srakin: cheater2, yes, 'diff /dev/pipe1 /dev/pipe2' actually work like lhunath've said
15:46  skered: So I'm using trap DEBUG to report when something has finished and I don't see a very good way or reporting what has finished.
15:46  cheater2: i have just tried this: diff <(find . | grep Ze) <(find . | grep Z)
15:46  lhunath: don't grep find's output.
15:46  cheater2: however, it reports a syntax error at an unexpected (
15:46  lhunath: learn about -name
15:46  umarzuki: hi, why would "$ awk -F; '{print $1}' address.csv" returns "awk: option -F lacks argument" ?
15:46  srakin: cheater2, =)
15:46  lhunath: cheater2: use bash.
15:46  cheater2: lhunath, "find" is just a dummy, i would be using something else
15:47  lhunath: sh does not know what <() means.
15:47  srakin: cheater2, find gives you an ability to form the complex search request
15:47  cheater2: ah, funny, my login shell on this one machine is sh. well guessed.
15:48  mar77i: umarzuki: why is there a semicolon after -F? the semicolon is *the* important bash metacharacter
15:48  cheater2: srakin, "find" is just a dummy, it would be replaced with something else later, it's just for testing how <() works.
15:48  umarzuki: mar77i, csv delimeter
15:48  lhunath: dark: yes, the lazyness is in the command that writes to the pipe, then, though.
15:49  mar77i: umarzuki: backslashes? http://xkcd.com/234/
15:49  tvm: umarzuki: -F";"
15:49  mar77i: ...or -F\;
15:49  umarzuki: mar77i,tvm thanks
15:50  srakin: cheater2, just know: command in <(...) output-of-a-process-as-tempfile substitution (process substitution) will be executed every time before of leading command call
15:50  cheater2: srakin, as i see it the command inside <() needs to finish executing
15:51  cheater2: before diff starts processing its output
15:51  lhunath: if it's a smart command, it will stop executing when its output closes.
15:51  lhunath: no, they run asynchronously.
15:51  lhunath: read: at the same time.
15:51  srakin: output of <() is piped. the <() substitutes a filename of a pipe symlink
15:51  Mowee: Hey :)
15:51  srakin: cheater2, so, i guess, you're just having problems with buffering
15:51  cheater2: i did this: diff <(find . | grep a && sleep 3) <(find . | grep Z)              and it gave me a 3 second wait before outputting
15:52  cheater2: this shows me that the left "find" needs to finish executing before diff is engaged
15:52  cheater2: am i right to think this?
15:52  srakin: cheater2, no, you're not right.
15:53  cheater2: then why does it not start outputting immediately?
15:53  mar77i: O_0 I'm confused, this actually works?
15:53  srakin: cheater2, real thing is that's output of find is just buffered
15:53  cheater2: how can i "unbuffer" it?
15:53  srakin: cheater2, into 4kb chunks or some size like that
15:53  srakin: lhunath, does find have any option to unbuffer its output?
15:54  cheater2: srakin: if i do (find . | grep a && sleep 3) | grep b                then it starts outputting immediately
15:54  lhunath: because diff's first buffer was not filled by your first find|grep's output.
15:54  lhunath: tell diff to line-buffer its input.
15:54  lhunath: if you can.
15:55  cheater2: man diff | grep buff     -> empty output
15:55  cheater2: :-\
15:56  cheater2: actually i have done something else: diff <(find / | grep a) <(find / | grep a)
15:56  dark: umarzuki, try -F\;
15:57  cheater2: this does not start outputting immediately. i think this might mean that there's an issue in diff, right?
15:57  dark: oh, already replied
15:57  dark: cheater2, I didn't know that you could do <(command 1) <(command 2), does this really work?
15:57  lhunath: yes, it really works.
15:58  cheater2: yes
15:58  lhunath: the issue is not find's output.  the issue is diff's input.
15:58  Bushmills: cheater2: try  man diff|grep and    for some output instead
15:59  srakin: dark, info -n '(bash)Process Substitution'
15:59  cheater2: lhunath, yes, i think we have decisive proof that diff's input is broken
16:00  lhunath: nothing broken about it.
16:00  lhunath: in fact, diff would be really crappy if it didn't work this way.
16:01  lhunath: diff fills up a buffer of data before it starts processing data.  as soon as it fills up its buffer or the input data ends (read: input fd closes), it starts processing.
16:01  cheater2: i don't think it has a fixed size buffer, i think it just reads the files to the end
16:01  lhunath: if you don't give diff enough data to start processing before you start sleeping, diff will wait for the buffer to fill completely or the fd to close (which happens after you sleep)
16:02  cheater2: look at what i pasted later - just two find /'s, and then diff didn't start outputting either
16:02  cheater2: whatever size buffer that is, it's too big, but i don't think there's a fixed size buffer at all
16:03 --- ChanServ sets modes [#bash +b *!*@212.3.203.149]
16:03 <-- ChanServ has kicked cheater2 from #bash (User is banned from this channel)
16:03  lhunath: I suppose it's possible.
16:04  oobe: I trying to write a script to make backups of a database but the db name has spaces in the name and i want to set a variable e.g DBNAME="DB Name" but using single or double qoutes doesnt seem to work
16:06  erUSUL: !quotewhen
16:06  greybot: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
16:08 --- ChanServ sets modes [#bash +o lhunath]
16:08  dark: oobe, DBNAME="DB Name" seems fine and works here
16:08 --- lhunath sets modes [#bash -bo *!*@212.3.203.149 lhunath]
16:08  oobe: strange
16:09  cheater2: hi, thanks
16:09  cheater2: i think i could write a version of diff that does only the minimal amount of input buffering
16:09  oobe: i decided to just remove that variable and used find and replace with "db name"
16:09  oobe: and it works
16:09  srakin: dark, that's not about DBNAME="...", but about substitution of $DBNAME in later command calls.
16:10  lhunath: cheater2: depends on what type of diffing you want to do I guess.
16:10 --- taylanub0 is now known as taylanub
16:10  srakin: dark, you should double-quote every $DBNAME to make it one parameter, not two
16:10  dark: yes, you have to use it as "$DBNAME" oobe
16:10  cheater2: after all it just needs to start buffering when the lines start differing. so you have two files that look like this:   a\nb\nc\nd\ne\nf  a\nb\ne\nf        then it just has to buffer when it gets to the third line, and continue buffering until it gets to the fifth line in the left file
16:10  srakin: # a="dark dark"; printf "%s\n" $a | cat -n
16:10  oobe: oh really?
16:10  evalbot: srakin:      1	dark
16:10  evalbot: srakin:      2	dark
16:10  srakin: # a="dark dark"; printf "%s\n" "$a" | cat -n
16:10  dark: funny, I was writing a test case that didn't required quotes:
16:10  evalbot: srakin:      1	dark dark
16:10  cheater2: i'm not sure what other type of diffing there would be? what do you mean?
16:10  dark: # DBNAME="DB Name"; if [[ $DBNAME = "DB Name" ]]; then echo hi; fi
16:10  evalbot: dark: hi
16:11  dark: (but yes, I see oobe's issue now)
16:11  oobe: doesnt matter its working now
16:11  srakin: dark, sorry, my answers were for oobe, not you
16:11  oobe: just stopped trying to set a variable
16:12  dark: cheater2, Maybe that this now left the realm of bash. Maybe ##posix would be a better place?
16:12  srakin: cheater2, diff will try to optimize the work of commands as hard, as it can
16:13  cheater2: dark: yes, i guess
16:13  cheater2: srakin, aha
16:14  oobe: thanks guys
16:14  TheBonsai: lhunath: is chanserv drunk?
16:15  srakin: cheater2, and yes, it will close the file descriptors (really, it'll close the pipes) and stop piped-in commands when it'll be able to make such decision.
16:15  lhunath: TheBonsai: he doesn't like cheaters.
16:15  TheBonsai: ah, a gamer.
16:15  cheater2: i only play the game of life
16:15  TheBonsai: i meant chanserv :)
16:15  lhunath: I expect cheater2 just identified himself to nickserv when he got banned.
16:16  cheater2: yep
16:21  cheater2: thanks for the help guys
16:21  cheater2: i'll see you later :)
16:21  oobe: this is what i have now http://pastebin.ca/2025472
16:22  srakin: oobe, mv $BACKUPDIR/*-backup.sql.gz.6 $BACKUPDIR/*-backup.sql.gz.7 => mv $BACKUPDIR/*-backup.sql.gz.6 "$BACKUPDIR"/*-backup.sql.gz.7
16:22  oobe: it works i could improve it though so it doesnt need to use mv but i dont know how else to make it delete the oldest
16:23  srakin: oobe, ,no, sorry, i'm an idiot
16:23  oobe: oops just tested it
16:23 * srakin turning brains on (if it's possible)
16:24  oobe: this is a mod of script i made ages ago that i had working perfectly
16:24  oobe: i used find and replace for a lot of things
16:24  srakin: oobe, pg_dump --username=pt3 "$DBNAME" > "$BACKUPDIR/PT3-backup.sql"
16:24  srakin: oobe, quote every variable substitution in your command calls
16:24  srakin: oobe, quote every "$DBNAME" and all filenames
16:25  oobe: ok so that is where i was going wrong
16:25  oobe: ok I will put it back in
16:26  srakin: oobe, but *-globs won't work in quotes, so quote $BACKUPDIR/*-backup.sql.gz.6 as "$BACKUPDIR"/*-backup.sql.gz.6
16:26  oobe: what are globs
16:26  oobe: *?
16:26  pgas: !globs
16:26  greybot: "Glob", the common name for pattern matching, filename expansion, "wildcards", etc. http://mywiki.wooledge.org/glob
16:27  srakin: oobe, stars, question marks, etc. see faq
16:28  srakin: glods aren't safe for use in your mv command. it may expand into two or more filenames
16:28  srakin: *globs arent... blah
16:28  oobe: ok thanks i knew that I just never heard the term glob refore
16:29  poisonbit: # dirname ..   # does this makes any sense ?
16:29  evalbot: poisonbit: .
16:29  poisonbit: # dirname ../foo
16:29  evalbot: poisonbit: ..
16:30  srakin: poisonbit, ./ is substituted at the left of every filename (except those starting with /) in dirname
16:31  srakin: poisonbit, so .. is equal to ./.. for dirname as parameter
16:32  poisonbit: thanks by the explanation srakin
16:33  ritzt3ch: # mdm=-15.4
16:33  evalbot: ritzt3ch: no output
16:34  oobe: ok finished and in cron thanks guys
16:35  ritzt3ch: # if [[ $mdm > "-17" || $mdm < "-13" ]] ; then ; echo "Number is betweeen -13 and -17" ; fi
16:35  evalbot: ritzt3ch: bash: syntax error near unexpected token `;'
16:35  srakin: ' then ; " <- mistake
16:35  srakin: ritzt3ch, bash doesn't support floating-point numerical calculations.
16:36  c0nsense: Hello! i'm creating a wargame, how can i do this script with a better method? http://pastebin.com/5H4nr2uS
16:37  ritzt3ch: ohhh hmmm so i cant run something if output resluts between -13 and -17 could i do a Less then -17 then ?
16:38  srakin: #test_ml() { [[ $(bc -l <<<"$1""$2""$3") == 1 ]];}; test_ml 1 '>' 2 && echo "1>2"; test "-2" ">" "-3" && echo "-2>3"
16:38  srakin: # test_ml() { [[ $(bc -l <<<"$1""$2""$3") == 1 ]];}; test_ml 1 '>' 2 && echo "1>2"; test "-2" ">" "-3" && echo "-2>3"
16:38  evalbot: srakin: no output
16:38  srakin: # test_ml() { [[ $(bc -l <<<"$1""$2""$3") == 1 ]];}; test_ml 1 '>' 2 && echo "1>2"; test_ml "-2" ">" "-3" && echo "-2>3"
16:38  evalbot: srakin: -2>3
16:39  srakin: yes, -2 > -3
16:39  ritzt3ch: i did use bc to where i had to do negative operatiosn
16:40  srakin: # test_ml() { [[ $(bc -l <<<"$1""$2""$3") == 1 ]];}; test_ml '-15.777' '<' '-15.555' && echo "-15.777 < -15.555 "
16:40  evalbot: srakin: -15.777 < -15.555
16:40  srakin: # test_ml() { [[ $(bc -l <<<"$1""$2""$3") == 1 ]];}; test_ml '-15.777' '>' '-15.555' && echo "-15.777 > -15.555 "
16:40  evalbot: srakin: no output
16:40  srakin: it works.
16:41  srakin: ritzt3ch, you've tested and did right, bc was made exactly for that.
16:41  ritzt3ch: now i gota figure out how to get this function to a iF lol
16:41  poisonbit: c0nsense, maybe using function ?
16:41  srakin: ritzt3ch,  ''help if''
16:41  lhunath: if test_ml
16:42  poisonbit: c0nsense, like p(){ for word; do printf '%s ' "$word"; sleep 1; done; }; p Your computer has infected, I can control YOU
16:42  lhunath: I fail to see the need to split the arguments up into three arbitrary ones.
16:43  lhunath: test_ml '-15.7' '77>-' '15.555'
16:43  srakin: lhunath, you're right
16:44  c0nsense: poisonbit: very good! thanks! we can do word by word? Y.. o .. u .. r
16:44  c0nsense: ?
16:44  poisonbit: char by char ?
16:45  lhunath: c0nsense: while read -n1
16:46  umarzuki: what method is the easiest to convert fom csv to vcf with bash script?
16:46  TheBonsai: c0nsense: http://pastebin.com/MamswZwr
16:46  srakin: c0nsense, your=(Your computer blah...); sleep(){ echo fake sleep here;}; for i in "${your[@]}"; { printf "%s\n" "$i"; sleep 1;}
16:46  TheBonsai: poisonbit: ah was too slow
16:46  srakin: # your=(Your computer blah...); sleep(){ echo fake sleep here;}; for i in "${your[@]}"; { printf "%s\n" "$i"; sleep 1;}
16:46  evalbot: srakin: Your
16:46  evalbot: srakin: fake sleep here
16:46  evalbot: srakin: etc... ( http://pastebin.com/JmWZaJfi )
16:46  poisonbit: p(){ while read -n 1 char; do printf '%s ' "$char"; sleep 1; done <<< "$@"; }; p Your computer has infected, I can control YOU char by char
16:47  lhunath: umarzuki: parse and format
16:47  lhunath: umarzuki: alternatively ask your package manager.  too vague a question for this channel.
16:47  srakin: umarzuki, use real csv parser for that.
16:48  lhunath: bash does not know what csv or vcf is.
16:48  srakin: umarzuki, look for help at #perl channel
16:48  ssspark: hey folks! I'm trying to have someone enter a password, that does not show up when it's being typed, but is fed through md5sum to get the md5-hash.. is that possible?
16:49  lhunath: read -s
16:49  TheBonsai: read -s
16:49  lhunath: ssspark: ^
16:49  srakin: umarzuki, ... use Text::CSV_XS, Text::xSV or DBD::CSV
16:49  ssspark: ahh, was trying to use 'cat' for that
16:49  TheBonsai: poor cat
16:49  TheBonsai: *meoooowwww*
16:49  e36freak: cat?!
16:50  ssspark: yeah, cat | md5sum
16:50  ssspark: but read -s works, thanks guys!
16:50  TheBonsai: e36freak: cat is a tuned pipeline implemented as program :)
16:50  ritzt3ch: dog
16:50  e36freak: TheBonsai: yeah, but it would be the last thing id think about using to do that
16:51  TheBonsai: e36freak: the last thing i'd think of is dd(1), but that's also possible
16:51  prince_jammys: last one for me might be date
16:52  TheBonsai: *scratches beard*
16:52  srakin: TheBonsai, real programmers use EMACS for that
16:52  poisonbit: c0nsense, if you don't like sleep 1, change it by something like: perl -E 'use Time::HiRes qw/nanosleep/; nanosleep(33_000_000);'
16:53  TheBonsai: srakin: i thought real programmers don't use emacs?
16:53  TheBonsai: oh, must have been in #vim
16:53  TheBonsai: :D
16:53  e36freak: haha, dd
16:53  e36freak: vim <3
16:53  ssspark: hm, 'read -n | md5sum' doesn't work
16:53  trash: read doesn't output anything there.
16:53  TheBonsai: ssspark: nah, read it into a variable, give the content to md5sum
16:53  prince_jammys: first, read into a variable. then redirect
16:54  TheBonsai: ssspark: read -s pw; echo "$pw" ( | md5sum)
16:54  srakin: ssspark, read -s; echo $REPLY | md3sum
16:54  prince_jammys: Q
16:54  c0nsense: thanks for all!
16:54  prince_jammys: U
16:54  srakin: -n is more complex option of read.
16:54  pgas: e36freak: if you don't have bash's read "-n" option, dd is pretty much what you have if you wan to read something char by char
16:54  srakin: prince_jammys, cheers
16:54  prince_jammys: hi
16:55  e36freak: pgas: interesting, never thought about doing that. theres also parameter expansion in a loop
16:55  detrate: does anyone know of a commandline tool that lets me organize a bunch of commands through a curses-like menu? Or is this something I have to create myself?
16:55  prince_jammys: too vague
16:55  TheBonsai: oh, and read -r
16:55  srakin: detrate, dialog
16:55 --- eno__ is now known as eno
16:55  pgas: e36freak: I mean to read from the keyboard
16:56  e36freak: pgas: ahh
16:56  detrate: thanks srakin
16:56  prince_jammys: ah, i would never have guessed
16:56  ssspark: excellent, that worked like a charm guys
16:57  srakin: pgas, oh, is there some POSIX-compliant way to determine that input really comes from keyboard, not from some fake data-generating stream?
16:57  srakin: pgas, in GNU/Linux /sys/ is usable, but...
16:58  TheBonsai: you can check if stdin is a terminal
16:58  TheBonsai: which is the right direction, but not what you want
16:59  TheBonsai: why do you need POSIX?
16:59  lhunath: open /dev/tty for reading.
16:59  mhahe: any suggestions for books or online material for somewhat newbie bash users? im very comfortable with bash, but i want to dig deeper and id like to have some reference material to aid me in getting familiar with tools and ways of going about things. so something extensive but not too overwhelming with examples and explainations?
16:59  lhunath: !guide > mhahe
16:59  greybot: mhahe: http://mywiki.wooledge.org/BashGuide
16:59  prince_jammys: /topic
16:59  srakin: mhahe, !topic
17:00  srakin: mhahe, i mean /topic, yeah, really
17:00  mhahe: oops, alrighty ill get reading :D thanks
17:00  prince_jammys: /topic + manual has all the bash in the known universe
17:00  prince_jammys: worth knowing
17:01  srakin: texinfo manual (info bash) is even better
17:01  prince_jammys: i suck at info
17:01  TheBonsai: for me it's the very same document
17:01  pgas: srakin: yeah, often what you want if [ -t 0 ] or [ -t 1 ]
17:02  TheBonsai: ah, that's just my instalölation. but the bash info page is just the reference manual, so.. :)
17:03  srakin: pgas, all terminal-related manipulations suck when program run in PTY
17:03  pgas: what I meant is that if you want to simulate the thing where you input * or make a game where you need to read keys like h j k l with a posix shell, dd is not a extreme choice
17:03  TheBonsai: srakin: a PTY is a valid terminal
17:03  lhunath: there are no guarantees.
17:03  srakin: TheBonsai, but keyboard in PTY is fake
17:03  srakin: TheBonsai, that's not what we want.
17:04  srakin: and not only in PTY
17:04  TheBonsai: srakin: there is no way to check that
17:05  TheBonsai: why do you need POSIX?
17:05  TheBonsai: or better: do you need POSIX for your read stuff before, too?
17:05  srakin: TheBonsai, i don't need read stuff.
17:05  TheBonsai: damn
17:05  TheBonsai: wrong man
17:05  TheBonsai: :)
17:06  prince_jammys: i had them mixed up too
17:06  pgas: ehe, maybe it's my fault
17:06  srakin: TheBonsai, i'm working in non-GNU posix compliant OS (cygwin+busybox on WinCE) and dow't want to break posix-compliance of my OS
17:06  TheBonsai: pgas: it's always your fault
17:06  TheBonsai: prince_jammys: it's pgas' fault.
17:06  prince_jammys: always
17:07  pgas: I shouldn't have started on dd especially since I'm not really following :D
17:07  lunaphyte_: on linux, what might be a good method for enumerating network (ethernet) interfaces?  currently, i'm parsing the output of ifconfig, but my sense is that there must be another method which requires less processing.
17:08  TheBonsai: srakin: then live with the limitations (infact this is a feature, imho)
17:08  prince_jammys: well, they both start with s, they both have a k, and they're both involved with terminals
17:08  srakin: lunaphyte_, it should be called GNU/Linux
17:08  prince_jammys: oh boy
17:08  srakin: TheBonsai, thanks, i think so too.
17:08  TheBonsai: lunaphyte_: check "ip link" and related subcommands.
17:09  lunaphyte_: TheBonsai: i'll do that, thanks for the hint.
17:09  srakin: lunaphyte_, look at the contents of /proc/net/dev
17:13  mhahe: anyone here uses bash in conjuncture with another scipting language, such as python or php?
17:14  srakin: mhahe, perl and vimscript.
17:14  lunaphyte_: both ip link show and the contents of /proc/net/dev look to require about the same amount of processing as the output of ifconfig.  ideally, i'd love to find a method that mimics freebsd'd ifconfig -l behavior.
17:14  prince_jammys: mhahe: not really
17:14  prince_jammys: i speak for everyone. well, anyone.
17:15  mhahe: so there is no real need for it anywhere?
17:15  prince_jammys: ambiguous pronoun
17:16  prince_jammys: you might invoke a program written in python/php from bash, sure.
17:17  prince_jammys: or you might use bash as a wrapper
17:18  srakin: lunaphyte_, a=($(cut -d: -sf1 /proc/net/dev)); for i in "${a[@]}"; { [[ $i == eth* ]] && { echo we will enumerate $i;}; } # isn't really difficult processing
17:18  mhahe: if you dont mind me asking, what do you mean by "wrapper"?
17:18  srakin: !wrapper
17:18  greybot: http://mywiki.wooledge.org/WrapperScript
17:18  TheBonsai: lunaphyte_: how do you process it? it's just a line of AWK
17:18  prince_jammys: a script that does some minor processing of say, arguments, before invoking the "real" program
17:18  srakin: greybot, yeah, baby, yeah!
17:18  TheBonsai: lunaphyte_: (since i don't know AWK, it may be even shorter)
17:19  prince_jammys: mhahe: e.g. on my system, /bin/gunzip is a wrapper.
17:20  lunaphyte_: i never said it was difficult.  just looking for the straightest path to a destination.
17:21  TheBonsai: awk '$1 ~ "^[[:digit:]]+:" { gsub (":$", "", $2); print $2; }' is the one i came up with my limited AWK knowledge
17:21  srakin: lunaphyte_, then steal a C-code of enumeration from ifconfig
17:21  TheBonsai: srakin: which makes it even worse :)
17:21  detrate: how do I remove "./" from find results without sed? I imagine find has a way to do this
17:22  srakin: TheBonsai, /proc contains files, that should be interpreted with something like csv reader (especially cut)
17:23  srakin: detrate, with awk or perl.
17:23  TheBonsai: lunaphyte_: could be simplified with ip -o (one line per record)
17:23  prince_jammys: or cd, maybe
17:23  prince_jammys: err, not cd, but "$PWD"
17:24  srakin: detrate, perl -npe 's|^./||'
17:24  detrate: so find has no way built in?
17:24  srakin: detrate, no, find has it.
17:24  detrate: how would I do it purely with find?
17:24  mhahe: prince_jammys, thanks
17:24  prince_jammys: welcome
17:25  prince_jammys: detrate: depending on your version of find. see -printf
17:26  detrate: alright thanks, that worked
17:28  srakin: i'm an idiot and just don't know how to be healed of this kind of illness.
17:28  prince_jammys: which?
17:28  srakin: holy hell, i'm really making such mistakes as ''s|^./||'' in scripts
17:29  TheBonsai: srakin: especially for /proc/net/dev you don't need a ready CSV parser
17:29  prince_jammys: nothing wrong with it, unless you're bashing yourself for not escaping the dot.
17:29  TheBonsai: he could mean ^./
17:29  TheBonsai: how should we know
17:31  srakin: TheBonsai, no, files of /proc/ should be parsed by libproc C-library or with CSV parser or with special yacc or bison parsing scheme
17:32  TheBonsai: srakin: and that makes my statement above exactly what?
17:32  sybariten_web: hi
17:32  consumerism: does bash do backreferences? i want to symlink a bunch of files at once with a regex for the target and a backreference for the link name...possible?
17:33  TheBonsai: srakin: /proc/net/dev is easy to parse using the shell, it doesn't mean it's the official way, but it's rediculus easy to code
17:33  srakin: TheBonsai, idk. forgive me for inconvenience and forget it, please.
17:33  sybariten_web: i'm using this line in a script, in order to try and log a bit...    echo $(date +%Y/%m/%d--%H:%M:%S) ": Running script" ${0##*/} "from" ${0%/*} "via" $(hostname) >>   some.log      i copied the variables from various search escursions i've done in google
17:33  srakin: !google
17:33  greybot: Google is NOT a preferred source for learning bash, because 90% of the "tutorials" and scripts out there are JUNK. Instead, ask a good question here or refer to the Guide and FAQ (see topic)
17:34  prince_jammys: 1. zap the echo
17:34  sybariten_web: but the path name seems kinda relative, i'd like something that stretches from the root , and preferably evaluates a link, if possible. Any ideas?
17:34  sybariten_web: uh, in other words, its the ${0%/*} i'm thinking of
17:35  TheBonsai: possible (with the usual limitations about absolute names and getcwd() )
17:35  TheBonsai: !faq location > might be near
17:35  greybot: might be near: http://mywiki.wooledge.org/BashFAQ/028 -- How do I determine the location of my script?  I want to read some config files from the same place.
17:35  srakin: sybariten_web, call your script by a full path and don't use "${0##*/}" expansion
17:36  sybariten_web: thanks bonsai
17:36  srakin: sybariten_web, so if you'll call script as /var/www/user/script, then $0 will contain "/var/www/user/script"
17:36  srakin: sybariten_web, and that'll be usable in log
17:36  TheBonsai: srakin: and while you're at it, completely eliminate the need for PATH. it's just a waste of memory ;)
17:36  sybariten_web: srakin: ok but in this very case i'd like to present the script name first, the path afterwards...
17:37  srakin: TheBonsai, PATH is really a waste of 1kb of memory.
17:37  srakin: TheBonsai, so we shouldn't implement this variable in our future operating systems
17:37  TheBonsai: srakin: i'm lazy, i consider a PATH search as feature
17:38  TheBonsai: !pebasename > sybariten_web
17:38  greybot: sybariten_web: Mangling file- and dirnames with parameter expansion: http://wiki.bash-hackers.org/syntax/pe#substring_removal
17:38  TheBonsai: these are the snips to extract basenames and stuff
17:38  srakin: TheBonsai, PATH is evil. it makes our system calls unusable in suid programs!
17:38  srakin: TheBonsai, unusable because of unsafety
17:39  prince_jammys: what's your alternative?
17:39  sybariten_web: so, in essence, this isnt a trivial issue then?
17:39  srakin: prince_jammys, eliminate it and call programs by full names always
17:39  sybariten_web: (considering the wooledge link)
17:39  TheBonsai: srakin: oh, you're one of those "blash/white" guys? there are only good and only evil features in computing, nothing inbetween?
17:39  TheBonsai: *blask
17:39  prince_jammys: you'll get no love from humanity
17:39  TheBonsai: er
17:40  TheBonsai: *black
17:40  sybariten_web: blask is the new black
17:40  sybariten_web: whereas blash is the new blask
17:40  srakin: TheBonsai, all so-called "features" are evil, the gifts of satan
17:40  TheBonsai: srakin: so wipe this POSIX compilant OS. UNIX-like OS have far enough design problems
17:40  prince_jammys: blash is the bourne loser (again) shell
17:41  TheBonsai: hehe
17:42  prince_jammys: you can always PATH= in your profile
17:43  srakin: prince_jammys, sh of busybox has "complete unavailability of variables setting" option.
17:44  srakin: prince_jammys, all shell variables are going to be hardcoded and it'll be impossible to change them somehow (even in script)
17:45  prince_jammys: i'd rather not worry about PATH
17:46  prince_jammys: i prefer to worry about money
17:46  TheBonsai: unset MONEY then
17:46  prince_jammys: readonly MONEY
17:47  TheBonsai: heh
17:48  prince_jammys: # echo $BASH_VERSION
17:48  evalbot: prince_jammys: 3.2.33(1)-release
17:48  prince_jammys: good ole 3
17:49  TheBonsai: same here (though 4.0-4.2 are installed and tested)
17:50  prince_jammys: i have 4, but use none of its features
17:51  TheBonsai: i experimented with hashes and case-changing PE, but that's all
17:51  TheBonsai: nothing essentially needed for now
17:52  ritzt3ch: is there a way to use links -dump to some how auto login to a webpage or is that possibilly a different method
17:53  prince_jammys: you'll likely need something fancier, a la Mechanize
17:53  TheBonsai: depends on the website's authentication mechanisms. tried to give auth info?
17:54  SiegeX: # var=a:b:c; IFS=: set -- $var; echo $2
17:54  evalbot: SiegeX: no output
17:54  SiegeX: hmm, shouldn't that say 'b' ?
17:54  srakin: ritzt3ch, use curl to log in and get html and then use links -dump to render it into readable text
17:54  prince_jammys: SiegeX: semicolon
17:55  ritzt3ch: swibby
17:55  ritzt3ch: will look at curl
17:55  prince_jammys: # var=a:b:c; IFS=:; set -- $var; echo $2
17:55  evalbot: prince_jammys: b
17:55  SiegeX: ahh. ive seen alot of times where IFS is set in-line, say right before 'read'
17:55  SiegeX: whats the diff?
17:55  prince_jammys: otherwise $var has already expanded
17:56  TheBonsai: SiegeX: the time $var expands
17:56  SiegeX: oh
17:56  SiegeX: that makes sense, thanks
17:56  prince_jammys: IFS directly affects read's mechanism, so that's different
17:56  TheBonsai: read as: read's read mechanism
17:56  TheBonsai: :D
17:58  prince_jammys: this is in the faq now
17:58  prince_jammys: somewhere in the 90's
17:59  SiegeX: # DIR=/opt/app/classes; JARS=a.jar:b.jar:c.jar; IFS=:;set -- $JARS; for jar; do path+=$DIR/$jar:; done; echo $path
17:59  evalbot: SiegeX: /opt/app/classes/a.jar /opt/app/classes/b.jar /opt/app/classes/c.jar
17:59  SiegeX: ohh
17:59  SiegeX: hah n/m my question
17:59  prince_jammys: !faq 104
17:59  greybot: http://mywiki.wooledge.org/BashFAQ/104 -- Why doesn't foo=bar echo "$foo" print bar?
17:59  SiegeX: was going to ask why the spaces
17:59  prince_jammys: somewhat related
17:59  SiegeX: but then its due to IFS=:
17:59  SiegeX: and no quotes
18:00  SiegeX: hmm, quoting path+="$DIR/${jar}:" doesn't seem to help
18:00  srakin: old_IFS=$IFS; before all and IFS=$old_IFS; before echo
18:01  prince_jammys: SiegeX: quote when you echo
18:01  prince_jammys: the colons should be there
18:01  prince_jammys: the assignment is OK
18:01  SiegeX: ah, so they are
18:01  TheBonsai: word splitting ftw
18:01  prince_jammys: you were hit by wordsplitting, only now with :
18:02  srakin: ... and quotes on echo "$path"
18:04  prince_jammys: # IFS=banana foo=bandana; echo $foo
18:04  evalbot: prince_jammys:    d
18:04  srakin: # oi=$IFS; DIR=/opt/app/classes; JARS=a.jar:b.jar:c.jar; IFS=:;set -- $JARS; for jar; do path+=$DIR/$jar:; done; IFS=$oi; echo $path
18:04  evalbot: srakin: /opt/app/classes/a.jar:/opt/app/classes/b.jar:/opt/app/classes/c.jar:
18:04  srakin: "$path" is safer
18:06  SiegeX: hmm, I thought it was for-loops I could use { } instead of do/done. Maybe it was 'while'
18:06  prince_jammys: no, i've seen it
18:06  srakin: # for i in 1 2 3; { echo $i;}
18:06  evalbot: srakin: 1
18:06  evalbot: srakin: 2
18:06  evalbot: srakin: 3
18:07  SiegeX: must havea got my semicolons in the wrong place then
18:07  SiegeX: ah, was missing the one before the {
18:07  srakin: # while [[ $a != aaa ]]; do a+=a; echo $a; done
18:07  evalbot: srakin: a
18:07  evalbot: srakin: aa
18:07  evalbot: srakin: aaa
18:08  prince_jammys: you can't use { } in a while because of ambiguity
18:08  srakin: it's good to avoid using {} if for too
18:08  steven_t: hey guys
18:08  prince_jammys: i never do
18:08  steven_t: what does ". file" do in bash?
18:08  prince_jammys: !source
18:08  greybot: ''source <script>'' or ''. <script>'' reads and executes the commands from <script> into the current shell, only one script per invocation the rest is passed as arguments to it
18:08  srakin: because of ... highlighting in emacs problems...
18:08  steven_t: i think its bash specific, because ive never seen it before and it doesnt work in zsh
18:08  prince_jammys: not bash specific, see above.
18:09  srakin: steven_t, 'source' keyword is more readable. use it
18:09  SiegeX: how portable is { }? I know it exists in ksh, in fact I think thats where it came from
18:09  prince_jammys: steven_t: i'm very surprised that it doesn't work in zsh
18:09  srakin: SiegeX, think of it as it's bug, completely unportable
18:09  srakin: SiegeX, that's easter egg of bash >=3
18:11  SiegeX: I believe it's documented in the info
18:11  SiegeX: actually, it was ash not ksh where it came from
18:11  srakin: SiegeX, that's not a historical feature, just random impelementation
18:12  srakin: SiegeX, and it's not documented anywhere
18:12  steven_t: thanks
18:14  SiegeX: srakin: it is a historical feature, I remember asking chet about it
18:14  SiegeX: and it's in the ash man page for sure
18:14  srakin: i'll hire a detective for investigation.
18:15  srakin: maybe even a pet detective
18:15  SiegeX: I charge $100/second --> "The words are expanded, and then the list is executed repeatedly with the variable set to each word in turn.  do and done may be replaced with ``{'' and ``}''."
18:15  prince_jammys: a penthouse pet detective
18:15  SiegeX: $300 por favor
18:15  prince_jammys: clearly you are a lawyer
18:16  SiegeX: hehe, obv
18:20  SiegeX: although I think the pethouse pet dectective may be a more fulfilling job ;)
18:20  prince_jammys: you can buy a penthouse pet detective after one week's work at $100/sec
18:28  SiegeX: How much just for the penthouse pet?
18:29  prince_jammys: i bet they'll settle for as little as $10/second
18:30  SiegeX: awesome, I can afford $600
18:30  JordiGH: what could be setting my LANG? I don't see the variable in /etc/bash.bashrc nor in my .bashrc nor in any files called by my .bashrc
18:31  JordiGH: On Debian.
18:31  cthuluh: JordiGH: /etc/default/locale
18:32  JordiGH: cthuluh: Yeah, that's disagreeing with my LANG.
18:33  JordiGH: Hm, it doesn't seem to be in /etc/profile either
18:34  cthuluh: JordiGH: (ugly) grep -FR LANG /etc/
18:34  prince_jammys: check your user's profile
18:34  cthuluh: I hope he already did...
18:37  JordiGH: How can I debug bash? Like, start a new bash and make it say what lines it's executing at startup?
18:37  TheBonsai: set -v
18:38  JordiGH: So... bash -v ?
18:38  prince_jammys: yes
18:39  JordiGH: Okay, this should help...
18:39  prince_jammys: echo $LANG at the top of your profile should be useful
18:40  prince_jammys: this way you'll see if it's even bash who's the culprit
18:41  JordiGH: Well, someone is telling bash to set that variable...
18:42  JordiGH: Huh, I can't seem to echo from my .bash_profile
18:43  e36freak: .bash_profile only runs when you first log in, are you looking for .bashrc?
18:43  e36freak: and you should be able to echo from either
18:44  JordiGH: Huh. There we go. Logging in and out fixed my LANG.
18:44  JordiGH: Well, logging in from a different tty.
18:44  e36freak: "source ~/.bash_profile" should also do it
18:45  TheBonsai: or bash -l
18:46  JordiGH: No, neither of those seem to do it.
18:46  JordiGH: Oh well, brb.
18:46  lunaphyte_: given a mac address, containing delimiters (e.g. colons, dashes, etc), how can i remove the delimiters?  or, how can i obtain the system's mac address, excluding any delimiters?
18:47  e36freak: sed should remove the delimiters
18:47  TheBonsai: tr -d :
18:48  lunaphyte_: great, thank you.
18:49  Bushmills: # mac="00:11:22:33:44:55"; echo "${mac//:/}"
18:49  evalbot: Bushmills: 001122334455
18:49  JordiGH: This didn't fix it.
18:50  JordiGH: If I log in to a tty, I get a different LANG than if I open an xterm in Gnome.
18:50 * JordiGH wonders if GDM is setting LANG.
18:50  e36freak: JordiGH: do you have anything in .bashrc?
18:50  TheBonsai: blame your system vendor
18:50  JordiGH: e36freak: Yeah.
18:50  e36freak: you can export the proper one in .bashrc as a hack
18:50  prince_jammys: suspect the gui
18:50  JordiGH: Yeah, I think Gnome is doing something wrong.
18:51  prince_jammys: i bet
18:51  e36freak: GDM is probably a good place to look
18:51  TheBonsai: depends if you can say "wrong"
18:51  e36freak: i doubt its gnome, but GDM can do some weird stuff
18:51  prince_jammys: first thing i suspected, at least.
18:51  TheBonsai: i mean, why should it read your bash startup files?
18:51  e36freak: haha
18:51 * e36freak starts X manually
18:52  Bushmills: actually, last slash not needed:
18:52  Bushmills: # mac="00:11:22:33:44:55"; echo "${mac//:}"
18:52  evalbot: Bushmills: 001122334455
18:52  Bushmills: lunaphyte_: ^^^
18:52  e36freak: bash supports if command; else foo; bar; fi with no then right?
18:52  prince_jammys: he doesn't have LANG set in his files, but apparently ends up with a different LANG than set in /etc/default/locale (debian)
18:52  e36freak: i could do command || foo but itd be nice to use an actual if statement here
18:52  prince_jammys: e36freak: no
18:52  TheBonsai: e36freak: tias
18:52  TheBonsai: e36freak: according to syntax, no
18:53  JordiGH: brb
18:53  e36freak: if command; then : ; else foo; bar; done then?
18:53  lunaphyte_: Bushmills: thanks, that works too.
18:53  prince_jammys: 'if' can take a series of commands (a "list"), so the "then" is necessary
18:53  e36freak: kk
18:53  TheBonsai: e36freak: yes, or if ! command; then ...; fi
18:53  e36freak: yeah, makes sense
18:54  TheBonsai: it's #bash
18:54  TheBonsai: we make sense
18:54  TheBonsai: :P
18:54  e36freak: heh
18:55  e36freak: and i could do say, if ! newsum=$(git rev-parse origin); then rm foo; return 1; fi
18:55  JordiGH: Yeah, gdm is setting the LANG...
18:55  JordiGH: and setting it wrong.
18:55  JordiGH: wtf
18:56  TheBonsai: e36freak: yes
18:56  e36freak: excellent
18:56  TheBonsai: e36freak: unless the variable setting fails for another reason, you should get the exit code of the $()
18:57  e36freak: i thought so
18:57  e36freak: i was just gonna use newsum=$(git rev-parse origin) || return 1 but i wanted to add some other stuff in there and expand it into a full if statement
18:59  TheBonsai: you can always group commands with { }
19:01  e36freak: also true
19:01  e36freak: i just like the indentation and newlines, makes it nice and pretty to read/edit
19:01  prince_jammys: yep
19:02  TheBonsai: foo || \
19:02  TheBonsai:   { bar; }
19:02  TheBonsai: foo || {
19:02  TheBonsai:   bar
19:02  TheBonsai:   baz
19:02  TheBonsai: }
19:02  e36freak: yeah, i know
19:03  e36freak: but is there a real advantage to that over if ! foo; then ?
19:03  prince_jammys: no
19:03  isaacs: how do i get the bot to tell me that link to the portable shell scripting tips?
19:04  isaacs: i could swear i've seen it here before.
19:04  prince_jammys: !posix
19:04  greybot: The POSIX standard defines what any modern unix should supply. Sticking to the commands and options in http://www.opengroup.org/onlinepubs/9699919799/utilities/contents.html will do wonders for the portability of your scripts.
19:04  isaacs: ack!! thanks!!!
19:04  prince_jammys: welcome
19:04  isaacs: prince_jammys: oh, no wait, it wasn't that...
19:04  isaacs: it was more specific.
19:04  prince_jammys: yeah, that's not condensed
19:04  prince_jammys: !portable
19:05  jordanm: that link isn't the actual POSIX.1 standard document is it?
19:05  jordanm: the "introduction" indicates that it is...
19:05  prince_jammys: isaacs: i don't think i've seen that doc.
19:06  isaacs: ok, more specific question that addresses my immediate use case rather than my general education (aka "Give me a fish, please") --
19:06  isaacs: i'm told that "which" is unreliable.  what's a better alternative
19:06  isaacs: ?
19:06  prince_jammys: type
19:06  isaacs: kewl, thanks
19:06  prince_jammys: !faq in my path
19:06  greybot: http://mywiki.wooledge.org/BashFAQ/081 -- How can I determine whether a command exists anywhere in my PATH?
19:07  prince_jammys: there are a few different ways
19:07  isaacs: yeah
19:08  isaacs: every time i have to write something that has to work in sh, i'm reminded how much i LOVE bash
19:08  isaacs: sh is like bash without everything awesome.
19:08  isaacs: </rant>
19:08  isaacs: thanks
19:08  prince_jammys: there's also 'command'. see that url
19:08  prince_jammys: /topic #!/bin/sh
19:09  e36freak: and grep will return 1 if it doesnt find a result? if oldsum=$(grep ${pkg} foo); then $pkg was found; else it wasnt; fi
19:09  prince_jammys: yes
19:09  e36freak: excellent
19:28 --- winkey_ is now known as winkey
19:34  craiggles: hey guys, im wanting to know how i could play a random mp3 file in the current directory with mplayer.
19:34  greycat: !faq random
19:34  greybot: http://mywiki.wooledge.org/BashFAQ/026 -- How can I randomize (shuffle) the order of lines in a file?  (Or select a random line from a file, or select a random file from a directory.)
19:40  isaacs: prince_jammys: it was this thing: http://www.gnu.org/software/hello/manual/autoconf/Limitations-of-Usual-Tools.html
19:40  isaacs: prince_jammys: which incidentally doesn't answer the question i had ;)
19:41  craiggles: so yeah i'm wanting to get better with linux and i'm using the terminal more and more so i'm guessing learning bash will be a good thing to do :)
19:41  greycat: !guide
19:41  greybot: http://mywiki.wooledge.org/BashGuide
19:43  craiggles: yeah cheers, i had a quick glance but i should really read it.
20:01  grosboulet: Hello
20:01  grosboulet: How can I check if $1 is an integer ?
20:02  greycat: !faq valid
20:02  greybot: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
20:02  grosboulet: thanks
20:06 --- isaacs_ is now known as isaacs
20:13  visof: hello
20:13  visof: i have file in that format : 20,12,"hello"\n12,34,"how are you"\n ....
20:14  sente: spectacular
20:14  visof: i want to replace the first column 20,12,.... to start from 1,2,3,4,...
20:14  visof: how can i do that ?
20:14  greycat: Sounds like a job for awk.
20:15  greycat: awk -F, '{$1 = (NR-1)*2+1; $2 = NR*2; print $1","$2","$3}'
20:15  greycat: or similar
20:24  sente: different/silly: K=0; while IFS=, read a b c; do echo "$((++K)),$((++K)),$c" ; done < yourfile
20:24  sente: i think it'd work anyhw
20:24  greycat: varcaps...
20:24  greycat: But yes, that should work.
20:25  tharkun: !function
20:25  greybot: To define: funcname() { your code here; } ## To use: funcname arg1 arg2 ... ## function http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
20:26  sente: greybot: hrm? d' you just mean the 'K' should be 'k', or something else?
20:26  sente: s/greybot/greycat/
20:26  greycat: !varcaps
20:26  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
20:28  skered: visof: 02:15PM      visof: i want to replace the first column 20,12,.... to start from 1,2,3,4,...
20:28  skered: visof: wtf does that mean?
20:29  greycat: !forget varcaps
20:29  greybot: OK, greycat
20:29  greycat: !learn varcaps By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
20:29  greybot: OK, greycat
20:30 * krzie loves your bot
20:30  greycat: Changing a factoid like that is somewhat primitive.  Most infobot-types can do a substitution.
20:30  sente: skered: yeah i was slightly confused by his wording as well
20:30  Dribble: thats a bot
20:31  greycat: sente: skered: I took a guess what he meant.  He hasn't complained.
20:31  krzie: right, my bot is the same for factoids, i just meant how well learned it is
20:31  alesan: hi
20:31  sente: yeah, and i followed you lead
20:32  greycat: I'm impressed by how well he described the input file format.  That's WAY better than what we usually get.
20:32  Dribble: i only want the first section of text in a large file how do I just grab this first part?
20:32  alesan: how do I transform a variable like 'arm-none-linux-gnueabi-gcc' in 'arm-linux-gcc'? Basically I need to remove the 2nd and 4th part of the name
20:33  Dribble: and I need it to grab the first part of each line to another file
20:33  krzie: "first part" ?
20:33  Dribble: yeah lest say its apple       apples are great I just need the apples part
20:33  edgy: Hi, is ctrl-D a signal? so I can trap it
20:34  greycat: You want the first word of each line, where "word" is defined to mean "up to the first whitespace"?
20:34  greycat: edgy: no
20:34  Dribble: yes
20:34  erUSUL: edgy: crtl + D is "EOF" on most contexts afaik
20:34  greycat: Dribble: awk '{print $1}'
20:34  Dribble: thanks
20:34  greycat: Ctrl-D as EOF when typing on a terminal in canonical input mode is handled by the tty driver.  See stty(1).
20:34  krzie: # echo "apple       apples are great"|cut -d" " -f1
20:34  evalbot: krzie: apple
20:35  krzie: # echo "apple       apples are great"|awk '{print $1}'
20:35  evalbot: krzie: apple
20:35  greycat: krzie: you're assuming it will always be a literal space, instead of possibly a tab...
20:35  edgy: greycat: so if some one wants to ignore it or trap it, what can he do?
20:35  greycat: well, the first one assumes that.
20:35  greycat: edgy: don't use canonical input mode
20:36  krzie: right
20:36  greycat: edgy: or are you talking about an interactive shell?
--- Log closed Tue Dec 21 20:40:05 2010
--- Log opened Tue Dec 21 20:40:31 2010
20:40 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
20:40  Dribble: trying to copy the names of the flight gear aircraft to another file where I just take the first part that has the aircraft id in it so I can use it in a case statement
20:41  greycat: Show us the actual line.
20:41  sente: Dribble: pastebin
20:41  edgy: greycat: because of what?
20:41  Dribble: whats that
20:41  greycat: History?  Random insanity?
20:41 --- Channel #bash was synced in 85 seconds
20:42  sente: Dribble: go to www.pastebin.com and show us the file
20:42  Dribble: ok
20:42  greycat: Or just the first, say, 10 lines of the file.
20:42  Dribble:  747-200                      Boeing 747-200
20:42  Dribble:    777-200ER                    Boeing 777-200ER
20:42  Dribble:    787                          Boeing 787-8
20:42  Dribble:    A380                         Airbus A380
20:42  Dribble:    A380-House                   Airbus A380-House
20:43  Dribble: and I just need the 747-200 part's
20:43  greycat: So there's a random amount of white space at the *start* of each line too?
20:43  sente: while read a b c; do echo $a; done < file
20:43  e36freak: what is the glob equivalent of "[0-9]+" ?
20:44  greycat: Can't be done with a pure glob.  You'd need an extended glob.
20:44  erUSUL: !extglob
20:44  greybot: "Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob
20:44  e36freak: thank you sir
20:44  greycat: Extended globs are as expressive as EREs.
20:44  Dribble: great thanks for your help that worked perfect
20:44  e36freak: kk
20:46  edgy: greycat: I am reading man bash and I see [-+]O [shopt_option] // isn't it strange to have O in Capital, it should be small, no?
20:46  greycat: eh... what?  I'd have to see the context.
20:47  greycat: "In addition to the single-character shell options documented in the description of the set builtin command, bash interprets the following options when it is invoked:"
20:48  greycat: imadev:~$ bash-3.2.48 -O extglob -c '[[ 42 = +([0-9]) ]] && echo yes'
20:48  greycat: yes
20:48  greycat: imadev:~$ bash-3.2.48 -c '[[ 42 = +([0-9]) ]] && echo yes'
20:48  greycat: bash-3.2.48: -c: line 0: syntax error in conditional expression: unexpected token `('
20:48  greycat: bash-3.2.48: -c: line 0: syntax error near `+(['
20:48  greycat: bash-3.2.48: -c: line 0: `[[ 42 = +([0-9]) ]] && echo yes'
20:52  e36freak: is there a difference between foo[0-9]bar and foo@([0-9])bar ?
20:52  greycat: Yes.
20:52  greycat: One of them is an extended glob, and the other is not.
20:52  e36freak: ahh, ok. so the *() is needed, which i guess was the real question
20:54  tm512: I'm having problems exporting functions for use in subscripts called
20:54  greycat: "subscripts"?
20:55  tm512: as in, one script will define some functions, and then it will call another script
20:55  greycat: The other script needs to be bash.
20:55  tm512: the script it calls needs to have the same functions
20:55  tm512: it is
--- Log closed Tue Dec 21 20:59:22 2010
--- Log opened Tue Dec 21 21:14:50 2010
21:14 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
21:15  greycat: Well, actually I guess *\ @* doesn't guarantee that the @ is in field 2.  It could be in field 32.
21:15  greycat: *shrug* an extglob could guarantee it, though.
21:15  greycat: or =~ for you perverts who use that shit
21:15  tm512: anyway, the line that calls uptime script is
21:15  tm512: eval "nick="$1" host="$2" chan="$3" ./scripts/$(cut -d" " -f1 <<< "$r")"
21:16 --- Channel #bash was synced in 78 seconds
21:16  greycat: oh. my. god.
21:16  steve___: :)
21:16  The-Compiler: greycat: what's wrong with =~ ?
21:16  tm512: could it be that eval doesnt pass on exports?
21:16  greycat: !regex
21:16  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
21:16  The-Compiler: !eval > tm512
21:16  greybot: tm512: 'eval' is a common misspelling of 'evil'. If eval is the answer, surely you are asking the wrong question. See http://mywiki.wooledge.org/BashFAQ/048
21:16  greycat: tm512: Your quoting is completely fucked.
21:17  The-Compiler: greycat: well I got an XKCD "Stand back for me, I know regular expressions" shirt :p
21:17  TheBonsai: wahahaha
21:17  greycat: !perl
21:17  greybot: http://xkcd.com/208/
21:17  The-Compiler: yep :D
21:17  steve___: tm512: "nick="  " host="  ... etc
21:18  greycat: tm512: as steve___ is trying to say (I think) you have a quoted string "nick=" and then an unquoted $1 and then a quoted string " host=" and then an unquotd $2, etc.
21:18  tm512: how do i fix that anyway
21:18  greycat: AND THEN you pass the whole resulting mess to eval.
21:19  tm512: is it eval that doesnt pass on the functions i exported?
21:19  greycat: Might as well just have the bot tell everyone your system's password in /msg when it joins the channel.
21:19  TheBonsai: do not try to shell until you can quote!
21:19  greycat: tm512: The issue with functions is so minor compared to the issues you have with quoting that it's a GOOD thing your script is failing.
21:19 * TheBonsai loves inventing new words
21:19  greycat: And no, eval has nothing to do with your inability to define a function.
21:20  e36freak: The-Compiler: nice, thats one of my favorites. that and the "import antigravity" python one
21:21  greycat: # printf '#!/bin/bash\neval func\n' > script; chmod +x script; func() { echo func; }; export -f func; ./script
21:21  evalbot: greycat: func
21:21  greycat: See?  The eval, it does nothing.
21:21  tm512: the eval was to run an external script
21:21  greycat: That is not what eval does!
21:22  greycat: eval causes another parsing of the current line.  Instead of parsing once, it gets parsed twice.
21:22  greycat: Usually because you want the contents of a variable to be parsed.  And executed.  And this is a HUGE security issue 90% of the time.
21:22  tm512: that's how i've seen it used with feh and xinitrc: eval `cat $HOME/.fehbg`
21:23  greycat: That's a stupid way to write  source ~/.fehbg
21:23  tm512: so I want : nick="$1" host="$2" chan="$3" source ./scripts/...
21:24  greycat: nick="$1" host="$2" chan="$3"; source ./scripts/foo
21:24  tm512: ok
21:24  greycat: But source does not RUN a script.  It READS the content of a script and executes that content in the *current* shell.
21:24  greycat: If you just wanted to RUN a script, then you'd not use source.
21:25  tm512: if I used source then I wouldnt need worry about exporting functions then
21:25  pigdude: how do I hide first 3 lines of output?
21:25  tm512: correct?
21:25  greycat: sed 1,3d
21:25  pigdude: greycat: thanks, perfect
21:26  tm512: i changed the line to
21:26  tm512: nick="$1" host="$2" chan="$3"; source ./scripts/"$(cut -d" " -f1 <<< "$r")"
21:26  pigdude: greycat: what about the last line?
21:26  greycat: sed '$d'
21:27  greycat: !faq 100 > tm512
21:27  greybot: tm512: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
21:28  pigdude: greycat: do you know how to chain these? I thought it was -e exp -e exp but that is not working for me
21:28  tm512: pigdude: exp;exp
21:28  greycat: printf '%d\n' {1..10} | sed -e 1,3d -e '$d'
21:29  greycat: Works here.  Both Unix and GNU sed.
21:29  tm512: sed 's/blah/heh/;s/blah2/heh2/'
21:30  pigdude: tm512: thanks
21:30  pigdude: greycat: hm, I must've done something wrong
21:32  tm512: can I get an answer for: "if I used source then I wouldnt need worry about exporting functions then"
21:32  TheBonsai: what?
21:32  greycat: It would totally depend on how your design works.
21:33  greycat: The obvious first question being "why is your bot spread across multiple files in the first place?"
21:33  pigdude: is there a way to turn join lines of output on a delimiter?
21:33  pigdude: `join` seems useful but uses files
21:33  pigdude: I want to turn a\nb to a,b
21:33  greycat: pigdude: tr '\n' '|'
21:33  pigdude: or similar
21:34  pigdude: greycat: oh, good call
21:34  tm512: greycat: because people should be able to add shell scripts to the scripts folder, and add necessary lines to the commands file
21:34  tm512: extend on-the-fly
21:34  greycat: I really don't think you're experienced enough with shell programming to succeed at this, but good luck....
21:35  tm512: I already have a bot, i just want it to be able to do this new command thing
21:35  greycat: Now I'm terrified.
21:35  greycat: You have an eval monstrosity up and RUNNING?!
21:36  tm512: no, the eval stuff didnt work
21:36  agentgasmask: Hi. How can I subtract a 18.34 from 17.87 and end up with -0.47 in bash? I've tryed "let"...
21:36  greycat: So, do you want these "extension functions" to run in the bot's shell process, or in child processes?
21:37  greycat: !faq float > agentgasmask
21:37  greybot: agentgasmask: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
--- Log closed Tue Dec 21 21:40:45 2010
--- Log opened Tue Dec 21 21:46:11 2010
21:46 --- Users 559 nicks [0 ops, 0 halfops, 0 voices, 559 normal]
21:46  yates: heh - i wrote this thing - a coupel years' back - now i don't understand it!
21:46  tm512: there were never any functions defined in a child script
21:47  tm512: i just wanted child scripts to have access to them
21:47  greycat: And I showed you that.  In action.  Twice.
21:47 --- Channel #bash was synced in 80 seconds
21:47  tm512: but it wasnt working for me until I used "source"
21:47  greycat: Then you fucked up.  Unfuck it.
21:48  tm512: im not even exporting the functions anymore because it sounds like source is just what I needed
21:48  tm512: the stuff in the child processes should be run as if they were in the parent process
21:49  tm512: only reason they're seperate is because its cleaner
21:49  tm512: and can be changed while the bot is running
21:50  yates: pigdude: do you know ms piggie?
21:50 * yates runs...
21:58  pigdude: yates: you won't say a word about her!
21:58  pigdude: yates: and that's mRs piggie
22:11  pigdude: why is there no output when I split lines 9-14 as I have here? http://paste.pocoo.org/show/308082/
22:13  greycat: two seds, an awk, a grep and a tr!
22:13  greycat: my god...
22:13  greycat: Well, we don't know why there's "no output".  Run each command one at a time and see what's happening to your stream.
22:13  pigdude: greycat: hey, let's not pretend I know what i'm doing
22:13  greycat: mysql > tmp1
22:13  pigdude: greycat: but yea, upon further analysis, it seems to have to do w/ me pulling out hardcoded vals
22:14  greycat: sed <tmp1 >tmp2
22:14  greycat: etc.
22:15  pigdude: ah, how do I turn on tracking again?
22:16  pigdude: there is a way to have bash log each command
22:17  pigdude: I cannot remember the option
22:17  greycat: !faq losing
22:17  greybot: http://mywiki.wooledge.org/BashFAQ/088 -- How can I avoid losing any history lines?
22:17  erUSUL: pigdude: run « script » ?
22:17  Samus_Aran: how can I check if a key has been pressed, without a 1 second timeout like with 'read'?  this is in a rapid loop, wanting to exit once a key is pressed.
22:17  greycat: Samus_Aran: requires bash 4.0.
22:18  pigdude: ah, set -x
22:18  pigdude: erUSUL: ^^
22:18  Samus_Aran: greycat: I don't mind using weird hacks.  I know it's possible, I played Tetris written in Bash.
22:19  greycat: You can specify -t 0 in bash 4.
22:19  greycat: Can't be done in bash <= 3
22:20  Samus_Aran: I am on version 4.0.33(1)-release, and the -t 0 does not work, it never acknowledges the keypresses, but it does with -t 1
22:20  pigdude: greycat: ah, the issue was $PREFIX was not defined
22:20  pigdude: greycat: so the grep -v was removing all lines
22:23  Samus_Aran: greycat: any other suggestions?
22:23  greycat: Yes.  Find out why it fails only for you and not for the rest of the world.
22:23  tm512: is there a way I can, mid-script, cause all output to cease from all child processes?
22:23  tm512: well, printing to stdout
22:23  greycat: !faq 106 > tm512
22:23  greybot: tm512: http://mywiki.wooledge.org/BashFAQ/106 -- I want to tee my stdout to a log file from inside the script.  And maybe stderr too.
22:23  pigdude: greycat: you found http://paste.pocoo.org/show/308086/ to be god-awful with its confluence of "two seds, an awk, a grep and a tr!", how might it be written otherwise?
22:24  pigdude: greycat: the script does work as expected
22:24  tm512: i know what tee is
22:24  tm512: so just run tee > /dev/null 2>&1 ?
22:25  greycat: Not tee.  exec.
22:25  e36freak: or &>/dev/null
22:26  Samus_Aran: greycat: it behaves as it always has for me in Bash, a timeout of 0 causes the read to be skipped altogether.
22:27  tm512: greycat: i want to redirect the output of already running processes?
22:27  tm512: -?
22:27  greycat: tm512: help exec
22:28  tm512: i don't follow
22:29  tm512: i dont want to execute a new command
22:29  mhahe: best way to read a file line by line? and also why does this not work?    ps | while read line ; do echo $line ; done
22:29  greycat: !faq 1 > mhahe
22:29  greybot: mhahe: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
22:30  erUSUL: mhahe: works here ;P
22:30  erUSUL: # ps | while read line ; do echo $line ; done
22:30  evalbot: erUSUL: PID TTY TIME CMD
22:30  evalbot: erUSUL: 1 ? 00:00:02 init
22:30  evalbot: erUSUL: etc... ( http://pastebin.com/J3T80Fz5 )
22:30  greycat: !umq
22:30  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
22:31  mhahe: actually it was:
22:32  mhahe: ps while read line ; do say hello ; done
22:32  mhahe: say is my text to speach command im using osx
22:32  mhahe: but when i want to see the last value of $line it doesnt show
22:32  mhahe: is it cause of forking?
22:33  greycat: mhahe: if you are missing the last line of output in a while read loop, generally that is because the last line is missing its newline.
22:33  Samus_Aran: greycat: is there something wrong with this test code: while true; do read -n 1 -t 0 key; [ -n "$key" ] && break; done
22:34  Samus_Aran: because read never grabs any of the keypresses, Bash 4.x.  changing only the -t 0 to -t 1 causes it to quit when a key is pressed.
22:37  greycat: Samus_Aran: Maybe it's got something weird to do with the tty.
--- Log closed Tue Dec 21 22:41:38 2010
--- Log opened Tue Dec 21 22:47:12 2010
22:47 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
22:47  spm_Draget: Despite the wiki not loading, what is wrong with my script?
22:47  spm_Draget: Oh, now it loads
22:47  e36freak: why are you mixing $() and back ticks?
22:48  \malex\: greycat: i'll disagree. especially with -o to output the proper ifnormation it's quite handy
22:48  spm_Draget: (Oh, and I know my script would also catch a 'nano rsnapshot.con', I am aware of that)
22:48 --- Channel #bash was synced in 84 seconds
22:48  e36freak: and dont use 1>/dev/null 2>&1, either just >/dev/null 2>&1 or better yet, &>/dev/null
22:48  greycat: \malex\: you'd have to bend pretty far backward to come up with a plausible scenario where it can be safely used.
22:49  greycat: !&>
22:49  greybot: &> is a bash-specific feature, unportable to other shells. command &> file is equivalent to command > file 2>&1. There is no &>> until Bash4. Use command >> file 2>&1 instead.
22:49  spm_Draget: Oh yes, removing the ` did the trick!
22:49  greycat: Some people like &>.  Some don't.
22:49  spm_Draget: Thank you e36freak
22:50  e36freak: spm_Draget: and why var=$(ps ax); echo $var | grep ...
22:50  e36freak: ps ax | grep ...
22:50  Samus_Aran: greycat: all 'stty raw' did was prevent me from being able to ^C or ^\ the loop.  I thought you said -t 0 works in Bash 4?
22:50  greycat: Samus_Aran: It did.  For me.  I tested it.
22:50  e36freak: !varcaps > spm_Draget
22:50  greybot: spm_Draget: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
22:50  greycat: I ran ./foo, waited a couple seconds, pressed l, and it stopped.
22:50  \malex\: greycat: find the pid of the current script's grandparent
22:51  spm_Draget: e36freak: ps ax | grep "something" woud obviously always succeed since grep would find itself searching for the searchstring :P
22:51  greycat: \malex\: does your back hurt? :)
22:51  \malex\: greycat: i had a valid reason to do that once :)
22:51  e36freak: spm_Draget: then you can grep -v grep, or better yet use pgrep. although the whole idea is flawed, read that wiki page
22:51  Samus_Aran: greycat: you pasted some very strange lines of code that did not involve having "read -n 1 -t 0" actually work.  I'm not talking about your six lines of code, but the -t 0 part.  my example code works perfectly fine with -t 1 but not at all with -t 0.
22:52  spm_Draget: e36freak: I just needed something really simple o.o
22:52  greycat: Samus_Aran: again, it worked for me.  My code has -t 0 in it.  It stopped immediately when I pressed l.
22:52  greycat: Samus_Aran: without the stty raw, I had to press Enter to get it to stop.
22:52  greycat: Samus_Aran: and when I ran it with a FIFO as stdin instead of a tty, I did not need the stty raw bits.
22:53  tm512: well, the whole external scripts thing has introduced old problems back into the source
22:53 * greycat wonders if it was bash 4.0 or 4.1....
22:53  greycat: !faq version
22:53  greybot: http://mywiki.wooledge.org/BashFAQ/061 -- Is there a list of which features were added to specific releases (versions) of Bash?
22:53  greycat: Damn, not listed.
22:55  greycat: CHANGES says 4.0.
22:55  pozican: if I need to delete everything in a dir except *.sh - Is there a reverse glob for that or soemthing?
22:55  pyoor: Any idea why only 1 element is being added to the array? http://pastebin.com/hk47CLwe
22:55  greycat: !extglob
22:55  greybot: "Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob
22:56  pozican: thanks greycat
22:56  spm_Draget: e36freak: Does the wiki page tell me anything on checking for a specific process at all? So far it explains to me all kind of things I already know, like hadling PIDs in bash. But I am not in the script starting the process that I look for
22:56  greycat: spm_Draget: "something simple" would usually be pkill or pgrep.  If those don't work, your problem is not simple.
22:57  e36freak: spm_Draget: it goes on to talk about it, but pgrep or pidof would be the way to do it
22:57  greycat: lhunath added a huge redundant blob of text to the start of ProcessManagement before the questions, and I'm still not quite sure how I feel about that.
22:58  pozican: Strange. My version of bash apparently doesn't like extglobs but !version says it was added in 2.02-alpha1 and I'm at 3.2.25
22:58  greycat: Did you remember to enable them?  NOT inside a function?
22:58  spm_Draget: Geeh, pgrep is exactly what I need.
22:58  pozican: I'm awesome.
22:58  pozican: thanks again greycat
22:58  spm_Draget: Why so much blahblah around it and that wikipage?
22:58  greycat: 16:57  greycat> lhunath added a huge redundant blob of text to the start of ProcessManagement  ...
22:58  spm_Draget: Would have saved me some time if I just knew abotu pgrep =)
23:00  pozican: I don't think I've ever seen greycat leave this channel
23:00  pozican: :\
23:01  Samus_Aran: greycat: if it was added to Bash 4.0, why does it not actually work under the normal usage of: read -d '' -n 1 -t 0 key
23:01  Samus_Aran: greybot: your code does seem to work, but I have no clue what it is doing.  and it certainly isn't normal usage for -t 0
23:02  pyoor: greycat left, and greybot is a bot
23:02  tm512: lool
23:02  pyoor: Any idea why only 1 element is being added to the array? http://pastebin.com/hk47CLwe
23:04  Samus_Aran: pyoor: I know greybot is a bot.  didn't notice greycat quitting.  tab-completion.
23:04 --- jzacsh_ is now known as jzacsh
23:04  pyoor: :) just giving you a heads up
23:04  Samus_Aran: pyoor: you're not creating an array, you're creating a string
23:05  pyoor: !array
23:05  greybot: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
23:06  pyoor: hrmm
23:06  Samus_Aran: $() is a way to capture output of a command and convert it into a string
23:06  pyoor: so ( $( ) )
23:06  Samus_Aran: sure
23:07  pyoor: sure as in yes or sure as in it'll work if you smell colors ? :)
23:07  pyoor:  /smell colorse/eat glue/
23:08  Samus_Aran: pyoor: it will work fine
23:08  Samus_Aran: are you trying to create an array for each line in a file, or what?
23:09  Samus_Aran: the field separator is the only thing you might need to pay attention to, depending on if you have items with spaces or tabs in them that you don't want broken up
23:10  pyoor: k, yeah only newlines
23:10  Samus_Aran: if you want to break on lines only, then you need to set the field separator: IFS=$'\n'
23:10  Samus_Aran: or else use read, which can create an array
23:12  pozican: Samus_Aran: I think that's '\n'$
23:12  pozican: pyoor: also, don't forget to unset IFS at the end of the script
23:12  steve___:   mysqlshow  "$mysql_opts" |
23:12  steve___:      awk -v OFS=" " '!/^wp_/ NR>4 {print "--ignore-table=$DB."x} {x=$2}'
23:13  steve___: oop
23:13  steve___: o/
23:13  steve___: my bad
23:14  Samus_Aran: pozican: $'' is the syntax to allow expansion of backslash operators like \t and \n
23:15  Samus_Aran: pozican: unsetting IFS would be like making it IFS='' which is different than the default IFS which would be: IFS=$'\n\t '
23:18  latenite: Hi folks, why is bash -e test not working with wildcards? http://pastebin.com/Zjxy7rvJ
23:21  Samus_Aran: latenite: what do you mean ?
23:23  Samus_Aran: latenite: your pastebin is also confusing.  I assume you're trying to check for the existence of files using a wildcard?
23:24  cthuluh: latenite: bash -e and test -e are very different things
23:24  e36freak: whats all that "stick/ #" crap?
23:24  cthuluh: latenite: globs don't work with [[
23:25  cthuluh: e36freak: CWD and login
23:25  e36freak: oh, terminal
23:25  e36freak: duh
23:25  cthuluh: latenite: well, what I said is false
23:26  cthuluh: latenite: file names expansion don't work, at least :P
23:31  e36freak: aww, he left. you could [[ -n $(ls foo/bar* 2>/dev/null) ]] && echo "true" || echo "false"
23:31  Samus_Aran: e36freak: no need to use ls in that manner, just use echo
23:32  Samus_Aran: echo *txt
23:32  e36freak: ahh, that too
23:32  e36freak: was just a thought
23:32  Samus_Aran: but then you need to keep in mind that globs that aren't expanded are left as plain text "*txt", so then you would need to use: shopt -s nullglob
23:33  Samus_Aran: which causes unmatching globs to be left empty
23:33  e36freak: ah, interesting. my way worked without doing that though
23:33 --- mindrape is now known as hansel
23:34  pyoor: hey, I'm trying to determine if "string" exists in an array element but its not working.  all of this will be done inside of a for loop to iterate over every element: if [[ ${array[3]} =~ ".*string.*" ]] ; then echo yes; else echo no; fi
23:34  pyoor: any ideas?
23:34  e36freak: why use regexp? and you are quoting the wrong thing
23:34  cthuluh: !isin > pyoor
23:34  greybot: pyoor: Check whether a value is in an array: inarray() { local q=$1 e; shift; for e; do [[ $q = "$e" ]] && return; done; } # Usage: inarray "$value" "${array[@]}"
23:35  pyoor: oh hey cthuluh, I figured out a way to use sed to solve my issue from last night
23:35  pyoor: parsing a pdf (if you remember)
23:35  e36freak: cthuluh: he said per index, not for the whole thing
23:35  Samus_Aran: e36freak: ls prints the error message if the glob is not found, which you filter out with the 2>/dev/null.  it's just less efficient because it's an external command
23:35  e36freak: Samus_Aran: i gotcha
23:36  cthuluh: e36freak & Samus_Aran : ( files=(/tmp/*); ((${#files[@]})) )  # with shopt -s nullglob
23:36  pyoor: e36freak: the element contains data in addition to "string".  Doesn't this require a regex?
23:36  Samus_Aran: I gotta go
23:36  e36freak: pyoor: glob? [[ "${array[3]}" = *string* ]]
23:37  pyoor: eh, sorry I'm dumb.  it works
23:38  Jak2000: hi, i have a large text file  (16GB), i am need search a word: 'tagui2010' and cut from here to end, any advice how do this?
23:39  e36freak: thats a hell of a text file
23:40  nikolaidis: I'd use sed or perl.
23:40  Spec: Jak2000: use something that doesn't read the entire file into memory all at once :)
23:40  Jak2000: vi?
23:40  nikolaidis: Yeah, that's perl. Maybe not, unless you have scads of ram on the system.
23:40  e36freak: vi would work
23:40  Spec: i don't think so...
23:40  Jak2000: and how to cut?
23:40  e36freak: ask that in #vim though
23:41  Spec: vi will want to load the whole file into ram afaik
23:41  e36freak: ouch
23:41  e36freak: uh
23:41  e36freak: hmm
23:41  Spec: use python, open the file, and read it line by line until you get the line number you want, then call readlines(), and write it all out
23:41  Spec: still gonna be slow.
23:41  e36freak: ouch
23:41  Jak2000: mmm ok
23:42  Jak2000: need a programming language :(
23:42  mattcen: Sed will do what you want. I can't remember the syntax for it though
23:42  e36freak: im thinking
23:42  e36freak: Jak2000: you want to keep whats after the word or before it?
23:43  nikolaidis: Something like
23:43  nikolaidis: cat file | sed -e "s/*.tagui2010//"
23:44  Jak2000: after
23:44  e36freak: dont abuse animals
23:44  e36freak: Naib:
23:44  e36freak: nikolaidis:
23:44  e36freak: sed -e 's/string/' file
23:44  Jak2000: nikolaidis, and how show only the next 5000 lines?
23:44  cthuluh: don't use sed
23:44  cthuluh: you'll need twice the storage size
23:44  cthuluh: !ed
23:44  greybot: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
23:44  nikolaidis: I think my example will only show what follows, Jak2000. It did on my test anyway.
23:46 * mattcen keeps telling himself he should get a handle on ed.
23:46  cthuluh: Jak2000: do you want to truncate the file, or just extract the first lines?
23:46  e36freak: theres also head or tail, but that wont search for the word afaik
23:47  Jak2000: cthuluh i want search the word: tagui2010 and the next 5000 lines need send to x.txt file
23:47  e36freak: vim can do that, but you need to open it in vim
23:47  nikolaidis: jak2000: take my example and > output.txt
23:47  Spec: well, you could just use grep
23:48  Spec: grep -A 5000 tagui2010 filename > output.txt
23:48  nikolaidis: Oh, of course. grep. Yes, there's always grep.
23:48  nikolaidis: I'd do more than 5000, just to be safe, however.
23:48 --- WinstonSmith_ is now known as WinstonSmith
23:48  nikolaidis: grep -A 99999 tagui2010 input > output.txt
23:50  geirha: That's GNU grep though.
--- Log closed Wed Dec 22 08:13:10 2010
