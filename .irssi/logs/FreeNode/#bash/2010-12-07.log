--- Log opened Tue Dec 07 00:00:08 2010
--- Log closed Tue Dec 07 00:05:02 2010
--- Log opened Tue Dec 07 00:10:26 2010
00:10 --- Users 533 nicks [0 ops, 0 halfops, 0 voices, 533 normal]
--- Log closed Tue Dec 07 00:13:37 2010
--- Log opened Tue Dec 07 00:15:24 2010
00:15 --- Users 528 nicks [0 ops, 0 halfops, 0 voices, 528 normal]
00:15  geirha: rocktop: Something is sending the SIGHUP signal to the shell then
00:16  geirha: # bash -c 'echo foo; kill -HUP $$; echo bar'
00:16  evalbot: geirha: foo
00:16  evalbot: geirha: Hangup
00:17 --- Channel #bash was synced in 128 seconds
00:20 --- jzacsh_ is now known as jzacsh
00:25  krzie: !ed
00:25  greybot: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
00:27  rocktop: geirha, thank you but how to make echo bar execute ?
00:28  HollyRain: hi! why when is used "#!/usr/bin/env script" with an argument (-arg) doesn't works from the script?
00:31  rocktop: how to write continue and break statement under while loop in bash ?
00:31  rocktop: !continue
00:31  rocktop: !if
00:31  greybot: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
00:32  rocktop: !break
00:44  slytux: test_bump
00:46  geirha: rocktop: help continue break
00:48  rocktop: geirha, Thank you ,  bash -c 'echo foo; kill -HUP $$; echo bar'    in this status how to make echo bar executing ?
00:49  geirha: rocktop: Remove the kill command
00:50  geirha: # bash -c 'echo foo; echo bar'
00:50  evalbot: geirha: foo
00:50  evalbot: geirha: bar
--- Log closed Tue Dec 07 11:09:52 2010
--- Log opened Tue Dec 07 11:10:14 2010
11:10 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
--- Log closed Tue Dec 07 11:59:49 2010
--- Log opened Tue Dec 07 12:00:11 2010
12:00 --- Users 540 nicks [0 ops, 0 halfops, 0 voices, 540 normal]
12:02 --- Channel #bash was synced in 126 seconds
--- Log closed Tue Dec 07 12:20:52 2010
--- Log opened Tue Dec 07 12:21:13 2010
12:21 --- Users 536 nicks [0 ops, 0 halfops, 0 voices, 536 normal]
12:23 --- Channel #bash was synced in 124 seconds
--- Log closed Tue Dec 07 12:46:39 2010
--- Log opened Tue Dec 07 12:47:03 2010
12:47 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
12:49 --- Channel #bash was synced in 127 seconds
12:57  _pingu: how can i exlude some dirs for a find command? something like find . ! ./a  ./b
12:58  pgas: !extglob > _pingu
12:58  greybot: _pingu: "Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob
12:59  Matuku: .join ##java
13:00  nDuff: _pingu, ...if you really do want to exclude things from find, and can't use extglobs, see -prune
13:01  _pingu: ok, thanks
13:01  nDuff: find . -name .svn -prune -o -type f -print
13:01  nDuff: ^^ prints all files under . excluding anything in a .svn tree
13:02  nDuff: ...now, to determine whether extglobs or find -prune are the right tool, we'd to know more about what you're trying to accomplish.
13:03  _pingu: nDuff: it's ok. I will read both and see.
13:07  pgas: oh I miss the "find" sorry
13:17 --- greenmang0_ is now known as greenmang0
13:33 --- Bersam1 is now known as Bersam
14:20  CyberDomovoy: hi
14:21  geirha: hi
14:22  CyberDomovoy: i have a question about some escaping, i have this axk command in a script: "awk '/vdstart$part_number/{print $2}'", part_number is a variable set by my script, of course the previous command won't work because "'" prevent it from being replaced by its value, what would be the correct way of doing this?
14:22  CyberDomovoy: s/axk/awk
14:22  geirha: Yeah, don't try to embed bash vars into an awk script.
14:23  geirha: use -v
14:23  geirha: awk -v var="vdstart$part_number" '$0 ~ var {print $2}'
14:24  geirha: You can use multiple -v to set more variables
14:24  CyberDomovoy: hmmm, need to read awk man about that
14:25  geirha: There's #awk btw
14:49  Eiler: geirha why did you say that i should use $() instead of ``? and also the ifgrep says to use if fi instead of both `` and $()?
14:50  Eiler: geirha and also why if instead of "$?" ?
14:50  greycat: !`
14:50  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
14:52  Eiler: if i have: if [ $? == "1" ]; then, should the $? be replaced by an if or something?
14:52  greycat: !pf == > Eiler
14:52  greybot: Eiler: http://mywiki.wooledge.org/BashPitfalls#pf20 -- Don't do this! -- [ bar == "$foo" ]
14:53  Eiler: so which one to use = or [[]]?
14:54  greycat: God, it must be SO hard to know what to do when someone gives you a URL to read.
14:54  CyberDomovoy: how can i check if a variable is formed as i want? i want to check if "$var" is corresponding to "[^:]+:[^:]+"
14:54  greycat: !faq valid > CyberDomovoy
14:54  greybot: CyberDomovoy: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
14:54  Eiler: the url just says use one of those two alternatives without explaining the difference between them
14:55  greycat: The difference between them AND WHAT YOU USED is what matters.  What you used is noncompliant code (POSIX [ command but not POSIX syntax for it), whereas the two alternatives are both legal.
14:55  greycat: ![[
14:55  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
14:55  CyberDomovoy: greycat: thanks, so simple :)
14:55  greycat: Maybe I can link from the [[ to that FAQ.
14:56  Eiler: most people are probably not interested maybe, they just want it to work
14:57  Eiler: but geirha said "And don't test $?, just use if", did we solve this with the == -> = replacement? or arent we still testing $?
14:57  greycat: OK, good, [[url|[[]] works....
14:58  greycat: He means replace     foo; if [[ $? != 0 ]]; then ...
14:58  greycat: with    if ! foo; then ...
15:01  Eiler: http://paste.pocoo.org/show/301651/ so here i could just replace if [ $? = "1"]; then, by if ISUP; then ?
15:01  sodapop: i collect cpu usage for a pid from ps output, how do i compare to a var?
15:02  sodapop: e.g. gt
15:02  greycat: Eiler: 1 is failure, so you want ! ISUP
15:02  greycat: sodapop: is it an integer
15:02  greycat: ?
15:02  sodapop: 2.0
15:03  greycat: !faq float > sodapop
15:03  greybot: sodapop: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
15:03  Eiler: hmm it says ISUP: command not found, maybe it should be: if ! $ISUP; then ?
15:03  geirha: Eiler: if wget ... | grep -q "is up"; then echo up; else echo down; fi
15:03  greycat: JESUS.
15:03  geirha: Or just use the lynx command I showed you yesterday
15:03  greycat: Eiler: I don't know what the fuck your code says.  You used ISUP as a command, so I assumed you had created a command by that name.
15:04  geirha: ISUP='wget ... | \  grep "is up"'; if [ $? == "1" ]; then
15:04  geirha: That's his current code
15:04  greycat: Christ.
15:05  geirha: The backslash is obviously meant to escape the newline (which is unecessary), but he has a space after it
15:05  greycat: And he doesn't even understand the pitfalls page.  He's not even that far along yet.  He needs to start with the BashGuide, and read it front to back.
15:05  Eiler: ah, i removed the newline
15:05  greycat: !guide > eiler
15:05  greybot: eiler: http://mywiki.wooledge.org/BashGuide
15:06  geirha: Eiler: You can have a newline after |, but you don't need to escape it.
15:07  greycat: That's just stylistic, though.  It's not even an error, unlike the several ACTUAL errors on that line.
15:07  geirha: Eiler: lynx -dump -nonumbers -nolist http://downforeveryoneorjustme.com/blah.com | head -1
15:07  geirha: That gives you almost the same result
15:09  Eiler: geirha is that solution better in any way?
15:09  greycat: You mean better than what yours WANTS to be if you remove all the errors?
15:10  greycat: Since you are obviously NOT capable of fixing them, let me:
15:10  greycat: if wget "$blah" | grep -q 'is up'; then
15:10  geirha: It's simpler, it just shows you the line you'd see in your web browser
15:10  greycat: That is what you want.
15:11  Eiler: i removed the errors, maybe its not entirely correct but it seems to run and work as expected
15:11  greycat: Suuuure he did.
15:11  Fatal: Eiler: can we see it?
15:12  Eiler: see what? in the paste it was only needed to change == to =, `` to $() and remove the space after \ and it works
15:12  Eiler: '' to `` or $() i mean
15:12  greycat: So you're capturing the output of grep in a variable you never use, and then just using the exit status... well, that's technically OK.
15:14  CyberDomovoy: hmmm, "[^:]+" means "1 or more chars that are not ':'" right?
15:14  greycat: It means "someone's using some sort of weird-looking syntax, and is probably a perl guy".
15:14  CyberDomovoy: lol
15:14  greycat: You have to tell us the CONTEXT in which you are using that block of line noise.  Or it's just a string.
15:15  greycat: E.g. if you are using that as a BRE, it is probably not doing what you expect.
15:15  CyberDomovoy: greycat: ok, wait a minute, i pastebin
15:16  geirha: CyberDomovoy: If it's a regex for awk, then yes, that's what it means.
15:16  greycat: If it's a pattern you're feeding to sed, which uses BREs, it means "one non-colon character followed by a plus sign".
15:16  geirha: !paste
15:16  greybot: Please don't waste our time by making us go to a pastebin just for a five-line snippet. Paste it in the channel. If you have a larger script that's showing problems, trim it down to the bare minimum size that still shows the problem. You'll probably fix it yourself once you do that.
15:16  greycat: And you should not need to use a web site to show us 1 line of code.
15:17  CyberDomovoy: actually it's 12 lines...
15:17  CyberDomovoy: http://pastebin.com/NTw2FA7S
15:17  greycat: You use it in 12 different contexts?
15:18  geirha: CyberDomovoy: case uses globs, not regexes
15:18  geirha: !glob > CyberDomovoy
15:18  greybot: CyberDomovoy: "Glob", the common name for pattern matching, filename expansion, "wildcards", etc. http://mywiki.wooledge.org/glob
15:18  geirha: CyberDomovoy: case "$1" in [^:]+:[^:]+) ...;;  would've been enough to show the context
15:19  CyberDomovoy: geirha: ho, ok. Didn't know there was differences between all those tools, now i know :) thx
15:19  greycat: If you must use a regular expression in a case statement, you'll have to convert it from ERE to extglob syntax.
15:19  geirha: CyberDomovoy: *:*)
15:20  greycat: *:* and +([^:]):+([^:]) don't mean exactly the same thing, though.
15:20  CyberDomovoy: geirha: yes, i thought about it, but wasn't sure, what if i have "foo:bar:zob"?
15:20  geirha: CyberDomovoy: If there must be only one :, put a *:*:*) before that
15:20  CyberDomovoy: geirha: ok, thx
15:20  geirha: if that doesn't match, but *:* does, then you know there's only one :
15:21  greycat: (or use extglobs, or use [[ =~, ...)
15:24  jeremy_c: I'm trying to do a string compare and the first string is --plat ... I keep getting the error [: 15: --plat: unexpected operator ... how do I get around this?
15:25  greycat: !umq > jeremy_c
15:25  greybot: jeremy_c: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
15:25  jeremy_c: thanks.
15:25  geirha: CyberDomovoy: IFS=: read -r -a split <<< "$1"; n=${#split[@]}; if ((n != 2)); then usage;exit; fi; vdi_file=${split[0]} partition_number=${split[1]}
15:26  greycat: I might go with this one:    IFS=: read -r vdi_file partition_number x <<< "$1"; if [[ $x ]]; then usage; exit 1; fi
15:27  greycat: Although that doesn't cover the "didn't have ANY colons" case
15:27  geirha: Or if it ends with a :
15:27  greycat: Presumably a sanity check on partition_number will be done later.
15:28  jcromartie: how could I write a shell script that changes to a different directory but doesn't leave the user there if something goes wrong?
15:29  greycat: !faq change dir
15:29  greybot: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
15:29  koala_man: jcromartie: you can't do anything but
15:29  jcromartie: durrrrr
15:29  jcromartie: ok that's great
15:29  greycat: Dir changes inside a script have no effect on anything outside that script.
15:29  jcromartie: for some reason I thought that was the case
15:29  jcromartie: not the case
15:29  jeremy_c: greycat: I think I'm doing it right. I can't use strong quoting as it has var expansion. if [ "${1}" == "${VAL}" ] ... $1 = --plat
15:29  greycat: !pf == > jeremy_c
15:29  greybot: jeremy_c: http://mywiki.wooledge.org/BashPitfalls#pf20 -- Don't do this! -- [ bar == "$foo" ]
15:38  avinashhm: hi, can i ask questions on nfs mount here ???  .. if not , can some one point where i can ask ...I am confused
15:39  greycat: Your OS channel.
15:44  avinashhm: greycat, thanks .. .
15:44  Fatal: probably linux specific, but I'll ask anyway, I have a situation where a bash script loses the fds for 0/1/2, /proc/<bashpid>/0 is; 0 -> /dev/pts/4 (deleted), and the script just spins out of control, trying to see what I can do to prevent it in the way the process is spawned, but is there anything I can do from bash to get it to die/crash/etc if the fd's "almost" go away?
15:44  greycat: The terminal died?
15:45  greycat: I'd expect you to get a SIGHUP or something...?
15:45  jeremy_c: greycat: thanks, that did the trick
15:46  Fatal: that's what I expected too, a collegue was logged on, running the script, closed his laptop and left the building, when he came back online and logged on the system the process was spinning out of control. So I'm suspecting maybe I have a bad opensshd, but I'm just guessing at this point
15:46  greycat: More likely something ignored SIGHUP.
15:47  greycat: Processes that ignore signals and then run away with all the CPU are classic commercial Unix 1990s programming style.
15:47  Fatal: the chain is sshd->bash->su->bash->script, will exclude su from the chain and see if I can get it to spin again
15:48 --- Coin_Ope_Boy is now known as Coin
15:49 --- Coin is now known as Coin_Ope_Boy
15:49  greycat: Or run it inside screen...
15:49 --- Coin_Ope_Boy is now known as Coin
15:51 --- Coin is now known as Coin_Ope_Boy
15:52  Fatal: greycat: thanks, your comments made me find it, some wrapper script that eats the signals for a cleanup function. I'm guessing it should reraise the signal if possible.
16:09  SNow: how to delete n chars from the end?
16:09  SNow: echo 123456
16:09  greycat: !faq 100 > snow
16:09  greybot: snow: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
16:10  greycat: What's the actual goal?  What's n?
16:10  SNow: echo 123456 and how I delete 3 chars from the end?
16:10  greycat: echo 123
16:10  nDuff: !pe > SNow
16:10  greybot: SNow: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
16:10  \DSAFEW\: SNow, what for? for fun?
16:10  greycat: Now what's the GOAL?
16:11  greycat: Is 3 known at script-writing time?  Run time?
16:11  greycat: Are you trying to remove the extension from a filename?
16:13  greycat: I see.  It's a sekr3t.
16:13  poisonbit: # var=123456; echo "from 0 to 3: ${var:0:3} or catch 3 last: ${var:(-3)}"
16:13  evalbot: poisonbit: from 0 to 3: 123 or catch 3 last: 456
16:13  SNow: for i in `ls log.proc.logprocdata/*data` ; do echo $i | cut -c 22- ; done
16:13  cthuluh: aïe
16:13  greycat: My god... so many errors.
16:13  greycat: !pitfalls > SNow
16:13  greybot: SNow: http://mywiki.wooledge.org/BashPitfalls
16:13  SNow: I would like to remove extension .data from all files.
16:14  greycat: SNow: ${filename%.*}
16:14  greycat: or ${filename%.data} if you prefer
16:14  nDuff: SNow, first, read the pitfalls page linked you to; it'll save you a _lot_ of trouble.
16:14  greycat: for f in log.proc.logprocdata/*data; do base=${f%.data}; ...
16:14  poisonbit: telepathy++
16:15  SNow: Thank you guys
16:15  \DSAFEW\: NO
16:15  \DSAFEW\: THANK YOU
16:15 * \DSAFEW\ bows deeply to SNow 
16:18  LXCC-Vincenzo: #join #assoli
16:22  Muncuie:  kontol
16:24  Fatal: ah I correct to assume that if you use trap 'cmd' multiple signals, it's not the signal that raised the trap cannot be determined by cmd?
16:24  greycat: You'd have to set separate traps and pass an extra argument in each.
16:25  sodapop: what is the meaning of [[ ]] ?
16:25  Fatal: ![[ > sodapop
16:25  greybot: sodapop: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
16:25  Fatal: greycat: mm, ok
16:32  Fatal: ok, lesson learned, trapping on sighup seems like a really shitty idea
16:33  Fatal: ssh to host, trap "exit" 1 ; bash script, log on and kill controlling sshd, script spins out of control
16:33  greycat: It's OK if your trap cleans up and exits.
16:33  greycat: ... I don't see why yours wouldn't be exiting.
16:34  greycat: Oh, you trapped *outside* the script?
16:34  Fatal: yes
16:34  greycat: I'd have to look up what happens when you inherit a nonstandard set of signal handlers.
16:35  Fatal: I got hung up on this sentence from SIGNALS: If bash is waiting for a command to complete and receives a signal for which a trap has been set, the trap will not be executed until the command completes.
16:36  Fatal: hmm
16:37  btfx: `!123' will execute that command from history, is there any way to get it into the CL without executing it?
16:37  btfx: Like... if I don't want to hold the up key for an hour
16:38  greycat: if you're in emacs mode, try Ctrl-R 1 2 3
16:38  \DSAFEW\: btfx, sync the history then search bash command history
16:38  greycat: Or am I misunderstanding what that ! crap does...
16:38  Fatal: btfx: from the top of my head, I'd use fc 123, but that doesn't do what you asked
16:39  \DSAFEW\: oh yeah, ctrl-R does a reverse search like "ssh blah blah" is just ctrl-R + ss usually
16:39  Fatal: greycat: !<num>  expands to item num in history
16:40  btfx: \DSAFEW\: Sorry, I'm not sure what you're saying, might be too noob.
16:40  paxl: do someone has a good guide on extglob ?
16:40  btfx: Fatal: Not sure what you mean by "fc"
16:40  greycat: !glob
16:40  greybot: "Glob", the common name for pattern matching, filename expansion, "wildcards", etc. http://mywiki.wooledge.org/glob
16:40  Fatal: btfx: help fc
16:40  Fatal: it'll open the history item in your editor, when you close it it'll execute the command
16:41  \DSAFEW\: btfx, don't worry about it, Fatal has what you want I think
16:41  Fatal: that's the closest I can come to what I guess you want [get the history item and edit it]
16:42  Fatal: AH!
16:42  Fatal: btfx: type: !123 and press M-^
16:42  Fatal: that performs history expansion without executing it
16:42  Fatal: history-expand-line (M-^)
16:42  btfx: Uhh... M-Ctrl ?
16:42  Fatal:    Perform history expansion on the current line.  See HISTORY EXPANSION below for a description of history expansion.
16:42  paxl: thanks greycat
16:42 * btfx is confused
16:42  Fatal: btfx: no, ^
16:42  Fatal: caret
16:43  Fatal: can I go back to cry over my trap use now? :)
16:43  btfx: I see!
16:44  btfx: greycat: Fatal: Thanks! Both ways work for me!
16:44  Lunar_Lamp: If I want to find the number of files in the current directoy, I feel like I should be able to use: ${#*[@]}, but this does not work, though if I used ${#foo[@]} with foo being an array of files in the dir, it would. Is there a nice little idiom I am missing?
16:44  Fatal: Lunar_Lamp: a=(*) ; echo ${#a[@]}
16:44  greycat: Lunar_Lamp: ${#array[*]}
16:44  greycat: or [@]
16:46  Lunar_Lamp: Cheers fatal.
16:46  Lunar_Lamp: I was trying that already, but I was hoping there was a magical way of doing it without two commands; i.e. without explicitely creating the array first.
16:46  Lunar_Lamp: Now I say that, it sounds retarded.
16:46  greycat: No, there isn't.
16:47  Fatal: Lunar_Lamp: you can't nest expansions
16:47  Lunar_Lamp: Fatal: yup, I guessed that - nice to learn something new though :-)
16:48  Fatal: greycat: if I could run the script in the background and use wait then I'd be fine it seems, but the script needs user interaction, so that goes out the window
16:50  poisonbit: can't I make  {1..${var}}  without eval or without seq ?
16:50  greycat: !pf ..$
16:50  greybot: http://mywiki.wooledge.org/BashPitfalls#pf32 -- Don't do this! -- for i in {1..$n}
16:51  poisonbit: ha c style loop, ok
16:52  poisonbit: # for ((i=1; i<=COLUMNS; i++)); do printf -- '-%.0s' "$i"; done
16:52  evalbot: poisonbit: --------------------------------------------------------------------------------
16:54 --- lupinstein is now known as lupinstein_away
16:54  Fatal: greycat: maybe I'm daft, if a script recieves a signal, will trap "cmd" 0  execute before bash shuts down?
16:55  greycat: TIAS
16:58  poisonbit: # echo '#!/bin/bash' > file; echo 'the_end(){ echo "bye" ; }; trap the_end EXIT;' >> file ; bash file
16:58  evalbot: poisonbit: bye
16:59  nDuff: Fatal, ...well, it depends on the signal, of course
17:01  poisonbit: # echo '#!/bin/bash' > file; echo 'the_end(){ echo "bye" ; }; trap the_end DEBUG; : ; : ;' >> file ; bash file
17:01  evalbot: poisonbit: bye
17:01  evalbot: poisonbit: bye
17:03  poisonbit: # echo '#!/bin/bash' > file; echo 'alarm(){ echo "Uuu" ; }; trap alarm 14 ; kill -14 $$ ;' >> file ; bash file
17:03  evalbot: poisonbit: Uuu
17:20  samfisher: hello
17:21  samfisher: I have a folder with multiple files in it and I want to count each row (they are lists with computer parts in html format)
17:21  greycat: wc -l *
17:23  samfisher: greycat: and if I want to cut the 6th field of each file and put it in a txt?
17:23  xeon-enouf: hi guys -- been a while; but i'm brainfarting; how do i grep/pipe/pass the list of output files, for _names_ of files after this command; $ find . \( -name '*.c' -o -name '*.h' \) | xargs grep -il 'module_param_named'
17:24  xeon-enouf: please don't xargs spank me ;-)
17:24  greycat: samfisher: read _ _ _ _ _ sixth < file
17:25  greycat: xeon-enouf: find ... \( ... \) -exec grep -il 'foo' {} +
17:25  greycat: P.S., you can use -name '*.[ch]'
17:26  samfisher: greycat: wouldn't it be something like: for i in file; do read cut -d 6 > file.txt?
17:26  xeon-enouf: greycat: ahh .. thanks!
17:26  samfisher: greycat: i'm very unexperienced with bash
17:27  geirha: !faq 1 > samfisher
17:27  greybot: samfisher: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
17:27  geirha: !guide > samfisher
17:27  greybot: samfisher: http://mywiki.wooledge.org/BashGuide
17:27  nDuff: samfisher, cut isn't an argument to read
17:27  greycat: samfisher: for i in *filepattern*; do read _ _ _ _ _ _ sixth < "$i" && echo "$sixth"; done > file.txt
17:28  nDuff: greycat, ...that said, did he specify that he wants sixth _and later_ arguments?
17:28  greycat: oops, too many _
17:28  greycat: nDuff: not that I saw
17:28  nDuff: ...then maybe another _ is called for on the end...
17:28  greycat: samfisher: for i in *filepattern*; do read _ _ _ _ _ sixth _ < "$i" && echo "$sixth"; done > file.txt
17:30  samfisher: greycat: I don't understand the line you wrote. I want to enter each file and cut the 6th column of each file and then add them to txt file
17:30  greycat: And that's what that DOES.
17:30  greycat: !faq 1 > samfisher
17:30  greybot: samfisher: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
17:31  greycat: If you want "every file", use * for the glob pattern.
17:31  greycat: (Although in that case, your file.txt had better be in a different directory.)
17:31 --- Weust` is now known as Weust`afk
17:31  xeon-enouf: greycat: i'm trying to pluck out strings found in the *filenames only* that your command yields (as well as my initial one) .. i tried piping the output of yours into '| xargs grep ... ' but i know that's incorrect, as the results show
17:31  xeon-enouf: $ find . \( -name '*.c' -o -name '*.h' \) -exec grep -il 'module_param_named'  {} + | xargs grep -il debug
17:31  greycat: xeon-enouf: I don't know what you want.  Speak clearly.
17:32  xeon-enouf: how's that?
17:32  greycat: Speak *English*.
17:32  greycat: Describe what you want to do.
17:32  xeon-enouf: i want only the files containing the word "debug" to appear in the end
17:32  greycat: find . -name '*debug*' -name '*.[ch]' -print
17:33  xeon-enouf: IOW, i'm grepping for a string in all .c and .h files, then from that list, i want to only see certain *filenames*
17:33  xeon-enouf: ok
17:33  xeon-enouf: no
17:33  greycat: find . -name '*debug*' -name '*.[ch]' -exec grep 'a string' {} +
17:34  xeon-enouf: er.. wait ... let me try then -- it seems i'm doing this bassackwards
17:34  geirha: find . -name "*debug*.[ch]"
17:34  xeon-enouf: i see -- yep -- thanks .. did i mention the brainfart? (however, this method is not useful for my purposes)
17:35  xeon-enouf: hrm -- better -- thank you all
17:35  samfisher: greycat: thanks. and if i need to > file.txt all the word in thos file containing the "$" sign? just the dollar no quotes
17:35  samfisher: s/word/words
17:36  greycat: samfisher: THE ENTIRE LOOP IS ALREADY REDIRECTED TO THE DESTINATION FILE
17:37  NateW: wondering why this doesn't work?      sudo mv "$TMP/file."* "$DEST/file.zip"
17:37  samfisher: greycat: i was talking of a different operation
17:38  greycat: NateW: you tell us... why doesn't it?
17:38  greycat: I mean, apart from the oddity of there being a DIRECTORY named file.zip...
17:39  NateW: there isnt, a directory named file.zip, there is a file named file.230d90f and the last part always changes, and i want it to be named file.zip
17:40  NateW: the error im getting is that there is  no file named file.*
17:40  NateW: shouldnt it use the * as a wildcard?
17:40  greycat: If there is no directory named file.zip, then    mv foo* .../file.zip   makes no sense
17:40  NateW: how can i do it so the file gets renamed to file.zip then?
17:41  greycat: How can you be sure there's only ONE file?
17:41  NateW: in this case there is
17:41  greycat: If your glob isn't even matching *one* file, then you have some rather big issues here.
17:41  xeon-enouf: indeed
17:42  xeon-enouf: NateW: cd /dir/in/question ; mv ./file* ....
17:42  samfisher: greycat: i want all the words containing the $ sign, from all files in a folder, to be added in a .txt file. So i can add all of them to a sum.
17:42  samfisher: greycat: added as in listed
17:43  xeon-enouf: (not that this is great advice, but still ; *somefilename* should match)
17:43  greycat: "all the words containing a $" is pretty hard to do unless you "cheat" and install GNU grep.
17:43  xeon-enouf: heh!
17:43  greycat: if you have to do it with sed, it's ugly.
17:43  greycat: Let's assume you have GNUgrep.
17:44  xeon-enouf: NateW: your initial question looks like it's meant for scripting, is that so?
17:44  NateW: yeah
17:44  xeon-enouf: well -- maybe your script stinks ;-)
17:45  NateW: agreed
17:45  xeon-enouf: as in defining $TMP, etc
17:45  greycat: Actually.... I don't even know how to use this \b shit properly.
17:45  greycat: Someone who knows how to use this GNU shit, tell samfisher how to answer his question.
17:45  samfisher: greycat: i have grep :)
17:45  greycat: Or samfisher, man grep.
17:45  greycat: *sigh*
17:45  greycat: GNU grep!  Not standard grep!
17:45  greycat: We all have grep, except Windows users, and they don't fucking count.
17:45  samfisher: ouch
17:46  greycat: But standard grep has no extensions for only showing PARTS of a line.
17:46  xeon-enouf: and $DEST -- but the error is from the $TMP likely since; < NateW> the error im getting is that there is  no file named file.*
17:46  greycat: You need GNU grep's -o extension for that.
17:46 * xeon-enouf hugs GNU and greycat ... just to piss him off :-P
17:47  samfisher: greycat: i'm affraid of sed. and awk
17:47 * xeon-enouf ^fives the " ...except Windows users, and they don't fucking count." comment
17:47  xeon-enouf: samfisher: how about some shrapnel?
17:47  xeon-enouf: samfisher: or c4, scared now?
17:49  xeon-enouf: samfisher: ask sed/awk questions in their respective channels ; if you're not an ahole, they should respond positively ;-)
17:50  greycat: I'd still be willing to bet he's a Linux user who has GNU grep.
17:50 * xeon-enouf too
17:50  greycat: And someone in this channel *ought* to know how to use this -o \b shit.
17:50  greycat: Or I could just hack up the portable version using tr...
17:51  xeon-enouf: not i -- i use rgrep, egrep, etc -- not the fandangled CL options, like -o
17:51  xeon-enouf: heh
17:51  greycat: for f in *; do tr ' \t' '\n\n' < "$f" | grep '\$'; done > ../file.txt
17:51  nDuff: I thought \b was a PCRE extension, not even a GNU one
17:51 * xeon-enouf does man ascii
17:51  greycat: GNU grep has \b and \B and \w and \W in its man page.  I just looked.
17:51  xeon-enouf: ouch!
17:52  nDuff: ...huh; it looks like GNU grep has optional pcre support, but the man page reads like \b is supported even when that's not currently enabled.
17:53  netsan: real ouch :-0
17:53  nDuff: s/it looks like/I knew that/
17:53  nDuff: (for the first one)
17:53 * xeon-enouf thinks of how 'head/{tail}' can print out certain characters from lines only
17:53  greycat: The tr loop should work for some definitions of "word".
17:54  greycat: Unless I screwed it up.
17:54  xeon-enouf: (not that the user knows exactly _which_ characters from each line, they want printed)
17:55  xeon-enouf: greycat: no offense or anythhing, but why the ../ rather than just ./   ?
17:55  greycat: Because we're using * in the loop.
17:56  xeon-enouf: oh, ok ...
17:56  greycat: So the output file has to be somewhere ELSE.
17:56  xeon-enouf: Ahh!! .. enlightening -- thank you
18:11 --- studyurnm3 is now known as misnix
18:19  gh0stwalker: Hi, anyone wrote a cgi using bash? I am having issues with refresh
18:19  gh0stwalker: I have this line in my script
18:19  gh0stwalker: echo '<meta http-equiv="refresh" content="360">'
18:19  gh0stwalker: but it not refreshing after 5 minis
18:20  gh0stwalker: and my script is bash.
18:20 * nDuff shudders
18:20  nDuff: gh0stwalker, if that line is in fact being emitted to stdout, then bash is doing what it's supposed to
18:20  nDuff: gh0stwalker, ...so you'll need to look for support elsewhere.
18:23  gh0stwalker: hmmm, it is
18:23  gh0stwalker: <meta http-equiv="refresh" content="360">
18:23  gh0stwalker: ok. Thought I ask here first since it is bash
18:24  mark_____: Hi guys... I can't use &>> to direct all output to append to a file
18:24  mark_____: how would I do it?
18:24  mark_____: &> would overwrite no?
18:24  geirha: !&>>
18:24  greybot: There is no such thing as &>>. What you want is: command >>file 2>&1
18:25  mark_____: got it thanks
18:26  mehwork: how do you delete every file and subdir, including hidden files, rm -rf * doesn't seem to do .hidden files and if i do rm .* it wwill require a second command (rm -rf *) to get the normal files. is there a way to get both?
18:26  trash: rm -rf dir/
18:26  trash: or rm -rf .* *
18:26  nDuff: mehwork, see dotglob
18:27  nDuff: !dotglob > mehwork
18:27  greybot: mehwork: dotglob, if set, makes bash include filenames beginning with a '.' in the results of pathname expansion (shopt -s dotglob)
18:27  trash: or shopt -s dotglob; rm -rf *
18:27  mehwork: trash well i want to not delete the parent dir, because i'm going to later be adding an exclude of deleting a specific file
18:27  mehwork: thanks
18:27  trash: Then probably dotglob.
18:27  nDuff: also see extglob
18:27  nDuff: if you want to exclude a specific file
18:27  trash: shopt -s extglob; shopt -s nullglob; rm -rf !(mypattern)
18:28  trash: Though that's not recursive, in which case you'd want find.
18:29  samfisher: greybot: echo "1 2 0\$3 4 5 6 \$777 8 9 10 11" |sed 's/ /\n/g' |sed -n '/\$/p'
18:29  samfisher: but how do i apply that to all the files?
18:31  nDuff: samfisher, there's a FAQ for that.
18:31  geirha: samfisher: awk '/\$/{ for (i=1;i<=NF;i++) if ($i ~ /\$/) print $i}' *
18:32  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:32  trash: I somehow think he want's to edit the file.
18:32  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:32  trash: wants*
18:32  nDuff: !faq 21 > samfisher (granted, this particular edit isn't a string replace, but the answer is broadly the same)
18:32  greybot: samfisher (granted, this particular edit isn't a string replace, but the answer is broadly the same): http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
18:32  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:32  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:32  kojiro: I smell a shitty bot
18:32  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:33  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:33  Muncuie: _ ( ( ( Made in Indonesia ) ) ) _
18:33 * kojiro lights a candle
18:39  mehwork: any idea how to get svn rm * to delete subdirs too?
18:40  rickest: !nabq
18:40  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
18:40  mehwork: fair enough
18:44  f00bar80: how to search all subdirectories and their subdirectoris in cwd for any .exe files or code injection inside each file using find or grep ?
18:44  geirha: search for code injection??
18:44  yitz_: !find > f00bar80
18:44  greybot: f00bar80: http://mywiki.wooledge.org/UsingFind
18:44  kojiro: find . -iname '*.exe' -exec grep 'code injection pattern' {} +
18:45  yitz_: -exec grep -q -print
18:45  kojiro: yitz_: er, you mean grep -l? :P
18:46  kojiro: the -q is a little weird if the + can't fit all the arguments in one command
18:46  yitz_: Oops. I was thinking -exec grep -q {} \; -print
18:46  kojiro: ah
18:46  yitz_: grep -l {} +  makes much more sense :)
18:46  kojiro: and I was thinking you meant grep {} \; -quit -print o_O
18:47  zealiod: how cani use dialog to show percentage of wget download?
18:47  kojiro: zealiod: um, I dunno, maybe you should just use the --progress flag?
18:49  zealiod: kojiro: can i link that up with dialog?
18:50  samfisher: gnubien: one more question: can I use bash to access a website as https://www.site.com/page.aspx (it has user/pass auth) and then run in one of the search fields (ie Name) all entries from a txt files with names? also to save the output each time, ie johnson.txt
18:50 --- studyurnm3 is now known as misnix_
18:50 * kojiro rolls his eyes at zealiod 
18:51  zealiod: kojiro: oh yeah? do tell?
18:52  geirha: samfisher: Try #curl or #wget
18:52  kojiro: zealiod: No offense, but why do you want to do unnecessary work?
18:52  gnubien: samfisher: maybe the apps called expect or the python version of expect can do that
18:52  zealiod: kojiro: no offence, but why have you deamed it unnecessary?
18:52  kojiro: zealiod: because wget provides a progress bar
18:53  zealiod: kojiro: wget runs in the background of an already well estabilished dialog app
18:53  kojiro: ah
18:53  kojiro: zealiod: well, it'd be a chore, but I'm sure you can capture the output of wget's *own* progress meter, and rejigger it so dialog can redisplay it
18:53  kojiro: but I wouldn't want to do it :)
18:54  zealiod: kojiro: i did that, but it flickers awful
18:56  linetrace: is there any easy way to split a filename on the last '.'? I need to finagle the filename before the extension
18:57  geirha: !lame
18:57  greybot: for f in ./*.wav; do lame "$f" "${f%.wav}.mp3"; done
18:57 --- misnix_ is now known as misnix
18:58  geirha: !faq 100
18:58  greybot: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
18:58  linetrace: @geirha but I don't know the file extension
18:58  geirha: linetrace: then  "${f%.*}"
18:59  linetrace: geirha: is that greedy?
18:59  kojiro: linetrace: no
18:59  geirha: "${f%%.*}" is greedy, "${f%.*}" is non-greedy
18:59  linetrace: geirha: awesome, I'll give that a try
18:59  kojiro: # foo="abc.def.wav"; echo "${foo%.*}"; echo "${foo%%.*}"
19:00  evalbot: kojiro: abc.def
19:00  evalbot: kojiro: abc
19:03  geirha: And if there is no ., it'll expand it unaltered (as if it was "$f")
19:04  TheBonsai: y0
19:04  geirha: yE
19:04  TheBonsai: :)
19:05  kojiro: yt
19:05  gwz: hey, how would i use tr to replace < with |
19:06  kojiro: # <<< 'foo<bar<baz' tr '<' '|'
19:06  evalbot: kojiro: foo|bar|baz
19:09  linetrace: geirha, kojiro: how would one then extract the extension?
19:11  TheBonsai: !pebasename
19:11  greybot: Mangling file- and dirnames with parameter expansion: http://wiki.bash-hackers.org/syntax/pe#substring_removal
19:12  joeschmoe: I have a file with several words on each line. How can I echo only the 4th word and all words past that for each line?
19:12  linetrace: TheBonsai: ah, okay, so it'd be something like "${foo##*.}"
19:13  gwz: how would i go about adding a character, in the starting of a string?
19:13  linetrace: # foo="abc.def.wav"; echo "${foo%.*}"; echo "${foo##*.}"
19:13  evalbot: linetrace: abc.def
19:13  evalbot: linetrace: wav
19:13  TheBonsai: gwz: foo="a$foo"
19:15  joeschmoe: nm, I figured it out with grep
19:31  douggibb: o Command map
19:38  gh0stwalker: ah, so there is a differents between ' and " with echo
19:40  pgas: with any command
19:42  pgas: the quotes are interpreted by the shell, not by the commands. The commands never see the quotees, the shell removes them.
19:45  gh0stwalker: Well I got me refresh working by doing echo " " instead of echo ' '
20:09  mattt_: Is there anything I should watch out for when passing function names as parameters and calling the function via parameter?
20:10  twkm: besides your sanity?
20:11  mattt_: heh.. is it not straightforward?
20:25  mattt_: Is there no way to do this?  The function is being executed in a subshell (I think).. I get command not found errors
--- Log closed Tue Dec 07 21:50:41 2010
--- Log opened Tue Dec 07 21:51:04 2010
21:51 --- Users 570 nicks [0 ops, 0 halfops, 0 voices, 570 normal]
21:51  poisonbit: nDuff, but you know... lot of people ask if they can remove the last "3" chars of a file name :)
21:51  greycat: Microsoft poisoning.
21:52 * nDuff disagrees with greycat on that, but not vociferously enough to defend his position.
21:53 --- Channel #bash was synced in 131 seconds
21:53  poisonbit: CP/M and MS Dos (fat*) was 8.3 filenames tipically
21:54  poisonbit: anyway is a bad logic... basename or expansion :)
21:54  greycat: No, it was 8+3 character file names *consistently*.  Even if the file's name was "foo", it was really "FOO        ".
21:54  greycat: Or perhaps more precsisely, it was "FOO     ""   ".
22:22  neilthereildeil: how can i dd from a file into a variable
22:22  greycat: !faq 2
22:22  greybot: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
22:22  greycat: In bash, var=$(< file)
22:23  patrickw: is there a script / executable somewhere that lowercases the variables in a bash script?
22:25  dak1n1: in bash variable naming conventions, what is the significance of case? ( $var as opposed to $VAR )
22:26  greycat: !varcaps
22:26  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
22:26  dak1n1: cool
22:26  dak1n1: that's handy
22:27  dak1n1: I've heard this term "internal shell variables", but I wasnt sure if that means variables that are just accessed by this script. But I guess for most variables, you just leave them lower case, right?
22:28  greycat: It most likely means non-exported variables.
22:28  greycat: Oh, never mind. /me reads up.
22:28  greycat: In THAT context, it means things defined by bash itself.
22:29  greycat: Although SHELL is not actually in that category.
22:29  dak1n1: hmm, okay, thanks. That clarifies things for me
22:32  neilthereildeil: im writing a bash script using dd and i want to read from a file, and use the of= command to be a bash variable. how can i do that?
22:32  greycat: !faq 2 > neilthereildeil
22:32  greybot: neilthereildeil: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
22:32  neilthereildeil: i jsut looked at that
22:32  greycat: You can't.  Just leave OUT the fucking of=.
22:32  greycat: Then it writes to stdout.
22:32  greycat: Then you capture stdout.
22:32  Riviera: neilthereildeil: you can't, as you can read in the documentation of dd, of= expects a file name,
22:33  neilthereildeil: ohh ok cool
22:33  Riviera: neilthereildeil: and a file is not a bash variable :)
22:33  neilthereildeil: true. thx
22:47  poisonbit: can I use a file as "template" (as input like a inhere-document) without using eval ?
22:48  greycat: !template
22:48  greybot: http://mywiki.wooledge.org/TemplateFiles
22:49  poisonbit: a nice
22:50  poisonbit: what diferences { echo "$commands" }  | sh    from eval ?
22:51  greycat: Not much.
22:51  greycat: They both cause parsing and evaluation of the content of the file.
22:53  neilthereildeil: what command would you all use if you want to see if a variable has a given substring inside of it?
22:54  greycat: [[
22:54  greycat: !faq 100 > neilthereildeil
22:54  greybot: neilthereildeil: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
22:54  neilthereildeil: thx
23:02  greycat: j #freenet
23:02  ChrisBuchholz: Hi. Is there a proper function i could use to look if a file exists and actually keep looking for it and then act when it gets created? I bit like `tail -f` but with a file instead of the last part of a file
23:04  patrickw: ChrisBuchholz: in bash?  you could just use a while / sleep loop?
23:05  ChrisBuchholz: patrickw: yeah in bash. I thought of that, but i wanted to check for other ways, since i wasnt sure if a while / sleep loop would take up too much memory. Perhabs that is what `tail -f` also is?
23:08 --- taylanub0 is now known as taylanub
23:09  patrickw: I'd think a while/sleep loop would use less memory than other "better" ways that use more advanced system calls.  At any rate the amount of memory used would be inconsequential as would the processor time as long as the sleep time was reasonable.
23:10  greycat: !fam
23:10  greybot: FAM (File Alteration Monitor), or maybe you wanted inotifywait instead.
23:12  patrickw: How long is this thing going to be waiting?
23:14  ChrisBuchholz: patrickw: well, it should be looking for the file maybe forever. Thing is, i have a background processe that runs and looks, via tail -f, for changes to a file. At the same time, it should look if a certain file gets created, and if so, it will take action
23:14  ChrisBuchholz: patrickw: could be forever - could be for only a minute
23:15  patrickw: err, yeah, you'd probably want to do something better than a shell script then, and go with one of greybot's suggestions.  are you on Linux?
23:17  ChrisBuchholz: patrickw: reason why i am using a shell script, is because i need this stuff to work on both linux and bsd (mac os x in my case)
23:17  ChrisBuchholz: patrickw: right now, i have it working with a while / sleep loop, but again, i am afraid it takes up too many resources in the long run
23:18  cthuluh: ChrisBuchholz: just add a sleep in your loop
23:21  ChrisBuchholz: cthuluh: that how it works right now - `sleep 2´
23:21  cthuluh: then use that :)
23:21  patrickw: Well, your memory usage won't grow over time with the loop, and the sleep will keep down the processor time.  It may wake the disk though, that would probably depend on the kernel.
23:21  cthuluh: or use FAM
23:21  cthuluh: but anyway, FAM is not bash
23:21  ChrisBuchholz: patrickw: hmm i see. I must keep a waking eye on that.
23:21  ChrisBuchholz: cthuluh: yeah, i figured that
23:22  patrickw: I'd get rid of the tail -f if you can and just check the modified time.
23:23  ChrisBuchholz: patrickw: i need the last line of the file anyways, so it seems easier. Should only be because of a big performance overhaul?
23:25  patrickw: Well, tail reads the file, which is generally more involved than looking at the attributes.  But if you need the last line, then you need to read the file anyway.
23:25  }ls{: (bash )    why does a "ls" give one line as result in contrast to "ls > TempFile" which gives a file in which  \n is appended after each item found?
23:26  ChrisBuchholz: patrickw: yeah, just my thought.
23:26  ChrisBuchholz: brb
23:28  Riviera: }ls{: ls checks whether or not it writes its output to a terminal or not
23:31  }ls{: Riviera: I want the "terminal-behaviour" of "ls"  in a file. How to do that?
23:32  \malex\: }ls{: man ls, look for columns
23:32  omani: how can i determine which sata type I got in my system. sata1 or sata2, etc.
23:33  cthuluh: omani: ask your OS channel
23:35  }ls{: \malex\:  read that again and again.  Goal is to write *every* GNU command output to a var/file, like it's beeing entered in a normal terminal. (Will try it anyway, thanks...)
23:36  patrickw: }ls{: you could try using unbuffer instead of hacking each command
23:37  }ls{: patrickw: sounds like that, what I didnt know, that I was searching for. Thanks. Howto?
23:38  \malex\: }ls{: why do yuo need this?
23:38  Riviera: }ls{: if you have that installed and running, you could try: ssh -t user@localhost ls ... > file
23:38  cthuluh: }ls{: do you know script(1)? type script<enter>ls<enter>C-dpr typescript | less -R<enter>
23:38  }ls{: Riviera: FINE. Thanks.
23:38  Riviera: }ls{: welcome
23:39  }ls{: \malex\:  need a little sript taking CmdArgument and pasting it to a wiki.
23:40  }ls{: (pasting a complete "codeblock" with faked prompt, cmd and results)
23:42 --- Unknown[NF] is now known as Unknown[OFF]
23:43  }ls{: cthuluh: no, I don't. Will have a look. Sounds very good as well.
23:43  }ls{: Thank you.
23:43  cthuluh: the problem is that script wasn't designed for pastebin, rather for mail or raw file transfer
23:44  cthuluh: and I don't know how to clean a typescript file
23:45  Riviera: screen could be used for this too, i'm sure
23:45  }ls{: cthuluh: looks fu**** good.  (And I do know to translate it easily) Thank you.
23:45  }ls{: screen I do use. How to read it's screen output?
23:45  Riviera: you can send commands to screen to execute them and also make screen "hardcopy" the session
23:45  Riviera: that'd be close to script, only without the escape sequences
23:46  cthuluh: argh
23:46  Riviera: but surely a bit more complicated to use
23:46  cthuluh: Riviera: you're a smart guy,you know? :)
23:46  }ls{: ok. Will try all named possibilities....
23:48  Riviera: }ls{: sorry
23:48  Riviera: }ls{: forgot to tell that this idea originally was introduced by cthuluh :)
23:49  Riviera: }ls{: he was a bit upset that i did not give credits :)
23:49  }ls{: cthuluh: I realized anyway  .-)
23:49  Riviera: anyway, i'd either use expect or ssh -t, if they suffice.
23:50  }ls{: And one more time: Thanks to all. It's my first and only channel for all kind of shell questions. Never left unanswered. And all answers lead me to better understanding.
23:51  }ls{: And it teaches me a lot just by hanging here around...
23:51  cthuluh: Riviera: heh. that's wrong. I had not thought about using screen's hardcopy feature
23:52  Riviera: cthuluh: too bad i don't keep logfiles .)
--- Log closed Wed Dec 08 00:00:50 2010
