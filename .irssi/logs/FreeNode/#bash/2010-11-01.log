--- Log opened Mon Nov 01 00:00:11 2010
--- Day changed Mon Nov 01 2010
00:00  poisonbit: BarkingFish, yes, you can just hardcode commands, without using a lot of bash features...
00:00  poisonbit: chmod +x file
00:00  poisonbit: ./file
00:00  BarkingFish: cool
00:00  BarkingFish: cheers :)
00:00  Rakko: hi
00:02  Rakko: This only prints out foo and bar; why doesn't it also print baz?
00:02  Rakko: string='foo:bar:baz'; arr=(); while IFS=: read -r -d : comp; do arr+=("$comp"); done <<< "$string"; for i in "${arr[@]}"; do echo $i; done
00:02  Rakko: oops, actually it used to say IFS=: (but both print the same thing)
00:02  Rakko: arg, I mean IFS=
00:03  BarkingFish: Sorry about that, hit the wrong button
00:04  BarkingFish: poisonbit: can you tell me if this looks about right? Do I need to separate the lines with anything, or is this fine as it? http://pastebin.ca/1978252
00:04  poisonbit: fine
00:04  poisonbit: try and see
00:04  BarkingFish: brilliant, thanks!
00:05  BarkingFish: So i just chmod +x to it, and ./ to use it - I'll drop off now and see how it goes!
00:05  lhunath: Rakko: -d specifies the "line terminator character"
00:05  Rakko: lhunath: does it need to be a "line" though? I'm just extrapolating from the use of -d '$\0', which does work
00:05  Rakko: anyway, I'm trying to split on :
00:06  lhunath: no, but it needs to be terminated by the character.
00:06 --- John[a] is now known as John[a][away]
00:06  Rakko: ohhh, and the baz isn't
00:06  lhunath: eg. moo:bar only the "line" moo is terminated, bar isn't.
00:06  lhunath: aye.
00:06  Rakko: so how do I split on :?
00:06  lhunath: you don't want -d.
00:06  lhunath: just IFS=:
00:06  Rakko: that returns the whole string unsplit
00:07 --- John[a][away] is now known as John[a]
00:07  lhunath: IFS=: read -r -d '' -a fields <<< "$string"
00:07  lhunath: no while.
00:08  Rakko: oh, ''? thanks
00:08  lhunath: well, '' is the same as $'\0'
00:08  Rakko: ah
00:08  Rakko: and fields is an array already?
00:08  lhunath: $'\0' is a c-string that contains a NUL byte.  but c-strings are terminated by nNUL bytes so the c-string actually ends before your nNUL byte; leaving ''
00:09  lhunath: aye, because of the -a option.
00:09  Rakko: nice! thanks
00:09  lhunath: read will use IFS to determine the character(s) to split your input on into array elements
00:09  lhunath: !faq 1
00:09  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
00:09  lhunath: !arrays
00:09  greybot: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
00:10  Rakko: FAQ 1 should really mention -a.
00:11  Rakko: in my case it's not necessary to use -d ''
00:13  poisonbit: # string='foo:bar:baz'; IFS=: read -a arr <<< "$string"; printf -- '%s\n' "${arr[@]}"
00:13  evalbot: poisonbit: foo
00:13  evalbot: poisonbit: bar
00:13  evalbot: poisonbit: baz
00:13  BarkingFish: works a charm, poisonbit - you're a star
00:13  poisonbit: no, i'm not :)
00:13  BarkingFish: cheers :D
00:13  Rakko: you can pass an unrolled array to printf %s?
00:14  BarkingFish: you are, if you can get a script newb like me, who even had difficulty with BASIC, to do that in 5 minutes, you're good
00:14  poisonbit: Rakko, yes, it's a way to do it without using a loop
00:15  ferret: you don't need to use -- with printf
00:16  ferret: %s can't begin with a -
00:16  ferret: it begins with a %
00:16  Rakko: OK... so why doesn't this modify arr? find . -type d -maxdepth 1 -print0 | IFS= read -r -d $'\0' -a arr; printf '%s\n' "${arr[@]}"
00:17  poisonbit: ferret, thanks, then i'm failing using it usually as well as i've been warned to overquote some things
00:17  ferret: !faq disappear > Rakko
00:17  greybot: Rakko: http://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop. Why do they suddenly disappear after the loop terminates? Or, why can't I pipe data to read?
00:18  Rakko: I didn't use a loop.
00:18  ferret: "Or, ..."
00:18  Rakko: oh, duh. thanks.
00:21  Rakko: hmm, now it only returns .
00:21  Rakko: s/returns/prints/
00:22  Rakko: IFS= read -r -d $'\0' -a arr < <(find . -type d -maxdepth 1 -print0); printf '%s\n' "${arr[@]}"
00:22  ritzt3ch: would i be able to view xls files with a bash script or is that more towards perl / py
00:23  cthuluh: Rakko: you need a loop
00:23  Oxy`: i'm looking for a command that complete by 0 at the left of my var if my var is < 10
00:23  Rakko: very doubtful, ritzt3ch
00:23  Oxy`: if [ "$nnumjour" -lt 10 ]; then
00:23  Oxy`: 	snumjour="0"$nnumjour
00:23  Oxy`: else
00:23  Oxy`: 	snumjour=$nnumjour
00:23  Oxy`: fi
00:23  Rakko: use a pastebin
00:23  ferret: Rakko: -maxdepth 1
00:23  Oxy`: sooryy dont wanted to do that
00:23  Rakko: cthuluh: why would I be able to read a :-delimited string without a loop, but I would need a loop for \0 ?
00:24  Rakko: ferret: that's not the problem
00:24  Oxy`: xls = xml ?
00:24  Rakko: no
00:25  cthuluh: Rakko: you're usind \0 as a delimiter, where usually you're using \n
00:25  poisonbit: ritzt3ch, it's hard for bash, unless the excel is really exported to CSV... try  http://search.cpan.org/dist/Spreadsheet-ParseExcel/
00:25  ferret: Rakko: hmm, maybe so.  Where did you find this code?
00:25  Rakko: I wrote it
00:25  ferret: Rakko: You can only create arrays with \0 as a delimiter in a loop
00:25  Rakko: lhunath: any input?
00:26  Rakko: ferret: why is that? is \0 special?
00:26  Oxy`: any help for -> i'm looking for a command that complete by 0 at the left of my var if my var is < 10 like (if [ "$nnumjour" -lt 10 ]; then; snumjour="0"$nnumjour)
00:27  Rakko: that should work, Oxy` . What's wrong with it?
00:27  ferret: Rakko: you're confusing what IFS and -d do.  IFS is the separator for each item to put in the array specified by -a
00:27  Rakko: although I would put snumjour="0$nnumjour"
00:28  ferret: Rakko: -d remains the character that causes read to terminate, even with -a
00:28  Oxy`: nothing but... maybe there a more "gentle" way to do it with a short command
00:28  ferret: Sadly you cannot put \0 into IFS, so there is no way to do it without a loop
00:28  Rakko: oh, you can't?
00:28  poisonbit: Oxy`,
00:28  poisonbit: # arr=( 8 18 ); printf '%02d\n' "${arr[@]}"
00:28  evalbot: poisonbit: 08
00:28  evalbot: poisonbit: 18
00:29  Rakko: oh, lol
00:29  Oxy`: he si a pro :)
00:29  Oxy`: poisonbit: ty .. agin :p
00:29  poisonbit: ;)
00:29  rocktop: how to test if $var = $foo ?
00:30  Oxy`: i know this one
00:30  Rakko: thanks, ferret
00:30  ferret: !gconditionals
00:30  ferret: !conditionals
00:30  greybot: Conditional Structures: http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
00:30  ferret: rocktop: ^^^
00:30  Oxy`: if [ "$foo" = "$bar" ]
00:32  poisonbit: near the question syntax can be done too:   if test "$foo" = "$bar"
00:35  Oxy`: hmm poisonbit, in my script it doesnt seems to work, maybe im doing it wrong... snnumjour=`printf "$nnumjour" '%02d\n' "${nnumjour[@]}"`
00:36  poisonbit: what does "$nnumjour" here ? between printf and his format
00:36  Oxy`: hmm this the var i want to format
00:37  poisonbit: what you want to format goes after the format
00:37  poisonbit: and you dont need a single var name as in loops, just pass the array
00:39  poisonbit: maybe what you want is:  printf -vrounded '%02d\n' "$value"
00:39  poisonbit: to get into $rounded the zeroed of $value
00:40  Oxy`: nnumjour=`printf '%02d\n' "${nnumjour[@]}"` i did that, no need of vrounded
00:40  poisonbit: ah :)
00:40  Oxy`: its ok ots working now :)
00:44  darkferret9: if you guys have a 2 line on the right side comment like [[ <code> ]] || # If A, then
00:44  darkferret9:               # B
00:45  darkferret9: would you put the code that goes after the || on the line with the B or on the line after that?
00:47  poisonbit: a right side comment should feet in less than 80 COLs for my taste...
00:47  poisonbit: else do a upper comment, before read the code, but anyway it's about each one... maybe you like other way
00:48  darkferret9: let's assume it does fit in less than 80 columns even with the code on the line with the B in it. What would you do then?
00:50  poisonbit: can you paste the example... i'm not sure if beer allows me to understand the issue  :)
00:51  poisonbit: if a single cmd needs to be splited ( \ ) to feet 80, then i use to comment before the code (the times i comment)
00:52  darkferret9: # [[ 0 == 1]] || echo hello && echo hello2
00:52  evalbot: darkferret9: bash: conditional binary operator expected
00:52  evalbot: darkferret9: bash: syntax error near `hello'
00:52  darkferret9: # [[ 0 == 1 ]] || echo hello && echo hello2
00:53  evalbot: darkferret9: hello
00:53  evalbot: darkferret9: hello2
00:53  nirlevy: hey. im trying to learn how to use my terminal on osx but i cant get bash to work
00:53  juanmabc: man, if we assume the code fits in one line, there is nothing to think for me then
00:53  nirlevy: the title bar of terminal says Terminal - login - 80x24
00:54  Gallomimia: nirlevy: type ps and hit enter
00:54  nirlevy: that does nothing
00:54  Gallomimia: it gives you an output
00:54  nirlevy: no commands seem to work, just creates a line break
00:54  nirlevy: nope
00:54  Gallomimia: sounds like your login is messed up
00:54  Rakko: you must be in a quote mode
00:54  Gallomimia: what OS are you running?
00:54  nirlevy: OSX
00:55  Gallomimia: there are 7 versions of OSX
00:55  nirlevy: haha sorry
00:55  nirlevy: the newest
00:55  Gallomimia: k. i'm unfamiliar with that one
00:55  nirlevy: 10.6
00:55  nirlevy: .4
00:55  Gallomimia: best ask them in #macosx
00:55  nirlevy: thanks for the reference
00:55  Rakko: the terminal shouldn't say 'login
00:55  nirlevy: yeah
00:55  Gallomimia: no it shouldn't
00:55  Rakko: did you type login?
00:55  Gallomimia: so, the question is what options did you change
00:56  nirlevy: i dont think so
00:56  nirlevy: i have no idea
00:56  nirlevy: im gonna ask #maxosx
00:56  Gallomimia: we can assume that you've quit and reloaded terminal.app
00:56  nirlevy: many times
00:57  Gallomimia: in my 10.5 OSX terminal.app it has options for startup
00:57  Gallomimia: it starts the program called /urs/bin/login
00:57  juanmabc: maxos, what an os
00:57  Gallomimia: which is what you've got. so probably the login isn't finishing
00:57  nirlevy: same here
00:57  nirlevy: thats the default
00:58  nirlevy: how do i address that?
00:59  Rakko: arr=(); IFS= while read -r -d $'\0' el; do arr+=(el); done < <(find . -type d -maxdepth 1 -print0); printf '%s\n' "${arr[@]}"
00:59  Rakko: this keeps saying syntax error near unexpected token `do'
00:59 --- Muzer is now known as MuzerAway
00:59  darkferret9: http://ideone.com/uaz2Z
00:59  darkferret9: poisonbit: ^^
01:00  Gallomimia: i came to ask some noob questions but i think they might be answered in the links within the topic
01:00  cthuluh: Rakko: while IFS= read -rd '' el; do arr+=( "$el" )...
01:01  Rakko: oh, I misplaced IFS=
01:01  Rakko: thanks
01:01  Rakko: among other things :/
01:01  darkferret9: how do I eliminate the stdout in the code I just pasted?
01:02  cthuluh: Rakko: using REPLY, you wouldn't need IFS=
01:02  darkferret9: nvm
01:02  cthuluh: while read -rd ''; do arr+=( "$REPLY" )...
01:02  darkferret9: my have function works perfectly :D
01:03  PRAEDO: hello
01:03  PRAEDO: i get an error in my shell script
01:03  PRAEDO: i have 2 variables set like this:
01:04  PRAEDO: var_inicial="ls -alis"
01:04  PRAEDO: and
01:04  PRAEDO: var_ordre="sort -nk 7"
01:04  PRAEDO: and i wnat to merge them into one
01:05  PRAEDO: i do this:
01:05  PRAEDO: var_total= $var_inicial '|' $var_ordre
01:05  cthuluh: don't put commands into variables. or if you reaaly want to, then use array variables
01:05  cthuluh: !ls > PRAEDO
01:05  greybot: PRAEDO: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
01:06  PRAEDO: it's just short paste, no need for pasetbin
01:06  PRAEDO: in fact that was all i had to say
01:06  PRAEDO: any idea to merge those correctly?
01:06  Rakko: cthuluh: oh, interesting
01:06  PRAEDO: when calling $var_total it fails
01:07  PRAEDO: but calling $var_inicial | $var_ordre works
01:07  cthuluh: PRAEDO: how does it fail? let me repeat: you should _not_ put code into variables
01:07  PRAEDO: fails = it thinks they're all parameters of ls
01:07  cthuluh: PRAEDO: the pipe will not be interpreted if it comes from a variable
01:08  PRAEDO: and "|", "sort" and "-nk7" aren't parameters of ls
01:09  PRAEDO: what would be the correct way tmerge the 2 variables into one?
01:09  cthuluh: therre is no correct way.
01:10  cthuluh: !ls > PRAEDO , since you didn't read this one
01:10  PRAEDO: you said using array variables
01:10  greybot: PRAEDO , since you didn't read this one: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
01:10  PRAEDO: how would that look like?
01:10  cthuluh: yes, put a pipe is not special when resulting from the expansion of a variable
01:10  PRAEDO: i don't understand what you mean
01:10  cthuluh: so using an array or not would not solve your problem
01:11  cthuluh: 4# pipe='|'; echo foo "$pipe" grep foo
01:11  shbot: cthuluh: foo | grep foo
01:11  PRAEDO: var_total= $var_inicial '|' $var_ordre
01:12  PRAEDO: could this line be fixed in some way to make it work?
01:12  alistrone: cthuluh... it is cthulhu.
01:12  cthuluh: alistrone: fine
01:12  alistrone: =D
01:12  cthuluh: PRAEDO: by not using variables
01:13  PRAEDO: my practise exercise consist of using them
01:13  cthuluh: who did give you this exercise?
01:13  PRAEDO: it must be possible to merge 2 variables into 1
01:13  darkferret9: why is mywiki.wooledge.com snail slow?
01:14  cthuluh: 4#  a=foo b=bar; concat="$a$b"; echo "$concat" # < PRAEDO
01:14  shbot: cthuluh: foobar
01:14  yitz_: # a="Hello " ; b=PRAEDO ; a="$a$b" ; echo "$a"
01:14  evalbot: yitz_: Hello PRAEDO
01:14  cthuluh: this is variable concatenation
01:15  PRAEDO: ok
01:15  PRAEDO: and if those are commands, would they work? (work=not be taken as ls parameters)
01:16  cthuluh: 4# array=('touch' 'foo' 'bar'); "${array[@]}"; echo ./* # < PRAEDO
01:16  shbot: cthuluh: ./bar ./foo
01:17  cthuluh: but, again, you can _not_ put a pipe in a variable. if you want to factorise (or any more appropriate english term) code, then use functions
01:18  PRAEDO: # a="foo" ; b="bar" ; c="$a$b" ; echo "$c"
01:18  evalbot: PRAEDO: foobar
01:18  PRAEDO: # a="foo" ; b="bar" ; c="$a $b" ; echo "$c"
01:18  evalbot: PRAEDO: foo bar
01:20  twkm: PRAEDO: perhaps you want command subsitution.
01:21  Rakko: is there a way to benchmark/profile bash scripts?
01:21  PRAEDO: if the pipe won't work, then how would it look to have a single variabl eworking?
01:24  Knirch: i cant find an original question that makes any sense, can you restate the question with what you've learned so far?
01:24  cthuluh: Rakko: check ''help time''
01:24  twkm: Rakko: probably.
01:27  Rakko: cthuluh: ok, but I want to know which lines and functions are taking up the most time
01:27  Knirch: PRAEDO: i dont understand your question, you shouldnt keep commands in variables, use functions if you must store a command and arguments. then it's just  output=$(func1 | func2)
01:30  poisonbit: # echo 'lla sthgin dooG' | rev
01:30  evalbot: poisonbit: bash: rev: command not found
01:30  poisonbit: bah
01:30  Rakko: I've noticed a lot of scripts that quote both the left and right sides of comparisons. Is that the standard practice? (I'm wondering whether I should just unquote the parts without variables and without spaces in them.)
01:31  Knirch: Rakko: depends on what you want to achieve and if you kuse test, [, [[ or ((
01:32  Knirch: s/ku/u
01:33  Rakko: ok
01:33  Rakko: how do [, [[, and (( differ in that respect?
01:34  yitz_: Rakko: [ needs vars quotes. [[ and (( don't
01:34  Knirch: # a=foobar ; [[ $a = foo* ]] && echo matches
01:34  evalbot: Knirch: matches
01:34  yitz_: Inside (( and [[ things are evaluated differently than elsewhere
01:34  Rakko: yitz_: but it doesn't need quotes around constants. Constants are what I'm talking about.
01:34  cthuluh: [[ needs quotes on the right hand side, if you want to avoid glob
01:34  Knirch: # a=foobar ; [[ $a = "foo*" ]] && echo matches
01:34  evalbot: Knirch: no output
01:35  Rakko: ok
01:35  twkm: you seldom need to quote constants.
01:35  Oxy`: is there a way for quoting multilignes like /* and */ in SQL
01:35  yitz_: Sorta. You can use a heredoc
01:36  yitz_: !<< > Oxy`
01:36  greybot: Oxy`: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
01:36  twkm: don't be afraid of #'s
01:39  Rakko: Oxy`: you want comments or quotes?
01:41  Oxy`: err i want to comment my bad not quotes
01:41  Oxy`: but ty yitz_
01:41  Oxy`: multiligens of comments
01:44  Oxy`: anyway its the same
01:44  Oxy`: <<COMMENTS
01:44  Oxy`: COMMENTS
01:51  twkm: not really.
02:16  Oxy`: hmm. does anybody know why my command (title=`sed "s/'//" <<<$title`) only replace the FIRST ' and not the others that it possibly have in the string
02:17  twkm: yes.
02:17  Oxy`: can you help me to define why ? :)
02:17  twkm: as an aside, replace it with just parameter expansion, no need to create a temporary file and run sed.
02:17  Oxy`: err i dont understand
02:19  krzie: besides the fact you shouldnt use sed for that, when you DO need to use sed you do s/'//g to replace all
02:19  krzie: the g is global, as opposed to first match
02:20  Oxy`: so what i should use to do that ?
02:21  ferret: !pe
02:21  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
02:23  twkm: just parameter expansion.
02:30  Oxy`: the thig is that is used this var in this command :-draw "text 145,580 '${title[@]}'"
02:30  twkm: using your sed won't change all of title's elements.
02:31  twkm: it will change just one of them.
02:31  Oxy`: yeah i know but this is just this char that cause me problems
02:31  twkm: *boggle*
02:32  Oxy`: if the var conatin a ' i got an error in draw
02:32  twkm: you have horrible amounts of quoting.
02:34  Bushmills: some people like to do  a=$(bc <<< "$a+1")  for incrementing the value of a variable.  yours is the text substitution equivalent of that
02:37  Oxy`: hmm thats not a pro script, i'm just learning in fac this is my first... so i'm not afraid of my mistakes by now
02:37  Bushmills: # a="foo'bar"; echo ${a/"'"/}
02:37  evalbot: Bushmills: foobar
02:38  Oxy`: # a="foo'b'ar"; echo ${a/"'"/}
02:38  evalbot: Oxy`: foob'ar
02:38  Oxy`: # a="foo'b'ar"; echo ${a/"'"/g}
02:38  evalbot: Oxy`: foogb'ar
02:39  Bushmills: # a="fo'o'b'a'r"; echo ${a//"'"/}
02:39  evalbot: Bushmills: foobar
02:39  Oxy`: i missed the g point :)
02:39  Oxy`: Thank you
02:40  Oxy`: ill use parameters expansion next time
02:40  Oxy`: (if ill get used to it usage)
02:43  Bushmills: # a=5; a=$(echo "$a+1" | bc); echo $a  # would this need an eval for good measure?
02:43  evalbot: Bushmills: 6
02:44  Oxy`: lol
02:45  c00kiemon5ter: when I ask a path argument, do I expect the argument to be like foo/bar or be like foo/bar/ ?
02:45  c00kiemon5ter: so if I store that path to a variable say 'p
02:46  Bushmills:  ${mypath}myfile looks ugly
02:46  c00kiemon5ter: yes ^
02:46  Bushmills: $mypath/myfile seems much better
02:46  c00kiemon5ter: but else I get path//file
02:46  aschoeke: Hi, I found a strange behavior of grep -n under Mac and wanted to ask if somebody might be able to confirm it. If you iterate over files and grep -n them in a for-loop with bash, I get two matches for each hit: First is the line number, second is the match itself. This is obviously wrong, as I should receive just one match being the line number followed by the match in the same iteration.
02:47  tmr: !faq 1 > aschoeke
02:47  greybot: aschoeke: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
02:48  aschoeke: That's not helpful per se... I know, that I can read file line by line.
02:49  twkm: i hope someone understood what you meant.
02:50  Bushmills: i didn't. but otoh, i don't use a mac.
02:50  c00kiemon5ter: well actually share some code to see if you do something wrong or it's actually a bug
02:50  c00kiemon5ter: I dont use mac either
02:52  Oxy`: Bye all and thx for help :))
02:52  aschoeke: for file in *.txt; do for i in `grep -n Scne $file`; do echo $i; done; done
02:53  twkm: change *.txt to ./*.txt, quote $file and $i, see if the results make more sense.
02:53  aschoeke: yields e.g. 35: bush , 73: , casi , 111: , weih where each coma is actually a new line.
02:54  c00kiemon5ter: why do you echo the results? grep does that anyway
02:54  aschoeke: twkm: First occu
02:54  falconindy: looks like working as intended to me
02:54  twkm: random parti
02:55  aschoeke: falconindy: no, each number and occurrence pair should be in one line.
02:55  falconindy: sure, but the way you've written it, it's working as intended
02:56  falconindy: perhaps you should glance at the output of grep -n and then read up on word splitting
02:58  c00kiemon5ter: I have a feeling what you really want is
02:58  c00kiemon5ter: for file in *; do grep -n Sche "$file"; done
02:58  c00kiemon5ter: I dont see the purpose of the inner for :S
02:58  falconindy: or just: grep -n Sche *
02:58  c00kiemon5ter: yes, or that.. :S
03:00  c00kiemon5ter: given . as the argument how can I make this the real dir name
03:00  c00kiemon5ter: I have a better question :P
03:00  falconindy: readlink -f .
03:00  c00kiemon5ter: should I work with full paths or relative ones?
03:06  aschoeke: c00kiemon5ter: not quite what I intended to do. I basically expected the same behavior from it as if I wouldn't do it in a for loop but for each file seperatly.
03:07  c00kiemon5ter: aschoeke: I'm not sure what you're trying to do, I dont get double results or anything, but the results of grep are splitted into multiple lines
03:08  c00kiemon5ter: that's expected because the results have spaces in them
03:08  c00kiemon5ter: and that's your problem probably
03:08  bonhoffer: i want to wget a file and unzip it in one line should i do unzip `wget http://foo/foo.zip`
03:09  bonhoffer: thinking a pipe would be a better option
03:09  c00kiemon5ter: if grep -n a test; returns --> test:3:foo bar bla
03:09  c00kiemon5ter: then your loop would return
03:09  aschoeke: c00kiemon5ter: the results should be one result each line, right? each result is the line number and the match, correct?
03:09  c00kiemon5ter: test:3:foo
03:09  c00kiemon5ter: bar
03:09  c00kiemon5ter: bla
03:09  bonhoffer: anyway -- the result is the file -- not the file name -- so i don't know of a slick way
03:10  falconindy: bonhoffer: zip is not a streamable format. you need the full file downloaded before it can be uncompressed
03:10  bonhoffer: falconindy: thought that
03:10  twkm: not true.  but it hardly matters.
03:11  c00kiemon5ter: you actually need a way to get the downloaded filename and give it to unzip
03:11  bonhoffer: maybe a bash script (custom) would take the url download it and then unzip it and delete the zip file
03:11  c00kiemon5ter: and then rm ..
03:11  c00kiemon5ter: ...
03:11  twkm: tee.
03:11  bonhoffer: doing this for 30 files
03:11  bonhoffer: little regex
03:11  bonhoffer: twkm: how would tee do it?
03:12  bonhoffer: it is just the name after .*\/
03:12  twkm: tee isn't needed for your original case.
03:12  twkm: (probably isn't needed for the lesser lie of the expanded case either)
03:22  Rakko: is test x == y the same as test x = y?
03:27  tmr: Rakko, yes.
03:27  Rakko: ok
03:28  Rakko: I just noticed that == isn't mentioned in `help test`, but it is mentioned in `help [[`
03:36  tmr: Rakko, it's same thing with bash builtin test.
03:36  Rakko: that's what I was talking about
03:40  Baralaq: how to show a line (for example, line 7) of a command ouput? thnks
03:40 --- remote is now known as Guest31021
03:40  Baralaq: how to show a line (for example, line number 7) of a command ouput? thnks
03:40  twkm: lots of ways.  don't you know any tools?
03:40 --- remote_ is now known as remote
03:41  Baralaq: i just want to know a way
03:41  Baralaq: ;)
03:41  Baralaq: i just want to know one way
03:41  Baralaq: ;)
03:44  Baralaq: does anyone know a way to show a line (by the line number. for example, line number 7) of a command ouput??
03:46  tmr: 4# for i in {1..10}; do printf "line %d\n" "$i"; done | sed -n 7p
03:46  shbot: tmr: line 7
03:48  twkm: because just saying ''sed -n 7p'' wouldn't penetrate?
03:50  tmr: Exactly.
04:01  Rakko: is there an easy way to see if an array contains a string, and tell me where in the array?
04:29  infid: what would happen if you did:  command 2&>/dev/null instead of 2>/dev/null ?
04:29  infid: er
04:29  infid: 2>&1/dev/null i meant
04:29  infid: ack no
04:29  infid: 2>&/dev/null
04:30  infid: third time's a charm
04:30  c00kiemon5ter: bashusr: /dev/null: ambiguous redirect
04:31  c00kiemon5ter: I dont know where usr came from :S
04:31  c00kiemon5ter: bash*usr* :S :S
04:31  gnychis: I'm trying to capture SCP's output of the progress bar which updates every 1 second and updates the transfer rate.  But, if I try piping then it only outputs the final rate ... does anyone know a trick that I could use to capture it?
04:31  infid: thanks
04:32  c00kiemon5ter: infid: if you want all streams to go to null then do 'command &>/dev/null' & would expect a stream and /dev/null is not one, it's a file
04:35  c00kiemon5ter: I might be making things up, it's early in the morning and I need some sleep, cu later
04:38  Baralaq: tmr, twkm i needed sed. thanks :)
04:38  twkm: sorry to hear it.
04:38  bashusr: c00kiemon5ter: don't tab complete me!
04:38  bashusr: =P
04:39  pragma_: bashusr: why not?
04:39  c00kiemon5ter: oh!
04:39  bashusr: cuz i'll get a text
04:39  bashusr: and then get mad
04:39  pragma_: bashusr: a text to your cell phone?
04:39  c00kiemon5ter: I pasted bash: and irssi autocompleted it to you
04:39  bashusr: pragma_: yeah
04:39  pragma_: bashusr: is irc that important to you?
04:39  twkm: hilarious.
04:40  bashusr: i run a channel
04:40  twkm: i think i'll put it on repeat.
04:40  c00kiemon5ter: for a moment I thought buffers were buggy
04:40  bashusr: and they often need me to kick someone or something
04:40  bashusr: i am never on IRC anymore
04:40  pragma_: bashusr: i hope you get unlimited texts rather than pay-per-text
04:40  twkm: most people would transfer some control to others.
04:40 * pragma_ pays $37 a month for an unlimited data plan
04:41  twkm: but whatever bashusr, i'll try not to mispaste bashusr instead of bash, hopefully bashusr.
04:41  bashusr: twkm: lol
04:41  bashusr: it doesn't text me when i'm here
04:41  bashusr: i have a cool irssi autoaway on screen detach
04:41  bashusr: and then a away message forward to email function
04:41  pragma_: doh!
04:41  twkm: moronic.  pass the baton.
04:42  pragma_: bashusr: are you an op in this channel?
04:42  bashusr: no
04:42  bashusr: another channel
04:42  pragma_: bashusr: then why do you need texts from this channel?
04:42  bashusr: i should set it to only alert me about my channelb
04:42  twkm: it is only semi-cool, not super-cool.
04:42  bashusr: but i never programmed it
04:42  tmr: bashusr, telling that in here could end up being a big mistake.
04:42  bashusr: it sends me alerts on PMs
04:42  bashusr: and text-highlight
04:43  pragma_: tmr: I'm still watiing to find out about his data plan
04:43  bashusr: pragma_: haha, it's fine - just annoying
04:43  pragma_: oh well, it'll still be fun knowing that his pager is going off when he's away
04:43  pragma_: er, phone
04:43  pragma_: shit, are pagers even around anymore?
04:44  bashusr: yeah they are
04:46  gnychis: I'm trying to capture SCP's output of the progress bar which updates every 1 second and updates the transfer rate.  But, if I try piping then it only outputs the final rate ... does anyone know a trick that I could use to capture it?
04:47  twkm: don't pipe it.
04:49  gnychis: and do what instead?
04:50  twkm: primarily don't use scp, but you might consider rewriting your script in tcl so you can make use of expect.
04:56  c00kiemon5ter: and use what in place of scp ?
04:57  c00kiemon5ter: sshfs can do the job right ?
04:58  c00kiemon5ter: I'm getting some sleep, cu later o/
05:05  Rakko: does bash have a way to join an array into a string with a given delimiter?
05:05  twkm: yes.
05:05  Rakko: without a loop?
05:06  Rakko: oh, IFS and arr[*]
05:06  twkm: keep adding requirements after each question, it makes this so much more like a game show.
05:06  Rakko: sorry :)
05:07  Rakko: hmm, not working for me. I have: IFS=':' echo "${paths[*]}"
05:09  Rakko: i.e. it still uses a space as separator
05:12  twkm: do you feel it is echo that expands the paths array?
05:12  Rakko: no, I assume the shell does
05:12  Rakko: are you saying I need to set IFS in a separate statement? I'll try that
05:13  Rakko: thanks, that's it
05:14  twkm: the key being that IFS was being set in echo's environment, not in the current shell's which is where the expansion was taking place.
05:14  Rakko: yeah
05:17 --- Guest94983 is now known as Nemphilis
05:21  Rakko: I am trying to time the execution of a shell function within a loop, but the function isn't available inside time's subshell, even when I invoke it with bash -lc function
05:21  Rakko: any hints?
05:22  Rakko: specifically now time (for ((i = 0; i < 1000; ++ i)); do bash -lc "add_to_path_ARRAYS --start $PATH /usr/local/bin"; done)
05:22  Rakko: add_to_path_ARRAYS is my function
05:23  gnychis: how can i replace all CR with LF using sed?  I have tried "sed 's/\r/\n/g' output" but that doesn't seem to work... this works to remove the CR though using tr:  "cat output | tr -d "\r \n""
05:24  Rakko: it also doesn't work with the outside ( ) out
05:29  Rakko: try \\r and \\n
05:30  twkm: Rakko: time bash -c
05:30  twkm: gnychis: avoid it.  use recode instead.
05:31  Rakko: ok, now I have time for ((i = 0; i < 1000; ++ i)); do bash -lc add_to_path_ARRAYS --start $PATH /usr/local/bin; done
05:32  Rakko: twkm: oh, ok... maybe I should put the loop inside the timed bash
05:33  Rakko: I'm still not getting it :/
05:34  twkm: time bash -c 'for ...'
05:35  Rakko: still the function isn't found
05:36  Rakko: it seems -c doesn't expose functions.
05:36  twkm: nothing does.
05:36  twkm: (there is a way, but it is ab(by)normal)
05:36  Rakko: oh, duh, I'll stick it in a shell script
05:36  Rakko: what's the abbynormal way?
05:36  twkm: ''help export''
05:37  Rakko: oh, cool
05:38  Rakko: you know what? I had a damn typo in my func name. sorry for the trouble :(
05:38  Rakko: with it spelled correctly, bash -c did work
05:39  Rakko: at least with -l too
05:44  Rakko: now a regression
05:44 --- mikeplus32 is now known as mikeplus64
07:37  fluter: hi buddies, is there any way to pass parameters to sed script?
07:37  fluter: hi buddies, is there any way to pass parameters to sed script?
07:55 --- streuner__ is now known as streuner
08:21  Andr00: "sudo rm -rf /" is to Linux what "Avada Kedavra" is to Albus Dumbledore
08:22  \DSAFEW\: Andr00, nooooo!! you spoiled linux for me.
08:22  Andr00: sry
08:22  \DSAFEW\: I was almost at the end too.
08:23  Andr00: lol
08:25  pgas: except it doesn't work with gnu rm
08:29  Andr00: anyway i think agent smith from the matrix forkbombed himself........ over ten thousand copys of himself
08:32  thunderstrike: i want to reverse the ip address from 1.2.3.4 to 4.2.3.1 in a single command or so...as i dont want to give multiple echo's for better performance..
08:32  thunderstrike: plz suggest
08:34  pgas: ahaha
08:35  pgas: echo is a builtin.I don't think 1 or 4 echo makes such a difference
--- Log closed Mon Nov 01 09:01:47 2010
--- Log opened Mon Nov 01 09:01:57 2010
09:01 --- Users 492 nicks [0 ops, 0 halfops, 0 voices, 492 normal]
09:02  fluter: pgas: ok, but loop is not so simpile, cause to support --name=aa and --name aa, -n aa
09:03 --- Channel #bash was synced in 85 seconds
09:04  poisonbit: the --name=var is the problem,  but the others are easy:  case "$1$ in ...  --name|-n) name_option="$2"  ;;
09:04  poisonbit: if you go with positional parameters, then you need positional parameters,
09:05  poisonbit: to use positional parameters + --foo=var syntax, you will need to substring "$1", and take the right side of the =
09:06  geirha: --name=*) name=${1#--name=} ;; --name) name=$2; shift;;
09:07  poisonbit: seen implemented it looks not too much work  :)
09:07  fluter: ha, right, shell expansion is great
09:22  fluter: !sed
09:22  greybot: sed is a Stream Editor, used to filter output. It's NOT primarily useful for editing files (use ed or perl instead). Ask sed questions in ##sed.
09:22  fluter: !ed
09:22  greybot: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
09:26  fluter: !faq ed
09:26  greybot: http://mywiki.wooledge.org/BashFAQ/014 -- How can I redirect the output of multiple commands at once?
09:34  bassliner: ed is the standard text editor.
09:43  hellman: how can i copy $@ into another array without word splitting? i don't want arguments to be splitted, but if i set IFS="" copied array has all arguments in one string
09:43  geirha: array=("$@")
09:43  geirha: The quotes are the key
09:43  geirha: !wordsplitting
09:43  greybot: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
09:44  geirha: !$@
09:44  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
09:45  hellman: thx, looks like it worked
09:51  fahmad: hello
09:51  fahmad: can some one tell me is there any log parster which will show stats for this log format ...
09:51  fahmad: http://paste.ubuntu.com/523731/
09:56  donatilo: i have a faile that has entries as follows '5278 Host 108  DS 8874' i want to loop in that file extracting the host_id which is the number next to Host and the id which is the number next to DS and put them in a mysql query 'select snmp_index from table where host_id='"$host_id"'' and id='"$id"'
09:57  twkm: pathetic.
10:00  donatilo: twkm: what did hit you as pathetic?
10:03  Zeu5: hi i have a bash script that contains a single line of sed
10:03  Zeu5: i am unsure but can i do something like this?
10:04  Zeu5: . bashScript anotherfilename
10:04  Zeu5: where anotherFilename is the file that i wish to run sed on
10:05  bassliner: Zeu5: you could do that, yes.
10:06  lhunath: Zeu5: sure; if you pass the first positional parameter to sed in the script.
10:06  lhunath: seems like a function would be more appropriate.
10:08  Zeu5: lhunath: so inside my bash script the first positional paramter is $1 yes?
10:08  lhunath: don't forget your quotes.
10:08  Zeu5: lhunath: oops. its $0
10:08  lhunath: nope, $1.
10:08  lhunath: $0 is the name of the process.
10:09  Zeu5: so i need to execute it as . mybashscript "/path/tofile/iwanttosedon/filename"
10:10  nicola_pav: hello. i want to use the command find to move files
10:10  nicola_pav: i want to use find only in the main directory
10:10  nicola_pav: not in the sub
10:10  lhunath: Zeu5: you need to quote every argument that contains whitespace or expansions.  $1 is an expansion, so in your script you need to quote the argument that contains $1.
10:10  nicola_pav: how can i do that?
10:10  lhunath: sed '..' "$1"
10:10  lhunath: !args > Zeu5
10:10  greybot: Zeu5: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
10:10  Zeu5: lhunath: i see
10:11  pgas: !find > nicola_pav
10:11  greybot: nicola_pav: http://mywiki.wooledge.org/UsingFind
10:11  lhunath: nicola_pav: how about... NOT using find?  seeing as you don't want to recurse.
10:12  lhunath: for file in maindir/*; do mv "$file" ...; done
10:12  nicola_pav: i want to use -mtime +10
10:13  lhunath: shrug.  ok, then you want maxdepth, I guess.
10:13  nicola_pav: i want to write a script and put it in crontab to run daily
10:15  hellman: !strings
10:15  greybot: Bash parameter expansion does lots of string operations. See !faq 100 for info on string operations in bash.
10:15  hellman: !faq 100
10:15  greybot: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
--- Log closed Mon Nov 01 11:10:22 2010
--- Log opened Mon Nov 01 11:11:06 2010
11:11 --- Users 502 nicks [0 ops, 0 halfops, 0 voices, 502 normal]
11:12 --- Channel #bash was synced in 89 seconds
11:17 --- sn181 is now known as sn18
11:25  hellman: !if
11:25  greybot: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
11:29 --- drizztbsd_ is now known as drizztbsd
11:30  fahmad: can some one tell me is there any log parster which will show stats for this log format http://paste.ubuntu.com/523731/
11:45  hipe: is there a way to echo out to stdout everything that you execute in a shell script? i'm writing a one line shell script that executes an rsync command, and i'd like to see the command that it issues.  if i remember way back, there was a dos scripting command for this, something like "@echo on"
11:47  geirha: echo command to be executed
11:47  geirha: command to be executed
11:47  geirha: Give set -v or set -x a look too
11:47  geirha: ''help set''
11:53  sn18: trap 'echo "$BASH_COMMAND"' DEBUG (bash 4)
11:57  nicola_pav: hello. i want to use find to delete some files
11:57  nicola_pav: can i exclude some files?
11:57  nicola_pav: i want to exclude 5 specific files
11:57  nicola_pav: how can i do this with find?
11:58  twkm: have you considered looking at the find documentation?
11:59  nicola_pav: no
12:00  erUSUL: !find > nicola_pav
12:00  greybot: nicola_pav: http://mywiki.wooledge.org/UsingFind
12:10 --- sn181 is now known as sn18
--- Log closed Mon Nov 01 13:04:22 2010
--- Log opened Mon Nov 01 13:17:27 2010
13:17 --- Users 509 nicks [0 ops, 0 halfops, 0 voices, 509 normal]
13:17  fris: just curious if it can be done in 1, i need both results
13:18 --- Channel #bash was synced in 86 seconds
13:21  koala_man: fris: you could grep both at the same time, if you're able to separate them by relative position
13:22  twkm: not even having looked, i can now smell glark.
13:25  Bushmills: you can loop through friends followers and use loop variable to substitute its value in your command
13:28  Bushmills: # for var in friends followers; do echo "complex command using $var in this iteration"; done
13:28  evalbot: Bushmills: complex command using friends in this iteration
13:28  evalbot: Bushmills: complex command using followers in this iteration
13:46  imMute: Need some help fixing my bash prompt.  The code is at http://pastebin.ca/1978642 and some screenshots are at http://www.d.umn.edu/~sick0034/stuff/bash.jpg - it works, until I start screen, then it freaks out..  any ideas why?
13:49  imMute: also, by "works" i should note that I have to manually run twtty every time I start a new bash session... it wasn't doing this a few days ago and I dont know why :(
14:03 --- Rada_ is now known as Rada
--- Log closed Mon Nov 01 14:56:13 2010
--- Log opened Mon Nov 01 15:01:35 2010
15:01 --- Users 516 nicks [0 ops, 0 halfops, 0 voices, 516 normal]
15:02 --- Channel #bash was synced in 87 seconds
15:05  heiner: TheBonsai: thanks
15:06  sybariten: hey
15:06  TheBonsai: sybariten: hey
15:07  TheBonsai: coachz: i'm not sure i understand what you mean
15:07  sybariten: i want to make a test in the beginning of a script or a function, so that all source dirs/files from a path are writeable by the user, (or _A_ user), and so that the dest place is writeable as well. What do you suggest as a good strategy for this...
15:07  sybariten: some "find" coupled with "grep" to look for offending permission bits?
15:08  TheBonsai: a foreign user or the user running the shell?
15:08  twkm: coachz: and?
15:08  twkm: perhaps you want read and case.
15:09  coachz: i think so, thanks
15:09  twkm: though select and some functions might be more interesting.
15:09  TheBonsai: or select
15:09  coachz: i found an example, ok, i'll check out select too, thank you
15:09  twkm: sybariten: i suggest not, but good luck with your race.
15:10  sybariten: TheBonsai: the user running the shell but i could even hardcode which user.
15:11  TheBonsai: if it's the user running the shell then it's easy, a list of directories, a loop, and a test command. but for "any" user it'll be hard. regardless the potential race, yes
15:12  twkm: race for the user running the shell too.
15:12  cocoa117: i got this line in my script, `echo "${sourceFile[$i]}" | grep "^\[.*\]$"`
15:13  cocoa117: but it keep telling me "./packageInstall: line 17: [keys]: command not found"
15:13  TheBonsai: twkm: yes, for both ways, of course
15:14  TheBonsai: cocoa117: the result of your backquote expansion is executed. what do you want to do with it?
15:15  droope: Hi! I have a list of a few servers (50 or so) and I want to connect through ssh to all of them and execute a command. Can anyone help me? I have tried massh, a bash util but it forces me to use keys and I don't understand that much
15:15  cocoa117: i want to use grep to find line with ^\[.*\]$
15:15  twkm: droope: #openssh
15:15  droope: twkm: thanks
15:15  droope: cocoa117 a line with anything inside?
15:15  TheBonsai: cocoa117: and what do you want to do with the result? at the moment you just execute the resulting text...
15:15  droope: Ah, sorry
15:15  droope: I got it now
15:16  TheBonsai: # `echo huha`
15:16  evalbot: TheBonsai: bash: huha: command not found
15:16  cocoa117: TheBonsai, the result is the condition for while
15:16  TheBonsai: you said this is your line
15:16  TheBonsai: there is no "while"
15:16  cocoa117: while, that line keep give me error message, the next line is while loop
15:16  TheBonsai: then use the grep exit code as condition: while foo ... | grep bar; do ...; done
15:17  TheBonsai: oh
15:17  TheBonsai: then not
15:17  TheBonsai: this line does exactly what it was told to do
15:17  cocoa117: yes, that's what i thought
15:17  cocoa117: can't figure where it went wrong
15:18  wame: hi eveyrone, i have an issue with cat in a script, i do something like this VAR=`cat configfile | grep pid-file` and i successfully get the name of the PID file, but what if i want to cat the content of the PID file ?
15:18  TheBonsai: put it as the while condition then
15:19  cocoa117: thebonsai, i did, and it gives error message, so I separated it and see what happens
15:19  TheBonsai: wame: cat $VAR? after some text cutting, probably
15:19  TheBonsai: cocoa117: the backquotes are wrong?
15:19  TheBonsai: cocoa117: backquotes expand to the output (TEXT!) of a command.
15:20  cocoa117: oh
15:20  TheBonsai: # while `echo huha`; do echo m00; done
15:20  evalbot: TheBonsai: bash: huha: command not found
15:20  TheBonsai: # while echo huha; do echo m00; done
15:20  evalbot: TheBonsai: huha
15:20  evalbot: TheBonsai: m00
15:20  evalbot: TheBonsai: etc... ( http://pastebin.com/c0jPVfhH )
15:21  TheBonsai: (echo's exit code is "true")
15:21  cocoa117: thebonsai, k
15:21 --- icqn is now known as ibqn
15:21  wame: TheBonsai: yep but it's strange i get a permission denied when i do this, my permissions are ok (root) and i can cat the file in a terminal
15:21  sybariten: TheBonsai: yeah it'll be for the user running the shell so thats cool. But on a more detailed level, do you know what's best for doing the permissions test beforehand, so to speak? The whole idea is to not start moving dir structures if some objects will be "stuck". Is find better than ls -l and awk uglery?
15:21  TheBonsai: wame: echo "'$VAR'" before and check if it is really only and only the filename
15:23  TheBonsai: sybariten: for dir in ... ... ... ... ... ... ...; do test -d "$dir" && test -w "$dir" || { echo FAIL >&2; exit 1; }; done
15:23  TheBonsai: sybariten: something like that
15:23  sybariten: oh, test
15:23  sybariten: thank you!
15:25  TheBonsai: sybariten: the race twkm mentioned: the permissions can of course change between the test and the use of the directory
15:27  wame: TheBonsai: ok i fixed it, now if i want to test if my strings is empty i do if [ -n $VAR ] ; then ... and even if my string is not empty it passes the condition, weird no ?
15:28  TheBonsai:         -n STRING
15:28  TheBonsai:         STRING         True if string is not empty.
15:28  TheBonsai: "and even if my string is not empty it passes the condition"
15:28  TheBonsai: --> ????
15:31  TheBonsai: !translate coati
15:31  TheBonsai: ehehehehe
15:32  geirha: wame: if VAR is empty, that command becomes [ -n ]  after expansion. Which tests if -n is a non-empty string.
15:33  geirha: [ -n "$VAR" ], however, will be expanded to [ -n "" ]  which will return false.
15:33 --- keystr0k_ is now known as keystr0k
15:33  geirha: wame: If you are scripting bash, don't use [
15:33  geirha: !tests
15:33  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
15:34  lunaphyte_: given a file as input, how can i remove all lines following the last line whose first non whitespace character is '#'?
15:35  lunaphyte_: in other words, i want to truncate a file following it's leading comments.
15:37  geirha: sed -n '/^[^#]/,$p' file
15:37  geirha: From the first line that starts with a character that is not # until the end of the file, print.
15:38  doublehp: hy; in some "daemon script", i used to do << command > result_file >>, where the file was very frequently read by an other daemon script. I have tried to use locks to avoid letting the readers read an empty file. Locks are hell to manage, and make code heavier; having to produce several dozen locks per second may be bad. I had a new idea:
15:38  geirha: Err, but you wanted the opposite ^^
15:38  geirha: sed '/^[^#]/,$d' file
15:39  lunaphyte_: geirha: d=delete?
15:39  geirha: doublehp: command > result_file.tmp && mv result_file.tmp result_file
15:39  doublehp: instead of  << command >logfile >> + lock, i thought about: << command > log.tmp ; mv log.tmp logfile >>, without locks; whould it work fine ? would it avoid me having to use locks, and, still protect against reading daemon to read an "empty file" ?
15:39  geirha: lunaphyte_: YEs
15:39  lunaphyte_: got it, thanks.
15:40  doublehp: i mean, is the mv command "atomic" enough to solve all this ?
15:40  geirha: doublehp: If it's on the same filesystem, it'll be atomic.
15:40  doublehp: geirha: not the problem yet, but still asking: would mv also work over NFS ?
15:41  geirha: doublehp: Probably. Try an nfs channel (if there is any) or OS channel.
15:41  doublehp: i also have proofs that cp is less atomic than mv; is there a way to make cp as much atomic as mv ?
15:42  doublehp: or do i have to use mv in the end anyway ?
15:42  geirha: doublehp: No. mv is atomic because it only renames the file. copy has to read all bytes from source file and write to dest file.
15:42  wame: doublehp: which proofs ?
15:43  geirha: doublehp: And if you move between filesystems, mv will become a cp+rm.
15:43  doublehp: wame: copy a movie over two disks; start reading the movie during copy: mplayer can't read the TOC (which is in the end in a .avi); also do "ls -lh" on the file, the target file during copy, the size is "growing" with time
15:43  doublehp: geirha: so, to have a "secured" mv over different FS, i again have to use a temp file ?
15:43  wame: maybe use rsync to copy
15:44  geirha: doublehp: Start the copy, sleep a few seconds, then mplayer -idx video.avi
15:44  wame: it's atomic so ...
15:44  doublehp: i can't use any kind of sleep or wait, and want to avoid locks. so ....
15:44  geirha: doublehp: Yes, cp, then mv when cp is complete.
15:45  doublehp: cp /mnt/a/file /mnt/b/file.tmp ; mv /mnt/b/file.tmp /mnt/b/file ... ?
15:45  doublehp: geirha: thanks. Will solve future problems :)
15:45  geirha: doublehp: I'd use && between those commands. In case cp fails
15:48  doublehp: other problem: one file is used as counter: in short ... imagine << echo 1 > /tmp/count ; while true ; do i=$(cat /tmp/count) ; echo $(($i+1)) >/tmp/count ; sleep 1 ; done >>. an other daemon script needs to reset the count at random time (to 1 or 0, i don't mind). how to do it without locks ? slightly changing the first loop is accepted
15:49  doublehp: using a second file is accepted
15:49  doublehp: pipes and fifos have too many incomings for me
15:50  geirha: !faq mutual > doublehp
15:50  greybot: doublehp: http://mywiki.wooledge.org/BashFAQ/045 -- How can I ensure that only one instance of a script is running at a time (mutual exclusion)?
15:50  doublehp: (yes, i d have written echo $(($i+1)) >/tmp/count.tmp ; mv /tmp/count.tmp /tmp/count
15:51  doublehp: geirha: no, it's not the problem; this solution is too heavy for me; already tried it
15:51  saml: hey, how do you test if directory is empty?  where empty means no files other than dot files
15:51  doublehp: saml: man test ?
15:51  erUSUL: !faq empty
15:51  greybot: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
15:52  saml: if [ -z `ls blah` ]
15:52  geirha: doublehp: Ok then. Have your daemon create a different file. And if your script sees it, the script resets the counter and removes that file again
15:52  doublehp: geirha: i am using locks ATM, but they have incomings; i want to rewrite my scripts without locks
15:53  geirha: saml: Definitely not.
15:54  geirha: It's ''help test'', not ''man test'' btw.
15:54  doublehp: geirha: so i just add, between i=$() and echo $i , sth like [ -f count.reset ] && rm count.reset && i=0 ... ?
15:54  doublehp: geirha: man test gives me a usefull page :) (maybe help is richer )
15:55  geirha: doublehp: Yes, though I'd use read instead of $().
15:55  doublehp: read ? how in this case ?
15:55  saml: how can I loop over new line delimited std out?
15:55  doublehp: ah, your usual while read ; do ... ?
15:55  geirha: doublehp: test is a builtin, so help test will give info on bash's test builtin.  The man-page probably explains POSIX test.
15:55  erUSUL: !faq 1 | saml
15:55  greybot: erUSUL: No matches found at http://mywiki.wooledge.org/BashFAQ
15:55  geirha: doublehp:  read i < file
15:55  erUSUL: !faq 1 > saml
15:55  greybot: saml: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
15:56  geirha: instead of i=$(cat file)
16:01  doublehp: thank you
16:02  saml: thank you
16:10  deepinferno: hello! i need from help wih create an script that run in real time.. md5 check.. i have two files index.php and mirror.php the index and mirror need have the same md5 if the md5 of index or mirror will changed i'll receive an email about ALERT, CHANGED MD5, this is hard? someone can help me?
--- Log closed Mon Nov 01 16:20:35 2010
--- Log opened Mon Nov 01 16:31:03 2010
16:31 --- Users 521 nicks [0 ops, 0 halfops, 0 voices, 521 normal]
16:31 --- Server: [gibson.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
16:32 --- Channel #bash was synced in 84 seconds
16:33  humpty: Polochon_street: replace by nothing means delete
16:34  Polochon_street: Yes
16:35  bronze: but substitution is karmicly more positive than deletion....
16:35  tmr: Did you try searching tr man page for that magickal keyword?
16:35  bronze: OMG tr has a cli option for deletion??? OMG!!!!!   </satire>
16:36  juk: how to write to file useing cat << EOF ?
16:36  koala_man: juk: cat << EOF >> somefile
16:36  juk: koala_man: thanks
16:37  bronze: damn, apparently having Kit-Kats and pretzels for your Apre-loween breakfast does not improve one's attitude about people who don't even try to read the man pages... Gimme a break......      ;-}
16:38 --- bronze is now known as greyKat
16:39  juk: bronze: me? Kit-Kats? You love them too?
16:39  greyKat: there, now i have a nick that suits my mood better.... :-)
16:39  koala_man: I have over half a kilo of chocolate left
16:39  greyKat: heh
16:39  koala_man: and not good chocolate, kid's chocolate
16:39  juk: cheers
16:39  greyKat: koala_man: eat it all now!
16:42  greyKat: American Milk chocolate is just a sick joke (and I'm addicted to it), best used for melting on the bare skin of your posslq.  Good, real chocolate is dark and has a tiny hint of the cacao bean's bitter aspect to it.
16:42  greyKat: well thats just a little off-topic for this channel.
16:42  greyKat: sorry
--- Log closed Mon Nov 01 16:58:30 2010
--- Log opened Mon Nov 01 16:58:55 2010
16:58 --- Users 529 nicks [0 ops, 0 halfops, 0 voices, 529 normal]
17:00  ket: geirah: thanks for pointing that out. but is there any significance that one should be aware of to why that is true?
17:00 --- Channel #bash was synced in 81 seconds
17:00  woxidu_home: so I'm writing a script to simplify "dialog" in some cases, and I want it to be able to read options from stdin
17:01  woxidu_home: however, when I do that, I think dialog gets confused and can't read its keystrokes from there anymore
17:01  geirha: ket: while :; or while true; is just more "readable" I guess.
17:01  woxidu_home: so the dialog shows up, but you can't actually move around in it
17:01  woxidu_home: is there a way to have a script read everything from stdin, and then hand input control back to the terminal?
17:01 * woxidu_home imagines his script working kind of like "less"
17:02  ket: ehh
17:03  geirha: woxidu_home: dialog wouldn't know where the options end and user input started ...
17:03  woxidu_home: geirha: well I'm collecting everything in stdin up to EOF with something like, options=$(cat)
17:03  geirha: woxidu_home: Maybe  dialog --input-fd 4 ... 4< file_with_options
17:04  woxidu_home: geirha: that looks cool, but it looks like BSD's dialog sucks more than linux's
17:04  woxidu_home: geirha: and FreeBSD is my target platform
17:05  geirha: Oh wait, --input-fd changes where keyboard input comes from, not options
17:05  shadow98: http://pastebin.com/pSNgwD9b
17:05  shadow98: cannot get this script to execute the csync2 part
17:05  woxidu_home: geirha: yeah, and BSD's doesn't have --input-fd
17:06  woxidu_home: geirha: so is it possible to get input from both the stdin pipe and the terminal in bash?
17:06  geirha: woxidu_home: Anyway, it sounds like you're piping the options to your script, which in turn means stdin won't be connected to the terminal.
17:07  woxidu_home: geirha: so how does "less" do it?
17:07  woxidu_home: I mean, I understand it's not a bash script
17:07  geirha: It reads directly from the tty I'd imagine.
17:07  woxidu_home: hm
17:08  geirha: dialog ... < /dev/tty  might work.
17:08  woxidu_home: hmmm
17:08  CalimeroTeknik: can I redirect the output bash -x generates to a file ?
17:09  CalimeroTeknik: (while keeping stdin and stdout at screen)
17:09  geirha: CalimeroTeknik: 2>file
17:09  CalimeroTeknik: I haven't got only the bash -x output using that :)
17:10  CalimeroTeknik: the goal is to see what a script using dialog does, sending the output to another PTS
17:11  geirha: CalimeroTeknik: Then I don't know if it's possible.
17:11  CalimeroTeknik: I tried bash -x ./script 2>/dev/pts/1 but it breaks dialog's outputs (they are in stderr)
17:11  CalimeroTeknik: and I can't browse
17:11  greyKat: CalimeroTeknik: use the "script" command.  it collects all stuff output.  hmm - maybe have to use it in both ends...
17:12  geirha: woxidu_home: output=$(cat) is broken btw, you should read into an array.
17:12  geirha: woxidu_home: I mean options=$(cat) is broken
17:12  geirha: CalimeroTeknik: Make dialog use a different fd then
17:13  geirha: (if possible with the dialog on your system)
17:13  CalimeroTeknik: ouch, need big modifs to the script but should be doable with sed
17:14  CalimeroTeknik: --output-fd 3 should be ok
17:14  geirha: ... or just add a function at the top
17:15  geirha: exec 3>&2; dialog() { command dialog --output-fd 3 "$@"; }
17:16  woxidu_home: geirha: what's the proper form for reading into an array?
17:17  woxidu_home: geirha: like opts=$(while read line; do res=(${res[*]} $line); done) ?
17:17  geirha: woxidu_home: see faq 1 and 5
17:22  woxidu_home: geirha: what about var=$(cat) is broken, btw?
17:22  greyKat: geirha: the faqbot needs a command that opens a pm to the indicated user and streams the entire faq entry to their PM window.  The macro should be named "fsu" for "flood single user"
17:24  geirha: woxidu_home: It's somewhat usable if var is only one option. Trailing newlines will be removed though.
17:24  sybariten: i think its great that find and du use different syntax for the "max depth" option
17:25  woxidu_home: geirha: ah, yeah... that's ok in this context though
17:25  geirha: They use different option schemes
17:25  geirha: woxidu_home: So stdin only contains one option?
17:25  woxidu_home: sybariten: my real beef is that linux's "find" takes totally different options than bsd's "find"
17:26  woxidu_home: sybariten: so any script I write that makes use of one is totally useless on the other
17:26  geirha: woxidu_home: You mean GNU find vs. BSD find
17:26  sybariten: woxidu_home: oh well i havent had the pleasure of struggling with those things, over different OSes
17:26  geirha: Stick to the POSIX options and it'll work on most systems.
17:26  woxidu_home: geirha: RMS, is that you?
17:26  woxidu_home: :P
17:26  geirha: RMS?
17:27  woxidu_home: richard stallman
17:27  geirha: No. Just pointing ou that there's no such thing as linux find.
17:28  geirha: Many linux distros ship with GNU find, but some have other implementations.
17:28  sybariten: But in the find/du case i see a group of people gathering, in my mental view, discussing the development of their tool (be it du or find)... "should we adapt the option and try to follow some sort of standard, together with that other tool?" "no... no, this is our tradition. We do it this way. Alt is called meta."
17:28  woxidu_home: geirha: in my context, my script needs to massage stdin in order to make it suitable for use with dialog
17:28  woxidu_home: geirha: so I read it in as one big turd, and then doctor it up a little
17:28  sybariten: "ah, the master has spoken... behold the master...." etc etc ..   Well its just my immediate mental image
17:29  geirha: sybariten: It would require a major rewrite of either of those GNU commands to use the same options.
17:29  woxidu_home: geirha: I was joking, before, about how so many people conflate Linux and GNU in the first place, and how few people speak up about it
17:30  sybariten: geirha: its not something like going into source code and doing search and replace?
17:30  sybariten: not that i know how big a deal that is, though
17:30  woxidu_home: geirha: and RMS is the first person who comes to mind when I think of people who take that conflation seriously
17:30  geirha: sybariten: And you'd break the POSIX compliance
17:30  cocoa117: why this line is not valid for while loop? while [ echo ${sourceFile[$i]} | grep -q "^\[.*\]$" ]; do
17:30  geirha: sybariten: Think of all the scripts out there that would suddenly break?
17:30  geirha: !ifgrep > cocoa117
17:30  greybot: cocoa117: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
17:31  geirha: Same with while, it also takes a command.
17:31  cocoa117: greybot, geirha, great, got it, thanx
17:31  geirha: cocoa117: while [[ ${sourceFile[i]} = \[*\] ]]; do ...
17:32  geirha: cocoa117: Assuming each element of that array contains one line.
17:32  shadow98: is this correct
17:32  cocoa117: geirha, yes, you are right
17:32  shadow98: while read file; do exec /usr/sbin/csync2 -x >/dev/null 2>&1; done
17:32  sybariten: geirha: well, if all established scripts are to be taken into consideration or held as holy cows then surely the development that can be done is fairly limited?
17:33  sybariten: i mean, generally speaking
17:33  geirha: shadow98: No, you probably don't want exec.
17:33  geirha: shadow98: exec replaces the shell with a new process. So after the first iteration, there won't be a shell to execute the rest of the script anymore.
17:35  geirha: sybariten: Indeed, that's probably one of the main reasons why Solaris (and other Unix systems) still doesn't have a POSIX /bin/sh
17:35 --- taylanub0 is now known as taylanub
17:36  geirha: sybariten: You can easily and quickly add options, but removing options requires decades.
17:36  sybariten: geirha: awrite! Then i have a super suggestion!
17:36  sybariten: (you know where this is leading don't you)
17:37  sybariten: BOTH tools....   (drumroll) ... take BOTH options! (badabim cymbal crash)
17:37  sybariten: then we're ready for the Future (TM)
17:38  geirha: Then both commands will have a useless option ^^
17:40  geirha: sybariten: You could make your own find and du functions that handles both and translates them for the real commands.
17:40  geirha: But I don't see the point. It doesn't take that long to look up a man-page.
17:40  sybariten: well....  both will have one that maybe not so many will use...  but dang will it feel nice to NOT have to go through bash history to see whether du takes max-depth or maxdepth
17:41  geirha: du takes neither :P GNU du takes one of them.
17:41  sybariten: what's plain du do then?
17:42  geirha: POSIX du: http://www.opengroup.org/onlinepubs/009695399/utilities/du.html
17:43  sybariten: no depth at all?  i cant tell whether my du is gnu or not but it takes --max-depth=N
17:43  sybariten: hm, --version
17:43  geirha: All GNU commands take a --version option
17:44  geirha: If it tells you that's not an option, it's not GNU
17:44  sybariten: hey, theres a swede involved
17:44  sybariten: yeah, it worked
17:45  geirha: du -s *  will often suffice
17:46  shadow98: ./notifyscript.sh &
17:46  shadow98: [1] 19750
17:46  shadow98: root@gamesweb:/var/www# -bash: ./notifyscript.sh: No such file or directory
17:47  shadow98: what is causing no such file or directory
17:47  geirha: shadow98: There's no file named notifyscript.sh in the current directory
17:47  shadow98: im an idiot
17:47  shadow98: sorry no sleep
--- Log closed Mon Nov 01 17:57:23 2010
--- Log opened Mon Nov 01 17:58:01 2010
17:58 --- Users 536 nicks [0 ops, 0 halfops, 0 voices, 536 normal]
17:58  ferret: But the example you gave should work.
17:58  ferret: More succinctly, var=123 sh script.sh
17:58  oopepe: ferret:Ok, thank you
17:59 --- Channel #bash was synced in 77 seconds
18:04 --- rbronosky is now known as richardbronosky
18:17  slater: hey guys i have a short question.
18:17  slater: I want to run a startup script but i only have the follwing folder structe : /etc/rc.d/init.d no rc0 or something else
18:17  slater: where do i need to place the script then?!?
18:17  greycat: Ask your OS channel.
18:18  slater: its a raw kernel
18:18  slater: no os
18:18  greycat: *plonk*
18:18  slater: its running fine, its a stripped done fileserver
18:18  greycat: If you are the OS designer then you can start your own OS channel.
18:19  slater: dang alright thanks anyway
18:19  skered: Silly Germans.
18:24  kotique: find / -iregex ".*/(proc\|var|sys|dev|home|virtfs).*" -prune -o \( -type f -perm /u+s,g+s -ls \)  doesn't work. why?
18:25  kotique: I mean it still traverses underneath /home
18:25  greycat: why do you have \| in one place and | in the other places?
18:25  kotique: hm
18:27  kotique: no frikkin idea, maybe ssh expanded it, okay, \| worked
18:28  kotique: strange that I have to escape it as shell doens't interpret anything inside single quotes
18:28  kotique: find / -iregex '.*/\(proc\|var\|sys\|dev\|home\|virtfs\).*' -prune -o -ls
18:29  kotique:     -prune True; if the file is a directory, do not descend into it
18:30  kotique: how does it return True if I have to use -o,  OR not AND.
18:36  consumerism: i'd like to define an alias ('s' for example) such that when i type 's' followed by a space, i can tab-complete a directory inside a given parent directory to cd to. so for the path /one/two/three, i could type s th<tab> and have the shell autocomplete the path, then i would hit enter and i would be in /one/two/three. is this possible?
18:39 --- MuzerAway is now known as Muzer
18:43  ferret: consumerism: ''help cd'', also man bash and search for CDPATH
18:43  ferret: the standard cd command in bash can do this
18:50  kotique: why was && choosen as actual || in bash? as the command returns 0 on success, so it should be || according to popular believes
18:50  yitz_: 0 is "success" and anything else is failure
18:50  greycat: && and || mean just what you think they mean -- AND and OR.
18:50  greycat: You're just confused about 0.
18:50  yitz_: !0
18:50  greycat: cd /foo || echo "my cd failed"
18:51  greycat: test -r "$config" || die "can't read config file '$config'"
18:54  kotique: it's so not C
18:54  yitz_: That's right. It's bash
18:55  geirha: You don't   return 0; at the end of your main() when it suceeds?
18:55  JAcksson: hi! When a user executes "su" on the terminal, is there a way to launch a process on behalf of the "previous" user, that was active before he typed "su"? Without typing "exit". can a superuser launch a process on behalf  of another user who has less privileges?
18:56  greycat: Yes, a superuser-privileged process can use "su username -c 'whatever'" to run a process with lower privileges.
18:56  kotique: su -m and next user will receive old environment with old USER var
18:56  erUSUL: !wayttd
18:56  greybot: What Are You Trying To Do?
18:56  kotique: !sextape
18:56  greycat: There is no "su -m" on my system.
18:56  JAcksson: it's a BSD system
18:56  kotique: -p
18:57  greycat:  SYNOPSIS
18:57  greycat:       su [-] [username [arguments]]
18:57  kotique: go update your toaster
18:57  greycat: *plonk*
18:57  bassliner: greycat: freebsd?
18:57  greycat: HP-UX 10.20
18:57  bassliner: hehe.
18:58  greycat: Hmm, there is no su page on http://www.opengroup.org/onlinepubs/9699919799/utilities/
18:58  JAcksson: greybot: i'm trying to make an installer in MacOS (which runs as root) to install some files into user's directory, but i need to chown every file afterwards, so i want to launch a script that'll start a process
18:58  greycat: Apparently it does not conform to POSIX.  Whee!
18:58  JAcksson: that process will do all the dirty job, launching daemons, etc
18:58  greycat: Or rather, "is not specified by POSIX".
18:59  JAcksson: thanks greycat, i'll try it :)
18:59  greycat: JAcksson: the $LOGNAME or $USER variable might contain the calling user's  name.
18:59  erUSUL: JAcksson: maybe MacOSX has the "install" command ?
18:59  greycat: erUSUL: and "install" will tell him the name or UID of the user who typed 'su'?
18:59  JAcksson: greycat yes, they do, but the current user is still root, so if i launch any process, that process is "root"ed
18:59  geirha: You shouldn't chown files in a user's homedir
18:59  erUSUL: greycat: quote « i'm trying to make an installer in MacOS (which runs as root) to install some files into user's directory, »
18:59  greycat: JAcksson: chown "$USER" file
19:00  greycat: erUSUL: and...?
19:00  JAcksson: geirha i dont want to chown, i just want to copy files using a process that was started by that user, thats all
19:00  greycat: Putting the files there is trivial if you're superuser and the file system is local.
19:00  erUSUL: greycat: looks like a job for install
19:00  greycat: You SAID you wanted to chown!
19:00  JAcksson: i sid, i would do that otherwise
19:00  greycat: 13:58  JAcksson> ... but i need to chown every file afterwards
19:01  JAcksson: yea, whatever, you suggested a better way :)
19:01  greycat: I did?
19:01  JAcksson: Yes, a superuser-privileged process can use "su username -c 'whatever'" to run a process with lower privileges.
19:01  greycat: if you don't want this thing to run as root, why are you running it as root?
19:02  JAcksson: that's macos, i have no choice, they make me to run as root, if i want to install app to /Applications :S
19:03  geirha: So why do you need to install files in a user's homedir?
19:04  JAcksson: because these are "documents and templates", users want them to be there, not in root filesystem
19:04  JAcksson: not in / *
19:05  sako: hey guys, how would i for loop through a directory of directories and copy all of the contents in those directories somewhere/
19:05  greycat: At some point, saying nothing seems to be the only way to make a problem go away.
19:05  geirha: So the app needs a directory to exist in the user's home, but won't create it?
19:05  greycat: !find > sako
19:05  greybot: sako: http://mywiki.wooledge.org/UsingFind
19:06  bassliner: greycat: no offense, but are you just keeping that 15 years old hp-ux installation to show ppl the differences from todays systems when they want to write portable scripts so you can slap em? or is that really a production machine in a university or something?
19:06  greycat: bassliner: It is the primary workstation sitting on my desk.  I use it every day at work.  I'm typing on it now.  I'm IRCing from it.  It's where my email resides.  It's a slave NIS server for the LAN on this floor.
19:07  bassliner: greycat: bit incredible, but sounds like fun. :-)
19:07  greycat: If you think that's "incredible", you haven't worked in too many places yet.
19:08  bassliner: greycat: that's possible. i had to learn that you should never touch a running system when i started to work in *nix environments, yeah...
19:09  geirha: We used to use solaris where I work
19:09  sako: greycat: thanks!
19:10  sako: greycat: one thing though... i am using xargs with find... how do i tell it to use the xargs? i tried
19:10  sako:  | xargs cp /path/to/copy/to
19:10  lhunath: !xargs
19:10  greybot: xargs(1) is dangerous (broken) when processing filenames that are not NUL-terminated. If you're working with filenames, use find's -exec {} + instead (yes, it does multiple-filenames-per-invocation, too).
19:10  greycat: sako: the UsingFind page has sections about -exec and so on.
19:16  zimmermanc: !regex
19:16  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
19:24  greyKat: !xml
19:24  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
19:25  greyKat: hmm - i expected that to be almost thesame as the regex one....
19:25  zimmermanc: hah
19:26  tuxdev: well, I don't know of any witty quote made by a famous guy on the subject
19:26  zimmermanc: sorry i can never remember exactly how it goes, I should probably pm greybot when i forget instead of spamming the chan
19:27  tuxdev: It's kinda unfair as usually quoted
19:35 --- nik0 is now known as niko
19:44 --- tsaavik_ is now known as tsaavik
19:45  Operator23: So I have a file of the format:
19:46  Operator23: word [ID Count]*
19:46  Operator23: By which I mean every even-numbered field is an ID and every odd-numbered field (except the first) is a count
19:46  Operator23: I want to pull out the words from lines with certain IDs
19:47  greycat: read the line into an array, iterate through it using i+=2
19:47  Operator23: Ah, sounds good.
--- Log closed Mon Nov 01 19:57:29 2010
--- Log opened Mon Nov 01 19:57:58 2010
19:57 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
19:57  greyKat: gracias
19:59 --- Channel #bash was synced in 83 seconds
20:04  mjrosenb: x=$(foo);  does the $(...) wait for foo to exit, or for everything in its group to exit?
20:04  road-runner: catalina.opts:-Xms1024m -Xmx1024m -XX:PermSize=64M -XX:MaxPermSize=128M
20:04  greycat: Yes, it waits.
20:04  road-runner: how do I grab just the 1024 from the Xmx?
20:05  greycat: road-runner: first, isolate that word.  Then use parameter expansion to chop it up.
20:05  greycat: !faq 100 > road-runner
20:05  greybot: road-runner: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
20:08 --- Natch is now known as Natch|
20:12  mjrosenb: calling if (fork() ==0) setpgid(0,0); should cause the child to have a differnet group id, and thus bash to return, right?
20:13  greycat: Are you trying to self-background something?  If so, WHY?
20:14 * ket wishes to learn/see "more about coproc" at this time...
20:15  mjrosenb: i want it to end up in the background, and I also want to capture all of its output in a variable
20:15  greycat: Unpossible.
20:15  greycat: Redirect its output to a file, and then when you know it's terminated, read the file.
20:16  mjrosenb: the only thing that is going to be printing is the first process.  the backgrounded process should never be printing anything.
20:16  greycat: You're either going to have to tell us what on earth you're doing, or figure it out on your own.
20:19  mjrosenb: program starts up, dumps out a .rc file that says how to communicate with the server, prints out the name of the .rc file, spawns the server, exits while the server continues to run
20:19  greycat: That should work, then
20:20  greycat: (It's still evil, but hey, maybe you're not able to fix that.)
20:20  mjrosenb: right, but when I try to read the name of the .rc file, it looks like `foo` and $(foo) are waiting for the spawned server to terminate before they bind the captured text
20:23  nDuff: mjrosenb, if that's happening, the spawned program isn't doing a good enough job of detaching itself
20:24  mjrosenb: nDuff: that is what i suspect
20:24  greycat: In my testing just now, adding >/dev/null 2>&1 to the "./bar &" line fixed things.
20:26  mjrosenb: ahh, file descriptors did it.
20:26  mjrosenb: oh dih.
20:26  mjrosenb: it isn't waiting for the child to exit
20:27  mjrosenb: it is waiting for stdout to close
20:27  greycat: yeah
20:34  greyKat: functions consisting entirely of shell builtins will execute entirely within the process speace the yare invoked within and will not cause a new process to be forked or spawned, correct?  example  a(){ return 7 ; } << is made up all builtins
20:35  greyKat: *space they are
20:35  greycat: as long as you don't invoke it in a subshell, sure
20:35  TheBonsai: a() { echo 7; }; var="$(a)" # fail
20:37  greyKat: as one specific caase, invoking it in a sub shell would mean invoking it inside parens, right?   (not a response to TheBonsai's example)
20:38  nDuff: there's more than one parenthesis-based syntax, but ( foo; bar ) does indeed create a subshell
20:39  greycat: !subshell
20:39  greybot: http://mywiki.wooledge.org/SubShell
20:40  bearly230: Hey all, I have a bash file that has 1 line in it "sudo modprobe -r psmouse", it works perfect, however I was wondering if there is a way to keep from having to enter the root pw. This is on Ubuntu 10.10.
20:40  greycat: !sudo
20:40  greybot: To use sudo commands in a script (without prompting for a password), put something like this into the sudoers(5) file: username ALL = NOPASSWD: /some/program
20:40  greyKat: #echo $$; if ( echo $$ ) ; then echo hi; else echo lo ; fi
20:41  greycat: greyKat: whatever you're attempting to show there, it's wrong.
20:41  bearly230: Thanks I'll give that a try. )
20:42  greyKat: when i ran it locally, it gave me two identical process ID's followed by "hi"   it seemed to show that the echo inside the parens ran in thesame process as the shell it was invoked from.  A funtion on the other hand???
20:42  greyKat: *function
20:43  TheBonsai: $$ isn't the PID of the current shell process
20:43  greycat: $$ in a subshell shows the PARENT'S pid, not the subshell's pid
20:43  greycat: if you want to see a subshell's PID, you have to use the BASHPID (or BASH_PID?) variable instead, and it's a recent addition
20:44  greycat: and I don't understand the purpose of your "if" at all.  your echo command is always going to return true.
20:44  TheBonsai: BASHPID iirc
20:44  greycat: hence 15:41  greycat> greyKat: whatever you're attempting to show there, it's wrong.
20:45  greyKat: Ja
20:45  greyKat: is $$ ever the PID of the current shell?
20:46  greyKat: like in bourne shell or csh ?
20:46  greycat: arc3:~$ dash -c 'echo I am $$; (echo my kid is not $$)'
20:46  greycat: I am 27955
20:46  greycat: my kid is not 27955
20:46  greycat: Do you have a Bourne shell that behaves differently?
20:47  greyKat: greycat: I don't know. I'm trying to figure out where i got the idea that $$ is the PID of the current process.
20:47  greycat: Wrongland.
20:48 * greyKat is screaming internally at thye idea of how many times he has used $$ ... in scripts ... 
20:48  greycat: even csh gives me the same thing for $$ in the parent and the subshell
20:49  greyKat: Jinkees, Scooby-Do!  What a mystery!
20:55  _stefanos_: Good evening everyone. I have tried this command 'find . -name "*.txt" -print | less' but I would like to have a number for each line it prints. for example, "[1] test.txt" etc...can I do that with find command?
20:55  pgas: no
20:55  _stefanos_: oh man :/
20:55  pgas: but you can pipe to something that will add the numbers
20:55  _stefanos_: i don't mind! :D
20:56  greycat: | cat -n | less
20:56  _stefanos_: ok let me try this
20:56  greycat: bear in mind the whole thing as written breaks if any of the filenames contain newlines
20:57  _stefanos_: that is very nice man :D
20:57  _stefanos_: it works :D
20:57  _stefanos_: haha! :D lovely
20:59  nDuff: ...if you need to worry about filenames with newlines, you can use -print0, and the FAQ 1 tips for handling null-terminated values.
21:00  _stefanos_: no, what I wanted is here thanks to greycat :)
21:00  greycat: I don't think the task at hand is amenable to that kind of programming at all.
21:01  _stefanos_: amenable?
21:01  _stefanos_: you mean something that is accepted by someone or something?
21:02  greycat: The task at hand being "dump filenames to stdout with numbers in front of each one and newlines after each one" and the kind of programming suggested being "delimit filenames with newlines and construct a newline-delimited-stream-reader program...."
21:02  greycat: Fuck.  Ignore the second half of that.  I wrote newlines where I meant to write NULs.
21:03  _stefanos_: :D you lost me there for a moment :)
21:03 * nDuff shrugs; the point of his suggestion was to raise awareness of newlines-as-dangerous, as opposed to actually being a practical solution.
21:04  nDuff: ...such that _stefanos_ might remember that NUL delimiting is an option later when handling filenames which can be created by an untrusted/malicious user (for instance).
21:04  _stefanos_: nDuff, I think you took it too far from my newbie knowledge mate :)
21:04  greyKat: whitespace terrorism  ~= TSA. :)
21:05  _stefanos_: all I wanted to do, was to add numbers in front of find results
21:05  _stefanos_: to see that i'm capable to do such a thing
21:05  _stefanos_: that's all
21:05  nDuff: _stefanos_, yup, and the point being made is that trusting that "one file => one line of output" isn't a safe assumption
21:05  greycat: Yeah.  It's kind of like when you're teaching a junior high student that momentum = mass x speed and then someone else says "but wait, you have to factor in the Einsteinian relativity stuff".
21:05  nDuff: _stefanos_, filenames can contain newlines.
21:05  _stefanos_: yeah I know that
21:05  _stefanos_: but I am not searching inside files
21:06  nDuff: where did searching inside files come up?
21:06  greycat: you're just confusing the noob
21:06  nDuff: the concern is that if you want your numbers to count files, as opposed to counting lines, the value can be wrong.
21:06 * nDuff shuts up.
21:06  tongueroo: hi guys, wondering what this means: exec 2<&1 su -c"$COMMAND"
21:06  tongueroo: the exec 2<&1 part in particular
21:07  greycat: You fucked it up.  It should be 2>&1 almost certainly.
21:07  alesan: hi! how do I redirect all output of a program I start in the background to /dev/null ???
21:07  greycat: foo >/dev/null &
21:07  tongueroo: greycat: great response :)
21:07  greycat: !faq 2>&1 > tongueroo
21:07  greybot: tongueroo: http://mywiki.wooledge.org/BashFAQ/055 -- Tell me all about 2>&1 -- what's the difference between 2>&1 >foo and >foo 2>&1, and when do I use which?
21:07  _stefanos_: greycat, stdin == 0, stdout == 1, and stderr == 2, true?
21:07  tongueroo: its really interesting because this is the scripts im seeing from engineyard
21:07  greycat: yes
21:07  grawity: _stefanos_: true
21:07  _stefanos_: lovely
21:08  tongueroo: yeah i understand 2>&1 , used it many times before
21:08  tongueroo: remember there being something special bout '2<&1'
21:08  greycat: 2<&1 makes no sense at all unless someone has previously closed and re-opened FD 1 for input instead of output.
21:08  tongueroo: or is it just wrong?
21:08  _stefanos_: for sure wrong
21:08  greyKat: greycat: I just read through the bash and builtin man pages, and I see, as you said,  $$ is the pid of the shell but the PPID of a subshell, (and the GPPID of a sub-subshell! which is kind of neat :-) ).  What i can't find in there is any way to consistently get the PID of the current process even when its a sub-shell.  Any ideas?
21:09  grawity: $BASHPID
21:09  greycat: greyKat: as we told you earlier, BASHPID
21:09  tongueroo: thanks guys
21:09  greyKat: greycat: well I looked for BASHPID, and tried to use it in my Bash shell and it doesnt seem to exist. note - I'm in bash 3 if that makes a difference
21:10  greycat: It's a recent addition.  I don't recall which version.
21:10  _stefanos_: nDuff, the previous info you all gave sounds very nice and i would like to learn more. Can you please recall what you mentioned before but with simpler examples please?
21:10  greycat: Looks like 4.0 based on brief testing.
21:10  greyKat: greycat:  I see.  Any workaround?
21:10  greycat: imadev:~$ bash-3.2.48 -c 'echo $BASHPID'
21:10  greycat: (blank)
21:11  greycat: greyKat: Yeah, stop fucking CARING.  It's a useless piece of information.  Unix survived 40 years without it.
21:11  nDuff: _stefanos_, so let's say you have a malicious user creating a file like this: mkdir -p $'foo/bar\n/etc/passwd'
21:11  pgas: also what with the nick change?
21:11  greyKat: greycat: so to paraphrase that, you're asking if I really need it? :-)
21:11  _stefanos_: nDuff, yes
21:12  greycat: I'm quite sure you don't need it.  You only ask because you have some troll-thing going on.
21:12  nDuff: _stefanos_, if you're using find -print, it emits two lines: 'foo/bar' and '/etc/passwd', even though it's only one file.
21:13  greyKat: not even that. just exploring the corners and niches of what I know of bash so i can understand it better.
21:13  _stefanos_: aha!
21:14  slater: hello is it possible to create a bash script with a timer and a press any key to continue? so when timer runs out no key pressed end script if key pressed start real script?
21:14  greyKat: greycat: I have to admit, I've lost track of what my original intent was when i tripped over this and started trying to understand it.
21:14  pgas: Changing from bronze to greyKat certainly makes you look like a troll
21:14  grawity: greyKat: If you really really REALLY need the PID of the current subshell, and you're fine with a non-portable Linux-specific solution, read -r pid _ < /proc/self/stat
21:15  greyKat: pgas: if you'll read thescrollback to this morning when I did that you'll see the reason  why was that i was feeling rather impatient with some of the people asking questions and felt like abusing them.
21:16  pgas: well I don't have a scrollback that long
21:16  nDuff: _stefanos_, ...the only two characters which aren't allowed in filenames are / and NUL (ASCII 0); using NUL, then, gives you a genuinely safe way to delimit filenames.
21:16  greyKat: so I adopted a nick that doles out same, at times. :-)
21:17  _stefanos_: nDuff yeah i got that, but you are referring to advanced techniques as also whereas as malicious user could have physical access on my PC, true?
21:18  nDuff: _stefanos_, that's all a matter of context. If you're writing scripts that handle files in an FTP upload directory, or a chroot writable only by a sandboxed daemon, or any number of other cases, and those scripts are running with more privileges than the user/daemon that wrote that file out, then you've got yourself a potential privilege escalation case.
21:18  pgas: slater: check "help read" the bash builtin has a -t option
21:19  _stefanos_: nDuff, yeah I know that. All I wanted was what I have asked before, that's all.
21:19  nDuff: _stefanos_, *nod*. I did shut up 'till you asked for clarification. :)
21:19  greycat: _stefanos_: it's also possible to create a filename with a newline in it accidentally, by fat-fingering stuff, or mis-pasting stuff with the mouse...
21:20  _stefanos_: nDuff, buddy i did not asked you to shut up; that would be rude
21:20  mjrosenb: _stefanos_: i would recommend using the line-numbering feature of less
21:21  mjrosenb: starenka: it will not show up in you search results in less.
21:21  starenka: okay
21:21  starenka: :)
21:21  slater: thanks its working!
21:21  _stefanos_: mjrosenb, i will try that
21:22  mjrosenb: starenka: err, sorry.
21:22  starenka: abslutely no problem ;)
21:24  greyKat: grawity: hey, thats nice.  thanks. :)
21:25  grawity: damn
21:25  greyKat: what what?
21:27  cthuluh: greyKat?
21:28  greyKat: oh fer hecks sake
21:28 --- greyKat is now known as bronzecat
21:30  bronzecat: ah - thats what started it - I was trying to do a 1 liner for  is/is not a leap year that did not spawn any processes.
21:31  grawity: hmm, what are the rules for leap years?
21:31  greycat: isleapyear() { if (($1 % 400 == 0)); then return 0; elif (($1 % 100 == 0)); then return 1; elif (($1 % 4 == 0)); then return 0; else return 1; fi; }
21:32  krzie: A year will be a leap year if it is divisible by 4 but not by 100. If a year is divisible by 4 and by 100, it is not a leap year unless it is also divisible by 400.
21:32  bronzecat: greycat: that looks correct.
21:32  alesan: how do I execute a command IF a file dows notr exist in sh (posix)?
21:32  alesan: how do I execute a command IF a file does not exist in sh (posix)?
21:32  krzie: so ya, exactly what greycat said
21:33  erUSUL: !test > alesan
21:33  greycat: alesan: if [ ! -e "$file" ]; then ...
21:33  greybot: alesan: help test <Enter> http://mywiki.wooledge.org/BashGuide/TestsAndConditionals | http://bash-hackers.org/wiki/doku.php/commands/classictest
21:33  bronzecat: greycat: did you have that laying around?
21:33  grawity: (( $1 % 400 == 0 )) && (( $1 % 100 > 0 )) && (( $1 % ... I give up.
21:33  greycat: bronzecat: I've written it before, in a different language.
21:33  greycat: bronzecat: but that was typed straight in, just now.
21:33  alesan: erUSUL, will the syntax with && work?
21:33  bronzecat: damn. I hate it when you do that. :-)
21:33  greycat: && is in POSIX, yes.  Just not [[.
21:33  alesan: I was looking for something less verbose than the full if then thing
21:34  alesan: thank's
21:34  alesan: but I need t onegate the result of the test
21:34  erUSUL: alesan: greycat already give you the answer. if you want to expand on it read the links the bot gave you
21:34  alesan: well but the bot gave me links for BASH
21:34  alesan: npot for posix sh
21:34  krzie: alesan, this is #bash
21:34  krzie: in case you missed that :-p
21:35  bronzecat: I was tring to do it with no else if, just boolean's  || and &&
21:35 * krzie says "this is bash" like a spartan
21:35  alesan: krzie, wel until some time ago the topic had a hint to specify if the question was for bash or sh
21:35  erUSUL: alesan: http://bash-hackers.org/wiki/doku.php/commands/classictest <<< this looks posix enough for me
21:35  greycat: alesan: that's the on-join message, not the topic
21:35  alesan: that implied here discussions about sh were tolerated
21:35  alesan: ok
21:36  greycat: Virtually every page of the FAQ has POSIX answers as well as Bash answers.
21:36  alesan: so is that valid, or not? are sh questions allowed here if not welcomed?
21:36  greycat: You were answered, weren't you?
21:36  bronzecat: grawity:
21:36  bronzecat: woops
21:36  krzie: alesan, you can change any if / elif to a much more complex combo of && / || if you get your grouping right... but theres really no reason to
21:36  alesan: greycat, I got an answer that does not mean those questions are welcomed
21:37  _stefanos_: guys, who's responsible for wiki.bash-hackers.org? I would like to ask a question about header 1 and title please
21:37  krzie: and what greycat said will work in sh except for the bash math, which can be replaced with bc
21:37  sowell: i was curious if someone would be willing to help me with a find problem?  find $LOGPATH/*/*/*/rejectlog -type f -cnewer $LOGPATH/$START/rejectlog -and ! -cnewer $LOGPATH/$END/rejectlog -name mx*.gz`
21:37  cthuluh: alesan: do you read the messages sent to your client when you join a channel?
21:37  alesan: cthuluh, yes of coause
21:37  alesan: course
21:37  greycat: krzie: ewww.  I'd rather use test $(($1 % 400)) = 0
21:38  sowell: unfortunately this does not get me the first user inputed dates worth because of the cnewer switch......how would i replace that with ctime and still have that command work?
21:38  krzie: greycat, that works in sh??
21:38  greycat: krzie: POSIX, yes.  Not Bourne.
21:38  sowell: so if the range was 2010/10/10 - 2010/10/12 i would only get 2010/10/11 and 2010/10/12 and not 2010/10/10
21:38  krzie: ahh
21:38  greycat: sowell: massive quoting failure.
21:39  greycat: other than that... can't parse.
21:39  sowell: quoting failure because i am not quoting the variables?
21:39  greycat: The variables and the glob.
21:40  greycat: If the question is "How do I find files from time T1 to time T2" then the answer is "touch -t ...; touch -t ...; find ... -newer F1 ! -newer F2"
21:40  sowell: i happen to agree with that i havent actually gone through and cleaned the script up yet....im just trying to make it work first ;)
21:40  alesan: [ ! -e /etc/dropbear/dropbear_rsa_host_key ] && dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_key do you think this is OK in posix sh?
21:40  bassliner: greycat: interesting attempt.
21:40  sowell: am i able to mix ctime with ! -cnewer?
21:40  sowell: is that possible?
21:41  geirha: alesan: Yes, that'll work in a posix shell
21:41  greycat: My find(1) appears to have -newerc not -cnewer
21:41  greycat: Actually, mine can compare mtime of file A to ctime of file B, etc.  In any combination.
21:42  krzie:      -cnewer file
21:42  krzie:              Same as -newercm.
21:42  krzie: (in fbsd)
21:42  greycat: Why anyone would ever use ctime for anything is beyond me.
21:42  sowell: heh, if you are on a mac or bsd it is newerc
21:43  krzie: sowell, mac and bsd have -cnewer which is the same as -newercm
21:43  cthuluh: all this depends on the OS (and on the BSD version, in this case)
21:43  krzie: as i pasted above
21:44  nDuff: ...if you're running a backup system which is supposed to keep metadata sync'd, perhaps, and want to determine whether permissions need to be updated even if content wasn't?
21:44 * nDuff isn't sure it's a very _compelling_ reason, but heck, it's a reason.
21:45  bassliner: i find myself a lot doing some tcl scripts using file atime and clock scan to decode date data. but that's probably just beyond it.
21:46  ilab: I'm calling several bash scripts and running them simultaneously in the background in one bash sccript. I'd like twrite to a file when each one completes. How can I do this?
21:47  bronzecat: grawity:  using booleans in one expression its: isleapyear() { if (($1 % 400 == 0))|| ( (($1 % 4 == 0)) && ( ! (($1 % 100 == 0)) ) )  ; then return 0; fi;  return 1; }
21:47  bronzecat: the order of the last compound expression should be reversed for efficieny
21:47  greycat: bronzecat: I thought the goal was NOT to use child processes
21:48  grawity: Isn't 'if' useless there?
21:48  bronzecat: is it?   would that
21:48  grawity: isleapyear() { (($1 % 400 == 0)) || { (($1 % 4 == 0)) && (($1 % 100 > 0)); }; }
21:49  bronzecat: that'll return a boolean ?
21:49  grawity: Without explicit 'return', the result of last statement or whatever is used
21:49  bronzecat: zero vs non-zero - OK.
21:50  bronzecat: re sub-shell - I grouped that last two logicals expression in parens - is that what caused a sub-shell?
21:50  greycat: That's hideous.  IMHO.
21:50  RenatoSilva: was bash 3 ascii-only?
21:50  greycat: I find the if/elif version that I wrote a lot easier to read.
21:50  bronzecat: greycat: yes it is.
21:51  sowell: is there a reason why i would get a paths must precede expression on this:  find "$LOGPATH/*/*/*/rejectlog" -type f -ctime -1 "$LOGPATH/$START/rejectlog" -and ! -cnewer "$LOGPATH/$END /rejectlog" -name mx*.gz`
21:52  greycat: sowell: More quoting failures.
21:52  grawity: sowell: Unquoted glob after -name expands to multiple arguments.
21:52  greycat: You want "$LOGPATH"/*/*/*/rejectlog because you want THAT glob to be globbed.
21:52  greycat: But you want -name "mx*.gz" because you want that glob NOT to be globbed.  Yet.
21:53  bronzecat: greycat: what you said above implied that my last version would have sub-shell(s).  Was it the parens around  the expressions that caused a sub shell?  eg ( (exp2 ) && ( ! ( exp 4 ) ) )
21:53  tuxdev: sowell, also just aesthetically, it's a bit easier to see what's going on if you put the -name right after the directories
21:53  Buglouse: Trying to terminiate(intr) this line after execute: "echo info |nc locahost 1111" How do i send intr to nc? I can pass the '-w' option to nc but i only know how to pass '1' as the lowest integer, i want about 1/4th of a sec for this command to run
21:53  greycat: bronzecat: yes.
21:54  greycat: And they aren't "expressions".  They're commands.
21:54  bronzecat: ah, pluck.
21:54  grawity: Buglouse: Don't use nc unless you must. There are four different implementations with their own quirks...
21:54  greycat: imadev:~$ ((4 == 2))
21:54  greycat: imadev:~$
21:54  greycat: See?  It's a command.
21:55  grawity: Buglouse: Three's socat, and there's bash's built-in TCP support (which for some reason is off in Debian Lenny)
21:55  greycat: Buglouse: if you happen to be on Ubuntu, there's a known bug in one of their netcats....
21:55  sowell: find "$LOGPATH"/*/*/*/rejectlog -type f -ctime -1 "$LOGPATH/$START"/rejectlog -and ! -cnewer "$LOGPATH/$END "/rejectlog -name "mx*.gz"  thats unfortunately throwing the same error with path must precede expression
21:55  sowell: unless i have more quoting failures
21:55  grawity: sowell: btw, is it in an interactive shell?
21:55  Buglouse: everything compiled from src. trying to control shell-fm remotely
21:56  sowell: im basically running the command through ssh
21:56  greycat: !faq cflags > sowell
21:56  greybot: sowell: http://mywiki.wooledge.org/BashFAQ/096 -- ssh eats my word boundaries!  I can't do ssh remotehost make CFLAGS="-g -O"!
21:56  sowell: so i ssh to a server and then that command gets run.
21:56  Buglouse: bash builtin tcp, ill have to look that one up
21:56  grawity: sowell: doesn't tell me anything.
21:56  bronzecat: I think i see, the "((" is the syntactical boundary, just as "[" is a command in sh.
21:56  ilab: greycat: what'sthe bug? is cryptcat preferable?
21:56  grawity: Buglouse: exec {fd}<>/dev/tcp/localhost/1111; echo "foo" >&$fd; exec {fd}>&-
21:57  grawity: Buglouse: "socat" is an external program, but very powerful; echo "foo" | socat stdio tcp:localhost:1111
21:57  greycat: ilab: in something like     printf 'GET / HTTP/1.1\nHost: foo.bar\n' | nc webserver 80     one of the netcats closes the pipe too soon and the data doesn't go through.  Or something.  It was several weeks back...
21:58  greycat: grawity: in other words, just like netcat is supposed to (and does, usually, if it's not busted)
21:59  bronzecat: grawity: your last leapyear is what I was trying for, i think. :-)   but o'course ah bin eddeecated some maoh since then.
21:59  grawity: greycat: see my above messages about why netcat should be avoided.
22:00  greycat: sowell: essentially, if you are doing this:     ssh u@h 'find "$stuff"/*/*/*/stuff -stuff -more -stuff "*glob*"'    you are fucked.
22:00  sowell: greycat: based off what you just send me.....i tried this 'find \"$LOGPATH\"/*/*/*/rejectlog -type f -ctime -1 \"$LOGPATH/$START\"/rejectlog -and ! -cnewer \"$LOGPATH/$END\"/rejectlog -name \"mx*.gz\"'
22:00  sowell: and im still getting the same issue
22:00  greycat: sowell: are you putting ssh in front of this?
22:00  sowell: i tried it w ithout the escaped " " too
22:01  sowell: yeah
22:01  Buglouse: grawity: thanks for socat and bash tcp
22:01  grawity: How about you put it in a script and execute _that_ over ssh?
22:01  greycat: sowell: Then you've got a big-ass problem to resolve.  The recommended workaround is this:
22:01  greycat: ssh u@h bash <<'EOF'
22:01  greycat: your complex code here
22:01  greycat: EOF
22:01  sowell: haha
22:01  sowell: why is it a problem just out of curiosity ;)
22:01  greycat: grawity's response is also valid.
22:01  greycat: sowell: for the reasons spelled out in the FAQ page
22:02  greycat: ssh emulates remsh/rsh including the fact that a shell on the remote end RE-PARSES the entire input.
22:04  lhunath: !ssh
22:04  greybot: Secure SHell (See #openssh, http://mywiki.wooledge.org/CategorySsh) - To run bash code remotely; adapt: ssh user@host bash <<< "$(printf 'echo %q' "$localVar")"
22:04  sowell: gotcha....so the reparsed command because its already been parsed once is getting mangled
22:04  sowell: i believe thats what you are saying
22:12  sowell: greycat: would something like <(command) work?
22:14  greycat: sowell: huh?  what's that got to do with ssh?
22:14  greycat: either put the script in a file, and then redirect that file to the remote shell, or use the here document that I showed, which is -- guess what? -- a file that gets redirected to the remote shell.
22:15  greycat: (Yes, here documents are implemented with temporary files.)
22:16  grawity: they are?
22:16 * grawity tries 'ls -l /dev/fd/ <<EOF'
22:16  sowell: i was under the impression that <(command) created a subshell much like ' '
22:16  greycat: <(command) is totally different.  And has nothing to do with your issue.
22:19  sowell: ssh u@h <<'EOF' find $LOGPATH/*/*/*/rejectlog -type f -ctime -1 $LOGPATH/$START/rejectlog -and ! -cnewer $LOGPATH/$ END/rejectlog -name "mx*.gz" EOF can i even do this?
22:19  greycat: griffon:~$ ls -l /proc/self/fd/0 <<EOF
22:19  greycat: > foo
22:19  greycat: > EOF
22:19  greycat: lr-x------ 1 greg greg 64 2010-11-01 17:19 /proc/self/fd/0 -> /tmp/sh-thd-1288656043 (deleted)
22:19  greycat: sowell: you forgot the SHELL!
22:19  greycat: ssh u@h bash <<'EOF'
22:19  sowell: ahhhh
22:19  sowell: ok
22:20  ferret: in ash, it's a pipe
22:20  shadow98: how do i take the scrip i have and make it run on boot in ubuntu
22:20  greycat: Ask #ubuntu.
22:20  greycat: ferret: hmm, dash too.
22:21  ferret: ksh => temp file also
22:21  sowell: haha
22:21  sowell: it tells me cannot execute binary file
22:21  sowell: nie
22:32 --- jzacsh_ is now known as jzacsh
22:36 --- Muzer is now known as MuzerAway
22:45  road-runner: -Xmx1024m  I want to extract this from a file, but sometimes it is 4th word deep sometimes 5th or 6th
22:45  road-runner: how?
22:45  road-runner: I can get the line with grep but the placing on the line varies
22:49  nDuff: road-runner, either use egrep -o (if only targeting GNUish platforms) to pick out the individual element from the line, or iterate through the line with read, or what-have-you.
22:50  nDuff: road-runner, you could also use bash's BASH_REMATCH to match the line against a regex and pick out the value you want as a group.
22:52  road-runner: hmm
22:52  road-runner: leme try
22:55  road-runner: dont understand the pattern part of egrep -o
23:16  strull: what could be the reason, that bash enters \366 instead of ö (umlaut-o), when I press the corresponding key on my german keyboard?
23:19  cthuluh: strull: probably your terminal emulator not running in the appropriate locale
23:20  strull: If I'm running vim in the same terminal, the keys work though
23:20  strull: the locale is "POSIX" btw.
23:20  strull: and on another computer with the same locale things work as expected
23:22  cthuluh: strull: an umlaut has no meaning in the POSIX locale (which is merely ascii). please try an other  one
23:25  strull: cthuluh: mmm ... ponders how and what
23:27  cthuluh: !locale
23:27  greybot: http://mywiki.wooledge.org/locale
23:29  strull: What to do, if "locale -a" only shows en_* locales? (Ubuntu here)
23:31  trash: strull: #ubuntu
23:31  strull: are you serious? have you ever been there?
23:32  cthuluh: :>
23:32  nDuff: strull, doesn't make it not a distro issue
23:32  cthuluh: the page on the wiki is quite clear, iirc
23:32  nDuff: strull, ...by the way, the language-support-* metapackages may be interesting to you.
23:33  strull: aah, that looks promising. Thanx, going to try
23:35  Buglouse: how to term(int) a command from bash alias? eg. echo | (TERM)
23:36  cthuluh: ouch, caught SIGPARSE
23:36  cthuluh: !alias > Buglouse
23:36  greybot: Buglouse: If you have to ask, use a function instead: myfunc() { foo "$@" | bar; }
23:37  Buglouse: roger, just wanted to know if there was something short that i was unaware of
23:38  Buglouse: cthuluh: thnx
23:38  road-runner: how can I pick a string fo the pattern Xmx$xm out of a line
23:39  road-runner: the 3 or four digit number $x is wha tI want
23:39  road-runner: the pattern si not always the 4th colum on the line
23:39  road-runner: varies to 5th 6th etc
23:44  nDuff: road-runner, I already suggested BASH_REMATCH
23:46  nDuff: # line='foo bar baz -Xmx1024m qux'; if [[ $line =~ .*[[:space:]]-Xmx([0-9]+)m[[:space:]] ]]; then echo "${BASH_REMATCH[1]}"; else echo "no match"; fi
23:46  evalbot: nDuff: 1024
23:46  nDuff: road-runner, ^^^
23:46  cthuluh: 4# echo foo bar baz quux1 42 toto | awk '{ for (i=4; i<NF; i++) { if (!match($i, /[^[:digit:]]/)) { print $i; next; } } }'
23:46  shbot: cthuluh: 42
23:47  cthuluh: I didn't want to bother to understand what Xmfoo was supposed to mean :P
23:49  nDuff: cthuluh, it's the argument to a Java interpreter specifying the maximum amount of memory allowed.
23:49  nDuff: cthuluh, ...I suppose in theory the "m" suffix should be left on, as it could be "g" or a different unit.
23:50  cthuluh: nDuff: the problem is that I understood that when _you_ pasted your example ;)
23:50  nDuff: ahh, right. :P
--- Log closed Mon Nov 01 23:57:24 2010
--- Log opened Mon Nov 01 23:57:47 2010
23:57 --- Users 506 nicks [0 ops, 0 halfops, 0 voices, 506 normal]
23:58 --- Channel #bash was synced in 79 seconds
--- Log closed Tue Nov 02 00:00:13 2010
