--- Log opened Thu Dec 09 00:00:18 2010
00:09  zxvff: can someone give me a hand with this one liner real quick?
00:09  zxvff: sum=0; for x in `ls | grep .du`; do echo "$x"; cat $x | cut -f1 | while read num; do let sum=sum+num; done; echo $sum; done;
00:09  cafaro: http://mywiki.wooledge.org/BashFAQ
00:09  zxvff: this should add up all of the output from a given file, but it's not adding anything it's just giving me the value 0
00:09  greycat: zxvff: Is this a "count how many errors are on this one line" contest?
00:09  zxvff: n
00:09  greycat: !faq sum > zxvff
00:09  greybot: zxvff: http://mywiki.wooledge.org/BashFAQ/076 -- How do I get the sum of all the numbers in a column?
00:10  greycat: awk '...' *.du
00:10  zxvff: alright, thanks
00:14  \malex\: shouldn't this bash channel promote bash solutions, instead of relying on awk and the like? :D
00:15  greycat: In the cases where the bash solution is competitive, sure.
00:17  cafaro: Is there a way to create (touch) a file to a dir, that possibly doesn't exist?
00:18  cafaro: e.g., touch /path/does/not/exists/textfile
00:18  greycat: mkdir -p first
00:18  cafaro: ok
00:21  \malex\: greycat: over here, bash is only about 20 times slower than awk for adding together the output of seq 1 1000000, with about 20 seconds of wall time. surely that's reasonable for a script, especially one not meant to deal with more than a few hundred items?
00:23  greycat: Now do it with floating points.
00:24  greycat: He never specified whether the input was integer or floating-point.
00:24  \malex\: he did not, no
00:25  greycat: So bash is 20 times slower, is longer to write, and only works in a subset of the cases.
00:25  \malex\: but it doesn't depend on external tools
00:25  \malex\: and it's easier to read, since you don't have to deal with multiple syntaxes
00:25  greycat: In this channel, we usually assume the presence of the standard POSIX tool set.
00:25  \malex\: ah, i didn't realize that was an assumption :)
00:26  CaT[t3]: how do I get bash to follow symlinks logically when .. is used?
00:26  greycat: !dotdot
00:26  greybot: .. refers to the parent directory. Relative pathnames like ../foo/bar cannot be converted into absolute pathnames in the general case -- see http://www.cs.bell-labs.com/sys/doc/lexnames.html to understand why. Also see http://mywiki.wooledge.org/BashFAQ/028
00:27  greycat: you might also want to check out "pwd -P"
00:30  CaT[t3]: gah. forgot that .. is a "real" dir in the... err... dir.
00:31  CaT[t3]: now i just want to stab something. sigh. *ponder*
00:35 * mar77i takes CaT[t3] by his throat...
00:35  geirha: bash's cd does some magic regarding .. in symlinked dirs though... which may cause some confusion.
00:36  greycat: hence the use of pwd -P vs. regular pwd to see both points of view
00:37  CaT[t3]: yeah. I'm just writing something that will hopefully give me the right result.
00:38  \malex\: greycat: bash CAN do floating point, btw
00:38  \malex\: # seq 0.1 0.2 1.2 | (tw=0; tf=0; fb=00000000; IFS=.; while read w f; do tw=$(( $tw + $w )); tf=$(( $tf + $f${fb:${#f}} )); done; echo $(( $tw + $tf / 1$fb )).$(( $tf % 1$fb ))  )
00:38  evalbot: \malex\: bash: seq: command not found
00:38  evalbot: \malex\: 0.0
00:38  \malex\: doh
00:39  \malex\: # echo -e "0.1\n0.3\n0.4\n0.7" | (tw=0; tf=0; fb=00000000; IFS=.; while read w f; do tw=$(( $tw + $w )); tf=$(( $tf + $f${fb:${#f}} )); done; echo $(( $tw + $tf / 1$fb )).$(( $tf % 1$fb ))  )
00:39  evalbot: \malex\: 1.50000000
00:39  CaT[t3]: w00t. that worked.
00:39  CaT[t3]: it is convoluted and evil but it works.
00:41  zambaboo: h i all
00:43  paissad: what's the difference between if (($?)) and if [[ $? ]] ?
00:43  greycat: !math
00:43  greybot: Add 7 to a variable: let a+=7; ((a+=7)); a=$((a+7)); See http://mywiki.wooledge.org/ArithmeticExpression
00:44  greycat: The first one checks the VALUE of $? and acts on whether that value is 0 or not.
00:44  zambaboo: writing an init script, here is the pertinent portion: http://pastie.org/1360597 once booted into the system the script stops/start fine. however, during init it seems that ${APP_USER} is empty. is there something happening during init that i am now aware of?
00:44  greycat: The second one checks the LENGTH of $? and acts on whether that LENGTH is 0 or not.  But the length of $? is NEVER zero.
00:45  greycat: APP_USER is never going to be defined unless you defined it.
00:45  zambaboo: greycat, it is sourced from /etc/conf.d/$SCRIPT_NAME
00:45  paissad: greycat, thanks
00:46  zambaboo: greycat, once in init 3 everything is dandy. but on reboot it looks like line 20 does not happen
01:01  zambaboo: folks over at #puppet helped out. basname $0 returns a different name from what i expected.
01:01  greycat: !$0
01:01  greybot: $0 is like argv[0] in C. It's whatever the caller decides to put there. You can't rely on it. See http://mywiki.wooledge.org/BashFAQ/028 and http://www.bash-hackers.org/wiki/doku.php/scripting/posparams#the_first_argument
01:03  zambaboo: greycat, great point. thank you.
01:03  zambaboo: i need to revise this thing.
01:06 --- jzacsh_ is now known as jzacsh
01:17 --- jeeves__ is now known as jeeves_moss
01:18  jeeves_moss: how can I script a way of moving a file from the input directory to an output directory, however, leave a "touched" file with the same file name in the input directory?
01:19  cthuluh: just cp the file and then truncate it
01:19  krzie: touch it, then cp it to new dir
01:20  jeeves_moss: examples?
01:21  jeeves_moss: I've got ~80Gb of files that I need to do this with, and I'm looking for the most efficent way to do this.  The only reason I need the touched file in the input directory is so wget skipps the file during the next scrape run
01:22  cthuluh: jeeves_moss: wget should have appropriate switches
01:22  cthuluh: ask #wget
01:23  jeeves_moss: cthuluh, thanks.  I have it currently set up so it won't clobber the files already there, but I need to make sure that I move the retreived files to the slower/larger drive.
01:25  cthuluh: oh, you just want to save disk space?
01:25  cthuluh: cp -- "$1" "$2" && : > "$1" then
01:26  jeeves_moss: cthuluh, yes, the dump drive array for the scrape script is SCSI disks that are small, but since there are MANY scrips running, I need something fast
01:26  jeeves_moss: cthuluh, so far, the sudgestions have been "cd input_dir ; for file in *; do mv ${file} output_dir ; touch ${file} ; done"
01:27  cthuluh: not touch
01:27  cthuluh: touch won't truncate the file
01:27  cthuluh: now I wonder whether rsync has an appropriate switch or not :)
01:28  jeeves_moss: cthuluh, lol, now the grey matter is burnin!  I'm trying to find the simplest way of doing this that is going to hammer the CPU as little as possible
01:30  cthuluh: first, use mv -- * /target
01:30  jeeves_moss: cthuluh, full script?
01:30  cthuluh: oh well...
01:30  cthuluh: no
01:30  cthuluh: cp -- * /target
01:30  cthuluh: then truncate the files
01:30 --- Unknown[NF] is now known as Unknown[OFF]
01:31  jeeves_moss: hummm
01:31  cthuluh: (preferably without using a loop)
01:31  jeeves_moss: lol, yea, that's allways a plus
01:32  jeeves_moss: cthuluh, would it be easier to just move all the files with a file size larger than 1K to an output dir, then touch files baised on the currently stored touched files in the input directory, then have the script skip file names already there?
01:39  cthuluh: hmmm
01:40  jeeves_moss: cthuluh, that's the fastest/easiest way I can think of doing it
01:40  cthuluh: (cd /dir && cp -u -- * /target && sed -ni '' -- * && touch /target/*)
01:40  cthuluh: horrible :))
01:41  cthuluh: non-portable, but it should be efficient
01:41  cthuluh: as long as you don't have too much files. in which case you would go above ARG_MAX
01:42  cthuluh: jeeves_moss: this assumes GNU cp and sed
01:43  jeeves_moss: cthuluh, true
01:43  jeeves_moss: even if I max out the script, and try to squeeze as many threads out of it as I can.
01:43  jeeves_moss: the network connection is gigabit and has superblocks turned on
01:44  cthuluh: you could use find's -exec ... + feature  to avoid the ARG_MAX problem
01:59  k[t: # if grep -q "tty" <(tty) ; then echo "TTY" >/dev/stdin 2>&1 ; else echo "Not a TTY" >/dev/stderr 2>&1 ; fi
01:59  evalbot: k[t: no output
02:00  k[t: faux..
02:00  k[t: # if grep -q "tty" <(tty) ; then echo "TTY" >/dev/stdout 2>&1 ; else echo "Not a TTY" >/dev/stderr 2>&1 ; fi
02:00  evalbot: k[t: no output
02:17  DasEi: I'm not a coder and have just rural knowledge in scripting; is there an easy way to get a hash (md5sum) of a whole directory (with subdirs ) ?
02:18 * k[t wished he could use console_ioctl(4) instead... *shrugs..
02:20  TheBonsai: DasEi: geht md5sumd recursively and md5sum this md5sum list
02:20  TheBonsai: or so
02:22  DasEi: bonsai: the manpage doesn't mention it
02:22  TheBonsai: the manpage of... what?
02:22  DasEi: md5sum
02:23  DasEi: there neither is a -r or list option
02:23  TheBonsai: that's why a) god created find(1) and b) traditional unix commandline work is about combining tools
02:23  TheBonsai: $ md5sum <(find . -type f -exec md5sum {} \;)
02:23  TheBonsai: a0381a2da8179e0ff1db0f679ad9b79b  /dev/fd/63
02:23  TheBonsai: for example
02:23  DasEi: It getswarmer..
02:25  DasEi:  md5sum <(find . *md5sum {} \                   , if I execute this in a dir, might work, but it's subdirs ?
02:25  DasEi:  md5sum <(find . * md5sum {} \
02:25  TheBonsai: find . -type f -exec md5sum {} \;
02:25  DasEi: TheBonsai: trying now
02:25  TheBonsai: find already finds files, no need to let the shell find files (the *)
02:26  \malex\: DasEi: do you need an md5sum of every file, or the md5sum of the direcotry listing/ or what?
02:28  DasEi: \malex\:I want a hash of a whole dir (and its subdirs), one hash, so I can check if it's content was altered
02:28  TheBonsai: since it's about the content of files and directories, the method should do
02:28  DasEi: rsync -u does it, though
02:28  TheBonsai: - a modified files gives another md5sum for this file in the list, which gives another md5sum for the list itself
02:29  paissad: !redirections
02:29  TheBonsai: - a new or a removed file will change the list aswell
02:29  TheBonsai: rsync -u?
02:29  \malex\: DasEi: will you be running this multiple times on the same system to see if anything changes, or will you be running this on multiple systems to make sure theya re in sync/
02:30  TheBonsai: that's what you get when you don't tell the whole story... why not just tell that you want to incrementally transfer files :)
02:30  DasEi: \malex\:multiple on same, else used rsync
02:31  DasEi: TheBonsai:  md5sum <(find . -type f -exec md5sum {} \  just leaves             >  open, no string
02:32  DasEi: should be easy, sth. like for i ..
02:35  TheBonsai: DasEi: then you're missing balanced quotes or whatever else. just copy&paste
02:38  DasEi: http://paste.ubuntu.com/541243/ , no go
02:38  TheBonsai: the find command ends with \;
02:38  TheBonsai: and you need to close the <( with )
02:39  DasEi: ah, bracket missing, sure
02:39  paissad: TheBonsai, i was reading you wiki about redirections,
02:39  paissad: cat some_file.txt 2>&1 1>/dev/null
02:39  paissad: cat some_file.txt 1>/dev/null 2>&1
02:39  paissad: i still don't see the difference (it there is one)
02:40  paissad: (if there's one)*
02:40  TheBonsai: because no stderr is produced, i guess?
02:40  TheBonsai: (fd 2)
02:41  TheBonsai: test with { echo OUT; echo ERR >&2 } YOUR_STUFF_HERE
02:42  TheBonsai: # { echo OUT; echo ERR >&2; } 2>&1 1>/dev/null
02:42  evalbot: TheBonsai: ERR
02:42  TheBonsai: # { echo OUT; echo ERR >&2; } 1>/dev/null 2>&1
02:42  evalbot: TheBonsai: no output
02:42  TheBonsai: it definitely makes a difference
02:43  TheBonsai: your "cat" command just produces no stderr output
02:43  paissad: indeed
02:44  paissad: TheBonsai, i never knew that the order was important ! .. i'm shocked
02:45  TheBonsai: sinde the >&N syntax references a descriptor, it's relevant where this descriptor points to at this time
02:45  TheBonsai: *since
02:45  paissad: TheBonsai, you should put you example in your wiki, simple & clear
02:45  paissad: your example above
02:45  TheBonsai: which page, exactly?
02:45  TheBonsai: the tutorial is from pgas :)
02:45  paissad: TheBonsai, http://wiki.bash-hackers.org/syntax/redirection
02:45  paissad: TheBonsai, mutiple redirections section
02:46  TheBonsai: !redirtut
02:46  greybot: Redirections: http://bash-hackers.org/wiki/doku.php/syntax/redirection http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection http://bash-hackers.org/wiki/doku.php/howto/redirection_tutorial
02:46  TheBonsai: check the last link
02:46  TheBonsai: pgas visualized it
02:46  paissad: ok
02:47  DasEi: FYI: md5deep -r /anyDirHere does the trick, pipe it to a file with date, then later on re-do it and diff the two files
02:48  DasEi: so can even not just say if there was a change, but also in which file
02:48  DasEi: else can use a derivate of tar, found at ubuntuforums, fine then
02:48  DasEi: (one hash only then)
02:51  TheBonsai: paissad: http://wiki.bash-hackers.org/syntax/redirection#multiple_redirections
02:53  Smirnov: is there a good way to wait till a process creates and finishes writing to a file ?
02:53  yitz_: Monitor the file handle via /proc/ ?
02:53  TheBonsai: not without direct OS support.
02:53  yitz_: incron, too
02:54  TheBonsai: paissad: of course you're mentioned :P http://wiki.bash-hackers.org/syntax/redirection?do=recent
02:56  paissad: lol, there was no need to mention it ^^
02:57  Smirnov: direct OS support is fine
02:57  Smirnov: how would i get the file handle from the file name though
02:58  TheBonsai: you don't. IMHO what you can do is checking if this file is open
02:58  TheBonsai: lsof or thelike
03:04  Smirnov: ah good one
03:04  Smirnov: ill try lsof
03:04  Smirnov: next question is there a image diff i can use, dont need anything fancy just the # of pixels difference or something like that would be great
03:08  lhunath: look into imagemagick
03:21  Smirnov: ah man this compare tool takes FOREVER.
03:26  lhunath: doesn't sound like you want that
03:26  lhunath: otoh your question was rather vague
03:29  mar77i: Smirnov: apparently afaik the regular diff can do binary data...
03:31  Smirnov: mar77i: yeah but i have a few pixels that are different, compare -metric AE (absolute error) with 1% diff is perfect but sooo slow
03:34  Bushmills: coding an image comparison in bash is guaranteed to be even slower :)
03:36  Smirnov: i just need compare -metric AE except without having it do any other useless comparisons (or outputting a comparison image)
03:38  tsolox: how do i process individually this series of items: 1 2 45 43 ab dog I did for f in '1 2 45';do <--- but it was only one swoop...
03:38  yitz_: Drop the quotes
03:39  tsolox: wow...
03:39  yitz_: I can't believe I just said that...
03:40  Bushmills: # for var in  "a b" 'c d' e f; do echo "$var"; done
03:40  evalbot: Bushmills: a b
03:40  evalbot: Bushmills: c d
03:40  evalbot: Bushmills: etc... ( http://pastebin.com/RuWWVPV8 )
04:00  tsolox: thanks..
05:17  pyoor: hi all.  Someone here gave me the following line to remove all \n's from a file with the exception of those occuring in between "foo" and "bar": awk -v ORS='' '/foo/,/bar/ { if ($0 !~ /bar/) $0 = $0 "\n" }; 1
05:19  pyoor: ah excuse me, that line should be changed to remove all spaces not \n's
05:19  pyoor: my question is, is there a way to use a similar line to convert all \n to \r, and then convert any repeating \r into a single \r
05:19  pyoor: all with the exception of what is contained in between "foo" and "bar".  Also, there may be several instances of "foo" and "bar" in the same file
05:19  pyoor: ahh additionally, the two strings are "stream" and "endstream" (since I figure sharing the same string may cause a problem.
05:20  Bushmills: !nabt
05:24  tmr: Not a bash thingie_
05:24  tmr: s/_/?/
05:27  pyoor: I know its not specifically a bash question since it's just a single awk line.  I figured i might be able to get help here since that line was given to me here yesterday.
05:29  go|dfish: pyoor: you want to convert all \n to \r except within a certain range?
05:29  pyoor: go|dfish: yes, and then in the event that there are consecutive \r I'd like to convert them to a single \r
05:30  pyoor: all outside of 2 strings
05:32 --- flippo is now known as underscore______
05:32 --- underscore______ is now known as flippo
06:53  geirha: pyoor: awk '/foo/{a=1} !a && !/^$/{ORS='\r';print} a{ORS=RS;print} /bar/{a=0}'
06:53  pyoor: geirha: thanks, but I have no idea what that means :)
06:53  geirha: But that question really belongs in #awk
06:53  pyoor: my apologies
06:56  geirha: If line contains foo, set a=1 (true). If a is false and line is not empty, use \r instead of newline and print. If a is true, use default newline and print. If line contains bar, set a to false.
06:58  pyoor: hrmm
06:58  pyoor: that might not work.
06:59  pyoor: unless i don't understand it correctly.  Between stream and endstream is binary data.  In the binary data could be \r or \n.
07:00  pyoor: also stream could be at the end of a line, so any preceding \n's on that line won't be converted to \r
07:02  geirha: Ok, that's way more complicated, and I don't know how awk will handle that binary data.
07:06  geirha: Again, you might have more luck in #awk, there's a wizard who lives there, he knows magic.
07:21  JRummy16: join #awk
07:21  JRummy16: lol, fail
07:25  pyoor: lol JRummy16 went in search of the wizard
07:26 * JRummy16 hasn't seen him yet but patiently waiting :p
07:26  pyoor: haha
07:26  pyoor: you must have just missed the unicorns
07:26  JRummy16: lol
07:27  flaccid: hmm is there a problem with using curly braces in here docs?
07:27  flaccid:  syntax error near unexpected token `}'
07:29  flaccid: !heredoc
07:29  greybot: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
07:31  flaccid: hmm needed <<
07:50  Eiler: how can i remove all the files in a directory without deleting the directory itself?
07:50  geirha: shopt -s dotglob; rm dir/*
07:53  avinashhm: hi, i am facing an error with inserting ko's and removing them .. not able to remove them ... more logs @ http://paste.ubuntu.com/541312/ .. any help ???
07:55  SiegeX: avinashhm: which part of bash is giving you a problem?
07:56  avinashhm: SiegeX, i am sorry .. i wan'ted to put it in ubuntu ... my mistake .. sorry
09:07  ManDay: Is there a difference between  printf "a\nb"   and   printf "a<CR>b" ?
09:08  geirha: Yes.
09:08  geirha: carriage return (\r) and newline (\n) are not the same
09:10  pgas: well, if by <CR> you mean press the return key, then no there are no difference
09:11  ManDay: pgas: geirha thats what i meant
09:53 --- Unknown[OFF] is now known as Unknown[NF]
10:15  mrtnt: I have a following file: http://pastebin.com/1jZc0bYM How to achieve the desired output? I tried with "cat file | sed 's/^[[:digit:]]{1,4} .*//'" but this does nothing..
10:16  geirha: awk '{print $1}' file
10:16  geirha: Your regex is almost right, you just need to escape { and } with backslashes
10:17  geirha: !uuoc > and this
10:17  greybot: and this: Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
10:17  geirha: err wait, you'll also need a grouping
10:18  geirha: sed 's/^\([[:digit:]]\{1,\}\).*/\1/' file
10:19  mrtnt: geirha: I see, thanks!
11:09 --- stateknife is now known as arkham
11:09 --- arkham is now known as Guest8284
11:10 --- Guest8284 is now known as stateknife
11:32  fahmad: hey
11:32  fahmad: can someone tell me how can i print line using sed if i know line number ?
11:32 --- Weust`afk is now known as Weust`
11:35 --- Unknown[NF] is now known as Unknown[OFF]
11:35  strull: sed -n 10p file
11:38  hemanth: how do i reset the sticky bits to the OS default ?
11:38  Perun_: how can I add a grep to this: http://paste.debian.net/101958/ (want only bup in the tmp/bup file)
11:39  hemanth: i had created some file with default sticky bits, then did a chmod over it, how does one revert it back to its permissions?
11:39  poisonbit: hemanth, using a backup ?
11:39  poisonbit: if you use -p in tar or -a in rsync it will save permissions
11:40  hemanth: poisonbit, its normal file
11:40  jacks_lt: I want to check if rdiff-backup is running, before I shutdown (or reboot)
11:40  jacks_lt: something like this but then in bash http://fpaste.org/dzH0/
11:41  poisonbit: !pm > jacks_lt
11:41  greybot: jacks_lt: http://mywiki.wooledge.org/ProcessManagement
11:41  jacks_lt: This is checking if rdiff-backup is running localy: [ -n "`ps -o pid --no-heading -C rdiff-backup`" ] && echo "running" || echo "not running"
11:42  poisonbit: jacks_lt, while true; do if your checkings; then your command; else sleep 60; fi; done
11:43  poisonbit: change "your checkings" and "your command"
11:43  jacks_lt: hmm k
11:43  fahmad: strull: ok
11:45  poisonbit: Perun_,   grep bup > file << EOF...
11:48  Perun_: poisonbit: done it with: sqlplus -S user@pass/host << EOF | /bin/egrep '^[[:alnum:]]{32}$' > /tmp/file
11:50  Perun_: it is possible to put a blabup EOF into a var and do something like sqlplus << $MYVAR ?
11:50  poisonbit: <<<
11:50  Perun_: ups
11:50  Perun_: can you show me a example?
11:51  poisonbit: # while read line; do echo $line; done <<< "$USER"
11:51  evalbot: poisonbit: no output
11:51  poisonbit: # USER=bill ; while read line; do echo $line; done <<< "$USER"
11:51  evalbot: poisonbit: bill
11:52  jacks_lt: poisonbit: something like this? http://fpaste.org/wwKZ/
11:52  poisonbit: jacks_lt, don't you have pgrep ?
11:52  Perun_: poisonbit: tough something like that: http://paste.debian.net/101961/
11:52  poisonbit: pgrep rdiff-backup
11:53  jacks_lt: poisonbit: sorry I have lvery ittle experience with bash...
11:53  jacks_lt: *very little
11:53  poisonbit: Perun_, var=$( cat << EOF....  blabla \nEOF)" ; echo "$var"
11:54  poisonbit: Perun_, var="$( cat << EOF....  blabla \nEOF)" ; echo "$var"
11:54  poisonbit: jacks_lt, no problem, me too
11:56  jacks_lt: poisonbit: just like this? http://fpaste.org/Stwh/
11:58  poisonbit: jacks_lt, compare if pgrep bash with  if pgrep bash >/dev/null; then ... try and see
11:59  poisonbit: maybe you just want to check, and do not want to see pids
11:59  poisonbit: Perun_,
11:59  poisonbit: # echo 'var="$( cat << EOF' > file; echo Hi >> file; echo 'EOF' >> file; echo ')"' >> file; echo 'echo "$var"' >> file; bash file
11:59  evalbot: poisonbit: Hi
12:02  Perun_: poisonbit: http://paste.debian.net/101962/ does show it but all in one line
12:03  poisonbit: !quotes > Perun_
12:03  greybot: Perun_: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
12:04  poisonbit: also cat <<< $var  is really /bin/cat,  just use echo or printf, that are already in the proccess ram
12:04  Perun_: aha
12:04  oskie: hello, I'm having a problem with this: "read -t 60 result < $tmpfifo" - it never returns - not even after 60 seconds. any idea what is wrong?
12:06  poisonbit: osky "read or "while read ....; do  ?
12:08  oskie: poisonbit: just 'read'
12:08  Uqbar: # mkfifo fifo; read -t 1 foo <fifo
12:08  oskie: poisonbit: after 60 seconds, I even tried echo 1 > $tmpfifo - then all of a sudden the read call returns!?
12:08  poisonbit: oskie, try something like:  while read line; do echo "$line"; done < "$tmpfifo"
12:08  evalbot: Uqbar: no output within the time limit
12:09  poisonbit: mmm no idea, never did the same
12:09  oskie: Uqbar: ah! easily reproducable
12:09  oskie: this must be a bash bug, no?
12:10  jacks_lt: poisonbit: you mean something like http://fpaste.org/k9TO/
12:11  poisonbit: jacks_lt, that will shutdown when it is running (reading it :) use unless, or change one the sleep and the shutdown of place
12:11  oskie: Uqbar: ah. found the reason. it is because of the '<'
12:11  Perun_: poisonbit: I test it only with cat, I use it later with sqlplus
12:11  poisonbit: if pgrep bla; then sleep
12:11  Uqbar: oskie: sorry?
12:11  jacks_lt: right
12:13  jacks_lt: http://fpaste.org/nPhH/
12:13  oskie: mkfifo fifo; read -t 1 foo <fifo   <- on my system this blocks indefinitely
12:13  oskie: Uqbar: at first glance it should timeout after 1 second, right?
12:15  oskie: apparently the following works as expected: mkfifo f; exec 42<> f; read -t 1 foo <&42
12:29  Uqbar: oskie: yes, but why it stalls in the first case is unclear to me.
12:45  geirha: oskie: with  read < f  it waits for f to open in the other end before running read
13:01  oskie: is it possible to redirect stderr into a variable, but keep stdout and stdin connected to terminal? (e.g. using backticks)
13:02  AL13N_work: oskie: sure, just swap stdout and stderr
13:02  geirha: !faq 2>&1
13:02  greybot: http://mywiki.wooledge.org/BashFAQ/055 -- Tell me all about 2>&1 -- what's the difference between 2>&1 >foo and >foo 2>&1, and when do I use which?
13:02 --- Weust` is now known as Weust`afk
13:02  geirha: !faq 2
13:02  greybot: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
13:03  AL13N_work: var=`command 2>&1 >&2`
13:03 --- Weust`afk is now known as Weust`
13:04  Riviera: hm, the example in the faq could IMHO be improved.
13:06  oskie: AL13N_work: thanks, but that didn't work - no display: p=`dialog --title "Password" --passwordbox "Enter password:" 8 34 2>&1 >&2`
13:06  oskie: I'll check out the FAQ
13:06  oskie: hmm output=$(command 3>&2 2>&1 1>&3-)
13:08  AL13N_work: hmm, could be
13:08  oskie: thanks
13:12  szonek: hi
13:12  Riviera: # f () { echo stdout; echo stderr >&2; }; { a=$(f 2>&1 >&3); } 3>&1; echo "a: $a"
13:12  evalbot: Riviera: stdout
13:12  evalbot: Riviera: a: stderr
13:13  Riviera: That is IMHO better than using stderr or /dev/tty for seeing stdout.
13:24  szonek: i know i can use something like: date '+%Y-%m-%d' -d '2 years ago'
13:24  szonek: to get date 2 years ago
13:25  szonek: but what if i want to get 2 years and 1 day ago
13:25  szonek: ? :)
13:26  TheBonsai: 1 day 2 yers ago, maybe
13:26  TheBonsai: check gnu date syntax ref
13:26  AL13N_work: Riviera: so `(cmd1 >&3 ; cmd2 ) 3>&1 | cmd3` is better than `(cmd1 >/dev/stdout ; cmd2 ) | cmd3`
13:26  AL13N_work: ?
13:32  oskie: how do I make this handle spaces in fifofile propery? trap "echo 1 >$fifofile" EXIT
13:34  TheBonsai: quote it (the variable itself)
13:34  TheBonsai: just use ' outside and " inside
13:34  TheBonsai: or " outside and \" inside
13:34  TheBonsai: and why do you use insane filenames?
13:35  oskie: TheBonsai: that's up to the malicious user
13:36  oskie: trap { echo 1 >"$fifofile" } EXIT seemed to work as well as quotes nesting
13:37  oskie: ah.. {} was not good
13:37  TheBonsai: hummmm. a compound command for trap without quoting?
13:37  TheBonsai: interesting
13:37  TheBonsai: oh, not?
13:37  TheBonsai: ok :)
13:41  oskie: trap { echo 1 >"$fifofile" ; echo 2 >foo } EXIT <- that looks pretty good doesn't it? only now 'foo' contains '2 } EXIT' - i suspect something went wrong :)
13:42  TheBonsai: just quote it
13:42  TheBonsai: trap is a command, not shell syntax
13:42  TheBonsai: trap WHAT WHEN
13:42  TheBonsai: where WHAT is one single argument
13:42  TheBonsai: trap 'foo; bar; baz; meow >blah'
13:43  oskie: yeah - it just doesn't look nice - quoting code inside code :)
13:51  geirha: oskie: Then put the code inside a function
13:51  geirha: onexit() { ...; }; trap onexit EXIT
13:55  rethus: what is the right way to execute a command like "ant-phone& -r" in a bash-script?
13:55  rethus: should i do $(command) ?
13:57  geirha: Is there really a & in the command name?
13:58  rethus: no, i have turn it now to ant-phone -r &
13:59  rethus: run in background
14:00  rethus: my problem seems to be, that the bash script is much faster finished, as ant-phone is start, so the ant-phone call comes to late. can i wait till the process is started in bash?
14:01  geirha: You mean wait till it's finished? Yes, with the wait builtin.
14:01  geirha: !pm > rethus
14:01  greybot: rethus: http://mywiki.wooledge.org/ProcessManagement
14:04 --- Unknown[OFF] is now known as Unknown[NF]
14:28  wereHamster: what would be the reason for bash not setting $SHELL ?
14:30  Synthead: wereHamster: anything in ~/.bashrc?
14:31  rethus: i have this:
14:31  rethus: if [ -z `pidof ant-phone` ]; then echo "joho"; else echo "noho"; fi;
14:31  rethus: ant-phone is running, but result is noho
14:31  rethus: why?
14:31  Synthead: wereHamster: also, try this on your prompt
14:31  Synthead: # echo $0
14:31  evalbot: Synthead: /bin/bash
14:31  wereHamster: Synthead: bash
14:32  wereHamster: colud it be because of the ancient verison of bash (3.2)?
14:32  erUSUL: !pm
14:32  greybot: http://mywiki.wooledge.org/ProcessManagement
14:33  Synthead: wereHamster: I just checked an old machine with Bash 3.2, it reports $SHELL
14:33  Synthead: wereHamster: no references to "SHELL" in ~/.bashrc?  or /etc/profile?
14:34  wereHamster: Synthead: no
14:35  Synthead: wereHamster: hmm, what distro?
14:35  wereHamster: ubuntu 8.04
14:35  _pingu: how can I sort the result of wc -l after the lines? the file with the most lines on top
14:35  Synthead: wereHamster: ubuntu might be using dash and is lying to you
14:36  Synthead: wereHamster: try typing "bash" at the prompt and then run "echo $SHELL"
14:36  wereHamster: the login shell is tcsh, which reports SHELL=/bin/tcsh. hen I then execute bash then it still reports SHELL as the same
14:36  Synthead: wereHamster: [max@killterm3 ~]$ dash
14:36  Synthead: [\u@\h \W]$ echo $SHELL
14:36  Synthead: /bin/bash
14:37  Synthead: looks like that's normal behavior, hm
14:37  wereHamster: dash, echo $SHELL -> /bin/tcsh
14:39  wereHamster: looks like the system is fubar
14:39  _pingu: wc -l * | sort -n looks ok
14:39  Synthead: wereHamster: I wouldn't say that so fast actually
14:39  Riviera: AL13N_work: my point was that the solution in the FAQ abuses /dev/tty for redirecting stdout to
14:39  Synthead: <Synthead> wereHamster: [max@killterm3 ~]$ dash
14:39  Synthead: <Synthead> [\u@\h \W]$ echo $SHELL
14:39  Synthead: <Synthead> /bin/bash
14:39  wereHamster: Synthead: at least it's 'FU'
14:39  Riviera: AL13N_work: and also, that your solution abuses stderr for redirecting stdout to
14:39  wereHamster: maybe not BAR :)
14:40  Riviera: AL13N_work: both are fine when it's only about seeing the output on a terminal
14:40  Synthead: wereHamster: dash reports itself as bash when bash is the primary shell
14:40  Synthead: wereHamster: you can set bash as your default login shell
14:40  Synthead: wereHamster: that ought to make it report itself as bash ;)
14:40  Riviera: AL13N_work: but a more generic solution where stdout stays stdout and stderr just is stored in the desired variable is IMHO better
14:40  wereHamster: Synthead: could it be that when switching shells the new one keeps the old SHELL ?
14:40  Synthead: wereHamster: that's exactly what I'm demonstrating with what I posted earlier
14:40 --- studyurnm3 is now known as misnix
14:41  Synthead: wereHamster: look again
14:41  Synthead: <Synthead> wereHamster: [max@killterm3 ~]$ dash
14:41  Synthead: <Synthead> [\u@\h \W]$ echo $SHELL
14:41  Synthead: <Synthead> /bin/bash
14:41  Riviera: AL13N_work: because it does not rely on the assumption that stdout is the current tty.
14:41  wereHamster: evidence would indicate so. But it's a stupid thing to do IMHO ...
14:42  geirha: SHELL is set by login, not by the shell
14:42  Synthead: wereHamster: # usermod -s /bin/bash [your username]
14:42  Synthead: wereHamster: that will set bash as your default login shell
14:42  wereHamster: geirha: interesting to know.
14:43  geirha: just like HOME
14:43  Synthead: wereHamster: imo, dash is annoying ...
14:43  wereHamster: it's not dash that's the problem, but one of the scripts which uses $SHELL to decide whethre to use setenv or export -.-
14:44  geirha: wereHamster: That script is broken. Throw it out.
14:45  geirha: I don't think it ever makes sense for a script to test $SHELL
14:54  rethus: ifhow can i interact with the value which result from kdialog --radiolist in a local bash var ?
14:54 --- r0dr1g0 is now known as r0dr1g0[away]
14:54  geirha: var=$(kdialog ...)
14:57  rethus: http://pastebin.com/wjnmQrw6
14:57  rethus: have this, but result nothing
14:58  rethus: does the linebreaks make problems?
14:59  geirha: What does it output?
15:00  rethus: nothing.. means an empty line
15:00  geirha: No matter what you select?
15:01  rethus: ah, found the error.
15:01  rethus: the first was preselected.
15:01  rethus: i didn't know, that second click deselect all
15:01  bob_f: If I have a string "a b c", how do I iterate over this string so that on each iteration a variable will hold the value a, then b, then c ?
15:02  AL13N_work: Riviera: i see your point
15:02  geirha: bob_f: Better to use an array
15:02  Riviera: bob_f: set -f; for var in $string; do ... "$var"; done
15:02  AL13N_work: bob_f: for i in $sttring; do ... done
15:02  geirha: !wordsplitting > rethus
15:02  greybot: rethus: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
15:02  AL13N_work: Riviera: what does set -f do?
15:03  Riviera: AL13N_work: prevent globbing, in case the string contains words with characters special to pathname expansion, like *, ?, [ and ]
15:03  AL13N_work: oic
15:03  bob_f: Hmm.
15:03  bob_f: This doesn't appear te be working for me.
15:03  SixThreeOh: Howcome in a single quoted string escaping a quote doesn't work? such as: 'don\'t', will work as 'don'\''t' which is silly
15:03  Riviera: AL13N_work: but again generally, using arrays is better
15:03  rethus: how can i enter linebreaks in the --radiolist string ?
15:03  bob_f: £ set -f; for f in "a b c"; do echo $f; done
15:03  bob_f: a b c
15:04  rethus: !linebreak > rethus
15:04  Riviera: SixThreeOh: How can you say that it is silly if you don't understand what happens?
15:04 --- jzacsh is now known as jzacsh_
15:04  geirha: bob_f: for f in "a" "b" "c"; do ...
15:04  AL13N_work: SixThreeOh: IIRC the ' ' does not allow backquoting at all
15:04  bob_f: geirha: Yeah, but I have "a b c"
15:04  SixThreeOh: well, the silliness is a solution borne from me not knowning what happens
15:04  geirha: bob_f: In a var?
15:04  bob_f: Well it's a literal.
15:04  SixThreeOh: ah duh thanks
15:04  geirha: bob_f: Then omit the quotes
15:04  SixThreeOh: that will explain allot of things :)
15:05  bob_f: Ah neat.
15:05  bob_f: geirha: Great, that works - thanks very much.
15:05  geirha: bob_f: Are you from UK since your prompt has £ instead of $ ? :P
15:05  bob_f: geirha: Yeah. :)
15:06  AL13N_work: i'll just refrain from answering anyone, since Riviera does it better and faster
15:06  geirha: funny :)
15:06  AL13N_work: geirha: so my prompt should be € then?
15:06  bob_f: Is there a variable that represents the index of the iteration when doing "for xxx in ..." ?
15:06  geirha: AL13N_work: Apparently ;P
15:07  greycat: bob_f: yes, it's xxx.
15:07  Riviera: AL13N_work: no no, stick to geirha and greycat :)
15:07  bob_f: greycat: No, the index of the iteration.
15:07  bob_f: Not the value.
15:07  bob_f: i.e. 0,1,2,n
15:07  AL13N_work: bob_f: the for .. in ... doe not have an index
15:07  AL13N_work: *does
15:07  geirha: bob_f: Keep a counter or use an array
15:07  greycat: bob_f: if you mean an INTEGER that COUNTS how many times you've done stuff, then you can make your own.
15:07  AL13N_work: bob_f: use for (( ... ; ... ; ... )) constructs instead
15:07  bob_f: And what is the most convenient way to make a counter ?
15:08  greycat: x=1; ((x++))
15:08  bob_f: I think I'm just gonna do this in Python. :)
15:08  geirha: i=0; for x in a b c; do echo "$i, $x"; ((i++)); done
15:08  AL13N_work: for (( i=0; $i < ${#var} ; i = $i + 1)); do ... done
15:08  bob_f: geirha: Aha, okay, very simple.
15:09  geirha: array=(a b c); for i in "${!array[@]}"; do echo "$i, ${array[i]}"; done
15:09  SixThreeOh: One other thing, puting \ at the end of a line, lets me put a new line to enter more text, is that a way to get this to work other than at the end of the line to break up a large string?
15:09  Synthead: what's a good regex to change every _character_ in a variable with "*" ?
15:10  greycat: Synthead: ${var//?/*}
15:10  greycat: !regex
15:10  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
15:10  bob_f: geirha: Actually the first one you gave me doesn't seem to work, I get an unexpected token for '('
15:10  greycat: bob_f: use bash.
15:10  bob_f: Yep, I am.
15:10  geirha: !sh
15:10  greybot: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
15:10  greycat: No, really, use bash instead of sh.
15:10  bob_f: I am.
15:10  Synthead: greybot: haha
15:10  Synthead: greycat: haha
15:11  geirha: # i=0; for x in a b c; do echo "$i, $x"; ((i++)); done
15:11  evalbot: geirha: 0, a
15:11  evalbot: geirha: 1, b
15:11  evalbot: geirha: 2, c
15:11  bob_f: Hey, huh.
15:11  bob_f: I must have typoed.
15:11  geirha: bob_f: See, it works in bash ^
15:11  bob_f: I checked like 5 times.
15:11  greycat: sh# i=0; for x in a b c; do echo "$i, $x"; ((i++)); done
15:11  Synthead: greycat: but!  when I replace with *, I see the contents of my current directory instead of *
15:11  bob_f: Copying&pasting works. Sorry about tha.
15:11  shbot: greycat: 0, a
15:11  shbot: greycat: /bin/sh: i++: not found
15:11  shbot: greycat: etc... ( http://pastebin.com/fnkb8P9r )
15:11  bob_f: t
15:11  Synthead: # a=12345; echo ${a//?/*}
15:11  evalbot: Synthead: *****
15:11  Synthead: D:
15:12  Synthead: ???
15:12  greycat: !umq > Synthead
15:12  greybot: Synthead: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
15:12  bob_f: Yeah, my mistake - missed a semicolon.
15:12  greycat: !pf echo > Synthead
15:12  greybot: Synthead: http://mywiki.wooledge.org/BashPitfalls#pf14 -- Don't do this! -- echo $foo
15:12  Synthead: greycat: dag, yo
15:12  Synthead: greycat: :)  I was omitting them for example's sake, so thanks!
15:13  geirha: # touch oops; a=12345; echo ${a//?/*}
15:13  evalbot: geirha: oops
15:13  Synthead: greycat: that kills a for; do loop in my script :)
15:13  csabo: good morning
15:13  greycat: So use them.
15:13  Synthead: # touch oops; a=12345; echo "${a//?/*}"
15:13  evalbot: Synthead: *****
15:13  Synthead: :)
15:13  bob_f: Ah, and now it's broken because of the previous set -f :)
15:13  SixThreeOh: sh# export foo="bra"
15:13  shbot: SixThreeOh: no output
15:13  SixThreeOh: sh# echo $foo;
15:13  shbot: SixThreeOh: no output
15:14  csabo: would 'awk' be my best bet for parsing a log file, and finding specific entries?
15:14  AL13N_work: SixThreeOh: don't you mean "bar" ?
15:14  greycat: That would depend on the format of the log file.
15:14  AL13N_work: SixThreeOh: where is your mind
15:14  SixThreeOh: if it is delimited awk would be especially useful
15:15  csabo: SixThreeOh: its data being pulled from TSM, i'm dumping a few things into a txt file, pretty basic
15:15  csabo: but theres some things, like a 6 line "IBM header" that i want to remove
15:17  csabo: i'm sure i'm not articulating this very well, i've never actually attempted to parse through and remove specific entries / lines
15:17  SixThreeOh: tail -n $((`wc -l file`)-6) :P (probably a better way than that).
15:17  csabo: lol
15:17  geirha: SixThreeOh: You mean one that works? ;P
15:18  SixThreeOh: in awk you can get a var of the curent line count so basically have if the line less than 7 do nothing
15:19  geirha: csabo: So far, sed and awk sound like candidates. Head on over to ##sed and/or #awk for more help on that.
15:19  csabo: ty
15:19  SixThreeOh: that works if you fix the bracket :)
15:20  SixThreeOh: and add the file param
15:23  pgas: SixThreeOh: tail -n +7 file
15:42  TheBonsai: omg now there are evil terroristic petitions like http://www.avaaz.org/en/wikileaks_petition/95.php?CLICKTF
15:43  SixThreeOh: attacking wikileaks is pretty funny because really it is nothing, it is the technology that enables, many people can put up a website, use tor, encryption, etc. So I wish them good luck on that.
15:46  TheBonsai: hey, i just needed some ironic words to spread the link
15:46  TheBonsai: :)
15:46  Riviera: As everyone could see since your name appeared in that list. :)
15:47  SixThreeOh: nice list of people for the alien corporate government lizards to incarcerate
16:00  gwz: how many ppl would they possible incarcerate? half a million? a million? maybe even 5 million? :P
16:02  go|dfish: we're already incarcerated
16:02  gwz: not literally..yet
16:02  greycat: Lemme off this stupid planet!
16:04  go|dfish: time for nature to perform a shutdown(1) or reboot(1)!
16:04  gwz: kill -9 humanprocess
16:11  TheBonsai: Riviera: :)
16:24 --- disgrntld1 is now known as disgrntld
16:24  Benkinooby: hi, is there a way to use the "currently executed" command as title? like, when i am running 'ping 127.0.0.1' my title bar would be "ping 127.0.0.1" and when it's waiting for a command, i get the current folder
16:25  greycat: You'd have to use a DEBUG trap.
16:25  greycat: !faq title
16:25  greybot: http://mywiki.wooledge.org/BashFAQ/093 -- How can I set the contents of my terminal's title bar?
16:25  greycat: not sure if it's in there or not...
16:26  Benkinooby: greycat, i'll read it... i found a lot of stuff on how to set the title, but no luck until now..
16:27  Benkinooby: greybot, looks promising! i'll report back, i you like
16:46  Benkinooby: greycat, thank you! works nice..
16:50 --- Azer_ is now known as Azer
17:14  avinashhm: hi, how to grep two words .. i am grepping using 'find 13* -name "*.txt" | xargs egrep -inr "fs-min"' ... but wan't to grep onemore word in addition to fs-min .. any help
17:14  greycat: !faq foo and bar > avinashhm
17:14  greybot: avinashhm: http://mywiki.wooledge.org/BashFAQ/079 -- How can I grep for lines containing foo AND bar, foo OR bar?  Or for files containing foo AND bar, possibly on separate lines?
17:15  greycat: !find > avinashhm: also...
17:15  greybot: avinashhm: also...: http://mywiki.wooledge.org/UsingFind
17:16  greycat: xargs is going to bite you in the ass if any of your filenames contain whitespace, double quotes or single quotes.
17:22  avinashhm: greycat, to avoid find and xargs i do 'grep -inr "fs-min*" 13*'  .. .there are directories 131* to 139*  which i wan't to search .. how to restrict it to txt files inside 13* dirs ...
17:22  greycat: find -print0 and xargs -0 would be acceptable, if your OS has them
17:23  greycat: grep -r can't filter by filename (*.txt)
17:23 --- TiCPU__ is now known as TiCPU
17:28  SeanInSeattle: Hey all.  I'm wondering.  How can I set my bashrc to color the prompt according to an RGB value set, instead of the ANSI color code (http://pueblo.sourceforge.net/doc/manual/ansi_color_codes.html)?
17:29  greycat: I have no idea what an "RGB value set" is, but you can put anything you want in your PS1.  If it's a non-cursor-moving character sequence, enclose it in \[ \].
17:30  SeanInSeattle: I apologize if I'm not using the correct terminology.  I mean, "how can I set the color from a RGB value, like when one sets a color property in CSS.... for example:  RGB(255,255,255)
17:31  greycat: Sounds like a terminal question, not a bash prompt question.
17:31  taylanub: SeanInSeattle: you can set your terminal emulator to use different colors
17:31  greycat: The most likely answer for most terminals is "BWA-hahahaha", but who knows, maybe your terminal can.
17:32  SeanInSeattle: Well, I only want to color the hostname in the prompt, so my terminal / xterm settings won't help me much there.
17:33  SeanInSeattle: What's the right place to ask this question, if not on this channel?
17:33  greycat: SeanInSeattle: The question you need to ask is "How do I get my *terminal* to display some text in this color I have in my mind."  Once you know *that*, if it's possible, then you can put the magic into PS1.
17:33  greycat: You could start by identifying which terminal you are using.
17:34  SeanInSeattle: gnome terminal 2.3.2
17:34  taylanub: #gnome then maybe
17:35  greycat: OK, if you can't find it in the gnome-terminal documentation, you can ask a gnome channel or your OS channel.  Or maybe someone here might happen to know.
17:39  Manyfold: hello
17:40  Manyfold: i have a question
17:40  Manyfold: hellowhy does 'kate $(dpkg -l)' not work ?
17:41  greycat: what did you expect it to do?
17:42 --- Weust` is now known as Weust`afk
17:43  Manyfold: greycat: i expect to open kate with the output from dpkg -l in an unamed file
17:43  Manyfold: test file
17:43  Manyfold: text file
17:43  greycat: There's no such thing as "an unnamed file".  You have to save the output into a file and then open that.
17:44  greycat: dpkg -l > foo ; kate foo
17:44  Manyfold: or dpkg -l &> kate ?
17:45  taylanub: that will create a file called kate
17:45  taylanub: you're thinking of  dpkg-l | kate  but i dunno if kate would allow that
17:45  greycat: And it will not invoke a command by that name.
17:45  Manyfold: ok thank you ffor your help
17:45  Manyfold: much remains to be understood
17:46  greycat: If kate can read from stdin rather than a file, then you could use the pipeline, sure.
17:46  greycat: I think kate is some kind of text editor, though.
17:46  greycat: Most text editors will refuse to read their "content" from stdin.
17:46  olskolirc: kate is God greycat
17:47  greycat: I thought Alanis Morissette was god.
17:47  greycat: (Or Eric Clapton, if you use a few-decades-older meme.)
17:48  taylanub: the newest thing is Ceiling Cat
17:49  greycat: Doesn't work quite as well against "kate" which is a feminine name.
17:50 * taylanub fails at culture
17:51  greycat: Yes, taylanub. that CTCP VERSION response is correct.
17:52  taylanub: are you a wizard, greycat ?
17:52  greycat: I appear to be devoid of pointy hats at the moment.
18:11  csabo: can i use if [ -e <file1> <file2> ]
18:12  greycat: No.
18:12  csabo: or rather ,what is the best way to have the logic require multiple files
18:12  csabo: i've got 3 log files, and incase one or all didnt get removed, i want to delete them
18:12  greycat: if [ -e "$file1" ] && [ -e "$file2" ]
18:12  csabo: ah okay, so seperate statements
18:12  greycat: or, if [[ -e $file1 && -e $file2 ]]
18:12  csabo: ty
18:14  csabo: greycat:  is there an intelligent way to do it if say theres 3 files?
18:14  Bushmills: why test before removing?   rm -f file  will remove it, if it exists.
18:14  csabo: Bushmills:  because the file shouldnt exist
18:15  csabo: but i dont want errors when the script runs if the file doesnt exist
18:15  greycat: csabo: for f in YOUR LIST; do if [ ! -e "$f" ]; then ...
18:15  csabo: ah ha!
18:15  Bushmills: but the result will be "doesn't exist", in either case of existed or not existed before
18:15  Bushmills: "incase one or all didnt get removed, i want to delete them" - same as "delete them"
18:17  SeanInSeattle: Can someone recommend a pattern to use in order to avoid letting a user use rm with the recursive flag?
18:17  SeanInSeattle: Or, at least, making them confirm that they really want to perform it recursively?
18:17  csabo: you want to block the -R flag?
18:17  SeanInSeattle: Want to confirm the -R flag on rm command.
18:17  csabo: its builtin functionality,
18:18  csabo: i mean, the -R is, you could create a daemon i suppose to halt if someone uses -R
18:18  SeanInSeattle: Kindof, it will ask for each file, and I just want it to ask once.
18:18  csabo: remake the rm app?
18:18  SeanInSeattle: I guess I'm so used to using -Rf that that's why I framed my question that way.
18:18  csabo: ah
18:29  Rayne: when calculating a checksum of a "chattr compressed" file, the checksum will be the one of the uncrompressed data - am i right?
18:30  geirha: SeanInSeattle: You want to warn yourself when you use -r/-R?
18:30  SeanInSeattle: Yes, that is my goal.  :)
18:30  greycat: Rayne: sounds like an OS question
18:32  geirha: rm() { local arg recursive=0; for arg; do if [[ $arg = -*[rR]* ]]; then recursive=1; break; fi; done; if ((recursive)); then read -p "Sure about this? (Ctrl+c to abort) " && command rm "$@"; fi; }
18:32  greycat: should break the loop on -- too
18:32  geirha: err, not quite
18:32  SeanInSeattle: geirha:  where would I put that?
18:32  SeanInSeattle: In the bashrc?
18:32  geirha: rm() { local arg recursive=0; for arg; do if [[ $arg = -*[rR]* ]]; then recursive=1; break; fi; done; if ((recursive)); then read -p "Sure about this? (Ctrl+c to abort) " || return; fi; command rm "$@"; }
18:32  geirha: SeanInSeattle: Yes
18:33  SeanInSeattle: cool,  thanks!  I'll try that out.
18:33  greycat: Overriding the behavior of rm is really NOT a good idea in general.  It will cause you to develop bad, dangerous habits and you will lose files permanently when you use your bad habits on a normal machine.
18:33  geirha: greycat: err right
18:33  geirha: rm() { local arg recursive=0; for arg; do [[ $arg = -- ]] && break; if [[ $arg = -*[rR]* ]]; then recursive=1; break; fi; done; if ((recursive)); then read -p "Sure about this? (Ctrl+c to abort) " || return; fi; command rm "$@"; }
18:36  SeanInSeattle: that works wonderfully, geirha.  Thanks a LOT!
18:38  ket: interesting: seems like you can completely get rid of binutils at that rate..
18:39  ket: that would be awesome.. rewriting all the basics...
18:39  greycat: huh?
18:39  geirha: SeanInSeattle: If you run ''type rm'' now, you'll see the function in a more readable manner.
18:39  ket: nvm i didn't see 'command rm`
18:39  greycat: I suspect he meant coreutils, not binutils, AND that he completely misunderstood the fact that the function still CALLS the system's rm command.
18:40  SeanInSeattle: geirha:  So, that'll work for really any command being used recursively, yes?
18:40  greycat: (And "coreutils" is a completely GNU-centric view of the universe.)
18:40  SeanInSeattle: at least, that's how I read it.
18:40  ket: hmm.. simulating rm with find,read@/dev/null
18:40  greycat: SeanInSeattle: It looks for - and r in the same argument.
18:41  SeanInSeattle: Cool.  thanks guys.  I appreciate the help this morning!
18:43  ss0: Would a grep construct be the best way to pull two matches from a pipe and put them next to each other, or would awk be the best tool?
18:44  greycat: Too vague.
18:45 --- kel39-d is now known as kel39
18:46  ket: yea, that's me senseless in the early AM
18:46  ss0: greycat:  I will try be more concise. Say I have a binary that queries the state of a raid controller and outputs a large amount of extraneous information. I really only care about two lines in this case. 1. disc name, and 2. state of disc. What I would like to do is have it be able to send an email if something went wrong with the disc name (which appears at the top of the output, and the state, which appears at the bottom.
18:46 * ket *sigh
18:46  greycat: If you want whole lines, then sure, grep is fine.
18:46  ket: !awk =)
18:46 * greycat reads more of the question...
18:47  greycat: If you only want the *first* and *last* line, regardless of content, then grep is not suited.
18:47  ss0: Really more of the 3 and 39th.
18:47  greycat: !faq n'th
18:47  greybot: http://mywiki.wooledge.org/BashFAQ/011 -- How can I print the n'th line of a file?
18:48  greycat: sed -n -e 3p -e '39{p;q;}'   or something similar
18:48  ss0: greycat:  I guess my real question is how to I align the data as a row rather than have them appear one on top of the other. Since the values don't change for the name of the row that I'm grepping for I think grep would be the best tool.
18:48  greycat: So you DON'T want whole lines??!  Jesus...
18:48  ss0: Ah, so you think sed would be better?
18:48  greycat: !b2
18:48  greybot: bashphorism 2: The questioner will keep changing the question until it drives the helpers in the channel insane.
18:49  ss0: Yes I want whole lines I just want to apend them, and it just struck me that I could assign them to variables and then echo them in right next to each other. it was a foolish question.
18:49  csabo: what would cause me using a var like this: var="email1 email2" and then mail -s "blah" $var
18:49  csabo: to not work? no errors, just no mail comes in
18:49  geirha: !faq complex > csabo
18:49  greybot: csabo: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
18:49  Mike1_: good Evening!
18:50 --- Mike1_ is now known as Mike1
18:50  ss0: Fear of greycat's wrath really does give brain a kick in the ass :D.
18:50  geirha: ss0: I'd consider awk or bash
18:50 * taylanub edits the last part of FAQ 11 to use  case $n in *[!0-9]*) foo; esac
18:51  Mike1: is there a way to have multiple applications reading on one FIFO?
18:51  csabo: geirha:  thanks but i'm not using single quotes.
18:51  csabo: i know that wouldnt work, its not a command i'm trying to process
18:51  taylanub: (oh, the point is to remove [!0-9]. /me edits nothing)
18:51  geirha: csabo: Never ever put more than one argument into a variable
18:52  csabo: alright
18:52  csabo: seems kinda ghetto
18:52  geirha: csabo: And you can't put syntactical quotes into variables
18:52  csabo: you cant make a list, or store as a string?
18:52  greycat: Using an array instead of a string to hold multiple elements is not "ghetto".
18:52  geirha: emails=("email1" "email2"); mail -s "blah" "${emails[@]}"
18:52  greycat: Using a string to hold mulitple elements is, in fact, the less elegant approach.  And fragile.
18:52  csabo: i have no need to call a specific element
18:53  csabo: but no point swimming upstream :)
18:54  csabo: so @ will use all elements in the array?
18:55  greycat: !faq 5 > csabo
18:55  greybot: csabo: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
18:55  greycat: yes.
18:55  csabo: cool thanks
18:55  csabo: do you have each faq memorized?
18:55  csabo: kind of odd you knew it was number 5
18:55  greycat: You know what the "f" stands for, right?
18:56  csabo: yes
18:56  greycat: No, I don't know all of them by number... just the *really* f ones.
18:56  Mike1: it’s still amazing
18:57  kriscolt: how would i find all folders older than six months, mindepth 1, maxdepth 1
18:57  greycat: !find > kriscolt
18:57  greybot: kriscolt: http://mywiki.wooledge.org/UsingFind
18:57  csabo: !greybot dance
18:58  kriscolt: cool thanks
18:59  geirha: kriscolt: touch a file with mtime six months back in time, then loop through and test.   for dir in */; do [[ $dir -nt touched_file ]] && continue; echo "$dir"; done
18:59  ss0: greycat:  is it possible to interleave the values loaded into two  arrays? as in I want to printf the first value of each array next to each other?
18:59  greycat: Only by looping.
19:01 * alphawave wonders when variables are executed, on the line they are defined or later on in the script when they are called...
19:01  ss0: What i would like to do is run this command only once, get multiple values out of it via whatever method, put them in arrays then use the arrays to feed the printf statement to make a nice looking report. I'm starting to feel awk is the only way to do this sensibly.
19:02  greycat: The "report" generates two columns of data?
19:02  geirha: alphawave: Are you thinking about  var=$(command) ?
19:02  greycat: Err, not "report".  "command".
19:02  greycat: alphawave: variables are not executed.  Commands are.
19:02  alphawave: geirha, along these lines: date=`date "+%A %m-%d-%Y %r %Z"`
19:02  geirha: alphawave: Then yes, command is executed once, and the the var is assigned the output of that command
19:03  ss0: greycat:  Correct,  it generates something like. Status    :Ok In a section headed up by Name :Physical Disk 0:0:2
19:03  geirha: !` > alphawave
19:03  greybot: alphawave: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
19:03  alphawave: geirha, it's excuted at the point of defining as shown above? or when it's called $date later on?
19:03  alphawave: good to note.
19:03  SeanInSeattle: Hey all.  Is there a way that I can dereference a symbolic link, inline?  like this?  "deref mySimLink" outputs "/some/dir"?
19:03  greycat: ss0: and the only parts of this output you want are field #2 from the line where field #1 is "Status" and field #2 from the line where field #1 is "Name"?
19:03  greycat: Or are there other lines where field 1 has that same label?
19:04  ss0: The naming fields are unique.
19:04  greycat: !faq target > SeanInSeattle
19:04  greybot: SeanInSeattle: http://mywiki.wooledge.org/BashFAQ/029 -- How can I display the target of a symbolic link?
19:04  ss0: Honestly I would like all four fields in series,     Name : physical disk balh   Status :ok  (like so)
19:05  greycat: ss0: while read label payload; do case $label in Status) status=$payload;; Name) name=$payload;; esac; done < file; printf "%s %s\n" "$name" "$status"
19:05  geirha: alphawave: date will be executed once, when it reaches that date=`date...` line. So "$date" will expand to the same string for the remainder of the script (unless you reassign it of course).
19:05  SeanInSeattle: ah, cool.  Thanks guys.
19:05  ss0: greycat:  Cool!
19:05  alphawave: geirha, thank you so much for clarification. that's what I thought, but wasn't 100% sure. cheers.
19:15  ss0: !while
19:15  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
19:15  geirha: ss0: ''help while read''
19:17  ss0: geirha:  That just a google search string?
19:17  geirha: s0enke: It's a command to type in a bash shell
19:17  geirha: ss0: ^
19:17  geirha: Shows you info about the while keyword and the read builtin.
19:18  ss0: geirha:  Ah wasn't aware of help.
19:18  ss0: geirha:  :D learned two things in one day. new record. hah
19:18  nicofs: how do i check, if a variable is a number or a string? "if ( $var is string ) then ..."
19:19  geirha: ''type foo''. If foo says it's a builtin or keyword, run ''help foo'' or ''man bash'', if it's an external command, try ''man foo''.
19:19  geirha: *If type says foo is a builtin
19:19  geirha: !faq valid > nicofs
19:19  greybot: nicofs: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
19:20  Mike1: when do processes die if I start them in the background using & in a script? When the script is terminated?
19:21  Hydrant: hey all... I'm trying to figure out how to write a utility script, but I'm not sure how to proceed.. is this on topic for this channel?  Not sure if there is a sysadmin channel
19:23  ss0: If the utility script is written in bash then yes It would be on topic, don't ask if you can ask just ask :D.
19:23  geirha: Hydrant: I don't know what you mean by utility script, but the BashGuide in /topic is probably a good start.
19:24  Hydrant: each channel has a different attitude to random questions ;-)
19:25  Hydrant: what I want to do is sync data from a ram disk to the hard drive
19:25  Hydrant: I can't just do cp * because the last file being output might not be doen
19:26  geirha: Hydrant: And how will you know when it's done?
19:26  Hydrant: and I'll need to do it every so often... I was thinking to do a cron-script to do something like cp `ls | sort -n | head` /mnt
19:26  f00bar80: how to use bash to find pattern or  entries like this http://pastebin.com/BVzMFWNk in error_log and send me an email if any found ?
19:26  Hydrant: that kinda idea... but make sure I always leave the last file (which is numbered sequentially) out of the copy
19:26  Hydrant: geirha: that's the thing, I don't really know when things will be done
19:27  Hydrant: well, I can watch particular processes, but I don't want a complex script
19:27  geirha: Hydrant: Are they numbered with leading zeros so they sort lexicographically?
19:27  Hydrant: if there was some way to run a script when a file is written to RAM that would be awesome, but I don't think such a thing exist
19:27  Mike1: Hydrant: written to RAM? To HDD you mean I think
19:27  Hydrant: geirha: no leading zeros unfortunately... I could do something like that... but there is a numeric sort that might work
19:27  Mike1: ah
19:28  Mike1: ramdisk
19:28  Hydrant: data is written to a ram disk, and I have to sync to the main disk very quickly
19:28  Hydrant: basically  I have a high-throughput device that really needs to get data to RAM, and then schedule to get the data off to the hard drive separately
19:28  geirha: Hydrant: There are probably filesystems that can do that for you
19:29  Hydrant: this execution will need to run for about 3 days, and it's fairly mission-critical during that time... so I'm thinking that a cron script will be more reliable than a bash script
19:29  seanjohn: is LEN a function of bash?
19:29  galaxywatcher: How do I show the full path for a filename? I know pwd shows the path of the current directory..I want to print the full path of a file, including the filename.
19:30  geirha: Hydrant: rsync -a ./ /dest/dir
19:30  Hydrant: oh, rsync might be a good idea
19:30  seanjohn: ok, I found ${#VAR }
19:30  Mike1: indeed
19:30  geirha: Hydrant: There's #rsync for more help with that
19:31  Hydrant: yah thanks, I never thought of it
19:31  f00bar80: geirha, can i use rsync instead of scp ?
19:32  geirha: f00bar80: Yes.
19:32  f00bar80: geirha, any difference ?
19:32  seanjohn: is this ok?       if [ "$VALID" = "1" ] && [ "${#3}" != "64"  ]  ; then           Im only trying to execute the "if" only if argument 3 is NOT md5.
19:32  geirha: f00bar80: Yes. Ask #rsync about that.
19:33  seanjohn: md5 is 64 characters, right and the other arguments would only be 2 characters, if the "if" is to be executed.
19:33  f00bar80: geirha, how to use bash to find pattern or entries like this http://pastebin.com/BVzMFWNk in error_log and send me an email if any found ?
19:33  geirha: seanjohn: Yes, but if this is bash, use (( .. )) instead
19:34  seanjohn: if ([ "$VALID" = "1" ] && [ "${#3}" != "64"  ])  ; then
19:34  seanjohn: ?
19:34  geirha: seanjohn: if (( valid == 1 && ${#3} != 64 )); then
19:34  geirha: !tests
19:34  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
19:34  geirha: !varcap
19:34  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
19:34  seanjohn: why two parentheses?
19:35  seanjohn: nothing is encapsulated between
19:35  geirha: seanjohn: Because single parenthesis is used for subshell
19:35  seanjohn: ok, but is my comarison correct, in logic? md5 is only 64 characters?
19:36  geirha: seanjohn: 32 I think. Easy to check though, isn't it?
19:36  seanjohn: If I was to do "${#3}" = "2"  to argue the reverse, it would be more inclusive than exclusive.
19:37  jsz`: seanjohn, it's 32
19:37  seanjohn: thank you both
19:37  alphawave: I have three variables that run commands in a bash script. I wanted to run all thee simultaneously, so I added & inside of each var's command, and a wait after all three var's. But they still run one at a time. What would you all recommend I do differently?
19:37  alphawave: thee = three*
19:37  greycat: !faq complex > alphawave
19:37  greybot: alphawave: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
19:38  geirha: f00bar80: if var=$(grep 'pattern' file); then mail -s "blah" ... <<< "$var"; fi
19:39  f00bar80: geirha, how to use this to run with tail -f error_log ?
19:39  greycat: f00bar80: tail -f never ends.
19:39  f00bar80: greycat, yea
19:39  greycat: f00bar80: do you want to trigger an email every time a matching line appears in the file?
19:39  f00bar80: greycat, yea
19:40  alphawave: greycat, nothing is failing, the script works. the simultaneous execution of the commands in three vars is still executed sequentially.
19:40  greycat: tail -f file | while read -r; do if [[ $REPLY = *bad* ]]; then ...; fi; done
19:41  f00bar80: greycat, REPLY => ?
19:42  greycat: help read
19:43  Mike1: how ugly is ncat for local IPC?
19:54  ss0: greycat:  I have tried using the case statement you showed me, and surprise surprise It's not sinking in. I know I must be doing something wrong but I'm not sure what I'm doing wrong besides being a hopeless nob. I tried command | while blah and also outputting the data to a file named dell.txt and importing it in place of file, in what you showed me. http://pastebin.centos.org/36526 has the script and data if you want to glance at it.
19:55  ss0: bash -x when i tried to execute that only showed me,  bash -x /usr/bin/raidmonitor
19:55  ss0: + read label payload
19:56  csabo: :-\
--- Log closed Thu Dec 09 20:00:34 2010
--- Log opened Thu Dec 09 20:15:58 2010
20:15 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
20:16  csabo: :-\
20:16  csabo: editing in notepad++
20:16  geirha: csabo: /etc/crontab? It has a slightly different format.
20:16  csabo: no no
20:16  csabo: mines in /var/spool/cron/crontabs
20:16  csabo: i'm using AIX..
20:16  halo: greycat, your command works fine, but if i want to exclude .MP3 and .txt also how can i do? how do you add OR? find . ! -name '*.mp3' || '*.MP3' is right?
20:16  greycat: csabo: YOU *MUST* USE "crontab -e"
20:17  greycat: csabo: Do NOT search out the internal files and edit them directly on disk.
20:17 --- Channel #bash was synced in 85 seconds
20:17  greycat: halo: -iname might be helpful.
20:17  halo: never used it too, i'll google. Thanks
20:18  geirha: !find > halo
20:18  greybot: halo: http://mywiki.wooledge.org/UsingFind
20:18  geirha: halo: There, all googled up for you ^
20:18  greycat: Or he could type "man find".
20:18  halo: ehehe thank you again :)
20:19  geirha: Hm. UsingFind actually doesn't cover -iname
20:19  geirha: So yeah, ''man find''
20:19  csabo: god i hate VI
20:19  csabo: its retarded
20:19  greycat: export EDITOR=whatever
20:19  geirha: EDITOR=notepad++ crontab -e
20:20  csabo: ?
20:20  csabo: notepad++ is a win32 application
20:20  greycat: *plonk*
20:20  csabo: i'm pretty sure that wont work
20:20  geirha: Oh, probably why I've never heard of it
20:20  csabo: very good editor, doesnt introduce random chars into files
20:20  csabo: syntax highlighting..ect
20:21  greycat: I won't even ask how he was able to use a Windows program to edit his crontabs on AIX.  (I wouldn't see the answer even if I did....)
20:21  geirha: See if there's nano or pico or something on that system then. Might be easier for you.
20:21  csabo: is that his antisocial nerd rage way of saying he put me on ignore?
20:21  csabo: what is he 10?
20:21  geirha: !plonk
20:21  greybot: The sound a name makes when it hits a kill file (or /ignore list).
20:22  halo: ok, read find manpage and now i know iname is for case insensitive, but if i want to exclude other extension too? like .rar or .txt
20:22  greycat: halo: read the UsingFind page, then
20:22  csabo: so he is 10 years old
20:22  csabo: pretty cool, bet he enjoys living alone
20:22  csabo: geirha:  and yes, another editor would be nice
20:23  taylanub: use ed
20:23  csabo: i use winscp and grab files and manipulate
20:23  csabo: is ed as terrible as vi?
20:23  gniourf_gniourf: it's worse
20:23  zambaboo: when i run a command from inside of a script is there a special variable that holds that programs' pid?
20:23  csabo: then why the hell would you recommend it
20:23  greycat: !pm > zambaboo
20:23  greybot: zambaboo: http://mywiki.wooledge.org/ProcessManagement
20:23  csabo: vi is retarded enough
20:23  geirha: csabo: Another option is;  crontab -l > file; edit file; crontab file
20:24  greycat: geirha: good old HP-UX 9.x.
20:24  csabo: geirha:  i already modifed it in vi, and it works
20:24  gniourf_gniourf: eg, to do some automatic editions from a script
20:24  gniourf_gniourf: and btw vim is cool
20:24  zambaboo: thanks greycat
20:24  taylanub: hating what you don't understand...
20:26  csabo: the fact that depending on the moons position and how fat my ass is, the delete key changes
20:26  csabo: and you praising somthing because it took you 2 hours of staring at man pages to figure out doesnt make it good
20:27  csabo: so far DEL, backspace, X have all been delete keys, but in random situations
20:27  csabo: re-assigning a LABLED keys value is a moronic move
20:28  geirha: greycat: Hm. I'm missing the context on that one.
20:28  greycat: HP-UX 9.x did not have "crontab -e".  You had to use crontab -l > foo; vi foo; crontab foo; rm foo
20:28  elkng: I have a function "myfunc() { return 111 }" and after I've called it with "num=myfunc" I have an empty "num" without "111" value, why?
20:29  greycat: elkng: you are confusing the exit status of a function with the stdout of the function
20:29  greycat: You are also very confused about how command substitution works.
20:29  elkng: greycat: how is right?
20:29  greycat: If you wanted to capture the output it should be num=$(myfunc)
20:29  greycat: If you wanted the function to actually PRODUCE said output, it should be echo 111 not return 111.
20:29  gniourf_gniourf: num is probably not empty
20:30  elkng: I wanna capture return value
20:30  geirha: greycat: Ah, lovely. At least it had vi though.
20:30  gniourf_gniourf: # num=myfunct; echo $num
20:30  evalbot: gniourf_gniourf: myfunct
20:30  greycat: elkng: The exit status?  myfunc; num=$?
20:30  gniourf_gniourf: see, it's not empty
20:30  elkng: how can I capture return value
20:30  taylanub: !$?
20:30  greybot: The special parameter ? (you use $? to expand it) contains the exit status of the previous command, an integer from 0 to 255 inclusive. In general, an exit status of 0 implies success (or "true") and non-zero implies failure ("false").
20:30  elkng: not stdout
20:30  greycat: elkng: I just told you.
20:31  elkng: greycat: thanks, I understand now =)
20:31  geirha: csabo: Once you learn what the keys do, it makes sense.
--- Log closed Thu Dec 09 20:41:09 2010
--- Log opened Thu Dec 09 20:46:35 2010
20:46 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
20:46  geirha: # date +"GNU date: %s.%N"
20:46  evalbot: geirha: GNU date: 1291924001.104146523
20:47  greycat: Hah, must be a very new GNUism, too.
20:47  greycat: imadev:~$ gdate +%s%N
20:47  greycat: 1291924033%N
20:47  greycat: date (GNU sh-utils) 2.0.11
20:47 --- Channel #bash was synced in 83 seconds
20:50  trash: Even Debian stable has it. ;-)
20:50  greycat: -rwxr-xr-x   1 netbin     other        77849 May 23  2003 /net/appl/tool/bin/gdate
20:50  greycat: I built it 7 years ago.
20:59  sikker: what's the prefered channel for file permission based questions?
20:59  greycat: !permissions
20:59  greybot: http://mywiki.wooledge.org/Permissions
20:59  greycat: If your question isn't answered there, just ask it and we'll redirect you if it's not standard unix.
21:02  sikker: greycat, it looks like it's loosely covered there, but I'm not seeing the solution per se. Pardon me for asking: I'm attempting to "setgid" I believe the article says it's called, of a folder. My google search tells me it's chmod g+s, but it doesn't appear to work
21:03  sikker: as in, the command completes, but new files within the folder does indeed not inherit the parent group
21:03  greycat: ls -ld /thedir
21:03  greycat: touch /thedir/afile; ls -ld /thedir/afile
21:04  sikker: -rw-rw-r-- 1 www-data www-data 0 Dec  9 20:04 folder/afile
21:04  greycat: meaningless without the first part.
21:04  sikker: the folder should have been www-data:yotn
21:05  sikker: this is all it gives me.
21:05  greycat: 15:03  greycat> ls -ld /thedir
21:05  sikker: oh
21:05  sikker: drwxrwxr-x 3 www-data yotn 4096 Dec  9 19:56 folder/
21:05  greycat: Indeed there is no setgid bit set on that.
21:06  greycat: You're sure this is a unix file system?
21:06  sikker: greycat, this is a xen-virtualized Debian environment on ext3
21:06  sikker: I did: chmod g+s folder/
21:06  greycat: After redoing "chmod g+s" the ls -ld output is still the same?
21:08  sikker: greycat, appears to be. it's the "3" after the permission-chunk we're looking at, if I'm not mistaken?
21:08  greycat: You're very mistaken.
21:09  greycat: You should see drwxrwsr-x
21:09  sikker: ah, the "s" should be there? it's not
21:09  greycat: Any unusual mount options on the file system?
21:12  sikker: greycat, this is what I have in fstab: http://pastie.org/1363143
21:12  greycat: !nopaste
21:12  alek{xmb}{bottz}: you
21:12  greybot: Please don't waste our time by making us go to a pastebin just for a five-line snippet. Paste it in the channel. If you have a larger script that's showing problems, trim it down to the bare minimum size that still shows the problem. You'll probably fix it yourself once you do that.
21:12  alek{xmb}{bottz}: hai grey
21:12  greycat: Should be one line.
21:12  greycat: hello
21:13  alek{xmb}{bottz}: i have a new dok, a lang ima koud in paik [ pike]
21:13  alek{xmb}{bottz}: wanna taik a luuk ?
21:13  sikker: greycat, I apologize, most other places freak the shit out if the paste has any more than one line.
21:13  rafuch0: loool is just 3 lines literal
21:13  greycat: Shouldn't be more than one line anyway.
21:14  greycat: We don't care about *other* file systems.
21:14  rafuch0: the rules of  floood is more then 5 lines right
21:14  rafuch0: ?
21:14  sikker: are you going to rant about this forever? O.o
21:14  alek{xmb}{bottz}: ter schal not bi any mor of negatiw rulc
21:17  Mike1: alek{xmb}{bottz} has a very funny way of writing :D
21:17  alek{xmb}{bottz}: merci
21:17  Mike1: are you reading lolcatz all day?
21:17  alek{xmb}{bottz}: maik ima koud a new language
21:17  alek{xmb}{bottz}: nawh
21:17  alek{xmb}{bottz}: ima inwented that
21:17  alek{xmb}{bottz}: easily
21:17  alek{xmb}{bottz}: just taip ac ya wrait
21:18  alek{xmb}{bottz}: er yescz and wrait ac ya spik
21:18  Mike1: I don’t want to imagine how you speak english :D
21:18  alek{xmb}{bottz}: dat new lang wil do greatn..., since its lang, not alphanum schit
21:18  alek{xmb}{bottz}: normal way yo
21:18  alek{xmb}{bottz}: strit slang i spik
21:19  taylanub: that should be "stiit" and "spiik" IMO
21:19  taylanub: s/stiit/striit/
21:19  alek{xmb}{bottz}: i start writing as written :
21:19  alek{xmb}{bottz}: as non spoken :
21:19  alek{xmb}{bottz}: faster to wrait
21:19  alek{xmb}{bottz}: i typed today my second dok about the language ima do soon in pike
21:20  alek{xmb}{bottz}: in which i found out err, no dup chars yo
21:20  alek{xmb}{bottz}: its fatal useschittznatz
21:20  Mike1: I only understand every second or third word :D
21:20  alek{xmb}{bottz}: how dat
21:20  alek{xmb}{bottz}: djust read how its typed chars by chart
21:20  alek{xmb}{bottz}: -t
21:21  alek{xmb}{bottz}: check this
21:21  alek{xmb}{bottz}: http://xmb.root.pe/def.koud.sch
21:21  alek{xmb}{bottz}: da lang may bi naimed " sch"
21:22  alek{xmb}{bottz}: the seknd dok isnt online and on tis komp
21:23  alek{xmb}{bottz}: there is ownajgdiy koud dat wil bi walid :
21:23  Mike1: what does koud mean?
21:23  alek{xmb}{bottz}: ! iv kouk ic alle du get mor of it.. from laik the onlain stor
21:24  alek{xmb}{bottz}: code
21:24  greycat: "code"
21:24  alek{xmb}{bottz}: koud
21:24  alek{xmb}{bottz}: merci grey
21:24  alek{xmb}{bottz}: :))
21:25  jsz`: how to launch a script from a directory?
21:25  alek{xmb}{bottz}: ./script
21:25  greycat: use 'cd'.
21:25  jsz`: ./path/to/script ?
21:25  alek{xmb}{bottz}: or bash [ -xv] [ ./]script
21:27  alek{xmb}{bottz}: to spawn it without bash u need to chmod +x it
21:36  taylanub: is there a common environment variable for the url-retrieving tool of choice? like wget or curl
21:36  greycat: no
--- Log closed Thu Dec 09 21:41:05 2010
--- Log opened Thu Dec 09 21:46:28 2010
21:46 --- Users 564 nicks [0 ops, 0 halfops, 0 voices, 564 normal]
21:46  alek{xmb}{bottz}: add traps
21:46  alek{xmb}{bottz}: that way
21:46  alek{xmb}{bottz}: or i or u can dig up koud in my xf koud, has get_traps or something
21:47  alek{xmb}{bottz}: trap " koud $(get_traps) koud" DEBUG
21:47  poisonbit: get_traps maybe like trap -p  ? :)
21:47 --- Channel #bash was synced in 78 seconds
21:47  alek{xmb}{bottz}: yecsz
21:50  csabo: geirha: you here mate
21:50  alek{xmb}{bottz}: $( get_traps DEBUG)
21:50  alek{xmb}{bottz}: tho
21:50  csabo: !faq 5
21:50  greybot: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
21:51  alek{xmb}{bottz}: fag
21:53  patrickw: alek{xmb}{bottz}: Well, yeah, I figured that.  But without the parsing function in hand, its easier to use the array of function names method.
21:54  poisonbit: # ( runall(){ for fun in "${funks[@]}"; do "$fun"; done; }; trap 'runall' EXIT ; exit_1(){ echo one; }; exit_2(){ echo two; }; funks+=( 'exit_1' ); funks+=( 'exit_2' ); )
21:54  evalbot: poisonbit: one
21:54  evalbot: poisonbit: two
21:54 --- gwz2 is now known as gwz
21:56  alek{xmb}{bottz}:  lab
--- Log closed Thu Dec 09 22:00:15 2010
--- Log opened Thu Dec 09 22:05:36 2010
22:05 --- Users 561 nicks [0 ops, 0 halfops, 0 voices, 561 normal]
22:06  gniourf_gniourf: isn't this supposed to be a channel where we speak english ?
22:06  greycat: Yes.
22:06 --- Channel #bash was synced in 82 seconds
22:07  alek{xmb}{bottz}: ticsz?pjur_inglisch
22:09  zambaboo: if i redirect output it doesnt look like $! is set
22:09  greycat: Why does it look that way to you?
22:09  zambaboo: because its empty :/
22:10  greycat: Then you haven't run any background jobs.
22:11  alek{xmb}{bottz}: lollz
22:11  zambaboo: well.. im executing this: java >> logs/log.txt 2>&1 & PID=$!; echo $PID > $PID_FILE
22:12  greycat: Should work.
22:12  zambaboo: i figured.
22:12  greycat: You're sure PID_FILE is set and does not contain any whitespace?
22:12  alek{xmb}{bottz}: try echo $! straight
22:12  zambaboo: sec
22:13  alek{xmb}{bottz}: # echo 1& echo $!
22:13  evalbot: alek{xmb}{bottz}: 1
22:13  evalbot: alek{xmb}{bottz}: [1] 230
22:13  evalbot: alek{xmb}{bottz}: etc... ( http://pastebin.com/NbEEHU0P )
22:14  zambaboo: nope. i set -x and the output shows nothing for $!
22:14  alek{xmb}{bottz}: duud u echo it
22:15  alek{xmb}{bottz}: see the koud i did
22:15  alek{xmb}{bottz}: to evalbot
22:15  alek{xmb}{bottz}: it workerd
22:15  zambaboo: yes yes
22:15  alek{xmb}{bottz}: k
22:15  zambaboo: doesnt for me though.
22:16 * zambaboo debugs
22:16  alek{xmb}{bottz}: k
22:16  alek{xmb}{bottz}: maybe u have set +b or something
22:16  greycat: It works for everyone else but you, so you're clearly doing *something* wrong.
22:16  alek{xmb}{bottz}: the * should be around the __ you
22:16  zambaboo: i understand that. you're certain its not the redirection though?
22:17  alek{xmb}{bottz}: oh
22:17  greycat: yes
22:17  greycat: # echo hi >>/dev/null 2>&1 & echo $!
22:17  evalbot: greycat: [1] 230
22:17  evalbot: greycat: 230
22:17  evalbot: greycat: [1]+  Done                    echo hi >> /dev/null 2>&1
22:17  alek{xmb}{bottz}: # >1 echo 1& echo $! + $( < 1)
22:17  evalbot: alek{xmb}{bottz}: [1] 230
22:17  evalbot: alek{xmb}{bottz}: 230 + 1
22:17  evalbot: alek{xmb}{bottz}: [1]+  Done                    echo 1 > 1
22:18  greycat: alek{xmb}{bottz}: you have a race condition on reading the contents of "1"
22:18  zambaboo: i see. thank you for that example.
22:18  alek{xmb}{bottz}: i give a schit friend :)
22:18  alek{xmb}{bottz}: t, f
22:19  alek{xmb}{bottz}: the race is to around 100 izi
22:19  alek{xmb}{bottz}: sinc prozecorc math in order
22:19  alek{xmb}{bottz}: and the subshell + cat is way heavier
22:19  csabo: i have a ksh snippet here to parse a txt file into arrays
22:20  csabo: its using set -A .. will this work in bash?
22:20  alek{xmb}{bottz}: yecsz
22:20  patrickw: lols, a race is a race...
22:20  csabo: sweet
22:20  alek{xmb}{bottz}: its declare -A
22:20  alek{xmb}{bottz}: maybe both works
22:20  alek{xmb}{bottz}: oh well
22:22  alek{xmb}{bottz}: well yo my arg is mightier than the other... so its the order logik[ mixed in the nimddle between prozi and coft and next] > prozi > soft > cukaji term at soft lewel
22:24  zambaboo: man.. sucky.
22:24  greycat: !exact
22:24  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
22:25  alek{xmb}{bottz}: plz paict dat
22:25  csabo: lol
22:28  csabo: alek
22:29  csabo: i've got two columns in a text file, i need to turn each into their own array, reading left to right would work fine, assiging every other to the arrays.. however i need to account for the blank spaces between them
22:29  csabo: and, variable length on the columns
22:29  alek{xmb}{bottz}: and i need to know what your result shall look like
22:30  alek{xmb}{bottz}: data output wise
22:30  csabo: sure
22:30  csabo: sec
22:30  alek{xmb}{bottz}: k =)
22:30  csabo: lets see how this goes in here
22:30  csabo: 000056L4               TAPEPOOL
22:30  csabo: W00014L4               TAPEPOOL
22:30  csabo: W00016L4               TAPEPOOL
22:30  csabo: i've stripped everything else out with sed already, it literally is two columns of needed data
22:31  alek{xmb}{bottz}: thats the base or the desired output
22:31  zambaboo: csabo, tr can get rid of your blank lines
22:31  csabo: alek, thats the base
22:32  csabo: thats what i've got right now
22:32  csabo: i was thinking maybe use sed to remove all but one space between each
22:32  alek{xmb}{bottz}: k what do u need now excepts the array sentence
22:32  alek{xmb}{bottz}: laik
22:32  alek{xmb}{bottz}: what u wanna do with em
22:33  csabo: i need to run a command against each row
22:33  csabo: so "command $(array1[1]) $(array2[2])
22:33  csabo: if that makes sense
22:33  alek{xmb}{bottz}: k no need for arrazcsz yo
22:33  alek{xmb}{bottz}: just
22:33  alek{xmb}{bottz}: while read a b ;do kmd $a $b ;done <fail
22:34  csabo: so the spaces wont effect me at all in this case?
22:34  alek{xmb}{bottz}: it reads a b
22:34  alek{xmb}{bottz}: per $IFS which is by default space tab or newline
22:34  zambaboo: csab
22:34  csabo: hi zambaboo
22:35  zambaboo: asdf
22:35  csabo: sup?
22:35  zambaboo: oops sorry about that
22:35  alek{xmb}{bottz}: zaio
22:35  alek{xmb}{bottz}: lablablab
22:35  csabo: alek does any of that stuff you say mean anything?
22:36  alek{xmb}{bottz}: of kourcsz, means greatnec
22:36  csabo: uh
22:36  csabo:  alright
22:36  alek{xmb}{bottz}: =)
22:36  alek{xmb}{bottz}: heh
22:36  csabo: ")
22:36  csabo: :) *
22:37  alek{xmb}{bottz}: i go sleep in the next mins
22:37  alek{xmb}{bottz}: go tschek yer koud
22:37  csabo: wait
22:38  csabo: while read a b; do cmd $a $b will work?
22:38  csabo: i dont have to do anything else with this
22:38  alek{xmb}{bottz}: yec, with a <file
22:38  alek{xmb}{bottz}: ya
22:38  csabo: the random length of each element and the spaces
22:38  csabo: none of that matter?
22:38  alek{xmb}{bottz}: ya
22:38  csabo: wtf
22:38  csabo: how
22:38  alek{xmb}{bottz}: heh
22:38  alek{xmb}{bottz}: easily
22:38  patrickw: csabo:  while read line; do a1+=( $(sed 's/[[:space:]]*[^[:space:]]*$//' <<< "$line") ) a2+=( $(sed 's/^[^[:space:]]*[[:space:]]*//' <<< "$line" ) ); done < FILE
22:38  alek{xmb}{bottz}: what language schall i try to explain it in
22:39  alek{xmb}{bottz}: newb
22:39  zambaboo: preferably legible English
22:39  alek{xmb}{bottz}: =p
22:39  csabo: +1 zambaboo
22:39  zambaboo: patrickw, i think tr might do a better job there.
22:39  alek{xmb}{bottz}: sl
22:39  alek{xmb}{bottz}: lso yeah
22:39  alek{xmb}{bottz}: do u know awk
22:39  alek{xmb}{bottz}: the a is
22:39  alek{xmb}{bottz}: by better koud
22:39  alek{xmb}{bottz}: this static length was fore yesterday
22:39  alek{xmb}{bottz}: nowadays its by separators
22:40  alek{xmb}{bottz}: just like space
22:40  csabo: jesus christ
22:40  alek{xmb}{bottz}: so u write " ab cde lablabg"
22:40  csabo: can anyone translate
22:40  alek{xmb}{bottz}: hum
22:40  csabo: i know hes trying to help, but yeah
22:40  alek{xmb}{bottz}: meit
22:40  alek{xmb}{bottz}: get my archive
22:40  alek{xmb}{bottz}: http://xmb.root.pe/xmb-code-tree-transition.tgz
22:40  alek{xmb}{bottz}: and learn mor
22:40  alek{xmb}{bottz}: i go to sleep
22:40  alek{xmb}{bottz}: nightsy :)
22:40  zambaboo: a certain Jules comes to ming
22:40  zambaboo: mind*
22:41  patrickw: zambaboo: how do you mean?
22:41  alek{xmb}{bottz}: flaesch gsex
22:42  csabo: patrickw:  hey mate
22:42  patrickw: csabo: yep
22:42  csabo: the line you provided me, what exactly does that do, i do recognize your sed command dealing with spaces, and reading lines
22:42  csabo: but i dont really understand it as a whole
22:42  zambaboo: this guy: http://www.qstudy.ru/pict/pulp-fiction.jpg
22:43  zambaboo: patrickw, that sed bit gets rid of the spaces, yes?
22:43  patrickw: the basic thing is:  while read line; do something; done < FILE
22:43  csabo: looks like it
22:43  alek{xmb}{bottz}: from thouscz im the one at the door
22:43  zambaboo: why not use tr for that
22:43  alek{xmb}{bottz}: laterzcs
22:43  zambaboo: byebye
22:44  csabo:  patrickw: so i dont even need to run a command to turn it into arrays?
22:44  csabo: patrickw:  i can just use what you provided?
22:44  patrickw: the something is the sed stuff that gets rid of the spaces and the column you DON'T want, and appends the rest (ie: the part you DO want) to an array
22:45  patrickw: csabo:  what I pasted will read a two column file, delimited by spaces/tabs/etc, into the arrays a1 and a2, by column
22:45  patrickw: which is what you wanted to do, righ?
22:45  csabo: yeah :) heres what i had
22:45  csabo: set -A first; set -A second; i=0; while read a b; do first[i]=$a; second[i++]=$b; done
22:46  Riviera: 4# set -A first
22:46  shbot: Riviera: bash4: set: -A: invalid option
22:46  shbot: Riviera: set: usage: set [--abefhkmnptuvxBCHP] [-o option-name] [arg ...]
22:46  csabo: Cool
22:47  csabo: patrickw:  so at this point, would i be able to just run the command and reference the elments i need?
22:48  csabo: assuming i used your lovely example
22:48  patrickw: csabo: yep
22:49  csabo: not to sound even more retarded, but if this were done in a loop, theres no need for me to count the elements beforehand is there?
22:49  csabo: i'm no programmer, i'm familar with some of the basics, but thats about it
22:50  patrickw: you wouldn't need to anyway, bash arrays don't have a pre-determined size
22:50  patrickw: what you have is close, but not quite right
22:50  csabo: what do you mean by what i have? you mean the example you gave me? because i'm using that
22:51  patrickw: you could actually simplify what I wrote using "read a b" instead of the sed stuff, now that I think of it
22:51  csabo: thus far all i've done is run the original data through sed 3 times to get rid of crap i dont need"
22:52  patrickw: unset array1, array2; while read col1 col2; do array1+=( "$col1" ) array2+=( "$col2" ); done < FILE
22:52  csabo: what is that?
22:52  patrickw: err, get rid of the comma
22:52  patrickw: one sec
22:53  csabo: man im so buying a book tommorow, anyone have any recommendations
22:54  patrickw: csabo: unset array1 array2; while read col1 col2; do array1+=( "$col1" ) array2+=( "$col2" ); done < FILE
22:55  patrickw: replace FILE with the name of the actual file
22:55  csabo: patrickw:  thank you mate, what does that do?
22:55  csabo: looks like it replaces the first line you gave me
22:55  patrickw: well, yeah, without the unnecessary sed stuff, heh
22:55  csabo: gotcha
22:56  csabo: as far as actually looping through the arrays, and running cmds.. can you point me in the right direction?
22:56  csabo: im looking at all kinds of array stuff i found on google
22:56  patrickw: it's basically what you wrote, but without using the "i" variable.  it uses the "array+=( element )" syntax to append to the arrays
22:56  csabo: its not really what im looking for
23:02  patrickw: csabo:  i=0; while [ "$i" -lt "${#array1[@]}" ]; do COMMANDS; ((i++)); done
23:03  zambaboo: i dont understand what i am doing wrong here. here's the relevant bit: APP_START_CMD="cd ${APP_HOME}/bin && java ${JAVA_OPTS} -classpath ${CLASSPATH} com.etouchpoint.batch.BatchServer \
23:03  zambaboo: >> ${APP_HOME}/logs/batch.out 2>&1 & BATCH_PID=$!; echo $BATCH_PID > $BATCH_PID_FILE"
23:03  zambaboo: $BATCH_PID should be populated, correct?
23:04  Riviera: !varcaps
23:04  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
23:05  zambaboo: Riviera, thanks for the style pointer
23:06  patrickw: maybe your cd command fails.  :)
23:07  zambaboo: id consider that, but the path to the pid file is constructed using the $APP_HOME guy, and that file gets created. its just empty.
23:08  patrickw: although...  won't the & have precedence over the &&?
23:08  zambaboo: im not sure
23:09  patrickw: # false && echo "Background" &
23:09  evalbot: patrickw: [1] 230
23:10  evalbot: patrickw: [1]+  Exit 1                  false && echo "Background"
23:10  zambaboo: what does this mean?
23:11  patrickw: It means that you're getting the wrong pid
23:11  zambaboo: it means that & precedes && ?
23:12  Spark: hi, what's a good way to convert utf8 to xml ampersand form in bash?
23:14  TheBonsai: Spark: bash can't do it, maybe recode(1) can
23:15  Spark: hmm it seems that there are only 5
23:15  Spark: but i thought it was possible to put in arbitrary unicode text with it
23:15  patrickw: zambaboo: actually you'd be getting the pid of a bash process that would run cd ... && java ...
--- Log closed Thu Dec 09 23:18:41 2010
--- Log opened Thu Dec 09 23:19:06 2010
23:19 --- Users 554 nicks [0 ops, 0 halfops, 0 voices, 554 normal]
23:19  patrickw: grey probably has an faq for that explanation...  :)
23:20 --- Channel #bash was synced in 85 seconds
23:20  patrickw: ! 50
23:20  zambaboo: i have no problem admitting i wrote something crappy, i'd just like to know why so i cant write it better :) if you lose, dont lose the lesson. ya know? :)
23:20  patrickw: !50
23:21  patrickw: !faq 50
23:21  greybot: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
23:23  CaT[t3]: put command args in arrays :)
23:27  zambaboo: patrickw, thank you for the URL.
23:28  zambaboo: does bash expand an array in to space separated strings?
23:28  yitz_: I think it uses the first char of IFS to expand?
23:28  yitz_: # list=(a b c); IFS=: ; echo "${list[@]}"
23:28  evalbot: yitz_: a b c
23:28  yitz_: Darn :( Or space
23:29 --- Martinp24 is now known as Martinp23
23:33  hevymetal87_: I am writing my first shell script (sh) someone on the ubuntu channel recommended this route, and asked me to run my research by you guys. the first reply at this link http://www.linuxquestions.org/questions/linux-general-1/bash-script-for-sorting-and-renaming-multiple-mp3-files-by-id3-tags-602105/ renames mp3 files based on their ID3 tags, I am wondering if it will do it recursively, and how I should configure it to create directori
23:34  hevymetal87_: not sure if it matters, I am using ubuntu 10.04 server, CLI only, I have 500GB of files mounted that need rearranged...
23:37  Bushmills: first reply hasn't much to do with bash, as it invokes grep and awk mostly
23:38  yitz_: The grep part is dumb. I'd do it largely in awk
23:38  Bushmills: right
23:38  yitz_: You can use **
--- Log closed Thu Dec 09 23:42:11 2010
--- Log opened Thu Dec 09 23:47:34 2010
23:47 --- Users 548 nicks [0 ops, 0 halfops, 0 voices, 548 normal]
23:48 --- Channel #bash was synced in 84 seconds
23:52  Bushmills: hevymetal87_: i think i'd start by reading/learning about variables, assigning data to data,  quoting of arguments (difference between ' and " and discouraged `), flow control constructs, difference between [[ and (( and discouraged [, then functions and arrays, argument lists between ( ), and only then, having covered that bit of ground work, start to apply it in a real sort of project.
23:53  Bushmills: data to variables ...
23:53  Bushmills: oh, and parameter expansion, too
23:53  Bushmills: !pe
23:53  poisonbit: like in "keeper of the seven keys"
23:53  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
23:55  hevymetal87_: thanks
23:56  flaccid: !quotes
23:56  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
23:59  Bushmills: actually, when i set out to improve my bash skills, i coded a virtual machine incremental compiler and interactive interpreter as exercise project.
--- Log closed Fri Dec 10 00:00:09 2010
