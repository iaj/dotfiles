--- Log opened Sun Jan 09 17:48:12 2011
17:48 --- Users 556 nicks [0 ops, 0 halfops, 0 voices, 556 normal]
17:48 --- Server: [niven.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
17:48  juniorbash: someone else
17:48  steve___: juniorbash: ask in #awk and be patient
17:48  sikilpaake: pgas: ${line_array[${#line_array}-1]} doesn't give me the last value of the array
17:49  juniorbash: thanjs steve :)
17:49  sikilpaake: pgas: but i'll keep fiddling with it until i find what's wrong
17:49  sikilpaake: pgas: thanks
17:49 --- Channel #bash was synced in 85 seconds
17:49  pgas: #  line_array=(one two three);echo  ${line_array[${#line_array}-1]}
17:50  evalbot: pgas: three
17:50  sikilpaake: pgas: thanks
17:50  sikilpaake: pgas: wow, that's real efficient
17:53  pgas: sikilpaake: if you only want the base name you can juse do var=/foo/bar;echo ${var##*/}
17:53  ech0s7: #((v=15*1,7)) && echo $v
17:53  ech0s7: # ((v=15*1,7)) && echo $v
17:53  evalbot: ech0s7: 15
17:54  ech0s7: why not evalutate also , ?
17:54  erUSUL: !float
17:54  greybot: for floating point numbers see !faq 22
17:54  erUSUL: !faq 22
17:54  greybot: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
17:58  sikilpaake: pgas: i want to do it with arrays
17:59  sikilpaake: pgas: no real reason, i just want to do it with arrays, so that i learn all i can about them while i'm at it
17:59  grosboulet: Hello
18:00  grosboulet: how can I cut lines number X and Y from file content.txt ?
18:01  grosboulet: s/cut/delete
18:01  pgas: printf %s\\n 4d 11d w | ex -s content.txt
18:01  sikilpaake: pgas: ok, check this out
18:02  sikilpaake: pgas: i'm trying to find out what the last value of the array is, right?
18:02  sikilpaake: # line_array=(one two three);echo  ${line_array[${#line_array}-1]}
18:02  evalbot: sikilpaake: three
18:02  sikilpaake: so far so good
18:02  sikilpaake: what about when i do this?
18:02  sikilpaake: line_array=(one two three four five six seven eight);echo  ${line_array[${#line_array}-1]}
18:02  sikilpaake: # line_array=(one two three four five six seven eight);echo  ${line_array[${#line_array}-1]}
18:02  evalbot: sikilpaake: three
18:03  sikilpaake: three? three is not the last value of that array! its "eight"!
18:03  sikilpaake: pgas: what gives?
18:03  erUSUL: grosboulet: sed 'Xd;Yd' contents.txt
18:03  Aitrus41: I want to write a simple script where every time "file.txt" is modified, X happens.  What's the best way to do that?
18:04  sikilpaake: Aitrus41: with or without using a cron job?
18:04  Aitrus41: sikilpaake: Without
18:04  Aitrus41: sikilpaake: Everytime file.txt is modified, scp this file to another server basically
18:04  sikilpaake: Aitrus41: right..
18:04  pgas: sikilpaake: oups sorry  ${#line_array[@]}
18:05  sikilpaake: Aitrus41: i'm sure somebody else has a better idea
18:05  sikilpaake: pgas: cool, thanks
18:05  erUSUL: !fam | Aitrus41
18:05  erUSUL: !fam > Aitrus41
18:05  greybot: Aitrus41: FAM (File Alteration Monitor), or maybe you wanted inotifywait instead.
18:05  sikilpaake: # line_array=(one two three four five six seven eight);echo  ${line_array[${#line_array[@]}-1]}
18:05  evalbot: sikilpaake: eight
18:05  sikilpaake: yay!!!
18:09  grosboulet: erUSUL: that delete all lignes between X and Y, no ?
18:09  pgas: no
18:10  erUSUL: grosboulet: it shouldn't. sed 'X,Yd'   is what will do what you say
18:11  erUSUL: grosboulet: you can use ed too. « printf "%s\n" 2d 5d w . | ed -s file »
18:11  erUSUL: !ed
18:11  greybot: ed is a command-based file editor. See http://bash-hackers.org/wiki/doku.php?id=howto:edit-ed - http://sdf.lonestar.org/index.cgi?tutorials/ed - http://wolfram.schneider.org/bsd/7thEdManVol2/edtut/edtut.pdf
18:12  grosboulet: great, thanks erUSUL
18:13  gniourf_gniourf: haha un grosboulet
18:13  erUSUL: you missed pgas ex solution ....
18:13  ritzt3ch: thanks pgas sorry i should of asked what kind of syntax to look for ...
18:17  juniorbash: b=sofa; awk -v vart=$b 'BEGIN {for (i=1;i<=length(b);i++) {print substr (vart,1,i)}' can you help me to fix this code
18:18  juniorbash: b=sofa; awk -v vart=$b 'BEGIN {for (i=1;i<=length(vart);i++) {print substr (vart,1,i)}' can you help me to fix this code
18:23  SiegeX: there was a great website ive seen floating around here on the history of terminals, anybody know it?
18:23  SiegeX: 4# b=sofa; awk -v vart=$b 'BEGIN {for (i=1;i<=length(b);i++) {print substr (vart,1,i)}'
18:26  sikilpaake: pgas: can you do me a favor? this is driving me crazy
18:28  sikilpaake: pgas: please let me know why line 7 won't work .. i know it already works the way you taught me, but i need to get it out of my head while my method just won't work http://sikilpaak.pastebin.com/tSHXMmsZ
18:28  sikilpaake: pgas: your method is line 9
18:29  sikilpaake: pgas: it appears that i have one ] more than i need
18:29  sikilpaake: pgas: no, wait, that ] is supposed to be there
18:30  sikilpaake: pgas: ${line_array_last_value[0]} is supposed to be an amount, so why isn't it expressed there?
18:33  sikilpaake: pgas: i made it work! thanks!!
18:33  SiegeX: line_array_last_value isn't an array
18:48  ritzt3ch: If i have an IF inside of an IF but i want to exit out the rest of the IF can i do that without exiting the script.
18:49  ritzt3ch: haha sounds kinda confusing
18:49  poisonbit: like  $you_are_here; fi; fi
18:49  poisonbit: ?
18:51  ritzt3ch: pastbinning it ;)
18:52 --- Fuco is now known as bckw
18:52  ritzt3ch: http://pastebin.com/YR0dTcrh
18:52  Fatal: heh, I've found myself wanting break to be able to break out of multiple levels of if before, normally takes a minute to rethink the logic to get around it
18:53  SiegeX: multiple break's or I perfer a goto statment if it's more than 2 levels deep.
18:53  SiegeX: since most shells (like bash) don't support goto, well that leaves only one option
18:54  Fatal: your description didn't make it easier to read I'm sorry, I have no idea whay you mean by "bypass the if "find rptnm""
18:54  SiegeX: although, I bet you could run the whole thing in a subshell and just 'exit'
18:54  SiegeX: # echo test
18:54  evalbot: SiegeX: test
18:54  poisonbit: break is for FOR, WHILE or UNTIL loops  (uppercases from help, not mine)
18:55  ritzt3ch: then i decided to maybe look at this but this syntax is not right
18:55  ritzt3ch: 	if [ "$(find "$rptnm" -mtime +1)" && $mkt != *fnd* ]
18:55  SiegeX: ah right, he was talking nested if's
18:55  Fatal: ritzt3ch: I'm guessing if [[ $mkt != *fnd* ]] && [[ "$(find "$rptnm" -mtime +1)" ]]; then
18:55  ritzt3ch: haha swiby ;)
18:55  SiegeX: use a case statement then
18:55  Fatal: ![[ > ritzt3ch
18:55  greybot: ritzt3ch: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
18:57  Fatal: (the order makes a difference, keep the simple tests first, the heavier ones last, since bash won't execute the second test if the first failed)
18:57  jameskk: what
18:57  jameskk: 's the easiest way to omit a file from a * wildcard. e.g. : rm * (except 1 file)
18:58  Fatal: jameskk: I'm guessing extglob
18:58  SiegeX: yep
18:58  SiegeX: using the !() construct
19:00  Fatal: # touch a b c aa bb cc a1a b2b c3c ; shopt -s extglob ; echo !(c)
19:00  evalbot: Fatal: a a1a aa b b2b bb c3c cc
19:00  jameskk: thanks, that's exactly what I'm after.
19:08  nicofs: how can i let a script check, if it's being run as su/root?
19:09  loomsen: (($EUID==0))
19:20  sikilpaake: how can i get a loop to printf "%s\n" into a new array?
19:21  koala_man: !faq append
19:21  greybot: http://mywiki.wooledge.org/BashFAQ/013 -- How can I concatenate two variables?  How do I append a string to a variable?
19:21  koala_man: meh
19:21  erUSUL: sikilpaake: array+=$(printf ....)
19:21  erUSUL: ?
19:21  sikilpaake: erUSUL: fanx, i'll check it out
19:23  erUSUL: sikilpaake: oops you need an estra pair of () there ....
19:23  erUSUL: sikilpaake: array+=($(printf ....))
19:23  sikilpaake: erUSUL: wow, thanks :)
19:28  ferret:  that's stupid
19:29  ferret: array+=($(printf '%s\n' one two three)) is like a broken version of array+=( one two three )
19:31  carlocci: Hello. Are there any security implications in using eval to dereference variables?
19:31  trash: Yes.
19:31  trash: !eval
19:31  greybot: 'eval' is a common misspelling of 'evil'. If eval is the answer, surely you are asking the wrong question. See http://mywiki.wooledge.org/BashFAQ/048
19:32  carlocci: it's for a template, like: eval echo "$time $host"
19:32  carlocci: I thought so
19:32  ritzt3ch: i got this a=`echo ${a//[0-9]}$(printf %04d ${a//[a-z]})`  changing los114 to los0114 Works FINE :)   But if i have los011 its not inserting right . (i think if theres a los051 or los086 the 0 is not setting right not sure where to change it.
19:32  trash: Oh my god.
19:33  ritzt3ch: los011 should be los0011
19:33  Fatal: what is that?
19:33  reverebeer: how do i prevent bash from expanding a ~ i put in a variable?
19:33  Fatal: reverebeer: quote it
19:33  reverebeer: danke
19:34  ferret: # a=los011; a="${a//[0-9]}$(printf %04d "${a//[a-z]}")"
19:34  evalbot: ferret: no output
19:34  Fatal: reverebeer: that is, quote the expansion aswell
19:35  Fatal: or wait, maybe you just need to quote it somewhere.. heh
19:35  Fatal: # a=~ ; b="~" ; echo $a $b "$a" "$b"
19:35  evalbot: Fatal: /root ~ /root ~
19:35  ferret: hrm
19:35  ferret: # printf %04d 011
19:35  evalbot: ferret: 0009
19:36  Fatal: ferret: you need to strip leading zeroes or it'll be octal
19:36  ritzt3ch: tahts weird i had the same thing 11 turned to 9
19:36  carlocci: Actually it doesn't look like a terrible security implication. Are there other common template patterns I can use?
19:36  ritzt3ch: line 686: printf: 086: invalid number
19:38  cafaro: How to expand a dirname when catting it from a file (e.g., $(cat [file-containing-string])) ?
19:39  erUSUL: !wayttd
19:39  greybot: What Are You Trying To Do?
19:39  Fatal: # printf "%04d\n" $((10#011))
19:39  evalbot: Fatal: 0011
19:40  anddam: hello
19:40  g4bittin: hi
19:41  ferret: that stripping-leading-zeroes thing is quite annoying...
19:41  Fatal: # a=los011; a="${a//[0-9]}$(printf %04d "$((10#${a//[a-z]}))")" ; echo $a
19:41  evalbot: Fatal: los0011
19:41  anddam: I'm trying to grep the "user" line from time's output but I get all the output (real, user, sys). How can I solve this?
19:41  Fatal: ferret: ^
19:41  erUSUL: anddam: time writtes in sterr
19:41  erUSUL: stderr*
19:42  ferret: not relevant
19:42  ferret: !faq time
19:42  greybot: http://mywiki.wooledge.org/BashFAQ/032 -- How can I redirect the output of 'time' to a variable or file?
19:42  anddam: I tried 2>&1 too
19:44  anddam: ferret: reading, thx
19:46  MegaHerz: HI all. How can I replace \n characters in a file with sequence of \r\n\r\b?
19:46  MegaHerz: \r\n\r\n i meant
19:47  vaxerdec: compat31 should be the default.
19:53  cafaro: So I have this file that contains, something like "~/backup", but when I cat the file: $(cat file), it's still "~/backup", how can I expand this to "/home/cafaro/backup"?
19:57  vaxerdec: cafaro: single line? or you just want to do it for arbitrary lines in the file (tilde expansion?)
19:58  vaxerdec: cafaro: also are they just filenames in the file? or potentially other stuff?
19:59  MegaHerz: How to correctly create pipe in this expression: find . -name '*.doc' -exec antiword {} | sed <etc>...
19:59  MegaHerz: I mean '|' between antiword and sed
19:59  MegaHerz: this doesn't work, and this too: '\|'
20:00  erUSUL: !find > MegaHerz
20:00  greybot: MegaHerz: http://mywiki.wooledge.org/UsingFind
20:01  vaxerdec: erUSUL: is that like "usul" as chani used it?
20:01  erUSUL: long history short; yes
20:02  vaxerdec: MegaHerz: when in doubt you can always use sh -c 'something | something'
20:04  vaxerdec: erUSUL: i always thought the relationship he created between those two was very beautiful concept in the mind.  i nearly cried when she died and he heard his private name called by her
20:05  vaxerdec: usuuuuuuuuul... <vanishing into infinity>
20:08  erUSUL: :`(
20:15 --- barack_osama_heh is now known as barack_osama
20:17  cafaro: vaxerdec: just 1 line with a filename
20:22  pyther: Hello
20:23  pyther: how can a I store stderr as stdout?
20:23  Fatal: 2>&1
20:24  pyther: Fatal: hmm this doesn't work sudo fdisk -l /dev/sda 2>&1 > test
20:24  grop: perhaps faq 55
20:24  Fatal: pyther: > test 2>&1  iirc
20:24  grop: !faq 55
20:24  greybot: http://mywiki.wooledge.org/BashFAQ/055 -- Tell me all about 2>&1 -- what's the difference between 2>&1 >foo and >foo 2>&1, and when do I use which?
20:25  pyther: well more goal is to store the stderr output into a variable
20:25  Fatal: var=$(cmd 2>&1)
20:26  pyther: as so? var=$(sudo fdisk -l /dev/sda | grep WARNING 2>&1)
20:26  e36freak: if you _just_ want stderr, use var=$(cmd 2>&1 1>/dev/null)
20:26  hacim: if I have a variable $blah='foo_server' is there a way to manipulate that variable so baz='foo' without having to do baz='echo $blah | cut -d_ -f1'? isn't there some variable substring method I can use?
20:26  e36freak: !pe > hacim
20:26  greybot: hacim: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
20:27  e36freak: !umq > hacim
20:27  greybot: hacim: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
20:27  pyther: e36freak: like this? var="$(sudo fdisk -l /dev/sda | grep WARNING 2>&1 1>/dev/null)"
20:27  vaxerdec: hacim: ${blah#foo_}
20:28  grop: # blah='foo_server' blah=${blah%_*}; echo "$blah"
20:28  evalbot: grop: foo
20:28  Fatal: pyther: I'm guessing WARNING comes on stderr from fdisk, if so; var=$(sudo fdisk -l /dev/sda 2>&1 | grep WARNING)
20:29  hacim: yeah sorry I was lazy with my quotes in my question :)
20:29  pyther: Fatal: ahh got it thanks!
20:29  hacim: thanks e36freak and vaxerdec
20:29  e36freak: !<<< > hacim (for future reference too, a lot better that echo | grep or whatever)
20:29  greybot: hacim (for future reference too, a lot better that echo | grep or whatever): Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
20:30  vaxerdec: cafaro: maybe "eval echo $(< file)"
20:31  e36freak: eval?!
20:31  vaxerdec: e36freak: yeah you have a different approach?
20:31  e36freak: ahh, didn't see the question
20:32  vaxerdec: e36freak: i thought about compgen but i can't get that to work.  "eval echo" is usually a hack but, oh well.
20:32  e36freak: # as long as it isn't "evar $(<file)
20:32  e36freak: eval**
20:32  evalbot: e36freak: Missing terminating quote, bracket or keyword
20:32  e36freak: why did i prefix that with a # -_-
20:34  maxedmelon: Hey, can anyone tell me a bash script to execute `tail -n 17 stats` every 10 seconds to display it like `top` ?
20:34  maxedmelon: Hey, can anyone tell me a bash script to execute `tail -n 17 stats` every 10 seconds to display it like `top` ?
20:34  maxedmelon: sorry lol wrong window
20:35  e36freak: while true; do tail -n 17 stats; sleep 10; done ?
20:35  geirha: watch -- tail -n 17 stats
20:35  e36freak: ahh, watch
20:35  maxedmelon: i pressed up and enter because i wanted to do what the script should do. didnt see its irssi, not ssh
20:35  geirha: (if you have watch(1))
20:35  maxedmelon: watch: fatal: bad device name
20:35  maxedmelon: probably another watch
20:35  geirha: Or, you know, just  tail -f stats
20:36  e36freak: is different though
20:37  anddam: bye
20:37  vaxerdec: watch is nice but it does a terminal reset.  i wish there was an option to turn it off
20:37  vaxerdec: but i guess that's its point sort of.
20:37  cthuluh: see what e36freak wrote
20:38  vaxerdec: cthuluh: right.  yes that's the other way.
20:38  vaxerdec: i have always felt that "while true" was more correct than "until false" but i'm not sure why.
20:39  cthuluh: ...
20:45 --- Nisstyre65 is now known as raist
20:45 --- raist is now known as umad980
20:45 --- Hunterm is now known as jmad980
20:46 --- jmad980 is now known as Hunterm
20:50 --- Unknown[OFF] is now known as Unknown[NF]
21:04 --- Unknown[NF] is now known as Unknown[OFF]
21:09  vaxerdec: is there a way to do a bit shift in bc?
21:09  yitz_: ^2
21:11  vaxerdec: that's left how about right.  guess just divide
21:12  geirha: In bash's arithmetic context you have the << and >> operators
21:12  vaxerdec: those only work on ints
21:12  vaxerdec: i'm using bc to get floats
21:12  geirha: Yes
21:12  vaxerdec: come to think of it maybe shifts on floats don't make sense anyways
21:13  ferret: vaxerdec: shifts on floats make a LOT of sense
21:13 --- olskolirc is now known as WorthyOfUrAttn
21:13  geirha: You have to know how floats are represented in binary
21:13  vaxerdec: since the bits are "structured" specially
21:13  ferret: because you only modify the exponent, not the mantissa
21:14  geirha: Oh, you do?
21:14  ferret: a float = mantissa * 2 to the power of exponent
21:14  vaxerdec: isn't each arch different? i remember reading about that.  and you can put the cpu in different modes or something, with more or less precision.
21:14  ferret: the actual meaning of the bits is different, yes
21:14  vaxerdec: aren't there like 80 bits available or something on x86?
21:15  cthuluh: yes. "extended format".
21:15  ferret: If you're asking whether using the integer << C shift operators on floats is a bad idea, the answer is of course yes
21:15  ferret: But logically the idea of shifting with floats is not completely silly
21:16  vaxerdec: how does that work if the registers are only 32 or 64 bits? are those just the integer registers?
21:16  ferret: a library could (carefully, with pains taken to be portable) implement it
21:16  vaxerdec: ferret: a library sure, but how about a machine instruction?
21:17  ferret: I have no idea.  There probably is one on some cpus
21:17  vaxerdec: do float ops use different registers that are longer? i guess i will rtfm.
21:17  e36freak: never a bad idea
21:18  vaxerdec: yeah but wtfm is always a pita.
21:19  vaxerdec: especially when it's to be on wiki.
21:29 --- WorthyOfUrAttn is now known as olskolirc
21:40  ritzt3ch: i had a narly juniper outage Thanks Fatal for the 0 stuff eariler ;)
21:42  Rakko: Hi. I have a script that runs some MySQL scripts. It has a variable $verbose that tells whether to redirect output to /dev/null or not. Right now the bash script checks $verbose, and if it's present, executes the line cat $i | "$mysql" -t "-p$pass" "$db". If not present, it executes cat $i | "$mysql" -t "-p$pass" "$db" > /dev/null. Is there a way I could put "> /dev/null" in a variable so I wouldn't need the if?
21:43  e36freak: !uuoc
21:43  greybot: Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
21:43  e36freak: uh, hm
21:44  Rakko: When I try putting "> /dev/null" into a variable, it interprets it as a plain argument to the command
21:44  geirha: ... > ${verbose:+/dev/null}
21:44  geirha: Or,  if ((verbose)); then exec > /dev/null; fi
21:45  Rakko: oh, thanks
21:45  geirha: err I meant ((!verbose))
21:46  Rakko: so ${verbose:+/dev/null} would expand to /dev/null if verbose is unset? what would it expand to if verbose is set?
21:46  geirha: err, it'll expand to /dev/null if verbose is set, nothing otherwise
21:46  Rakko: e36freak: thanks for the tip about cat. I just find it easier to read than using < $i along with >
21:46  geirha: so maybe call the variable something else
21:46  Rakko: ok
21:47  Rakko: geirha: is it OK in bash to use > without a filename after it?
21:47  geirha: Oh wait, no.
21:47  geirha: Sorry, don't know what I was thinking about :/
21:47  e36freak: haha
21:47  e36freak: can you...
21:48  ferret: "$verbose${verbose:+/dev/null}"
21:48  ferret: :)
21:48  ferret: or maybe := does this?
21:48  e36freak: nah, that's no good
21:48  ferret: "&1${verbose:+/dev/null}"
21:49  e36freak: nice
21:49  ferret: better?
21:49  ferret: it looks awful
21:49  e36freak: maybe
21:49  Rakko: yeah
21:49  Rakko: I think the exec > /dev/null thing is the most readable to me
21:50  Rakko: if I want to turn that off, would I use exec >&1 ?
21:50  geirha: run() { if ((verbose)); then "$@"; else "$@" > /dev/null; fi; }; ...; run mysql ...
21:50  e36freak: or you could do the opposite, set $verbose to &1 if you want it, and use >"${verbose:-/dev/null}"
21:51  ferret: Rakko: no, exec >&1 does nothing
21:51  ferret: it has no effect
21:51  Rakko: so how do you undo exec > /dev/null?
21:51  e36freak: # verb="&1"; echo "foo" >"${verb:-/dev/null}"; unset verb; echo "foo" >"${verb:-/dev/null}"
21:51  ferret: # exec >"&1"; echo foo
21:51  evalbot: e36freak: no output
21:51  evalbot: ferret: no output
21:51  e36freak: hmm
21:51  ferret: OK, this doesn't work
21:51  ferret: # exec >"&1"; echo foo; ls
21:51  evalbot: ferret: no output
21:52  koala_man: (( verbose )) && log=/dev/stdout || log=/dev/null; foo > $log
21:52  ferret: NFI what is happening to that output
21:52  e36freak: Rakko: just create a function to output
21:52 --- Unknown[OFF] is now known as Unknown[NF]
21:52  e36freak: Rakko: so you can just call the function instead of having to put if statements everywhere
21:53  geirha: # verbose=0; run() { if ((verbose)); then "$@"; else "$@" > /dev/null; fi; }; run echo foo
21:53  evalbot: geirha: no output
21:53  Rakko: e36freak: ok. exec > will only affect the rest of the function then?
21:53  geirha: # verbose=1; run() { if ((verbose)); then "$@"; else "$@" > /dev/null; fi; }; run echo foo
21:53  evalbot: geirha: foo
21:53  pgas: (( verbose )) && exec 3>&1 || exec 3>/dev/null; foo > &3
21:53  Rakko: or did you mean geirha's foo() func?
21:53  e36freak: yeah, similar to that
21:54 * geirha votes for pgas's approach.
21:54  Rakko: I see
21:54  Rakko: I just learned you could use ((verbose)) like that
21:54  Rakko: previously I had been using either [ "$verbose" -ne 0 ] or [ -n "$verbose" ]
21:55  geirha: Yeah, don't use [ in bash
21:56  vaxerdec: Rakko: yeah most people don't seem to know about arith.  it's very useful and short. you don't need ${} for arrays either.
21:56  Rakko: I did know about (()) for arith
21:57  vaxerdec: Rakko: and btw the [...] in arrays is also evaluated using arith
21:57  Rakko: how do you do an array without ${}? you meant inside of (( ))?
21:57  vaxerdec: so you can do $((array[n+5]))
21:58  vaxerdec: Rakko: i just mean that within arith expansion array variables can stand naked without the braces
21:58  Rakko: oh, wait... $(())? how is that different from (())?
21:58  e36freak: !$((
21:58  greybot: $((...)) is an arithmetic substitution. After doing the arithmetic, the whole thing is replaced by the value of the expression. See <http://mywiki.wooledge.org/ArithmeticExpression>.
21:58  lhunath: one expands, the other doesn't.
21:58  Rakko: ok
21:59  vaxerdec: Rakko: (()) is an expression with a value whereas $(()) is an expansion
21:59 --- bckw is now known as Fuco
22:00  Rakko: right
--- Log closed Sun Jan 09 22:02:02 2011
--- Log opened Sun Jan 09 22:02:26 2011
22:02 --- Users 563 nicks [0 ops, 0 halfops, 0 voices, 563 normal]
22:03 --- Channel #bash was synced in 85 seconds
22:09  Caelum: I forgot, in an if statement how do you match the beginning of a variable? like if [ "$FOO" = start* ] or something
22:10  e36freak: with [[, sure
22:10  e36freak: if [[ $foo = start* ]]; then
22:10  e36freak: !varcap
22:10  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
22:10  e36freak: ![[
22:10  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
22:10  manizzle: how can i get stdout and stderr to pipe to oene
22:10  manizzle: file at the same time
22:10  e36freak: !faq 2>&1 > manizzle
22:10  greybot: manizzle: http://mywiki.wooledge.org/BashFAQ/055 -- Tell me all about 2>&1 -- what's the difference between 2>&1 >foo and >foo 2>&1, and when do I use which?
22:10  grondilu: !|&
22:10  manizzle: thank you daewg
22:11  Caelum: e36freak: thank you :)
22:11  Rakko: hah, I was just wondering about capitalization conventions
22:12  viridior: looking for a little help since this is outside my realm of knowledge.  I want to send commands to a program that is already running via a script, similar to screen -X.  Is this possible?
22:12  grondilu: consider using expect
22:12  viridior: interesting, thanks
22:12  e36freak: !expect
22:12  greybot: http://expect.nist.gov/ -- a Tcl package for driving interactive terminal-based programs
22:14  viridior: specifically im managing a gaming server with its own console commands, of which i would like to use it's save and stop methods so it shutsdown properly vice using nohup/kill
22:14  e36freak: !trap
22:14  greybot: If you want processes to communicate, the easiest way (besides a pipe) is to use signals. See: help trap <Enter>, man kill and man bash /SPECIAL PARAMETERS | http://mywiki.wooledge.org/ProcessManagement
22:17  viridior: not sure expect and trap will work, since im not waiting for an event to issue said command.  I just want to shut the server down when user requests from withing the program's console interface.
22:17  viridior: s/withing/within/
22:18  ormaaj: How do I turn $@ into an array and then slice it? I'm trying to get the CDR/tail of $@ to make a recursive call
22:18  viridior: screen -X `command` will work, however it required screen... which is not a given
22:18  e36freak: viridior: make exit kill $PPID ?
22:18  e36freak: !faq easily
22:18  greybot: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
22:18  grondilu: ormaaj: a=("$@"); echo "${a[@}"  ?
22:19  grondilu: ormaaj: a=("$@"); echo "${a[@]}"  ?
22:20  viridior: e36freak: that would theoretically work, but there is no guarantee that all data is saved, this program stores most of its data in RAM and i believe its internal 'stop' command actually force writes everything to disk.  My fear is that kill will just stop the server.
22:20  Rakko: what server is it, viridior ?
22:20  viridior: minecraft_server
22:20  e36freak: # foo() { echo "${@:${#@}}"; }; foo bar baz blah
22:20  evalbot: e36freak: blah
22:21  ormaaj: grondilu: Is making an assignment required? You'd think something like this would work f(){ echo ${("$@"):1}; }; f *
22:21  e36freak: ormaaj: see above
22:21  e36freak: # foo() { echo "${@:((${#@}-1))}"; }; foo bar baz blah
22:21  evalbot: e36freak: baz blah
22:21  viridior: there are some scripts already out to do this, but they all require 'screen' in order to do this
22:22  Tramp: !slice
22:22  greybot: Some people use the word "slice" to mean "a contiguous set of array elements", as in "I want array elements 5 through 7". "${array[@]:5:3}" or "${@:5:3}"
22:22  Tramp: ormaaj: ^^
22:22  ormaaj: e36freak, Tramp thanks!
22:22  e36freak: # foo() { echo "{@: -1}"; }; foo bar baz
22:22  evalbot: e36freak: {@: -1}
22:22 --- taylanuc is now known as taylanub
22:23  e36freak: bah
22:23  e36freak: # foo() { echo "${@: -1}"; }; foo bar baz
22:23  evalbot: e36freak: baz
22:23  e36freak: also works that way, to "tail" it
22:23  grondilu: that's neat
22:24  echelon: hi, is there a way to do pass by reference?
22:24  yitz_: Just use the same variable name
22:24  vaxerdec: echelon: bash is arbitrarily reflective
22:24  e36freak: viridior: everything i've seen for minecraft uses screen
22:25  ormaaj: Actually the specifics of whether it's "contiguous" or not or not probably aren't that important since I'm hoping the scope of the $@ should be new for recursing through directories
22:25  echelon: so the value assigned to $1 in a function changes the value of the global var
22:25  viridior: e36freak: yeah, its the easy answer.
22:25  vaxerdec: echelon: no it doesn't.
22:26  vaxerdec: echelon: positional parameters in functions are local
22:26  echelon: http://www.mcwalter.org/technology/shell/functions.html
22:26  viridior: was hoping i could use a program outside screen to do this, hopefully already existing in bash or most linux default installs
22:26  echelon: that guy said to use eval ^
22:27  viridior: e36freak: thanks for the help, ill probably just use screen also.
22:27  e36freak: !eval
22:27  greybot: 'eval' is a common misspelling of 'evil'. If eval is the answer, surely you are asking the wrong question. See http://mywiki.wooledge.org/BashFAQ/048
22:27  echelon: but i can't get it to work
22:28  e36freak: foo() { echo "$1"; }; var=$(foo bar); echo "$var"
22:28  e36freak: # foo() { echo "$1"; }; var=$(foo bar); echo "$var"
22:28  evalbot: e36freak: bar
22:29  echelon: bah, i'll just do it outside of the function
22:29  e36freak: or just don't use local variables
22:30  e36freak: # foo() { bar=baz; }; bar=foo; foo; echo "$bar"
22:30  evalbot: e36freak: baz
22:30  vaxerdec: e36freak: damn you beat me to it.
22:31  e36freak: echelon: the problem with eval is this:
22:31  vaxerdec: eval can get really ugly.
22:31  ormaaj: # foo() { echo "${@:1}"; }; foo bar baz blah
22:31  evalbot: ormaaj: bar baz blah
22:31  e36freak: # foo() { eval "$1=foo"; }; foo "rm -rf /*; foo"
22:32  evalbot: e36freak: rm: cannot remove `/proc/kallsyms': Operation not permitted
22:32  evalbot: e36freak: rm: cannot remove `/proc/dma': Operation not permitted
22:32  evalbot: e36freak: etc... ( http://pastebin.com/vc7eezuD )
--- Log opened Sun Jan 09 22:34:10 2011
22:34 --- Users 567 nicks [0 ops, 0 halfops, 0 voices, 567 normal]
22:34  e36freak: echelon: it's the "bobby tables" thing
22:34  echelon: i just wanted function to be able to set the variables at the end within check_dep.. http://pastie.org/1443619
22:35  e36freak: http://xkcd.com/327/
22:35 --- Channel #bash was synced in 85 seconds
22:36  e36freak: !varcaps
22:36  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
22:36  e36freak: echelon: any reason in particular you're using sh and not bash?
22:36  echelon: no :/
22:36  e36freak: !sh
22:36  greybot: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
22:37  echelon: backwards compatibility?
22:37  e36freak: !evalbot > vaxerdec
22:37  greybot: vaxerdec: evalbot runs each session in a new VM as root. Feel free to play with, or hack, the bot in #evalbot or look at it more closely on http://www.vidarholen.net/contents/evalbot/
22:38  e36freak: echelon: that would be a valid reason, just specify beforehand
22:38  e36freak: also, use moar quotes
22:39  echelon: where
22:39  e36freak: everywhere
22:39  e36freak: haha
22:39  echelon: :/
22:39  e36freak: check_dep "$dialog"
22:39  echelon: oh, is that needed?
22:40  echelon: part of the conventions?
22:40  e36freak: !pf 2
22:40  greybot: http://mywiki.wooledge.org/BashPitfalls#pf2 -- Don't do this! -- cp $file $target
22:40  Rakko: sprechen Sie vidarholen bitte
22:42  taylanub: vidarholen, the evalbot creator? :P
22:42  Rakko: yeah
22:43  vaxerdec: ich habe kleine kopf
22:43  Rakko: I believe "sprechen Sie wiederholen" in German means "speak slowly"
22:43  taylanub: nah, doesn't make sense
22:43  taylanub: and "wiederholen" means "to repeat"
22:43  e36freak: aye
22:43  e36freak: that is "do you speak vidarholen please"
22:43  Rakko: oh!
22:43  Rakko: I was very confused
22:43  e36freak: you wanted "speak to vidarholen please"
22:44  e36freak: i think
22:44  Rakko: all I know of German is from a cassette tape of phrases I listened to 20 years ago
22:44  Rakko: I wanted "speak slowly, please"
22:44  e36freak: ahh
22:44  Rakko: and got it confused with "please repeat"
22:44  taylanub: this is now #german! :P
22:45  e36freak: echelon: so you can use eval if you know what the input to the function is going to be, if you really want to
22:45  taylanub: !eval > read the link!
22:45  greybot: read the link!: 'eval' is a common misspelling of 'evil'. If eval is the answer, surely you are asking the wrong question. See http://mywiki.wooledge.org/BashFAQ/048
22:45  echelon: ok
22:46  taylanub: there's strong eval-hate in this channel, but the link actually shows you some OK use of it, and properly tells you to just "use it at your own risk"
22:46  e36freak: yes
22:46  e36freak: i showed you the danger, so use can use it with care :P
22:48  Rakko: sprechen Sie langsam
22:50  Rakko: I know you can do array=(*); for i in "${array[@]}"; ...
22:50  Rakko: but can you use an array directly in a for loop without putting it in a variable?
22:51  e36freak: for i in *; do
22:51  taylanub: for file in ./*; do
22:51  e36freak: !ls > Rakko
22:51  greybot: Rakko: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
22:51  taylanub: he didn't try to parse ls...
22:51  e36freak: (yes, i know, you were doing it properly)
22:51  e36freak: but the answer is in there
22:51  Rakko: e36freak: taylanub: those wouldn't work if the files have spaces
22:52  grashopper: Hi, I have a script in /etc/profile.d what runs just espeak. Problem is that when It runs it slows down login, and user cannot start typing right away. How can I run this command in "background"
22:52  taylanub: Rakko: would
22:52  Rakko: ok
22:52  Rakko: I will check the page
22:52  taylanub: Rakko: wildcards expand nicely as if the filenames were quoted
22:52  Rakko: oh, cool
22:52  e36freak: !& > grashopper
22:52  greybot: grashopper: If you put the control operator & at the end of a command, e.g. ''command args &'', the shell executes the command in the background in a subshell. The shell does not wait for the command to finish, and the return status is 0. Pid of the last backgrounded command is available via the special variable $!
22:53  e36freak: !nohup > grashopper
22:53  e36freak: ...maybe
22:53  e36freak: also, look into renice
22:54  grashopper: greybot: Hmm, I think i tried to use that, but it wasn't working... Maybe I did screw it up
22:54  grashopper: I'll test it again
22:54  e36freak: greybot is a bot
22:54  grashopper: really :D
22:55  grashopper: oo,  didnt notice command :P
23:13  echelon: how do i get input values from dialog without calling outside shell scripts or files?
23:15  e36freak: from dialog? explain
23:16  echelon: from dialog menus?
23:18  e36freak: like.. read? or something like kdialog?
23:19  echelon: you've never used `dialog`?
23:19  e36freak: nope
23:19  echelon: i'm guess it's something like kdialog
23:19  echelon: it requires you to redirect input
23:19  e36freak: i would assume var=$(dialog ...)
23:20  echelon: http://www.terminally-incoherent.com/blog/2006/08/21/bash-getting-input-from-the-user/
23:20 * e36freak just uses read or cat when needed
23:22  e36freak: just put it in $( ) to capture the output
23:22  e36freak: it mentions sending it to stderr, so use 2>&1
23:22  shingen: looking for some regex help... trying to figure out how to match CD1 as \2 ....   e.g., echo The\ Kid\ 2010\ Limited\ Bdrip\ Xvid\ Fico.-CD2 | sed -E 's/^(.*?)(CD[0-9])(.mkv|.avi)$/mkdir \1\n\r\mv \1\2\3 \1/' works, but I'd also like it to print out if there is no CDx, e.g., echo The\ Last\ Exorcism.2010.avi | sed -E 's/^(.*?)(CD[0-9])(.mkv|.avi)$/mkdir \1\n\r\mv \1\2\3 \1/'
23:22  e36freak: shingen: ##sed
23:22  echelon: eh.. so var=$(dialog ....) ?
23:22  e36freak: !tias
23:22  greybot: Try It And See
23:23  echelon: i mean is that what you meant?
23:23  e36freak: yeah
23:23  echelon: ok, let's see
23:23  e36freak: try it, lemme know if it works
23:24  echelon: e36freak, it hangs
23:24  e36freak: hmm
23:24  echelon: and the menu doesn't display
23:24  e36freak: lemme play with it
23:24  e36freak: what options are you giving it?
23:25  echelon: i did.. input=$(dialog ...)
23:25  echelon: oh
23:26  echelon: dialog --clear --backtitle "example 1" --title "blah" --menu "" 8 30 2 1 "option 1" 2 "option 2"
23:27  e36freak: hmm
23:27  e36freak: i would just use a temp file i guess
23:27  echelon: :/
23:28  e36freak: or just use read
23:28  echelon: dialog w/ read?
23:28  e36freak: no, just read :P
23:28  echelon: oh
23:28  e36freak: you could also try using named pipes
23:29  e36freak: !fifo
23:29  greybot: http://mywiki.wooledge.org/NamedPipes
23:30  echelon: umm
23:30  echelon: how about this.. http://bash.cyberciti.biz/guide/The_form_dialog_for_input
23:32  echelon: ah, worked :D
23:33  echelon: awesome :)
23:36  TheBonsai: !faq dialog
23:36  greybot: http://mywiki.wooledge.org/BashFAQ/040 -- How do I use dialog to get input from the user?
23:37  echelon: the example i linked to is simpler :P
23:43  zooz: does GNU egrep support \d regex?
23:43  echelon: i would use sed
23:45  kojiro: # egrep '\d' <<< 0
23:45  evalbot: kojiro: no output
23:45  kojiro: I guess not?
23:45  kojiro: it probably depends which glibc was used to build it
23:51  undecim: Someone please confirm/correct this for me: If I write a script, aliases set from .bashrc or through the alias command will not affect the script.
23:53  undecim: That would only happen if the script was sourced with ". /path/to/script", correct? or not at all?
--- Log closed Mon Jan 10 00:00:50 2011
