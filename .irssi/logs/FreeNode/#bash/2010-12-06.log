--- Log opened Mon Dec 06 00:00:07 2010
00:00  Somelauw: For example gcc "file.c" and gcc 'file.c'
00:00  trash: In this case, yes.
00:01  trash: !quoting > Somelauw
00:01  greybot: Somelauw: Quoting 101: Always use "double quotes" around expansions: "$foo", "$(awk ..)". Use 'single quotes' to prevent even bash expansion: awk '$1 == foo'. You "can 'nest'" quotes but can't put literal single quotes in single quotes; so use: 'Don'\''t forget to quote!'.
00:01  trash: Nah, not that one.
00:01  trash: !quotes > Somelauw
00:01  greybot: Somelauw: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
00:01  gwz: anyone?
00:01  trash: gwz: tr -d ',' < file > file.new
00:01  gwz: thanks
00:03  Somelauw: Okay, but I don't want bash expansion, so it's okay to use single quotes.
00:03  Somelauw: Thanks
00:04  Somelauw: Does this also go for sh? How compatible are those rules?
00:06 --- abstract4d is now known as abstract3d
00:11  gwz: Hmm is there anyway to remove enters in file and just join the text together
00:13  Riviera: gwz: Try the command trash gave you before. Only that this time you don't want to remove commas but newline characters which are representated as \n in tr.
--- Log closed Mon Dec 06 00:17:49 2010
--- Log opened Mon Dec 06 00:18:10 2010
00:18 --- Users 528 nicks [0 ops, 0 halfops, 0 voices, 528 normal]
00:18  lju2: how to delete folder and everything within it, but not to delete the folder itself?
00:18  lju2: i hope its not a too noobish question
00:18  jsz`: rm -R folder/*
00:18  lju2: yeah, but thats not gonna delete hidden files
00:20 --- Channel #bash was synced in 125 seconds
--- Log closed Mon Dec 06 00:24:58 2010
--- Log opened Mon Dec 06 00:35:24 2010
00:35 --- Users 524 nicks [0 ops, 0 halfops, 0 voices, 524 normal]
00:35  nDuff: lines=(); while read line; lines+=( "$line" ); done <yourfile; (IFS=','; echo "${lines[*]}")
00:35  nDuff: ...or, better...
00:35  nDuff: tr '\n' ',' yourfile.txt
00:36  alek{xmb}{bottz}: yet own now
00:36  alek{xmb}{bottz}: maen
00:37  gwz: tr '\n' ',' yourfile.txt complains about extra operand
00:37 --- Channel #bash was synced in 123 seconds
00:37  alek{xmb}{bottz}: cat file |tr ..
00:38  alek{xmb}{bottz}: stop quitting and start chatting
00:39  alek{xmb}{bottz}: nowpitown
00:40  nDuff: gwz, tr '\n' , <yourfile.txt
00:40  nDuff: !uuoc
00:40  greybot: Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
00:40  Somelauw: shebangs sometimes don't work
00:40  Somelauw: cd test/
00:40  Somelauw: ./test.py
00:40  nDuff: Somelauw, ...indeed; if they have DOS newlines, or if they don't fit your operating system's restrictions...
00:41  Somelauw: And test.py contains: :!bin/python
00:41  nDuff: Somelauw, ...but if you want us to provide advice that's actually specific to your situation and useful, you'll need to tell us more
00:41  nDuff: Somelauw, it's #!, not :!
00:41  nDuff: Somelauw, you probably want #!/usr/bin/env python
00:42  Somelauw: Okay, the file contains exactly:   #!/usr/bin/env python
00:42  nDuff: Somelauw, ...when you say "exactly", you don't mean also containing the whitespace at the beginning of the line, I hope.
00:43  Somelauw: And it says: user@user-laptop:~/user$ ./user.py
00:43  Somelauw: : No such file or directory
00:43  nDuff: Somelauw, by the way, shebangs aren't handled by your shell, they're handled by your operating system after the shell has already done an exec call; strictly speaking, it's not #bash that's the right place.
00:43  nDuff: ...also, by the way, the following applies just as much to .py as to .sh:
00:43  nDuff: !.sh > Somelauw
00:43  greybot: Somelauw: Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
00:44  Somelauw: Okay, but I don't know that much. But since I started explaing can I finish this question here?
00:44  nDuff: Somelauw, ...python _libraries_ should end in .py, not python _executables.
00:44  Somelauw: And no, it doesn't contain all those spaces in the shebang/
00:44  nDuff: absolutely -- if you're not done, just keep going; no need to ask permission for taht.
00:45  nDuff: Somelauw, ...and have you made sure your script is a UNIX text file, not a DOS one?
00:45  nDuff: (if you're editing in vim, :set fileformat=unix)
00:45  Somelauw: My file does end on .py
00:45  nDuff: Somelauw, right, and as I just mentioned, it shouldn't.
00:46  nDuff: but that's a convention issue rather than a correctness one
00:46  Riviera: Somelauw: Please show the output of
00:46  nDuff: if it has a shebang, it's an executable, not a library, and thus shouldn't have an extension
00:46  Riviera: Somelauw: sed -n l user.py
00:47  Somelauw: I don't know how to check fileformat.
00:47  Riviera: Somelauw: Please show the output of "sed -n l user.py"
00:48  Somelauw: Can I just print the top line?
00:49  Somelauw: #!/usr/bin/env python\r$
00:49  nDuff: so it's \r\n rather than \n
00:49  nDuff: aka dos newlines
00:49  Somelauw: Then it just contains my file followed by dollarsigns on each line.
00:49  Riviera: Somelauw: oh, err, my fault. Wrong sed-script, should have only printed the first line.
00:49  nDuff: use dos2unix, or whatever equivalent functionality your editor provides
00:49  Riviera: Somelauw: tr -d '\r' < user.py > user; chmod +x user; ./user
00:50  nDuff: Riviera++
00:50  Somelauw: I do want a file extension since vim relies on file extensions.
00:50  alek{xmb}{bottz}: hey riv
00:50  alek{xmb}{bottz}: i got something for ya to read
00:50  alek{xmb}{bottz}: vgg schtuff
00:50  nDuff: Somelauw, not if used correctly
00:50  alek{xmb}{bottz}: a lang ill dev
00:50  alek{xmb}{bottz}: http://xmb.root.pe/def.koud.sch
00:51  Riviera: Somelauw: vim is smart enough to detect the fileformat without using the extension.
00:51  nDuff: Somelauw, vim will determine the language via the shebang, _or_ a modeline at the bottom; the extension is only a worst-case fallback, and certainly not needed for python
00:51  Riviera: xmb, let's see :)
00:51  alek{xmb}{bottz}: vgg
00:51  nDuff: (well, you can also put your modeline at the top)
00:52  alek{xmb}{bottz}: do provaid mi topikcsz and i will do more greatnecsz
00:52  alek{xmb}{bottz}: vgg
00:52 * nDuff washes out his eyes with soap after reading alek{xmb}{bottz}'s spew
00:52  Somelauw: But Riviera, what will that latter script do?
00:52  alek{xmb}{bottz}: vbg
00:53  nDuff: Somelauw, fixes your file.
00:53  nDuff: Somelauw, ...making a copy just called "user" with the carriage returns stripped out
00:53  nDuff: Somelauw, ...and then running it
00:53 * nDuff wanders home, on hearing a rumor that there's dinner cooking there.
00:54  alek{xmb}{bottz}: this koud is like lol :
00:54  Riviera: xmb, not that it really matters, but i'm curious in which programming language you plan to implement this? :)
00:54  alek{xmb}{bottz}: generate 7 windows with 7 buttons with random text, all buttons on klick do close the current window
00:54  alek{xmb}{bottz}: pike meit
00:54  Riviera: xmb, err, yes, sorry 8)
00:54  alek{xmb}{bottz}: lolol
00:54  Riviera: xmb, forgot that while reading :)
00:54  alek{xmb}{bottz}: gggg
00:54  alek{xmb}{bottz}: vgg
00:55  alek{xmb}{bottz}: it matters due to
00:55  alek{xmb}{bottz}: tschatt
00:55  alek{xmb}{bottz}: i lowne tschatt
00:55  alek{xmb}{bottz}: erhehe
00:55  Somelauw: Hmm, but yes now I think of it, I used a file from windows as a template.
00:55  Riviera: xmb, indeed, it ruins concentration and short-term memory :)
00:55  Somelauw: I didn't realize that linux hates it.
00:55  alek{xmb}{bottz}: riv the car and biologik sektschion is teh schizzel
00:56  alek{xmb}{bottz}: hmhm depends yo
00:56  alek{xmb}{bottz}: i write as i speak
00:56  alek{xmb}{bottz}: all one together to each own nowman
00:56  alek{xmb}{bottz}: lol
00:56  Riviera: Somelauw: Did you only think or also test if it works?
00:56  alek{xmb}{bottz}: riv, do say that : " thread konkurrencciy split"
00:56  alek{xmb}{bottz}: that gains you greit threading
00:57  Somelauw: I tested it and it works.
00:57  alek{xmb}{bottz}: vgg
00:58  alek{xmb}{bottz}: btw stories to tell about... i got kaetschet another time smoking in my room in that wg where i liwt, and they put me to psychiatry
00:58  alek{xmb}{bottz}: here i met new people as usual, and for one im doing tobaugarrian transdlations
00:58  alek{xmb}{bottz}: gave me casch, and this laptop im writing on
00:58  alek{xmb}{bottz}: vgg
00:58  Riviera: xmb ... tobaugarrian? :)
00:58  alek{xmb}{bottz}: fazit konklusion, im greatnec
00:58  Riviera: xmb, ah,
00:58  alek{xmb}{bottz}: he he ha hw hw hw
00:58  Riviera: xmb, bugarski 8)
00:58  alek{xmb}{bottz}: bulgarian, baugarr
00:59  Riviera: ah, no, blgarski? ili kako?
00:59  alek{xmb}{bottz}: yeccsszz
00:59  Riviera: xex
00:59  alek{xmb}{bottz}: daaaabeeeetotschnotuiuteka
00:59  alek{xmb}{bottz}: xexx!!
00:59  alek{xmb}{bottz}: ut kade mojesch da pisches tui hahaha
00:59  alek{xmb}{bottz}: xexa
00:59  alek{xmb}{bottz}: xoxo
00:59  Riviera: :)
00:59  poisonbit: I think that a 10000 level case/esac with 22.000 cases in each level and too many funtions as cases, can make the DoWhatIWrite
--- Log closed Mon Dec 06 01:03:31 2010
--- Log opened Mon Dec 06 01:08:53 2010
01:08 --- Users 517 nicks [0 ops, 0 halfops, 0 voices, 517 normal]
01:09  geirha: goose: And if you don't understand what alek{xmb}{bottz} says, you're not alone
01:09  poisonbit: lol
01:09  alek{xmb}{bottz}: vgg
01:09  alek{xmb}{bottz}: if u do not understand then reread or refrase your understanding
01:09  poisonbit: i think more or less i understand most. cat.
01:09  alek{xmb}{bottz}: vgg
01:10  alek{xmb}{bottz}: lablab
01:10  Riviera: hehe, "rephrase your understanding"
01:10  alek{xmb}{bottz}: vgg
01:10  alek{xmb}{bottz}: i got that refrase by a good meit from schweden
01:10  alek{xmb}{bottz}: im xmb hes zfz
01:10 --- Channel #bash was synced in 128 seconds
01:11  goose: also, unrelated question, I'm total face-desk that I can't remember, but what's the command for the input to 'press any key to continue, ^c to quit'? Is it an "echo" or a "read" flag?
01:11  poisonbit: read has a -p option
01:11  geirha: !faq pause
01:11  greybot: http://mywiki.wooledge.org/BashFAQ/065 -- Is there a "PAUSE" command in bash like there is in MSDOS batch scripts?  To prompt the user to press any key to continue?
01:12  goose: thanks again :p
01:12  alek{xmb}{bottz}: goose, do u know mac ambrosias escape velocity gaeim ? there are some goose schippcsz in there
01:13  poisonbit: not a bash question ? :)
01:14  alek{xmb}{bottz}: define xmb to be own
01:14  goose: ok, I think I've got it: cat list.txt | while read -r line; do (new line) grep blah blah blah what I want to do on each existing line in the file
01:14  goose: ?
01:14  alek{xmb}{bottz}: looks workajy
01:14  alek{xmb}{bottz}: u do however
01:14  alek{xmb}{bottz}: one grep
01:15  Riviera: goose: while IFS= read -r line; do ...; done < list.txt
01:15  alek{xmb}{bottz}: while read .. ; do .. ; done |grep ..
01:15  Riviera: goose: the grep part i did not understand, hence the ellipsis :)
01:15  poisonbit: goose, make a tmp copy and try and see
01:15  alek{xmb}{bottz}: in my lang u would do
01:15  alek{xmb}{bottz}: one of the many possibilities :
01:16  alek{xmb}{bottz}: schow me anything matching blah blah of any files around
01:16  alek{xmb}{bottz}: u coukd also just in schell
01:16  alek{xmb}{bottz}: grep -r blahblahlablab *files*
01:17  goose: Riviera: it's a script for looking up the abuse@ e-mail for a list of IP addresses. so my logic is: cat $FILEPATH | while read -r line; do <new line> grep -i abuse >> $HOME/abuse-list.txt
01:17  goose: (that's not the actual line, just my thought process so far)
01:18  Riviera: goose: and you don't want something like that? grep -Ff list.txt "$HOME/abuse-list.txt"
01:19  Riviera: goose: i mean, in your example the part with the grep,
01:19  Riviera: goose: the part inside of the loop does not use the variable "line" at all.
01:19  Riviera: goose: so it's hard to guess what you want to do.
01:20  goose: well, the issue I've found is, when doing a whois on a domain/IP, the formats can vary. so I want to look for the line "abuse" first, if that cannot be found, then re-look for the any lines containing the symbol '@', and if that cannot be found, echo "The IP address $IP could not be looked up properly. Sorry.\" >> abuse-list.txt
01:20  goose: Sorry.\n **
01:21  goose: so I've got to pipe the line into bash to run the series of commands on it, execute the desired result, then loop back to the next line
01:21  alek{xmb}{bottz}: ttell him grep -r
01:21  goose: grep recursively? why?
01:22  Riviera: goose: so the file list.txt contains the IP addresses?
01:22  alek{xmb}{bottz}: uhm
01:22  alek{xmb}{bottz}: i gotsa a ipgrep and a urlgrep
01:22  alek{xmb}{bottz}: im vgg
01:22  alek{xmb}{bottz}: lolajgiycsz
01:23  raminnietzsche: hi. i need 2 compile this source : http://mirror.transact.net.au/sourceforge/s/project/ss/sserver/rcssserver/5.26/sserver-5.26.tar.gz
01:23  goose: Riviera: yes, one per line
01:23  raminnietzsche: :(
01:24  alek{xmb}{bottz}: got mi a schell ram ?
01:24  Riviera: raminnietzsche: this channel is about the bash shell, not about compiling.
01:24  alek{xmb}{bottz}: i kould help if u got mi uone
01:24  raminnietzsche: ok
01:26  Riviera: goose: well, since indeed the format can vary, you need something more elaborate; a dirty and non-working way is what you have in mind: while IFS= read -r ip; do whois "$ip" > tempfile; grep -Fi 'abuse' tempfile || grep -F '@' tempfile; done < list.txt >> abuse-list.txt
01:27  goose: Riviera: I can show you what I have so far, but don't make too much fun of me :p I decided to start writing bash about 24 hours ago
01:28  Riviera: goose: already a bad decision :) (Use a programming language for programming, (not excluding "scripting languages") but not a shell.) Not really making fun of you. The while loop I just gave you does exactly what you said,
01:29  goose: heh, yeah.. but bash seems simple, perl seems scary
01:29  alek{xmb}{bottz}: tru
01:29  Riviera: goose: reading the ips from list.txt, whoising each of them and checking the output for lines containing "abuse" and if none were found, all lines including an @ character,
01:29  alek{xmb}{bottz}: take a look at #pike
01:29  Riviera: goose: saving everything in abuse-list.txt
01:29  alek{xmb}{bottz}: and #awk
01:30  Riviera: goose: I doubt this will suffice, but maybe it can help figuring what really should be done. But for that .. try it :)
01:32  alek{xmb}{bottz}: well i tschattet with yer liitnecc riv about my liitnecc, good achhiefment
01:32  alek{xmb}{bottz}: gnighty yo
01:32  Riviera: nite xmb :)
01:32  alek{xmb}{bottz}: =)
01:33  poisonbit: gnighty sounds like a cute name for a gnu program
01:35  Riviera: poisonbit: Google says: "This Is Gary Gnu and The No Gnightie Gnews Is Good Gnightie Gnews Show."
01:36  poisonbit: its hard to find a "cute" word that does not shows results in google
01:37  Riviera: yep, "abattoir" has roughly 7 million hits.
01:38  mar77i: lol I wonder about "cuteness" and "abattoir" xD
01:38  poisonbit: is_cute () { return $RANDOM ; } ; find /google -exec is_cute {} ;   # :P
01:38  poisonbit: i loosed the \
01:39  poisonbit: local words are more easy to find
01:39  mar77i: you know that you break the world if you $ ls /google
01:40  mar77i: *cough* break teh internets
01:40  poisonbit: getconf LINE_MAX
01:40  poisonbit: it they use linux, i could like to see some sysctl values
01:42  mar77i: ...what I mean is how to even get ALL searches ever made on google?
01:42  poisonbit: some google worker published a crc32 code made in bash  :D
01:43  mar77i: poisonbit: look at my cellular automaton http://bash.projectnet.org/wiki/index.php/Wolfram-1d
01:44  mar77i: testing repetition could be done more efficiently tho
01:44  poisonbit: looks nice 8)
01:45  poisonbit: wow
01:47  poisonbit: mar77i, fun program
01:47  mar77i: there are about 5 different species of oscillators in that 2||4 out of 5 rule...
01:48  poisonbit: i'm always writting more boring stuff
01:49  mar77i: I've also done some attractors and cyclic-ca in cpp, which is too far off topic here. query me if you want them :)
01:53  poisonbit: mar77i, I know as little c++ as languages like haskell
01:55  poisonbit: currently i'm trying to write a "bash framework" in hobby time, but it's going slower and slower, when i make functions of funtions, and add things like iteration
01:58  poisonbit: as it's on topic, i launch the post final question here:   http://poisonbit.wordpress.com/2010/12/02/apply-perl-knowledge-in-other-context-vi/
01:59  poisonbit: maybe a framework makes things more slow, but /me launch all bash scrips/crons with lower nice and ionice in production  :)
--- Log closed Mon Dec 06 02:03:30 2010
--- Log opened Mon Dec 06 02:08:54 2010
02:08 --- Users 515 nicks [0 ops, 0 halfops, 0 voices, 515 normal]
02:10 --- Channel #bash was synced in 127 seconds
02:11  poisonbit: mar77i, experienced bash users doesn't like the idea of a framework
02:11  mar77i: still, no comment on that. look at ${var:-default} :)
02:11  poisonbit: but i think it can be a interesting experiment, so i'm wasting some hobby time on it :P
02:13  mar77i: ...and get an additional source of failure for free :)
02:14  mar77i: !bashlib
02:14  greybot: A library of convenience functions for scripting: http://stuff.lhunath.com/bashlib
02:15  poisonbit: cool
02:16  poisonbit: lacks cl_arry_join, cl_arry_reverse, cl_array_safequote, etc :)
02:16  mar77i: stop that :P
02:17  mar77i: use perl/python/ruby.
02:17  poisonbit: mar77i, why i could source that lib for do a bash script ? only if there is something between all the funcs loaded i'm going to use
02:17  poisonbit: my "framework" only imports functions you call
02:18  poisonbit: i use perl too :)  but nothing will stop me to try to get this idea to a 1.0 version... I've enought Perl at $job   :P
02:32  poisonbit: i.e. gentoo had a library, called functions.sh and as far as I know it was widely used by system users
02:32  poisonbit: s/system/distro/
02:40  rocktop: any way to parse apache config file to get ServerName and its Documentroot  for each virtualhost entry ?
02:43  poisonbit: grep should be enought, if there are splited config files, maybe a blog or use find
02:43  poisonbit: blog -> glog (*)
02:43  poisonbit: glob
02:45  poisonbit: maybe cool a bash framework with a cl_apache2 namespace
02:45  poisonbit: ( :P )
02:45  rocktop: poisonbit, grep its not enough because I have each entry with its DocumentRoot and ServerName so I need each Documentroot and its ServerName in same line
02:47  poisonbit: grep is enoguht to extract the lines that have that words
02:47  poisonbit: then, once you have the lines, format what you need
02:47  poisonbit: find /etc/apache2/ -exec grep -iE '(servername|documentroot)' {} \;
02:48  rocktop: poisonbit, I have all them in httpd.conf file
02:49  poisonbit: if you want a magic command, give us example input
02:49  poisonbit: i do not have apache2 at home, only nginx :)
02:50  tsolox: need help on somethin'.After I 'su - user2', then know the pts# via 'ps'. Then 'ls -l /dev/pts' shows that user2's pts# is owned by user1. What configuration did i missed?
02:57  rocktop: poisonbit, I have too many virtualhosts entry look like http://pastebin.com/D9NGcctS each entry defined from  <VirtualHost  to </VirtualHost> I need to capture ServerName domaitup.com and DocumentRoot /home/domaincom/public_html  for each one entry in same line
02:59  peterrooney: tsolox: how is that different from expected behaviour?
02:59 --- awb_ is now known as awb
03:07  poisonbit: rocktop, bad code, but works with your pastebin: domains=( $(awk '/ServerName/{print$2}' example) ); roots=($(awk '/DocumentRoot/{print$2}' example) ); for i in $(seq 0 ${#domains[@]}); do echo ${domains[$i]} ${roots[$i]}; done
03:07  poisonbit: sure that if you google 2 minutes you find something better
03:08  rocktop: poisonbit, I have more than 4 hours with google about this without results :(
03:11  rocktop: poisonbit, yes your script is near that what I am looking for but its give wrong results
03:11  poisonbit: er in the bad code, "example" is httpd.conf in your case
03:11  rocktop: poisonbit, yes I know
03:12  poisonbit: bad results, then the real httpd.conf is different than the paste
03:12  poisonbit: that code rely in order and not duplicated lines
03:12  rocktop: poisonbit, its give me the Nameserver and documentroot  for deffirent Virtualhost
03:12  poisonbit: forgetting comments, etc
03:13  poisonbit: maybe you will go better using perl and Config::General or some apache config parser
03:13  poisonbit: they use to provide access to the config in a tree /hash) structure
03:15  poisonbit: and they have in mind comments, duplicated entries and all my code flaws
03:19  gwz2: aks
03:20  gwz2: hey sorry, is there anyway to append, >>, to last line of the file instead of newline
03:20  poisonbit: printf '>>' >> file
03:21  poisonbit: time to sleep, good nights
03:23 --- gwz2 is now known as gwz
03:28  mrclark: hello all.  when running http://pastebin.com/H3jzvP3D , i get "line 7: syntax error near unexpected token 'then' " .  I'm running this on snow leopard (which i think means bash 3.2.48 ).  It's a reasonably simple "validate the input, and upload stuff to my webserver" script, but i'm not too familiar with bash syntax.  Anyone have any clues?
03:34 --- roxy is now known as pixie__
03:36  cthuluh: mrclark: first, you're trying to use a command named "if[". such command doesn't exist. then, you're trying to use && as an argument to the test command, but test / [ doesn't see the &&
03:36  cthuluh: !faq difference > mrclark
03:36  greybot: mrclark: http://mywiki.wooledge.org/BashFAQ/031 -- What is the difference between test, [ and [[ ?
03:36  cthuluh: just use if [[ foo = bar && baz = quux ]]
03:37  cthuluh: !quotes > mrclark , also:
03:37  greybot: mrclark , also:: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
03:37  cthuluh: mrclark: you assignement, on line 17, isn't valid according to bash's syntax
03:38  cthuluh: !pf $foo=
03:38  greybot: http://mywiki.wooledge.org/BashPitfalls#pf15 -- Don't do this! -- $foo=bar
03:39  cthuluh: mrclark: I suggest reading the bash guide (see the /topic)
03:39  mrclark: cthuluh:  i have been, but apparently not as in-depth as i ought to have been
03:50  mrclark: cthuluh:  now we have http://pastebin.com/YytVJ9aD ; however line 14: `$itemToUpload': not a valid identifier  and line 17: uploadedPath: command not found.  So, the tests are now correctly formatted, but i'm still doing something syntactically wrong.
03:52  cthuluh: !pf 16 > mrclark
03:52  greybot: mrclark: http://mywiki.wooledge.org/BashPitfalls#pf16 -- Don't do this! -- foo = bar
03:53  mrclark: argh, whitespace
03:53  cthuluh: and the + sign
03:53  cthuluh: that doesn't mean concatenation
03:54  mrclark: argh
03:54  cthuluh: 4# foo='ab'; bar='cd'; var="$foo$bar"; echo "$var
03:54  shbot: cthuluh: Missing terminating quote, bracket or keyword
03:54  cthuluh: 4# foo='ab'; bar='cd'; var="$foo$bar"; echo "$var"
03:54  shbot: cthuluh: abcd
03:54  cthuluh: oh, also, I missed an other one :)
03:55  cthuluh: for $itemToUpload in $*
03:55  cthuluh: should be
03:55  cthuluh: for itemToUpload in "$@"
03:55  cthuluh: !$@
03:55  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
03:55  mrclark: ah!  i was wondering about that
03:56  cthuluh: still, you need more quotes on lines 8 and 18
03:58  mrclark: something like http://pastebin.com/Tsj764Sm  ?
03:58  mrclark: it now executes the scp command, but doesn't cleanly hand back display to the terminal
03:58  mrclark: that is, i have to ditch out with ^C
03:59  cthuluh: mrclark: on line 19, rather ;)
03:59  indigo: echo wtf | read a; echo $a   # why is $a not set to "wtf"?
03:59  cthuluh: !faq disappear > indigo
03:59  greybot: indigo: http://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop. Why do they suddenly disappear after the loop terminates? Or, why can't I pipe data to read?
--- Log closed Mon Dec 06 04:03:25 2010
--- Log opened Mon Dec 06 04:08:46 2010
04:08 --- Users 515 nicks [0 ops, 0 halfops, 0 voices, 515 normal]
04:10 --- Channel #bash was synced in 127 seconds
04:11  mar77i: # a=hello; echo
04:11  mar77i: # a=hello; echo ${a^}
04:11  evalbot: mar77i: no output within the time limit
04:11  evalbot: mar77i: bash: ${a^}: bad substitution
04:12  mar77i: # a=hello; echo ${a^*}
04:12  evalbot: mar77i: bash: ${a^*}: bad substitution
04:12  cthuluh: 4# a=hello; echo "${a^}" mar77i ';)'
04:12  shbot: cthuluh: Hello mar77i ;)
04:12  mar77i: o_O
04:13  mar77i: oh b4 :P
04:16 --- nohk_ is now known as nohk
04:17  szr: does anyone know of a nice "Courier New" TTF font that has less line spacing? (preferably one that has a complete UTF-8/unicode charset)
04:25  gwz: hey, how would i go about deleting the very last character of a file?
04:25  cthuluh: !pe > gwz
04:25  greybot: gwz: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
04:28  geirha: That's not an easy thing to do from bash.
04:29  geirha: There's the GNU truncate command, but that's of course not portable
04:29  cthuluh: oh, you think he meant the last byte of the file, not the last char of the file name?
04:30  cthuluh: sorry if I have misleaded you, gwz
04:31  wald0: i have a loop script that is a little slow... anybody recommends me a faster solution for this?  s_item="$( echo "$line" | awk -v FS="::" '{print $7}')"
04:32  geirha: Yes, by notting running a new awk for every single line.
04:33  geirha: s/notting/not/
05:47 --- k3rmit4 is now known as K3rmit
05:57 --- maxim is now known as Guest44415
06:09  galaxywatcher: gwz: tail -1 filename | sed 's/.$//'
06:17 --- The-Comp1ler is now known as The-Compiler
06:23  TheBonsai: y0
06:30  edgy: Hi, var1=hi; (echo $var1) printed hi but I thought parentheses would run the echo in a subshell and subshells won't inherit the values from parent shell unless exported!
06:30  edgy: what's wrong in my logic, please
06:53  TheBonsai: edgy: "subshells" are not treated like normal subprocesses (for example a shell started by /bin/bash -c 'echo $var1')
06:55  TheBonsai: edgy: a subshell is a copy of the parent shell, hence it has all data from it, plus/minus the stuff that doesn't survive a fork()
06:57  edgy: TheBonsai: let me rephrase to see whether i got your answer. You are saying: echo $var1; bash; echo $var1 is different than (echo $var1) because the first is a subprocess where as the second is a subshell?
06:57  TheBonsai: i said bash -c 'echo $var'
06:57  TheBonsai: but yes
06:58  TheBonsai: for this bash you can also take any other program you want, it will only get the environment (see the fork/exec steps)
06:58  sitaram: hi guys; is there any way to "load" and/or "flush" the history file?  I want to have per-directory HISTFILEs
06:59  TheBonsai: a subshell as mentioned in the documentation is a copy of the process (fork), not a newly exec's process
06:59  edgy: sitaram: you can delete your history by rm .bash_history e.g but what do you mean by per-directory HISTFILEs?
07:00  sitaram: let me explain...  when I cd into a directory, the history should change to what pertains to that directory only
07:00  sitaram: commands I may have typed elsewhere don't come up
07:00  edgy: TheBonsai: this is which man page?
07:00  sitaram: brb
07:00  TheBonsai: edgy: for what?
07:01  edgy: sitaram: I don't think there is such a thing in bash
07:01  edgy: TheBonsai: subshells are a copy or fork not a newly exec's process
07:04  TheBonsai: edgy: i don't think it's documented explicitly
07:04  edgy: TheBonsai: still little confused. isn't the subshell has its own PID?
07:04  edgy: TheBonsai: echo $$; (echo $$) prints the same PID!
07:04  TheBonsai: now THIS is documented
07:04  TheBonsai: $$ is not the current process id
07:05  TheBonsai: it's the "shell's PID", which is the same in all subshells
07:05  TheBonsai: it's meant to refer to "the shell", which usually is the father of all the processes there, like the shell that shows your user prompt, or the shell that drives your script
07:06  TheBonsai: !$$
07:06  greybot: $$ expands to the PID of the shell. In a () subshell, it expands to the process ID of the current shell, not the subshell.
07:08  edgy: TheBonsai: Umm! thanks for this nice tip
07:08  TheBonsai: #4 echo
07:08  TheBonsai: #4 echo test
07:08  TheBonsai: 4# echo test
07:08  shbot: TheBonsai: test
07:08  TheBonsai: 4# echo $BASHPID; (echo $BASHPID)
07:08  shbot: TheBonsai: 239
07:08  shbot: TheBonsai: 244
07:09  TheBonsai: the PID is different, but $$ means "the main shell"
07:09  TheBonsai: 4# echo $$; (echo $$)
07:09  shbot: TheBonsai: 239
07:09  shbot: TheBonsai: 239
07:10  TheBonsai: 4# echo $BASH_SUBSHELL:$BASH_PID $(echo $BASH_SUBSHELL:$BASH_PID $(cho $BASH_SUBSHELL:$BASH_PID))
07:10  shbot: TheBonsai: bash4: cho: command not found
07:10  shbot: TheBonsai: 0: 1:
07:10  TheBonsai: err
07:11  TheBonsai: 4# echo $BASH_SUBSHELL:$BASH_PID $(echo $BASH_SUBSHELL:$BASH_PID $(echo $BASH_SUBSHELL:$BASH_PID))
07:11  shbot: TheBonsai: 0: 1: 2:
07:11  TheBonsai: 4# echo $BASH_SUBSHELL:$BASHPID $(echo $BASH_SUBSHELL:$BASHPID $(echo $BASH_SUBSHELL:$BASHPID))
07:11  shbot: TheBonsai: 0:239 1:244 2:245
07:11  sitaram: edgy: I suppose you're right; I'll have to deal with this a different way I guess :)  [per-dir history]
07:12  TheBonsai: the environment doesn't matter for a process copy, but when this process copy is substituted by a new process image, only the environment survives
07:14  edgy: TheBonsai: thanks for your tips
07:22  alek{xmb}{bottz}: hey bounsczai
07:31  alek{xmb}{bottz}: check this bounzai
07:31  alek{xmb}{bottz}: http://xmb.root.pe/def.koud.sch
--- Log closed Mon Dec 06 08:03:20 2010
--- Log opened Mon Dec 06 08:08:42 2010
08:08 --- Users 506 nicks [0 ops, 0 halfops, 0 voices, 506 normal]
08:10 --- Channel #bash was synced in 125 seconds
08:28  avinashhm: hi , is there any way to delete everything from current position , backwards , upto a space .. ?? I know 'de' does this forward, but not sure for backward .. any help
08:29  strull_: avinashhm: are you sure you are in the right channel? This sounds like a vi question to me
08:29  avinashhm: strull_, nope ... its in the bash command line ...
08:30  avinashhm: oops .. i am sorry .. yeah this vim question .. i never realised i have oppened vim ..
08:30  strull_: aah, of course. Try db
08:30  pgas: in vi mode?
08:30  avinashhm: sorry for the noise
08:31  avinashhm: strull_, yep .. db was the thing i was looking for thanks ..
08:31  avinashhm: pgas, yeah in vi mode ..
08:32  pgas: well..no since you are in vi....
08:33  strull_: pgas: how do you know?
08:34  pgas: he said so
08:35  pgas: well in vim, not vi but still
08:36  strull_: you confuse me
08:36  pgas: ? he said "i never realised I have oppened vim"
08:37  pgas: I pressed return on my vi mode question before seeing his answer
08:38  pgas: so I assume he is not really using readline in vi mode but vim
08:40  digital_chaos: hello all!
08:41  digital_chaos: is this talking or help only?
08:43  digital_chaos: anyone got something i can co
08:43  digital_chaos: do
08:44  digital_chaos: any interesting bits about bash?
08:44  digital_chaos: sleepers
08:44  digital_chaos: .......
08:44  digital_chaos: ......
08:44  digital_chaos: ...
08:44  digital_chaos: ...
08:44  digital_chaos: .
08:45  digital_chaos: r we supposed to be playing
08:45  yitz_: Read the man page or the guide?
08:45  digital_chaos: am i missing the whole point
08:45  digital_chaos: which one
08:45  digital_chaos: hey wait
08:45  digital_chaos: dont go
08:45  digital_chaos: i tried man suicude
08:45  digital_chaos: oh maybe i spelled it wrong
08:46  digital_chaos: duh
08:46  digital_chaos: yep
08:46  digital_chaos: its working now
08:47  digital_chaos: well i really like bash have not used this irc since back in the days i had high expectations but for what...
08:48  jzacsh: is there an 'unset' or 'unalias' for functions?
08:49  pgas: unset -f
08:50  jzacsh: pgas: thank you :)
09:26 --- jham is now known as lynucs
09:27 --- lynucs is now known as jham
09:33  alek{xmb}{bottz}: pgas hai
09:33  alek{xmb}{bottz}: check this sch url
09:37  alek{xmb}{bottz}: same to yitcsz
09:38  alek{xmb}{bottz}: http://xmb.root.pe/def.koud.sch
09:40  alek{xmb}{bottz}: hey buntfalke same goes to j00 to tschekk this url
09:44  alek{xmb}{bottz}: lab read emiter backwards
10:13  karthee: hi .. how do i pass piped value into a shell script .. sort  -u filename |  while read line; do echo "$line"; done < ____ ?
10:13  Fatal: yes
10:14  Fatal: karthee: what's the question? the code you showed works fine
10:14  karthee: ops .. sorry ..
10:15  karthee: i thought I should redirect it  something like  done < 1; or done < -; ..
10:15  karthee: sorry
10:22  alek{xmb}{bottz}: fatall
10:22  alek{xmb}{bottz}: tsdschekk dicsz sch url
10:22  alek{xmb}{bottz}: its big greatnec
10:23  Fatal: oh yay, methhead is back
10:25  alek{xmb}{bottz}: yeahmaen
10:26  alek{xmb}{bottz}: btw new la ng defs, one l is like small l or u[ a], two l csz is your desired l in fatall
10:26  alek{xmb}{bottz}: fatal brutalo logikwordity
10:28  alek{xmb}{bottz}: test
10:29  alek{xmb}{bottz}: sukcecszdt
10:32  alek{xmb}{bottz}: lablab
10:32  alek{xmb}{bottz}: im like this digtal chaos dude
10:33  alek{xmb}{bottz}: i wanted to talk to him but when i checked i saw him leaving
10:33  alek{xmb}{bottz}: or left
10:33  alek{xmb}{bottz}: whatsooon
10:33  alek{xmb}{bottz}: did ya tschekhh the url
10:41  alek{xmb}{bottz}:  haiiia haiiiia baeeeiiii biiii
10:51 --- Weust`afk is now known as Weust`
10:51 --- Laynef_ is now known as Laynef
10:54  vbCrLf: Hello. What is the correct way to repeatadly read a key?
10:55  vbCrLf: I tried 'read -sn1 key' but if I hold a key, the first time is recognized and before it is repeated there is one second delay
10:56  alek{xmb}{bottz}: a while loop yo
10:56  vbCrLf: I know, read my second message
10:57  alek{xmb}{bottz}: huh what
10:57  alek{xmb}{bottz}: i read it
10:57  alek{xmb}{bottz}: i saw koud
10:57  alek{xmb}{bottz}: no loop
10:57  alek{xmb}{bottz}: read is singular
10:57  alek{xmb}{bottz}: so for multi
10:57  alek{xmb}{bottz}: u need a loop spawning single to have multi
10:57  vbCrLf: I'll upload my code
10:57  alek{xmb}{bottz}: k ?
10:57  alek{xmb}{bottz}: =)
10:57  vbCrLf: And you'll see what I mean
10:57  alek{xmb}{bottz}: k
10:57  vbCrLf: I know what are loops and I'm using it :)
10:57  alek{xmb}{bottz}: lablab
10:57  alek{xmb}{bottz}: kk
10:58  vbCrLf: http://pastebin.com/7MJi1skh
10:58  alek{xmb}{bottz}: wanna know a great language also ? then if tschekkh //xmb.root.pe/def.koud.sch
10:58  vbCrLf: the 'read' command does not recognize key hold as multiple presses, only after a delay
10:58  vbCrLf: Like when you hold a character key
10:59  alek{xmb}{bottz}: sek
10:59  alek{xmb}{bottz}: yeah i get your koud, not what it does due to whats the usb0 and dunno what doesnt work with multiples
10:59  alek{xmb}{bottz}: so like lemmi ask
11:00  alek{xmb}{bottz}: if u hold down some key in read, it doesnt recognize it ?
11:00  alek{xmb}{bottz}: as multi
11:00  alek{xmb}{bottz}: or
11:00  alek{xmb}{bottz}: just after a delay
11:00  alek{xmb}{bottz}: if so whats wanted
11:00  vbCrLf: It recognize it as one key, and after a delay of one second it recognizes it repeatadly
11:00  vbCrLf: the problem is the delay
11:01  alek{xmb}{bottz}: wa nna reduce it ?
11:01  alek{xmb}{bottz}: kbdrate -d ms -r rate
11:01  vbCrLf: Not for the whole system, only for this bash script
11:01  alek{xmb}{bottz}: well its more system than skripting
11:01  alek{xmb}{bottz}: so try kbdrate
11:01  alek{xmb}{bottz}: if it doesnt work due to permissions, not much kaen be doun
11:01  alek{xmb}{bottz}: u know
11:02  alek{xmb}{bottz}: its
11:02  alek{xmb}{bottz}: system spawns software
11:02  alek{xmb}{bottz}: and keystrokes are hardware, thats the system
11:02  alek{xmb}{bottz}: then the system preferences gotta get changed for aktivity
11:02  alek{xmb}{bottz}: k ?
11:02  vbCrLf: So I thought about finding an alternative way of reading keys
11:02  alek{xmb}{bottz}: u could
11:02  alek{xmb}{bottz}: however the delay will stay
11:02  alek{xmb}{bottz}: nada
11:02  vbCrLf: For example, if there was a function "iskeyPressed"
11:03  alek{xmb}{bottz}: its the system passing keys over
11:03  alek{xmb}{bottz}: the hardware
11:03  alek{xmb}{bottz}: like
11:03  vbCrLf: I could do that w/o the delay
11:03  alek{xmb}{bottz}: the example kontroller of the keyboard
11:03  alek{xmb}{bottz}: yeah u could
11:03  alek{xmb}{bottz}: hmmhmmh but theres nada
11:03  alek{xmb}{bottz}: do a small ko and ull have it
11:03  alek{xmb}{bottz}: however u could
11:03  alek{xmb}{bottz}: delay will stay
11:03  alek{xmb}{bottz}: hm
11:03  alek{xmb}{bottz}: u could emulate it
11:03  alek{xmb}{bottz}: say
11:04  alek{xmb}{bottz}: speicekakekey is the meta key
11:04  alek{xmb}{bottz}: space a .... waiting time ... while that koud does repeat that stroke halfways .... space
11:04  alek{xmb}{bottz}: 7d7man7
11:05  alek{xmb}{bottz}: seems the better way
11:06  alek{xmb}{bottz}: on opportunity space key pressed do repeat all next pressing with truely random time in between
11:06  alek{xmb}{bottz}: that above sentece works in my language
11:06  alek{xmb}{bottz}: vgg
11:06  alek{xmb}{bottz}: brb
11:07  vbCrLf: Thanks, bye
11:08  david00: Hi all; slightly strange question
11:09  david00: What is the best (most bulletproof) way to skip over all command line options passed to my script?  Where the options need to be getopt_long style, as this is a wrapper script.
11:10  david00: Context is a sudo wrapper that allows the user to use arbitrary options (including long ones) on an external tool, but restricts the arguments passed.
11:12  david00: I say 'skip over' since once I validate the arguments I can just pass the whole command line straight to the external tool.  I don't need to process the options in any way
11:13  david00: I figure getopts might have some problems with the long options
11:14  david00: Or maybe non-option can just be defined as 'first argument not beginning with a dash'?
11:14  david00: scratch that for obvious reasons
11:19  superlinux: hi. what command can list me the background PID's?
11:21  Naib: ps
11:21  superlinux: ok
11:22  superlinux: Naib, thanks
11:29  alek{xmb}{bottz}: superlinux, " # jobs"
--- Log closed Mon Dec 06 11:37:49 2010
--- Log opened Mon Dec 06 11:48:14 2010
11:48 --- Users 522 nicks [0 ops, 0 halfops, 0 voices, 522 normal]
11:50 --- Channel #bash was synced in 125 seconds
11:59  twkm: kollapse: ''help for''
12:00  twkm: if the number of indexes is not expected to be large you might prefer parameter expansion.
--- Log closed Mon Dec 06 12:16:22 2010
--- Log opened Mon Dec 06 12:21:49 2010
12:21 --- Users 523 nicks [0 ops, 0 halfops, 0 voices, 523 normal]
12:23 --- Channel #bash was synced in 128 seconds
12:26  avinashhm: hi, ls -l /bin/sh , shows -> dash .. so i think my present shell is dash ... I need to change this to bash temporarily to install a cross compiler .. can someone help on howto change the sh to bash ..
12:28  erUSUL: avinashhm: if it is an ubuntu/debian install « sudo dpkg-reconfigure dash » iirc
12:28  erUSUL: !nabq
12:28  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
12:29  twkm: not reconfigure sh?  weird.
12:31  nDuff: twkm, unless Debian provides a package called "sh", there wouldn't be anywhere to hook that.
12:32  nDuff: that said, I thought (vaguely) that Debian provided an alternatives system; that would be through update-alternatives, though, not dpkg-*
12:32 * nDuff shrugs; nabq, indeed.
12:34  jophish: Hi all
12:34  jophish: I have a bunch files, each with some numbers in
12:34  avinashhm: erUSUL, twkm .. sure i ll ask in #ubuntu .. thanks
12:34  jophish: one per line
12:35  jophish: What would be superb would be to be able to find the most frequently occurring numbers
12:35  twkm: and you want to do it as slowly as possible, so you thought of bash?
12:38  erUSUL: jophish: cat file1 ... fileN | sort | uniq -cu | head
12:43  jophish: Brilliant, thanks erUSUL
--- Log closed Mon Dec 06 13:16:24 2010
--- Log opened Mon Dec 06 13:21:58 2010
13:21 --- Users 520 nicks [0 ops, 0 halfops, 0 voices, 520 normal]
13:23 --- Channel #bash was synced in 133 seconds
13:24  shai__: Hi :) I have two lists: 1) server1,server2,server3 ; 2) server2,server3,server1 ; I need to be able to compare the two lists, and make sure that all the servers that exist in the first list, exist in the 2nd list. How can do this?
13:24  Riviera: !faq intersection
13:24  greybot: http://mywiki.wooledge.org/BashFAQ/036 -- How can I get all lines that are: in both of two files (set intersection) or in only one of two files (set subtraction).
13:24  Riviera: shai__: Check if that FAQ 36 gives some hints. Maybe using comm with tr , '\n'
13:28  shai__: Ok ... I'll read :)
13:34  shai__: Riviera: Problem is, I have actual lines that are as follows: server1.domain.com,server2.domain.com,server3.domain.com ; and then another line as follows: server3.domain.com,server1.domain.com,server2.domain.com ; and I need to make sure that all the servers in the first line exist in the latter line ...
13:35  shai__: I'm trying to use sort to sort the two lines... but I'm not sure how ...
13:38  erUSUL: # comm <( tr ',' '\n' <<< "server1.domain.com,server2.domain.com,server3.domain.com") <( tr ',' '\n' <<< "server3.domain.com,server1.domain.com,server2.domain.com")
13:38  evalbot: erUSUL: bash: comm: command not found
13:39  erUSUL: # grep -xF -f <( tr ',' '\n' <<< "server1.domain.com,server2.domain.com,server3.domain.com") <( tr ',' '\n' <<< "server3.domain.com,server1.domain.com,server2.domain.com")
13:39  evalbot: erUSUL: server3.domain.com
13:39  evalbot: erUSUL: server1.domain.com
13:39  evalbot: erUSUL: server2.domain.com
13:50  massimo: Hello. Is it better to write  bc < <(echo "4/2")  instead of  echo "4/2" | bc ?  Is the first faster in theory or is there a better variant?
13:50  nDuff: massimo, bc <<<"4/2"
13:50  massimo: I know about bc <<<"4/2"  but it needs to be bash-2.05 compatible.
13:51  nDuff: *shudder*
13:51  massimo: nDuff: Again, is < <() better than | ?
13:52  shai__: erUSUL: what is the output though that you got?
13:52  nDuff: massimo, I wouldn't use < <() in place of | in that case.
13:53  massimo: nDuff: Ok, I noticed < <() is compatible with old bash but not with old ksh.  | does work on all so I go for that..
13:53  shai__: erUSUL: does it show all the matching servers, ignoring all the different or non-existing servers?
13:54  shai__: erUSUL: is there a way to reverse that so that it only outputs the servers that don't exist in either of the lists?
13:54  nDuff: shai, the comm variant, certainly -- read the relevant FAQ page
13:54  shai__: ie. if nothing is outputted, then all is good, but if something does output, then that's both bad and I have the server's name right away.
13:55  nDuff: !faq 36 > shai__
13:55  greybot: shai__: http://mywiki.wooledge.org/BashFAQ/036 -- How can I get all lines that are: in both of two files (set intersection) or in only one of two files (set subtraction).
14:06  shai__: nDuff: got it working ...
14:06  shai__: # comm -3 <( tr ',' '\n' <<< "server1.domain.com,server2.domain.com,server3.domain.com" | sort ) <( tr ',' '\n' <<< "server3.domain.com,server1.domain.com,server2.domain.com" | sort )
14:07  evalbot: shai__: bash: comm: command not found
14:10  shai__: nDuff: the above command works like a charm.. but the problem is that if either of the above lists contains a server that doesn't exist in the other list, it will give me the output.. but then I would like comm to exit with status 1 and not 0
14:10  shai__: can that be done?
14:11  nDuff: shai, personally, I'd collect the output into an array and check its length; in bash 4, that's 2 lines.
14:11  nDuff: shai, ...that way you also have the collected output if  you happen to want to use it.
14:18  Riviera: shai__: sorry, I was away; is your problem solved? :)
14:24  shai__: Almost....
14:27  jeffroman: so im emailing 'who' during bashrc.  so i can see when someone ssh into the server
14:27  jeffroman: why doesnt it parse the new line?
14:28  jeffroman: my who is just a long string that looks terrible in the mail message
14:29  nDuff: jeffroman, if you don't tell us _exactly_ what you're doing, we can't comment on it.
14:29  nDuff: !exact
14:29  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
14:31  Ammler: easiest is copy&paste
14:32 * nDuff wouldn't be surprised if jeffroman is missing some quoting, and thus having his content string-split on IFS, but that's all guessing until he sees the implementation.
14:33  jeffroman: ok
14:33  c0nsense: hello!, i have an folders with so much .html files and if i use the command "grep -r "sites.serverlan.lan" ." it's show me so much results in .html files, how can i replace that are "http://sites.serverlan.lan/..." to "http://www.mydomain.com/..."
14:33  jeffroman: this is what i have in my bashrc
14:33  jeffroman: echo 'Login on' `hostname` `date` `who`| mail -s "Login on `hostname` `who | awk '{print $5}'`" name@domain.com
14:34  jeffroman: just curious why its just one long string, and doesnt have the \n
14:34  nDuff: jeffroman, ...yup, that's exactly what I suspected.
14:34  jeffroman: or even when i do this:
14:34  nDuff: !umq > jeffroman
14:34  greybot: jeffroman: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
14:34  jeffroman: echo `w` | mail -s "Alert: Shell Access" emailrobot@twocapstudios.com
14:34  nDuff: jeffroman, you're parsing the individual words out of the output of who or w, and passing them as individual arguments to echo, which emits its arguments each separated by a single space
14:35  nDuff: jeffroman, ...read the wiki pages the bot linked you to understand why and how to fix it.
14:35  jeffroman: nDuff:
14:35  jeffroman: ahhh
14:35  jeffroman: thanks
14:35  c0nsense: any ideas?
14:35  nDuff: !faq 21 > c0nsense
14:35  greybot: c0nsense: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
14:37  sybariten: hey, is a construction like        if [ ${FRAME_NO} -gt 0 ]    equally 'correct' for bash as for ksh ?
14:38  nDuff: well, without more quotes, that's not very correct
14:38  nDuff: doesn't do the right thing when FRAME_NO is empty
14:39  nDuff: !varcap > sybariten (also, as a matter of convention)
14:39  greybot: sybariten (also, as a matter of convention): By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
14:39  nDuff: sybariten, ...also, for code not intended to be compatible with POSIX sh, (( frame_no > 0 )) would be preferred.
14:41  sybariten: ok thanks
14:42  sybariten: hm, you dont need the dollar when written like that?
14:43  nDuff: correct
14:43  jeffroman: nDuff: this still doesnt address my problem
14:43  mrtnt: How to print all process numbers(PID's) in one columnt separated with newline. "ps -aux | awk '{}"
14:43  geirha: !pm > mrtnt
14:43  greybot: mrtnt: http://mywiki.wooledge.org/ProcessManagement
14:43  jeffroman: nDuff: do i have to append a \n to all my commands manually?
14:44  mrtnt: How to print all process numbers(PID's) in one columnt separated with newline. "ps -aux | awk '{printf $2}" or "top -n1 | awk '{printf $1}'" does not work :)
14:44  nDuff: jeffroman, ...huh?
14:44  mrtnt: geirha: thanks, I'll take a look
14:44  nDuff: mrtnt, look at pgrep
14:45  jeffroman: nDuff: im just echoing out who into the mail message, in terminal i get new lines, but not in the mail message
14:45 * nDuff sighs.
14:45  nDuff: jeffroman, running echo `who` is not the same as who
14:46  jeffroman: ok
14:46  nDuff: jeffroman, ...so if you're comparing between behavior in the terminal and your mail message, be sure you're comparing like to like.
14:46  c0nsense: i try grep -r "sites.serverlan.lan" . | sed -i 's/sites.serverlan.lan/www.blog.domain.com/g' but it show "sed: no input files" ???
14:46  nDuff: c0nsense, where does the FAQ tell you to run that command?
14:47  c0nsense: idk
14:48  nDuff: c0nsense, sed doesn't accept filenames on stdin, so you can't use it that way. Follow the FAQ.
14:49  nDuff: c0nsense, ...also note that the faq tends to pretty strongly recommend ed over sed for this purpose, for generally good reasons.
14:53  c0nsense: nDuff: but, how can i specify all files?
14:54  nDuff: c0nsense, see the examples in the FAQ which use find
15:00 --- greenmang0_ is now known as greenmang0
15:00  c0nsense: nDuff: i try it find -type f -exec sed -i 's@sites.serverlan.lan/wordpress@www.blog.domain.com@g' {} \; its run recursive?
15:02  nDuff: c0nsense, you're missing something in your find syntax there -- specifically, the directory to start searching from.
15:02  nDuff: c0nsense, also, that syntax only works with GNU sed; it'll break badly with BSD sed, as the FAQ describes.
15:02  nDuff: (and it'll break symlinks)
--- Log closed Mon Dec 06 15:16:27 2010
--- Log opened Mon Dec 06 15:21:48 2010
15:21 --- Users 536 nicks [0 ops, 0 halfops, 0 voices, 536 normal]
15:21  shal3r: for example
15:22  nDuff: geirha, ...welll, //foo is special in some (weird, bizarre, but not necessarily out-of-POSIX-spec) places
15:22  cthuluh: !pf in $( > shal3r
15:22  greybot: shal3r: http://mywiki.wooledge.org/BashPitfalls#pf1 -- Don't do this! -- for i in $(ls *.mp3)
15:22  cthuluh: !find > shal3r
15:22  greybot: shal3r: http://mywiki.wooledge.org/UsingFind
15:22  cthuluh: !faq deal > shal3r , also
15:22  greybot: shal3r , also: http://mywiki.wooledge.org/BashFAQ/020 -- How can I find and deal with file names containing newlines, spaces or both?
15:23  geirha: shal3r: bash can handle such files without any problems. You just need to learn how to iterate them and how quoting works.
15:23  shal3r: geirha, that's what i was looking for
15:23  shal3r: thank you!
15:23 --- Channel #bash was synced in 125 seconds
15:24  cthuluh: :>
15:26  geirha: nDuff: It's mostly just that PWD will start with two slashes ... which could be an issue in some rare cases.
15:27  sybariten: geirha: yeah, its great that multiples slashes dont destroy stuff (it seems), but its more readable, IMO, to have the slash explicitly written in a script, instead of being part of a variable...
15:28  geirha: sybariten: Indeed
15:28  nDuff: sybariten, indeed.
15:29  shal3r: looks like i got it working now. Thanks again
15:31  do0ob: hi
15:33  qwd: In bash commands aren't saved to history when you start with space, can I make it so it ONLY goes to history when starting with space?
15:38  poisonbit: qwd, maybe, see in man bash, HISTIGNORE and HISTCONTROL
15:38  qwd: poisonbit: thanks!
15:39  poisonbit: np, welcome
15:44  itr8r: got a challenge for ya
15:44  itr8r: ... is there a better way to do this:
15:44  itr8r: tee >(wc -c > fifo) < "$1" | cat fifo -
15:45  itr8r: need the count of bytes first, then the contents
15:45  itr8r: cant read the file more than once
15:45  koala_man: does that even work?
15:45  itr8r: because it might be a fifo
15:45  itr8r: koala_man: yes
15:46  itr8r: koala_man: actually im using it with your evalbot vm ;P
15:47  itr8r: $ ./runqemu <(echo 'grep bar') <(echo -e "foo\nbar")     bar
15:48 --- jzacsh is now known as jzacsh_
15:49  koala_man: itr8r: doesn't work here
15:49  koala_man: only happens to work for small files
15:49  itr8r: oh damn
15:50 --- ksk_ is now known as ksk
15:51  itr8r: koala_man: how big of a file did it fail with?
15:52  itr8r: hmm so it just hangs
15:55  itr8r: i dont see why though
15:56  koala_man: because tee tries to write to the files at the same time
15:56  koala_man: it won't try to infinitely buffer up data if one of the sources is slow
15:56  koala_man: one of the targets, I mean
15:56  itr8r: gotcha
15:57  itr8r: might as well just use perl or something then
15:59  koala_man: copy to a temp file
16:01  itr8r: i want it to be fast though
16:01  itr8r: thinking that having one stream without writing to disk would be faster
16:02  itr8r: perl -e '$/ = undef; $_ = <>; print length,"\n" ; print
16:03  itr8r: s/^/'
16:03  itr8r: err
16:03  itr8r: s/$/'
16:03  itr8r: :P
16:03  ritzt3ch: is there a way to see like a Debug view of all characters like Enter carriage returns spaces or Tabs
16:03  falconindy: ritzt3ch: if you have GNU coreutils, cat -A will show them
16:03  itr8r: ritzt3ch: how about cat -A ?
16:03  yitz_: cat -A
16:03  geirha: while IFS= read -r line; do ((size+=${#line})); printf '%s\n'; done < "$1"
16:03  ritzt3ch: only reason is for the life of me i cant seem to remove the newline character IF it is one (a hidden one i cant find lol)
16:04  ritzt3ch: var1=`echo "$rfhlvl" | sed -n 1p | tr -d '\n'`
16:04  ritzt3ch: i thought the tr - d '\n' will do but i still cant get rid of it
16:04  koala_man: ritzt3ch: sed -n l
16:04  ritzt3ch: not p
16:05  koala_man: ritzt3ch: that was for visual unambiguous output
16:05  Naib: echo -e "this\nis\na\nTEST" | sed ':a;N;$!ba;s/\n/ /g'
16:05  Naib: that gets rid of \n
16:05  geirha: ritzt3ch: The command substitution already removes trailing newlines
16:06  itr8r: ritzt3ch: maybe its a \r?
16:06  ritzt3ch: am i dealing with something else then
16:07  ritzt3ch: because when i combine them    rfhlvlhex1=$(echo "$var1$var2")  it will only show var2
16:07  geirha: sed -n 1p <<< "$rfhlvl" | od -tx1
16:07  geirha: See what that outputs ^
16:07  geirha: ritzt3ch: Then yes, probably a CR
16:07  geirha: !cr
16:07  greybot: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
16:08  ritzt3ch: kinda sounding dumb but what if i do a sed -r 1
16:14  ritzt3ch: in the script could i cat a $var
16:16  nDuff: ritzt3ch, it's not clear to me what you're intending to communicate.
16:16  ritzt3ch: trying to cat -e whats in a varaible because im trying to see carriage returns because its an output that generated within my script already
16:17  nDuff: ritzt3ch, cat doesn't print variable contents, ever; it concatenates files.
16:17  geirha: printf %s "$var" | cat -e
16:19  ritzt3ch: ^M$  thats what im getting lol
16:20  ritzt3ch: theres that hidden squirrle
16:20  greycat: !cr
16:20  greybot: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
16:27  ritzt3ch: woot thatnks for the printf thing :)
16:51  jww: hello !
16:51  katie: hi
16:52  bassliner: !ssh
16:52  greybot: Secure SHell (See #openssh, http://mywiki.wooledge.org/CategorySsh) - To run bash code remotely; adapt: ssh user@host bash <<< "$(printf 'echo %q' "$localVar")"
16:52  bassliner: hm. confusing example.
16:53  katie: i had a question about regex matching... I'm not sure how to use sed/awk for just matching (I know to substitute with sed, but I just want a boolean check for a match).. and I know I can do [[ "$foo" =~ pattern]], but this requires setting a flag to toggle between case sensitive and not right? well my pattern is pretty simple, in perl it could be done =~ m/\.[mM][pP]3$/ or =~ ,/\.mp3/i but im not sure how I can do this
16:53  katie: with bash
16:53  katie: its for a school assignment ~_~
16:54  katie: seems to get confused when I use square brackets for char classes
16:54  poisonbit: if grep -iq fooo file; then...
16:54  Naib: !homework
16:54  greybot: "I have to count the lines in a file. But I'm not allowed to use wc. And I'm not allowed to use grep. And I have to type it in using a teletype. With no paper in it. In the dark. Left-handed."
16:54  greycat: For starters, *always* put the regular expression in a variable, and use [[ $foo =~ $regex ]]
16:55  greycat: To make is non-case-sensitive, turn on the nocasematch option.
16:55  greycat: (it's a shopt)
16:56  lyhana8: hi, I try to use this variable in a rsync command: EXCLUDE='--exclude="*~" --exclude="*.bak" --exclude="*.old" '
16:56  greycat: !faq complex > lyhana8
16:56  greybot: lyhana8: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
16:56  greycat: or am I misreading the question...
16:56  lyhana8: but it failed, could it be that bash can't expand my var?
16:56  greycat: does rsync want literal double-quotes there?  I would tend to doubt it.
16:57  greycat: does it use that as an environment variable, or what?
16:57  katie: yeah I've been double-bracketing.. we never learned _why_ thats needed in bash, but ive picked it up from examples ;z
16:57  greycat: ![[ > katie
16:57  greybot: katie: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
16:58  greycat: katie: the important part of what I said was the use of   =~ $variable  rather than   =~ bunch\ of\ gibberish
16:58  katie: to get around confusing it with the square brackets?
16:58  greycat: To get around changes in the behavior of =~ in 3.x versions
16:59  greycat: And to avoid falling into various pitfalls like accidentally quoting an important part of the RE.
16:59  lyhana8: greycat: I guess literal double-quote aren't what it expect
16:59  katie: oic
16:59 * greycat searches for EXCLUDE in the rsync man page and does not find it, except in headers
16:59  greycat: So I must conclude that this is NOT an environment variable that rsync recognizes....
17:00  greycat: So I think I was right the first time.  You're attempting to put complex command options in a variable and then expand that variable via the shell.
17:00  greycat: Stop doing that.  Read the URL the bot gave.
17:01  lyhana8: I'm reading :)
17:03  katie: but, since i was asking, is there a way to use sed/awk to simply _match_ the text, and evaluate the match as true within the script?
17:03  greycat: ask #awk or ##sed
17:03  katie: i could use perlre too i guess but im not sure how available it is
17:04  greycat: Or, tell us what you're attempting to do.
17:04  katie: like i said, if i have a situation where i want to do like
17:05  katie: if [ foo matches pattern ]; then ...
17:05  greycat: What is "pattern"?
17:05  katie: any pattern o_o
17:05  greycat: And you need [[ for pattern-matching, not [.
17:05  greycat: DEFINE THE FUCKING PATTERN.
17:05  nDuff: katie, "pattern" meaning a regular expression? a glob?
17:05  nDuff: katie, ...if it's a regex, which syntax?
17:05  greycat: "Begins with a"?  "Is all digits"?
17:05  katie: sorry, a regular expression
17:05  greycat: Why does it have to be an RE?
17:05  nDuff: standard? extended? perl-compatible?
17:06  katie: preferably a perly syntax since thats what Im most familiar with
17:06  greycat: *sigh*
17:06  greycat: You're not actually interested in anything we say.
17:06  katie: eh?
17:06  greycat: You want THE UBERSOLUTION TO ALL PROBLEMS EVAR(tm) instead of something sane for the problem you are ACTUALLY solving.
17:06  greycat: !cult
17:06  greybot: The Cult Of The Regex. This eldritch brotherhood is dedicated to the dogma that Every Problem Must Be Solved By A Regular Expression, Preferably A PCRE. They will invent ludicrous problems whose only feasible solution is a regular expression, driving all men mad.
17:07  katie: well, for my homework I am solving it with the builtin bash regex
17:07  katie: but I was asking hypothetically
17:07  greycat: What is "it"?
17:07  nDuff: katie, if [[ $foo =~ $pattern ]] does what you want with extended regular expressions, as greycat told you quite a while back.
17:07  katie: I just needed to find out if a filename ends with some variation of .mp3
17:07  greycat: if [[ $filename = *.[Mm][Pp]3 ]]
17:07  katie: eg case insensitive
17:07  greycat: NO NEED FOR AN RE HERE!
17:07  greycat: Note that I used = NOT =!
17:07  jww: but with a RE it would looks elite.
17:07  greycat: NOT =~ either
17:07  jww: :)
17:08  katie: well, i didnt know you could do that with shell globbing!!
17:08  greycat: And if you want it portable, you can do it with case.  Again, using GLOB syntax, not RE.
17:08  greycat: 95% of the real-world problems can be done with globs and do not require REs.
17:09  katie: hm i see
17:09  katie: but as you know, homework rarely reflects real life :p
17:09  greycat: That's why we have to know what the problem is.
17:11  katie: well the actual assignment is like, "write a script that takes <source directory> and optionally <output directory> (or PWD if not specified), read ID3v1 tags for files ending with .mp3 in that directory, create folders for artists, ls -s <sourcefile> <artist>/<dst file>, and write a log of all this in an XHTML file
17:11  lyhana8: greycat: actually there is a --exclude-from=FILE comand that can replace what I was trying to do :P
17:11  katie: "
17:11  greycat: katie: for file in *.[Mm][Pp]3; do
17:12  greycat: parsing the ID tags will be the hard part, unless your professor has provided a better tool for doing this than any I know of
17:12  katie: neh thats pretty easy
17:12  katie: for id3v1
17:12  greycat: Suuuuure....
17:12  katie: `tail -c 128 $mp3`
17:12  greycat: Oh my... *raw*?
17:12  katie: they're all fixed width fields
17:13  greycat: Interesting.
17:13  katie: yeah, it might not work well depending on locale and stuffd
17:13  katie: but i dont think we have to worry about it
17:13  greycat: Most people attempt to use "tools" for it, like id3v2 -l or whatever.  And those all suck.
17:14  katie: thats probably why were doing ID3v1, since its much simpler to work with
17:15  greycat: Also, be sure to quote your variables.  "$mp3" not $mp3.
17:17  guampa: you can evaluate a match as true using [[ -z $(sed -n '/someregex/p') ]]
17:18  katie: ah i thought -z would do it
17:18  greycat: But why WOULD you?
17:18  katie: but i couldnt make it work
17:18  katie: ;o
17:18  guampa: because you can?
17:18  katie: well personally i think regular expressions are easier to understand than shell globbing
17:18  greycat: If the task is "do stuff to all files ending in .mp3, case-insensitive" then EVERY APPROACH that is not   for file in *.[Mm][Pp]3   is wrong.
17:19  guampa: dunno why bash doesn't support regex as an option besides normal globbing syntax
17:19  greycat: Because Chet is not part of the Cult.
17:19  koala_man: it does, shopt -s extglob
17:20  guampa: oh
17:20  greycat: koala_man: hah, you know fully well they meant "in something approximating ERE's syntax"
17:20  koala_man: of course >=)
17:20  Dieterbe: Hey guys, i think i'm having a weird scoping issue. is it possible that when you source a file (which sets a variable) , then you do a whole bunch of other stuff (but not unsetting the variable) to ultimately call a function which uses said variable, but the variable is not set anymore?  note that this function is also sourced (not run like ./script.sh or something), so afaik all should be in the same scope
17:20  Dieterbe: i'm pulling my hair out over this issue.
17:21  Dieterbe: if you want to know the background.  the function is get_possible_fs and the variable is $filesystem_programs @ https://github.com/Dieterbe/aif/commit/2c5994e359da4299ffb0a9e7f3f338002677a904
17:21  Dieterbe: note that page shows a bug on line 85 (fs instead of $fs), but that's unrelated
17:22  greycat: Dieterbe: can you shrink the problem down to something that's WAY smaller than 85 linse?
17:22  Dieterbe: i perform debugging in get_possible_fs and verify that "${!filesystem_programs[@]}" and "${filesystem_programs[@]}" expand to nothing
17:22  Dieterbe: greycat: actually, that commit is only a part of the code.  it's about 3k lines of bash in total, actually.
17:22  greycat: If those expand to nothing, it just means the array has no elements.
17:23  greycat: Dieterbe: isolate the 3 or 4 lines that actually matter.
17:23  Dieterbe: weirdly enough, if i just source that file on commandline and run the function manually, it works fine
17:23  Dieterbe: this is the problem... "something" is causing the variable to be not set anymore.  but i checked throughout the code, nowhere is the variable being unset or something
17:23  Dieterbe: the problem lies somewhere in those 3k lines of bash
17:24  greycat: Start removing lines until it goes away.  Then start putting lines back.
17:24  krzee: prolly eating it in a subshell
17:25  krzee: or maybe not exporting it TO a subshell
17:25  Dieterbe: krzee: a subshell inherits all vars from the parent, no?
17:25  greycat: Dieterbe: yes
17:25  krzee: if they are exported, yes
17:25  greycat: krzee: incorrect.
17:26  Dieterbe: ~  var=foo; (echo $var)
17:26  Dieterbe: foo
17:26  krzee: when what i say != greycat, listen to him
17:26  fstping: when i do echo "${test[5]} b" .. (where test[5] == XYZ@test.com) the output becomes ' bZ@test.com'.. what could cause that?
17:26  Dieterbe: krzee: haha, ok
17:26  greycat: !cr > fstping
17:26  greybot: fstping: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
17:27  greycat: You have a literal carriage return byte in the array element.
17:27  fstping: ye i think i do actually
17:27  fstping: didnt think it would affect it like that tho
17:28  fstping: i current read a .csv created in windows with: while IFS="," read -r test test2 _ test3; do
17:28  fstping: currently*
17:29  fstping: should i do that any differently to not pick up the \r ?
17:29  greycat: Either whack the CRs from test3 each iteration, or read from something like <(tr -d \\r < file)
17:29  fstping: alright i'll try it out
17:31  fstping: awesome. thank you greycat
17:38  rocktop: I have this  if [[ -f $fullpath ]] work in command line but it doesn't work when I run it from script.sh why ?
17:38  greycat: !sh
17:38  greybot: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
17:39  nDuff: !.sh > rocktop (as an aside)
17:39  greybot: rocktop (as an aside): Don't use extensions for your scripts. Executables shouldn't have extensions. Just like you run 'ls' instead of 'ls.elf', you should run 'myscript' or './myscript', not 'myscript.sh'. In any case, putting 'sh' extensions on *bash* scripts (which are *not* sh scripts) is retarded.
17:39  rocktop: greycat, yes I have '#!/bin/sh' at the top and I run with sh
17:39  nDuff: rocktop, yes, that's your problem
17:39  nDuff: rocktop, ...as greycat told you.
17:39  nDuff: rocktop, [[ ]] is a bash-only feature
17:40  rocktop: nDuff, same problem
17:41  nDuff: !exact > rocktop
17:41  greybot: rocktop: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
17:41  greycat: rocktop: what are you typing on your keyboard to RUN the program?
17:43  nDuff: rocktop, ..."same problem" doesn't tell us what you changed, what the message you're getting was or is, or anything else of interest or use. "same problem after I changed the shebang to #!/bin/bash" or "same problem after I started running my script as 'bash foo'" would actually be something useful.
17:44  nDuff: (though it leaves out the definition of what that "same problem" is in the first place -- we've never been given a specific error message or description of the undesired behavior, and are thus relying on experience and guesswork)
17:47  rocktop: nDuff,  http://pastebin.com/DEaUtr9V
17:48  sybariten: ok... so... is $? a ksh-only thing or does it exist in bash ?
17:48  nDuff: !questions > rocktop
17:48  greybot: rocktop: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
17:48  nDuff: !set-x > rocktop
17:48  greybot: rocktop: Setting the -x option on bash enables a debugging mode that makes bash output the command name and arguments that it will run (after all parsing and expansion has been applied). Set it by starting a script with ''bash -x ./myscript'' or putting ''set -x'' before the code you want to debug. ''set +x'' turns this behaviour off.
17:48  nDuff: !$? > sybariten
17:48  greybot: sybariten: The special parameter ? (you use $? to expand it) contains the exit status of the previous command, an integer from 0 to 255 inclusive. In general, an exit status of 0 implies success (or "true") and non-zero implies failure ("false").
17:49  nDuff: rocktop, use set -x to see what's actually being run
17:49  taylanub: is >&- practically the same as >/dev/null ?
17:49  taylanub: (same goes for <&- and </dev/null)
17:50  duper: i don't think so
17:50  sybariten: nDuff: "the previous command", you say... hmm
17:50  duper: >/dev/null is redirecting to /dev/null
17:50  sybariten: nDuff: do you know where i can read more on this?
17:50  duper: >&- is actually close()'ing FILENO_STDOUT iirc
17:50  taylanub: duper: hence why i said "practically"
17:50  sybariten: or, what is a good search keyword
17:50  taylanub: i.e. would they ever produce different behaviour
17:50  duper: yes
17:51  duper: cuz now that file descriptor isn't even associated with that tty anymore
17:51  taylanub: sybariten: man bash
17:51  rocktop: nDuff, ++ fullpath=$'/home/albse1/public_html/bas.zip\r'
17:51  nDuff: rocktop, ahh -- there's your problem
17:51  taylanub: !wiki > sybariten
17:51  greybot: sybariten: http://mywiki.wooledge.org/ - http://bash-hackers.org/wiki/
17:51  nDuff: rocktop, your script has a DOS newline at the end of the filename
17:51  duper: you won't be able to ioctl() on it or anything
17:51  nDuff: rocktop, ...and your actual file doesn't.
17:51  rocktop: nDuff, what I do
17:52  nDuff: rocktop, ...don't use stupid Windows tools to edit your scripts?
17:52  taylanub: duper: ok, thanks. i guess i should use /dev/null to ensure that applications behave sane
17:52  sybariten: hm, so does the shell always know whether the "last executed command" went allright or not?
17:52  nDuff: rocktop, (also, see dos2unix, or vim's :set fileformat=unix command, or the like)
17:52  duper: taylanub: yeah so just an example
17:53  taylanub: sybariten: commands return exit codes. from 0 to 255. 0 is considered success by the shell, everything else is considered failure
17:53  duper: when you use /usr/bin/write on Solaris it tests stdin (fd 1) to tell the target user which tty you're coming from.. if you close it, it'll say "no tty"
17:53  rocktop: nDuff, can I do that automaticly by a command to remove any DOS newline characters ?
17:53  sybariten: taylanub: interesting
17:53  nDuff: rocktop, ...I already gave you two commands to do that.
17:53  duper: but if you redirect it to /dev/null it still knows what tty you're on
17:54  nDuff: rocktop, ...there's also tr -d '\r' if you need a third.
17:54  duper: it just won't be able to write them anything since you closed it (null message)
17:54  taylanub: duper: ok, thanks for the explanation.
17:55  sybariten: is there anything obviously wrong with this line? i'm getting an error :   if (( $? != 0 )) then
17:56  koala_man: bash requires a ; or line feed before the 'then'
17:56  sybariten: aaaaaaaaaaaaah
17:57  nDuff: sybariten, that said, why would you do that?
17:57  nDuff: sybariten, instead of doing foo and then if (( $? != 0 )) ; then ...
17:57  sybariten: nDuff: its checking if the previous ffmpeg-run went OK, i _think_
17:57  nDuff: sybariten, ...just do if ! foo ; then ...
17:57  paideia: hi, Im doing: unzip *zip and getting: caution: filename not matched. Why??
17:57  nDuff: sybariten, yes, but it's silly to use $? instead of just putting the thing you're trying to run inline with the if
17:58  nDuff: paideia, unzip only takes one zip file on its command line
17:58  nDuff: paideia, ...read the man page for usage
17:58  paideia: nDuff, thanks
17:58  nDuff: paideia, ...other arguments are files to be unzipped _from_ that zip file.
17:58  sybariten: nDuff: oh you mean there can be an if statement and an ! infront of the actual chunk of code i want to do? And it will be executed
17:58  nDuff: sybariten, exactly.
17:58  sybariten: nDuff: ok, it feels a bit more backwards to me
17:59  nDuff: !if
17:59  greybot: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
17:59  nDuff: sybariten, ...read the fine wiki.
18:00  sybariten: alrite
18:03  ChrisBuchholz: Hi. I read every line of a file like "while read firstword, secondword" and so on. What i really want is to have a "firstword" and "everythingelse" variables. How would i do that?
18:03  Uqbar: while read firstword alltherest
18:03  greycat: while read firstword everythingelse
18:04  ChrisBuchholz: Uqbar & greycat: oh sorry - i do that, just mis-rewrote: "while read firstword secondword". But secondword only contains _the-second-word_
18:05  greycat: ChrisBuchholz: incorrectc.
18:05  Uqbar: if there are only two words on the line, ChrisBuchholz
18:05  greycat: # read one two <<< "a lot of words"; echo "one=<$one> two=<$two>"
18:05  evalbot: greycat: one=<a> two=<lot of words>
18:07  ChrisBuchholz: Uqbar & greycat & evalbot: yeah, its not working for me ... hmm. Would there be any characters that would "stop" the default behavior?
18:07  greycat: !exact
18:07  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
18:10  ChrisBuchholz: greycat: okay, i see that it works when i just type it on shell, but it doesnt in my program
18:10  greycat: *sigh*
18:10  greycat: You are claiming that something that has been IN THE SHELL FOR FORTY YEARS is not working.  You have to prove such a bold thing.
18:11  ChrisBuchholz: greycat: i am trying to :P
18:11  ChrisBuchholz: greycat: but i first need to find out where it breaks, you know
18:11  greycat: If you'd just fuckin' SHOW the line, we could show you !faq disappear or whatever you're doing wrong.
18:12  ChrisBuchholz: greycat: well, this is line: http://pastebin.com/FwETfqtL
18:12  nDuff: !pastebin > ChrisBuchholz
18:12  greybot: ChrisBuchholz: Paste the *relevant* code: http://pastie.org/ - http://pastebin.ca/ - http://sprunge.us/ - http://pastebin.bash-hackers.org/
18:12  nDuff: errm
18:12  nDuff: no
18:13  nDuff: greycat, which is the "don't use pastebins" factoid?
18:13  greycat: A one line pastebin
18:13  greycat: JESUS CHRIST
18:13  greycat: Here's what it says:
18:13  greycat: tail -f .irssi/fnotify | while read header message; do
18:13 * nDuff sighs.
18:13  Uqbar: what is in .irssi/fnotify?
18:13  nDuff: !faq disappear > ChrisBuchholz
18:13  greybot: ChrisBuchholz: http://mywiki.wooledge.org/BashFAQ/024 -- I set variables in a loop. Why do they suddenly disappear after the loop terminates? Or, why can't I pipe data to read?
18:13  greycat: And here's the !faq disappear we promised:
18:13  greycat: Ah, beaten.
18:13  ChrisBuchholz: if i then attack it with $header and $message, in my program $message only contains a word, but on the shell it works perfectly
18:13  greycat: !umq > ChrisBuchholz
18:13  greybot: ChrisBuchholz: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
18:14  nDuff: ChrisBuchholz, READ the faq.
18:14  greycat: I bet it's UMQ.
18:14  greycat: He probably calls myfunc $message and myfunc uses $1
18:14  nDuff: seems likely
18:14  Uqbar: clearly our fault for not divining it.
18:14  nDuff: !set-x > ChrisBuchholz
18:14  greybot: ChrisBuchholz: Setting the -x option on bash enables a debugging mode that makes bash output the command name and arguments that it will run (after all parsing and expansion has been applied). Set it by starting a script with ''bash -x ./myscript'' or putting ''set -x'' before the code you want to debug. ''set +x'' turns this behaviour off.
18:16  nDuff: ChrisBuchholz, ...maybe with PS4=':${LINENO}+' if you want to make it a little easier to see where things are.
18:16  ChrisBuchholz: nDuff & greybot: i'm just digging through what you have wrote. Taking some time though
18:19  Dieterbe: greybot, krzee can you have a look at this: http://fpaste.org/Be8u/ look first at the output. lines 76 to 79, then you'll notice these statements are very close to each other. that is, they are triggered on line 48 and then 28
18:20  greycat: So there are 6 relevant lines?  Then why are the other 73 lines there?
18:20  Dieterbe: so one function calls another.  in the child function the sourcing happens, and it knows the variable.  then it returns back to the parent function, where the variable is empty again
18:20  Dieterbe: to give you some context
18:20  greycat: I'm not seeing what the bug is.
18:21  Dieterbe: me neither.
18:21  greycat: I mean, what did you EXPECT?
18:21  ChrisBuchholz: greycat & nDuff: okay, thank you for your help guys. The page about quotes did the work :)
18:21  Dieterbe: that the call on line 29 calls get_possible_fs, which prints "  ->: mkfs.vfat lvcreate mkfs.ext3 mkfs.ext2 vgcreate mkswap mkfs.ext4 mkfs.nilfs2 mkfs.jfs mkreiserfs cryptsetup pvcreate mkfs.xfs"
18:22  greycat: Fucker's actually going to make me go to a 79+ line pastebin, isn't he...
18:22  nDuff: !questions > Dieterbe (note the bit about coming up with a minimal example that demonstrates the problem)
18:22  greybot: Dieterbe (note the bit about coming up with a minimal example that demonstrates the problem): Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
18:22  Dieterbe: hey no need to offend
18:23  poisonbit: noot ofend, usually finding the smallest sample code, you will find the bug
18:23  Dieterbe: i'm struggling with this issue the entire afternoon.  and i cannot cut it further without breaking my program
18:24  greycat: If you have function A which calls function B which declares a variable, and that variable is local to B, why would you expect it to be visible in A?
18:24  Dieterbe: oh damn, it's because of the declare, right
18:25  Dieterbe: now i see the issue..
18:26  nDuff: Dieterbe, I don't understand why you couldn't have demonstrated with just one line
18:26  nDuff: Dieterbe, ...for instance: func_a() { declare b; b=5; }; func_b() { func_a; echo $b; }; func_b
18:27  Dieterbe: because back then i had no idea the declare was the problem..
18:27  nDuff: then you would have figured it out in the process of creating that example
18:27  Dieterbe: no, because i can only reproduce it by keeping some of my code intact
18:28  greycat: The goal is to reproduce the PROBLEM in an isolated environment/setup.
18:28  greycat: Not to reimplement your entire application.
18:42  Dieterbe: hmm, associative arrays since bash v4 are really cool, but the fact that you must use `declare -A` (and hence, making them inherently local) is quite a burden
18:42  greycat: bash 4.2 will allow you to declare global variables
18:42  nDuff: Dieterbe, declare them outside of function scope
18:43  greycat: yes, that's the workaround for 4.0-4.1
--- Log closed Mon Dec 06 18:57:59 2010
--- Log opened Mon Dec 06 18:58:27 2010
18:58 --- Users 549 nicks [0 ops, 0 halfops, 0 voices, 549 normal]
18:58 --- Server: [jordan.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
18:59  ish10: hey guys whats the command to kills the bash scrip from the bash script
19:00  ish10: is it return 0?
19:00 --- Channel #bash was synced in 130 seconds
19:00  cthuluh: exit
19:01  cthuluh: ish10: ''help exit''
19:01  cthuluh: or kill $$, if you really want to kill it
19:01  ish10: whats the diff?
19:02  taylanub: 'kill' actually sends signals to processes
19:02  cthuluh: kill sends SIGTERM to the current shell process, whose PIS is stored in the special variable $$
19:03  cthuluh: PID*
19:03  taylanub: the script can do whatever it wants when it receives a specific signal (excet 9 aka SIGKILL). the 'exit' command makes the shell exit with a given exit code. quite different things, essentially
19:04  richardbronosky: ish10: signal handling example: https://github.com/RichardBronosky/tools/blob/master/bash.patterns/bash.signaltrap.sh
19:05  ish10: I have a more difficult question. Lets say i start a process which requires input, like a yes/no or a password. How can I automate that response in bash?
19:05  richardbronosky: expect
19:06  richardbronosky: !expect
19:06  greybot: http://expect.nist.gov/ -- a Tcl package for driving interactive terminal-based programs
19:06  nDuff: or pexpect, if Python is more your thing than TCL
19:06  nDuff: ...but it's NABQ either way
19:06  richardbronosky: nDuff: Ooooo, nice thanks!
19:07  taylanub: often just pushing text to the process' input suffices
19:07  alek{xmb}{bottz}: yo
19:08  richardbronosky: I'm already skeptical.
19:09  ish10: how about perl? i know perl alot
19:10  nDuff: ish10, *shrug*; search CPAN
19:10  nDuff: !nabq > ish10
19:10  greybot: ish10: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
--- Log closed Mon Dec 06 19:20:25 2010
--- Log opened Mon Dec 06 19:20:50 2010
19:20 --- Users 550 nicks [0 ops, 0 halfops, 0 voices, 550 normal]
19:22 --- Channel #bash was synced in 126 seconds
19:23  alek{xmb}{bottz}: again: http://xmb.root.pe/def.koud.sch + bye
19:25  AlexC_: morning
19:25  AlexC_: is it possible to do extended globs recursively?
19:26  greycat: what do you mean?
19:26  greycat: if you mean nested a la +(x*(y)) then yes.
19:26  AlexC_: essentially to replace: for file in $(find . -name "*.php" -o -name "*.html" -o -name "*.txt"); do
19:27  greycat: Oh, you mean globstar.
19:27  greycat: I've never tried, but I don't know of any reason that globstar would fail to operate with extglobs.
19:27  AlexC_: globstar is a bash 4 feature (for recursion, at least)?
19:28  greycat: yes
19:29  AlexC_: hum, I'll have to stick to the find then
19:30  taylanub: $(find ...) is generally bad, AFAIK
19:31  greycat: I'm hoping he was only using that as a vague description, not literal code.
19:31  AlexC_: hence why I'm looking into alternatives :)
19:31  AlexC_: no that is the current code
19:40  ritzt3ch: is tehre a way to save once to a variable BUT also show Whiles its running on the screen
19:40  ritzt3ch: out=`/usr/local/bin/switch/ports.exp $ip1 2> /dev/null`  this is what i have now
19:40  greycat: you need to pipe through tee.
19:41  greycat: out=$(ports.exp "$ip1" 2>&1 | tee /dev/stderr)   or similar (relies on an OS providing /dev/stderr, not standard)
19:41  greycat: and also...
19:41  greycat: !faq 9
19:41  greybot: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
19:41  ritzt3ch: what about not seeing the ERROr output could i still put dev/null
19:42  greycat: sure, whatever
19:45  chovy: i'm limited to bash 3.00 and this line is failing: do files+=("$file");
19:45  greycat: += is 3.1
19:46  greycat: keep an index variable and use files[i++]=$file
19:47  mattalexx: If you look at the examples here: http://www.bo.infn.it/alice/alice-doc/mll-doc/linux/scripts/node5.html , You will see that empty lines are commented out. Why?
19:47  greycat: How would we know?
19:49  pgas: there is no reason besides "because the author liked it this way"
19:50  mattalexx: pgas, Gotcha
19:57  mattalexx: I'm trying to check if a variable has been set, then exit with an error if it's not. I've come up with the following: [[ -z "${DIR+y}" ]] && echo "-d needs to be set like '2010-12-06_11-29-15'" 1>&2 && exit 1
19:57  mattalexx: Is there a better way to do this?
19:57  greycat: && { echo; exit; }
19:57  greycat: otherwise, your check looks good
19:58  greycat: it's very similar to what we have in our FAQ
19:58  mattalexx: So ..   [[ -z "${DIR+y}" ]] && { echo "-d needs to be set like '2010-12-06_11-29-15'" 1>&2; exit 1 }
19:58  greycat: needs a ; before }
19:58  mattalexx: So ..   [[ -z "${DIR+y}" ]] && { echo "-d needs to be set like '2010-12-06_11-29-15'" 1>&2; exit 1; }
19:59  greycat: !faq defined > if you're curious
19:59  greybot: if you're curious: http://mywiki.wooledge.org/BashFAQ/083 -- How do I determine whether a variable is already defined?  Or a function?
19:59  mattalexx: greycat, Thanks
20:01  a4f0: is there a way to sort by line length?
20:01  twkm: yes.
20:01  greycat: prefix each line with the length, pipe to sort -n, and then strip off the first field
20:02  a4f0: thanks!
20:02  Dmole: careful to use "0001" not "1"
20:03  greycat: Not if you use -n
20:03  Dmole: yah *if not using -n
20:04  mattalexx: I can'
20:05  mattalexx: t figure out how to Google this question: What's the difference between [ -a "$FILE" ] and [[ -a "$FILE" ]] ?
20:05  greycat: ![[
20:05  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
20:05  greycat: In that particular example, no real difference.
20:06  twkm: ''help [''
20:07  mattalexx: greycat, thanks again for your help.
20:09  mattalexx: In bash, is there a way to detect whether a file is incomplete (being downloaded)?
20:09  greycat: No.
20:09  greycat: !upload
20:09  greybot: If you're asking "How can I find all the files that have been uploaded recently?" then you're probably in deep trouble. The server side can't tell when a file is finished uploading unless the client renames it or uploads an "all done" file afterward.
20:09  mattalexx: greycat, Thank
20:09  mattalexx: s.
20:11  DrSlony: Hey, I have a file with a list "ABC - XYZ", where ABC and XYZ are changing chars seperated by " - "
20:11  greycat: while read a _ b; do ...
20:12  DrSlony: i need to turn that into a list like "imagemagick bla ABC XYZ foo bar"
20:12  DrSlony: removing the dash
20:12  DrSlony: whats the best tool for the job?
20:12  yitz_: !pe
20:12  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
20:12  greycat: while read a _ b; do echo "imagemagick bla $a $b"; done
20:14  greycat: !faq 1
20:14  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
20:14  DrSlony: greycat: how do i turn "read a _ b" to read lines from this text file?
20:14  tm512: ")syntax error in expression (error token is ":victim.lostsignalnetwork.com
20:14  DrSlony: ok :]
20:14  tm512: what might that error mean?
20:14  greycat: It might mean you have a syntax error.
20:14  tm512: im trying to make an irc bot and that happens when i try to pong the server
20:15  tm512: i can pastebin real quick
20:16  twkm: DrSlony: have you considered faq #1 and parameter expansion?
20:16  twkm: tm512: test doesn't understand your weirdo moon language.
20:16  twkm: (use quotes)
20:16  greycat: Doesn't even need parameter expansion, at least not in the sense that's more difficult than "echo foo $bar"
20:17  DrSlony: twkm: im reading it now
20:17  tm512: i have used quotes, i think
20:17  tm512: lol
20:17  twkm: i am guessing he is lying about the total formatting, such that whitespace may exist in abc or xyz.
20:17  mspalmer1: Could somebody help me with a really really simple web script?
20:17  twkm: so far.  no.
20:18  tm512: http://victim.homeip.net/users/tm512/bot.sh
20:18  tm512: its very untidy at the moment :/
20:18  greycat: Let me guess... he pasted the ENTIRE script instead of the one broken line?
20:19  tm512: i dont know the exact broken line
20:19  tm512: well, i guess if it is test
20:19  tm512: if [[ `echo "$1" | grep -e "^PING\ *:\(.*\)"` -ne "" ]]
20:19  greycat: You don't use -ne inside [[.
20:20  greycat: Use != instead.
20:20  tm512: it errored with that
20:20  greycat: (And if you DID use -ne inside [ you'd give it a NUMBER, not an empty string.)
20:20  greycat: !ifgrep > tm512
20:20  greybot: tm512: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
20:21  tm512: so use "if grep -e "blah blah"; then..."
20:22  greycat: if grep -q "^PING:..." <<< "$1"; then
20:22  katie: wow
20:22  katie: the manpage for find(1) is awesome
20:22  greycat: !find > katie
20:22  greybot: katie: http://mywiki.wooledge.org/UsingFind
20:22  katie: "-L This option is supported."
20:22  katie: lol
20:23  mspalmer1: Can somebody give me a hand with learning how to make a web script?
20:23  mspalmer1: I need to execute 'df -h' via a web script
20:23  greycat: #!/bin/sh
20:23  greycat: echo "Content-type: text/plain"
20:23  greycat: echo
20:23  greycat: df 0h
20:23  nDuff: katie, in the "standards compliance" section, that seems perfectly fine
20:23  nDuff: katie, ...up in the OPTIONS section, it describes what -L _actually does_, which is probably what you're looking for.
20:26  tm512: greycat: thanks, it doesnt error out now
20:27  katie: meh its not working anyway ^_^
20:27  katie: bleh
20:27  tm512: still dont know whether it pings the server back, but thats a different issue
20:29  tm512: well, works great, much appreciated
20:35  nDuff: katie, ...if you care to give a more detailed description than "not working" (ideally -- what you're doing, what you expect, and what you actually get), we might be able to help.
20:35  katie: neh thats cool
20:35  katie: its just painful given how many options find has and that its picky about where they appear
20:36  katie: if thats on an exam im going to stab someone
20:36  katie: :0
20:36  greycat: The GNU man page is less than adequate in many places.
20:36  lordgreg: hi all. i'm having difficulties printing directories with spaces with awk like this (prints date+directory name. ends after 1st word if it has spaces) --> ls -ltd /home/Public/@Trash/*/ | head -n 5 | awk 'BEGIN {print "Datum\t\t Naslov\n---\t\t ---";}{print $7, $6, $8, "\t", $9;}' <--- $9 being obviously 1st word in directory with spaces. Is there such thing as just typing $9+ or something?
20:36  greycat: #awk
20:36  katie: im almost done though, at least
20:36  katie: mwahaha.
20:37  lordgreg: sorry & ty greybot
20:37  lordgreg: *greycat
20:41  DrSlony: Thank you greycat and twkm
20:43  twkm: cool.
21:06 --- y3llow_ is now known as y3llow
21:06 --- cuba33ci_ is now known as cuba33ci
21:08 --- silverra1ndog is now known as silverraindog
21:20  aggrav8d: hi, bash.
21:21  markdark: hi
21:23  katie: fuck
21:24  katie: when you guys were in school
21:24  katie: did you have to satisfy really poorly written scripts in order to submit your work to get graded
21:24  katie: it is the most picky crap
21:24  aggrav8d: I have a file with space-separated values, return delimited: name ip user pass.  I want to test which of the 100-some odd accounts are still valid FTP user/pass combos.  Would one of you kind souls please help me?  I'm sure such a script exists already.
21:24  katie: "omg you used background-color: ... instead of background: in CSS, YOU FAIL"
21:24  Riviera: katie: Apologies.
21:24  greycat: We didn't have CSS.  Or a world wide web.
21:25  aggrav8d: katie - i learned in the streets.
21:25  katie: well its just an example
21:25  katie: damn it is annoying 8D
21:25  aggrav8d: i only need to satisfy the w3c validator.
21:25  katie: that was part of the assignment too
21:25  katie: heh
21:25  katie: D:
21:27  markdark: aggrav8d: you can start with: name=$(cat yourfile | awk '{print $1}')
21:27  greycat: !uuoc
21:27  greybot: Useless Use of Cat (cat foo | grep bar). See http://partmaps.org/era/unix/award.html
21:27  greycat: !faq 1 > aggrav8d
21:27  greybot: aggrav8d: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
21:27  markdark: and with print $2 you have the ip in a variable
21:27  markdark: etc etc
21:27  greycat: while read name ip user pass; do ...
21:28  greycat: markdark: incredibly suboptimal.
21:28  markdark: that is
21:28  markdark: but i am learning
21:28  markdark: :)
21:28  greycat: while read name ip user pass; do ...; done < file
21:33  markdark: greycat: that's my best award ever ;)
21:46  thieusoai: how do I move a list of files  to a dir  ?   e.g.,   mv  [f1.txt f2.txt]  dir  ?
21:46  yitz_: mv f*.txt dir
21:46  yitz_: mv f1.txt ... f5.txt dir
21:46  TheBonsai: just name the files, single or by glob
21:47  thieusoai: yitz_, if they don't have the same name,  e.g.,   mv  [a.txt 1.c  bc.h]  dir   -- then I can't use  *
21:47  greycat: thieusoai: get rid of the damned brackets.
21:47  yitz_: Just drop the []'s
21:47  greycat: mv a.text 1.c bc.h dir
21:47  thieusoai: oh
21:48  thieusoai: I thought that would rename a.text to 1.c
21:48  nDuff: thieusoai, no; the last argument given to mv is the destination
21:48  nDuff: (unless -t is in use, but that's a completely different story)
21:48  thieusoai: ic -- thanks   -
22:07  aggrav8d: markdark - ok, i can parse the file and get the values I want.  i'm trying to FTP to each account without much success.  http://pastebin.com/4FH90iBv
22:07  aggrav8d: any ideas?
22:07  greycat: !lftp
22:07  greybot: $ lftp myname@server/some/directory -e 'mput *.gif; quit' # Read "man netrc" to learn how to store your password as cleartext in a file, and read http://mywiki.wooledge.org/FtpMustDie
22:09  aggrav8d: thanks greycat, but that's not really helping :)
22:10  aggrav8d: i don't actually want to transfer a file.  i just want to test if my login is valid.
22:11  greycat: I'm sure you can figure out a way.
22:13  markdark: aggrav8d: http://www.linuxquestions.org/questions/linux-newbie-8/bash-script-return-code-ftp-641042/
22:14  greycat: Oh, gods, I'm almost afraid to look...
22:14  greycat: No, I take that back.  I am totally afraid to look.
22:14  greycat: Well, could've been worse.  But as I expected, it was not good.
22:15  markdark: you have a better way greycat ?
22:15  greycat: !lftp
22:15  greybot: $ lftp myname@server/some/directory -e 'mput *.gif; quit' # Read "man netrc" to learn how to store your password as cleartext in a file, and read http://mywiki.wooledge.org/FtpMustDie
22:15  greycat: lftp is actually DESIGNED for noninteractive use
22:16  greycat: I've heard good reports from ncftp users as well.
22:16  aggrav8d: http://pastebin.com/1ExWer3h doesn't quite work.  i keep getting "unknown command [$ip]"
22:16  greycat: Hmm, too bad nobody taught the bot how to demonstrate basic lftp syntax.
22:17  greycat: I guess you'll just have to keep trying random combinations of -c and -u and whitespace.
22:17  greycat: For the record, his pastebin has:  lftp -c pwd -u $user,$pass $ip
22:17  greycat: There, now nobody else has to click it.
22:17  aggrav8d: and i tried it without -c pwd
--- Log closed Mon Dec 06 22:24:29 2010
--- Log opened Mon Dec 06 22:39:57 2010
22:39 --- Users 544 nicks [0 ops, 0 halfops, 0 voices, 544 normal]
22:40  greycat: Lovely.
22:40  phantomcircuit: yeah it does
22:40  phantomcircuit: which is where he is getting all of this
22:40  phantomcircuit: "this doesn't seem possible, do you just want the script to make a best guess?"
22:41 --- Channel #bash was synced in 124 seconds
22:43  aggrav8d: bah.  in the end it was simpler to use PHP's built in FTP commands.
22:44  aggrav8d: thanks anyways, guys.  it was educational :)
22:44  greycat: He never told us that switching to a real language was an option....
--- Log closed Mon Dec 06 23:04:59 2010
--- Log opened Mon Dec 06 23:10:24 2010
23:10 --- Users 538 nicks [0 ops, 0 halfops, 0 voices, 538 normal]
23:12 --- Channel #bash was synced in 127 seconds
23:27  pyoor: Hey all.  What's the wiki page for formatting a while or if statement based on "command".  I.E. while grep foo file; do
23:28  krzie: pyoor, what you typed
23:28  rickest: !if > pyoor
23:28  greybot: pyoor: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
23:29  pyoor: Thanks, I was looking at when to us [ as compared to [[ and $(), etc
23:30  erUSUL: !ifgrep
23:30  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
23:30  krzie: [ for compat only, otherwise [[ for strings, (( for numbers, $() for the output of the process inside to be used in place of the $()... i prolly didnt explain that well tho
23:31  pyoor: k, I didn't know if I needed to wrap the commands with anything.
23:31  pyoor: what is the while ! command; used for?
23:31  krzie: the ! flips the return value
23:32  krzie: so instead of happening while its true, it will happen while it is false
23:32  pyoor: oh i see.  thanks
--- Log closed Tue Dec 07 00:00:08 2010
