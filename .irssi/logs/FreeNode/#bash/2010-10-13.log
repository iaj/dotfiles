--- Log opened Wed Oct 13 08:40:13 2010
08:40 --- Users 525 nicks [0 ops, 0 halfops, 0 voices, 525 normal]
08:40  bruenig: [[ > [
08:40 --- loomsen is now known as d-_-b
08:40 --- d-_-b is now known as loom
08:41 --- loom is now known as loomsen_xmpp
08:41  mar77i: Imho that's covered by "Unless you're writing for POSIX sh, we recommend [[.", but thx anyway bru :)
08:41 --- Channel #bash was synced in 75 seconds
08:44 --- loomsen_xmpp is now known as loomsen
08:47  roccity_: hey everyone
08:48  bbowles: hello
08:50 --- gyaresu_ is now known as gyaresu
08:58  mouche: I'm looking right at a bash faq and still can't seem to get this string compare right. What am I doing wrong?
08:59  mouche: if [[ $1 = "-v" ]] || [[ $1 = "--verbose" ]]; then
09:00  lhunath: nothing.
09:00  lhunath: though you might want to rewrite it as [[ $1 = -v || $1 = --verbose ]]
09:00  bbowles: would someone be willing to help me out with a bash echo color terminator issue?
09:01  geirha: !tput
09:01  greybot: Terminalcodes and stuff: http://www.bash-hackers.org/wiki/doku.php/scripting/terminalcodes
09:01  lhunath: or case $1 in -v|--verbose)
09:01  mouche: lhunath, why no quotes?
09:01  lhunath: not necessary inside [[ on the left hand side.
09:01  selckin: <-- left
09:02  lhunath: (only because [[ and case are keywords, this isn't true for [)
09:02  bbowles: i've tried many variations of echo "\[\033[01;31m\]${CHARGE}%\[\033[00m\]" but can't get it to work without having extra \] and [ or entirely messing up my prompt
09:02  lhunath: bbowles: don't hardcode those.
09:02  lhunath: use tput.
09:03  lhunath: bbowles: and the \[ \] is only necessary inside PS1, I doubt that's what you're doing, seeing as you're echo'ing.
09:03  bbowles: well i am trying to get it into the PS1
09:03  bbowles: trying echos to see where i have gone wrong
09:03  lhunath: then don't echo.
09:03  lhunath: ok.
09:03  bbowles: do you mind a msg with more of the function?
09:03  lhunath: I'd be repeating greybot.
09:04  mouche: lhunath, if quotes aren't necessary on just the left, why did you remove them from the right string as well?
09:04  lhunath: mouche: they do nothing for -v.
09:04  lhunath: mouche: there are no special bash characters inside -v
09:04  lhunath: but feel free to quote both ends if you prefer. quoting will do no harm
09:04  lhunath: if in doubt, quote, and all will be fine.
09:04  mouche: heh, I've just been putting quotes around all my strings. apparently I need to do some more research :P
09:05  mouche: but if you quote a variable like $1, it becomes the literal string?
09:05  lhunath: "" allows expansions.
09:05  lhunath: '' doesn't.
09:05  lhunath: # echo "$PWD"; echo '$PWD'
09:05  evalbot: lhunath: /root
09:05  evalbot: lhunath: $PWD
09:05  mouche: ok
09:06  lhunath: # echo "loong    spaace"; echo loong      space
09:06  evalbot: lhunath: loong    spaace
09:06  evalbot: lhunath: loong space
09:06  lhunath: space is a special character.  it needs quotes.
09:06  mouche: ok
09:06 --- gyaresu__ is now known as gyaresu
09:06  mouche: but [ $a = "TRUE" ] and [ "$a" = "TRUE" ] are identical, right?
09:06  lhunath: nope.
09:06  lhunath: as I said; [ NEEDS quotes.
09:06  lhunath: it's not a keyword.
09:07  lhunath: but you shouldn't use [ in bash anyway.
09:07  mouche: oh, my bad, I meant [[
09:07  mouche: I was just working with [ and switched over
09:07  lhunath: yeah, exactly.  the mistake is made quickly.
09:07  mouche: oh heh, I'm using [ in that one spot that I'm having the problem
09:08  lhunath: it helps to train some mind-fu to stab you in the eye whenever you see or write a [ in a bash script.
09:08  mouche: excellent idea
09:09  mouche: wait, does that mean you have to stab yourself twice whenever you use [[?
09:11  lhunath: rather, pat on the back
09:11  lhunath: but for numbers, you're better off with ((
09:11  mouche: it's unfortunate for bash learners that google sucks at searching for special characters
09:11  lhunath: (( $# = 5 ))   or  (( debug == 1 )) or even (( debug ))
09:11  lhunath: I'd call that fortunate.
09:12  lhunath: !google
09:12  greybot: Google is NOT a preferred source for learning bash, because 90% of the "tutorials" and scripts out there are JUNK. Refer to the Guide and FAQ (see topic) instead.
09:12  mouche: heh, you even have a factoid
09:12  bbowles: here is what i have (mostly barrowed from some website) to get my battery percent
09:12 * lhunath prefers (( debug )) to [[ $debug = TRUE ]]
09:12  bbowles: battery_status() {
09:12  bbowles: BATTERY=/proc/acpi/battery/BAT1
09:12  bbowles: REM_CAP=`grep "^remaining capacity" $BATTERY/state | awk '{ print $3 }'`
09:12  bbowles: FULL_CAP=`grep "^last full capacity" $BATTERY/info | awk '{ print $4 }'`
09:12  bbowles: CHARGE=`echo $(( $REM_CAP * 100 / $FULL_CAP ))`
09:12  bbowles: NON="\033[00m"
09:12  bbowles: RED="\033[01;31m"
09:12  bbowles: echo -e "${RED}${CHARGE}%${NON}"
09:12  bbowles: }
09:12  bbowles: PS1='[$(battery_status)] ${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
09:13  lhunath: yuk.
09:13  bbowles: and i understand my problem is that bash isn't recognizing the escaped characters correctly and my ps1 ends up not wrapping correctly
09:13  lhunath: just toss it out and begin anew.
09:13  mouche: bbowles, pastebin would be kinder next time
09:13  bbowles: ok
09:14  lhunath: forking 2 bashes, 2 greps and 2 awks for something a builtin read can do
09:14  lhunath: !varcap
09:14  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
09:14  lhunath: and don't put backslashes in variables when you intend to put escape codes there.
09:15  bbowles: mouche, apologies, I haven't irced in a few years
09:19  Knirch: bbowles: the output from battery_status does not have its escape sequences protected with \[ and \]
09:19  bbowles: lhunath, where would i find out more about the builtin read, anything i've found so far grep/awks the current and last full capacities
09:20  pgas: help read, man bash
09:20  lhunath: !io
09:20  greybot: Data and File Processing: http://mywiki.wooledge.org/BashGuide/InputAndOutput
09:21  lhunath: if it's more than 1 line, though, you may want to use awk after all
09:21  lhunath: but just one awk would be preferable
09:22  lhunath: (and no greps)
09:22  Knirch: I was starting to wonder what kind of wunderread you use to get a line from a file based on a pattern to match :)
09:23  pgas: not that it will make such a difference for a prompt anyway
09:26  skydrome: !operators
09:27  skydrome: what are the difference between the = and == operators?
09:29  pgas: == is not defined by posix
09:30  pgas: = doesn't compare in (( ))
09:30  pgas: otherwise no difference
09:32  skydrome: cheers
09:46 --- t-EDI-o is now known as e-DIO-t
09:55  mouche: I'm looking at the faq, and it says that functions may have local variables. Does that mean that if you don't use 'local', the variable is global?
09:59  bbowles: lhunath, i've been messing with read and awk but can't figure out how to read just a single line from the file like the 4th line without going through a look
09:59  bbowles: *through a loop
10:00  bbowles: it seems like for my purpose that would be a stupid waste of cycles since the BAT1/info file isn't going to be changing
10:16 --- Guest6415 is now known as h4x0r`
10:20  pgas: mouche: correc the variables are global by default
10:22  mouche: pgas, is using echo $var and $result=`func` preferred or using a global variable for the result?
10:22  mouche: to return something from the function
10:24  pgas: it's probably a matter of taste
10:25  pgas: the subshell ` ` is probably slower, but it's perhaps a bit cleaner and obvious
10:26  mouche: pgas, ok thanks
10:27  hpt: how to make =~ ignore case?
10:29  pgas: if shopt -s nocasematch doesn't work, I don't know
10:31  hpt: it works, thanks
10:41 --- Weust`afk is now known as Weust`
10:50  ericlee: hi, how to restore the program exit code?
10:50  koala_man: what? how to set $? to some arbitrary value?
10:53  ericlee: koala_man, like this:
10:53  ericlee: if host "$host" > /dev/null 2>&1 && ping -c 3 "$host" > /dev/null 2>&1
10:54  ericlee: how do I get the exit code of these two command?
10:54  Naib: og host and of ping?
10:54  trash: ericlee: What for?
10:55  Naib: well the && ensures that the host command worked so you don't really need its exit code
10:55  Naib: and if it failed you have hosts exit code since ping would not have executed
10:56  nunojpg: without using a c binary, is possible to measure elapsed time with a monotonic time source so that it is not vulnerable to time changes steps?
10:56  koala_man: doesn't time to that?
10:57  ericlee: Naib, yes, I know that, just want to know how to store the exit value of a command in shell. For example, many command will execute I wanna store them if possible.
10:57  koala_man: exitvalue=$?
10:57  trash: ericlee: But WHY?
10:57  ericlee: trash, just curious...
10:58  Naib: as koala_man said then
10:58  trash: *sigh*
10:58  ericlee: koala_man, I knew that, but if I execute many commands in a shell script, how do I store them? Still using $?
10:58  ericlee: ?
10:58  koala_man: yes
10:58  koala_man: it will give the exit value of the previous command each time
10:59  ericlee: koala_man, oh, hmm, got it@!
10:59  Naib: echo_exitcode=$?
10:59  ericlee: thanks, guys.
10:59  pgas: ericlee: the real problem if if you do cmd1 | cmd2
10:59  Naib: then after the next command which you want the exitcode: somecommad_exitcode=$?
11:00  ericlee: pgas, so what's the exitcode?
11:01  nunojpg: koala_man: not at all. First I'm not trying to measure a execution time, and it's vulnerable to system clock changes
11:02  pgas: ericlee: the exit code of cmd2, but when you do, say cmd1 | tee file, you often want the exist status of cmd1
11:03  pgas: !pipestatus
11:03  greybot: bash: use the PIPESTATUS array, posix sh: see http://sdf.org/l/55 and http://pipestatus.sf.net
11:03  ericlee: oops, nice.
11:05  marty: hey guys does any one know how to put the time in your bash command line
11:05  ericlee: pgas, a question. I execute cmd1 and cmd2 separately, so I get 2 exit codes, exit1 and exit2. Is it possible to make thing better, if the exit code is 0, echo good or echo bad?
11:08  koala_man: marty: see man bash under Prompting
11:08  mar77i: # date +%R
11:08  evalbot: mar77i: 09:08
11:08  marty: cool thank
11:36  ericlee: Hi, how to use printf to print following format strings?
11:36  geirha: huh?
11:37  ericlee: http://pastebin.com/MThMDKJd
11:37  ericlee: sorry
11:38  geirha: printf "%-10s -5s -5s\n" aaaa yes no bbbb no yes
11:38  geirha: something like that
11:38  geirha: err s/-5s/%-5s/g
11:39  geirha: ''help printf''
11:40  ericlee: hmm, geirha thanks , I will have a try
11:44  ericlee: geirha, could you explain that? Thanks.
11:44  geirha: ericlee: type ''help printf'' in a bash shell.
11:48  ericlee: okay
12:02  cousteau`work: how do I remove the .0 in the variable DISPLAY=:0.0 ?
12:02 --- Astyan_away is now known as Astyan
12:03  cousteau`work: I'd google for it, but I'm not sure how is it called
12:04  cousteau`work: (man, I hate this xilinx thing)
12:04  Naib: !PE > cousteau`work
12:04  greybot: cousteau`work: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
12:04  cousteau`work: "parameter expansion", thanks
12:05  geirha: !google
12:05  greybot: Google is NOT a preferred source for learning bash, because 90% of the "tutorials" and scripts out there are JUNK. Refer to the Guide and FAQ (see topic) instead.
12:07  cousteau`work: so "${DISPLAY%.*}" would be OK
12:07  tmr: 90% is pretty optimistic.
12:07  Naib: # DISPLAY=:0.0; echo "${DISPLAY%.*}"
12:07  evalbot: Naib: :0
12:08 --- nadir is now known as Guest34325
12:13  cousteau`work: ...note to myself: don't modify a bash script you're currently running
12:16  cousteau`work: now I hate Google too, because of the damn "I assumed you don't know how to type so I replaced your search terms with whatever made sense for me, specially the ones looking like error messages"
12:16  trash: That's how it works like 5 years now
12:17  cousteau`work: also, somebody please explain me why this xilinx thing didn't work until I searched Google
12:18  cousteau`work: like, I hit the "Search" button, and the program opens after like a minute frozen
12:21 --- Obadiah is now known as Vivek
12:21  metiu: hi
12:21 --- Vivek is now known as VivekvC
12:21 --- VivekvC is now known as VivekVC
12:21 --- VivekVC is now known as Vivek
12:21  metiu: can I launch a subprocess in background giving it one open file descriptor as stdin?
12:22  metiu: I have fd 3 with an input stream
12:22  metiu: and I'd want it to be processed by a subprocess
12:22  metiu: while I manage my stdin where I receive some commands
12:22  cousteau`work: subprocess <&3 &   maybe?
12:24  pgas: metiu: sure you can
12:25  {g}: Hey Bash People! Any ideas how to send a certain number of http requests to a server simulaneously and see if one returns any other status then 200 OK?
12:25  {g}: Maybe there is a better channel for this kind of questions?
12:26  {g}: I thought maybe i could write a shell script that does a wget and then call it 50 times with some bash magic?
12:26  metiu: thank you
12:27  pgas: !pm > {g}
12:27  greybot: {g}: http://mywiki.wooledge.org/ProcessManagement
12:28  pgas: though maybe #httpd or some channel about web development knows about better tools that bash and wget
12:49  Guest34325: #exit
12:50 --- metiu_ is now known as metiu
13:00  voodoor: I want to use echo to send multiple commands to netcat- how do I format this into one line/ echo command?
13:00 --- metiu_ is now known as metiu
13:00  twkm: use printf.
13:01  twkm: as an aside, there is no need for you to use just one echo (or printf) command or line.
13:02  voodoor: twkm, can you give an example please? I'm unsure if I should be using semi colons to separate, newlines or what
13:03  koala_man: { echo foo; echo bar; } | nc ..
13:03  koala_man: or you can use a here document
13:03  koala_man: !heredoc
13:03  greybot: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
13:03  twkm: since netcat has no commands i presume you mean you need multiple lines sent via netcat, if so you might use: printf "%s\n" "line one" "line two" ... | netcat ...
13:07  rdz: hi all. is there a way to split lines by matching pattern?
13:07  twkm: certainly.
13:07  rdz: sorry: i meant to say: split files at lines matching a pattrn
13:07  twkm: moderately painfully of course.
13:08  pgas: ehe split day! I answered 2 similar question in #awk today
13:08  rdz: hehe
13:09  pgas: awk 'BEGIN{file="file".0} /foo/{close(file);file="file" (++i)}{print > file}' file
13:09  rdz: pgas, so that makes me hope there are way to split files by some automated mechanism?
13:09  rdz: pgas, thanks
13:11  erUSUL: file="file".(++i) ?
13:11 --- metiu_ is now known as metiu
13:13  voodoor: twkm, in your printf example why have you put "%s\n" as the first argument? Shouldn't the second one be "line one\n" etc?
13:13  cthuluh: 4# printf 'a\n' 'b\n'
13:14  shbot: cthuluh: a
13:14  cthuluh: !printf > voodoor
13:14  greybot: voodoor: The printf command: http://bash-hackers.org/wiki/doku.php/commands/builtin/printf
13:16  twkm: voodoor: so i don't have to type a lot of \n's.
13:19  pgas: erUSUL: oups the . should go in the " "
13:19  pgas: "file." 0,  "file." (i++)
13:19  erUSUL: pgas: yep i actually tried the onliner ... ( should do that more often before talking to much ... )
13:57  hipe: i am a novice sysadmin (been doing it for years but still novice)  i have a little development box and i need to repeat the same task (run the same install script) but logged in as 8 different of my developers
13:58  hipe: as i am the sysadmin, i can "su -l some-user" to login as them and run the script, but now i am trying to script this across the 8 users.  is this a bad idea?   i tried to write a bash script that reads usernames from stdin and logs in as them and got "su: must be run from a terminal"
13:59  hipe: i could also do all the stuff as root and chown the generated files appropriately, but logging in as the users 'feels' better ?
14:04  twkm: invoking a command at the same time seldom requires a terminal.
14:05  twkm: but anyway, if you do need one you'll probably have to consider expect.
14:08  soreau: Would /bin/su username -l -c "/bin/bash --login -c /path/to/script" work?
14:09 --- CaptainCook is now known as PTSWorldFriend
14:10  twkm: -c twice?  not usually.  more likely -s to name the shell.
14:22 --- jzacsh is now known as jzacsh__
14:22 --- jzacsh_ is now known as jzacsh
--- Log closed Wed Oct 13 14:25:04 2010
--- Log opened Wed Oct 13 14:25:37 2010
14:25 --- Users 542 nicks [0 ops, 0 halfops, 0 voices, 542 normal]
14:26 --- Channel #bash was synced in 80 seconds
14:27  hipe: lhunath: i'm running a few things that install software into the user's home directory. it will go much more smoothly if the environment is loaded for them and their .bashrc have been run when i invoke the script
14:29  lhunath: how does the user care about the script's environment?
14:39 --- JmZ_ is now known as JmZ
15:48  TheBonsai: 1
15:52  erUSUL: 2
15:53  _abc_: hello
15:53  twkm: moo.
15:53  _abc_: This is a sed question. #sed is dead (rhymes with Zed is Dead honey)
15:54  _abc_: How come this sed line does not delete blank lines generated by the s/// part? :: sed -e 's/,[ \t]\+/\n/g;/^[ \t]*$/d'
15:54  _abc_: And no flames please. I'm using sed from bash ;P
15:56  _abc_: Of course the d command works fine if I pipe the output into another sed instance
15:56  _abc_: The input is a comma separated list which also contains ,,, sequences
15:56  _abc_: And yes I could replace those with just one , and then subst but why does the command not work as shown?
15:56  _abc_: I'm done
15:57  yitz_: Nothing dead about ##sed. It's just lower volume traffic than bash
15:57  pgas: maybe the lines are not really blank and you have a \r that you don't see?
15:58  nDuff: pgas, no, it's reproducible with lines that really are blank
15:58  nDuff: # echo $', \nfoo, \n' | sed -e 's/,[ \t]\+/\n/g' -e '/^[ \t]*$/d' | wc -l
15:58  evalbot: nDuff: 4
15:58  yitz_: And running something from bash (eg Firefox, Xorg, Gimp) doesn't make it bash-related
15:58  nDuff: # echo $', \nfoo, \n' | sed -e 's/,[ \t]\+/\n/g' | sed -e '/^[ \t]*$/d' | wc -l
15:58  evalbot: nDuff: 1
15:58  Carmageddon: guys, I have a simple echo -n "string" line in a bash file, then I have declared port 6666 in services, in xinet.d I created conf telling to run this little script when someone connects on this port
15:58  twkm: _abc_: as an aside, try ##sed instead.
15:59  Carmageddon: problem is, it runs perfectly only locally, from remote machine it takes good 10+ secs to get response
15:59  Carmageddon: why?
16:00  yitz_: Carmageddon: Use strace?
16:00  nDuff: Carmageddon, does it respond immediately if the remote string terminates with an endline?
16:00 * nDuff is wondering if this is a buffering issue
16:00  pgas: _abc_: maybe the problem is that the delete operates on the whole pattern space and not on the line in it?
16:02  twkm: Carmageddon: dns or ident.  no bash issues.
16:03  Carmageddon: nDuff: if I remove the -n, I get connection refused.. duno why
16:03  pgas: _abc_: ie the lines you add with \n in the pattern space are not parsed as separately by the rest of the commands, ^and $ matches the beginning and end of the pattern space, not the begginning and end of lines IIRC
16:03  nDuff: Carmageddon, sounds like there's something else going on (ie. a networking issue)
16:03  MTecknology: Can I use export to take a variable from inside of a shell script and reuse it when the script terminates?
16:03  yitz_: !parent > MTecknology
16:03  greybot: MTecknology: When you run a script, it can not affect the parent shell. If you want to affect the parent shell, you need to source the script from the parent shell. See ''help source''
16:04  pgas: depends what you mean by reuse it
16:04  MTecknology: take the data is wound up having and play with it
16:04  yitz_: You can print it to STDOUT and capture it. Or a tmpfile
16:04  Carmageddon: nDuff and twkm: I doubt its dns or network issues, because I have similar code written in C, to which remote telnet responds instantly
16:04  twkm: your code isn't xinetd.
16:04  nDuff: Carmageddon, ...and you've tested that that's working _now_?
16:05  MTecknology: I'll try that
16:05  nDuff: Carmageddon, (also, check xinetd's logs!)
16:05  yitz_: MTecknology: Or even fifos :)
16:05  Carmageddon: ah, so the delay could be because xinted is waiting for ident response?
16:05  MTecknology: thanks :)
16:06  MTecknology: gah.. I keep wanting to use 'print' or 'return' instead of 'echo'
16:06  nDuff: Carmageddon, personally, I use tcpsvd rather than xinetd (and very much prefer it), so I can't speak to xinetd's behavior. (Also, xinetd is rather off-topic in #bash). That said -- depending on xinetd's behavior and configuration, it could be doing ident, it could be doing a reverse DNS lookup...
16:06  yitz_: printf > echo
16:07  nDuff: Carmageddon, ...a packet sniffer, or strace, is your friend.
16:07  MTecknology: I really need to learn to start using printf
16:07  Carmageddon: hmm, ok thanks. in this case I'll just do the same in C, will be faster than debug xinetd lol
16:07  Carmageddon: thanks :) at least I know the cause
16:08 * nDuff shrugs -- it should take less time to fix your xinetd configuration than to write code that could be done in bash in C
16:08  nDuff: but eh, knock yourself out :)
--- Log closed Wed Oct 13 21:58:57 2010
--- Log opened Wed Oct 13 21:59:18 2010
21:59 --- Users 564 nicks [0 ops, 0 halfops, 0 voices, 564 normal]
21:59  RAWRjar: if I launch a command with nohup, is there a way to later send input to its stdin?
21:59  prince_jammys: no
22:00  RAWRjar: Hmm. Is there a better way to launch a process that will keep running after I disconnect from SSH?
22:00  prince_jammys: at least not that i know of.
22:00 --- Channel #bash was synced in 72 seconds
22:00  prince_jammys: screen, maybe
22:00  greycat: screen
22:01  RAWRjar: kk
22:12  wald0: I have a big script that does a lot of things with packages, i would like to add a feature for generate a "statistics" (similar to logs), so my idea is to send logs to a file and then an external tool that parse it and generate a beautiful html... is there any existing tool or any recommendation before i start writting it ?
22:12  greycat: Write in a format that is easy to parse.
22:13  wald0: yep, that looks like to be the more delicated part
22:13  wald0: is there tips for formats easy to parse ?
22:13  greycat: Well, the obvious way would be to write the parser at the same time, so you know what's easy and what's hard....
22:14  crocket: POSIX shell document tells the grammar of if is if compound_list; then compound_list; fi
22:14  greycat: Common(?) sense things.  Put fixed fields first, with sensible delimiters.  If there are a variable number of things, put them last.
22:14  crocket: it means "if test -x xxx[newline] test -x yyy; then blahblah; fi" is possible.
22:14  greycat: crocket: yes.
22:14  crocket: But I never saw a newline in the list of commands to be evaluated by if.
22:14  crocket: It's confusing
22:14  greycat: # if false; true; then echo "true"; fi
22:14  evalbot: greycat: true
22:15  greycat: Think of it as an anonymous function if you like.
22:15  greycat: There's a block of commands.  The final result of the block is whatever $? is set to at the end.
22:15  crocket: greycat : there is no newline in the list of commands evaluated by if that you presented.
22:15  greycat: I can only assume that [newline] means ; or $'\n'
22:15  ferret: just pretend there was
22:16  crocket: a newline means a newline
22:16  greycat: Then put a newline there and test it on your own shell.
22:16  crocket: greycat : have you tested it??
22:16  greycat: imadev:~$ if false
22:16  greycat: > true
22:16  greycat: > then echo true; fi
22:16  greycat: true
22:16  greycat: HAPPY NOW?
22:16  crocket: ??
22:18  taylanub: POPOZOA
22:18  taylanub: crocket: what do you want?
22:18  greycat: And before you answer: we're all out of ponies.
22:19  crocket: greybot, the exit status of a compound list is the exit status of the last command list?
22:19  ferret: It would appear to be
22:19  chalcedny: how could I grep for http://www.undernet.org/usernames/ in a dir and all subfolders?
22:20  ppasteau: hi
22:20  greycat: $? is just a variable that gets overwritten any time a command is executed
22:20  chalcedny: hi ppasteau
22:20  greycat: whatever $? is set to when you reach the "then" is what matters
22:20  erUSUL: chalcedny: grep -R "http://www.undernet.org/usernames/" dir/
22:20  ferret: chalcedny: on a specific system or in a portable script?
22:20  ppasteau: I got some file to parse with space and '#' caractere
22:20  taylanub: crocket: there's some limitations on what you can use, but think of the 'compound list' as a whole script, with a return status.
22:21  chalcedny: ferret, probably mirc logs
22:21  crocket: taylanub, ok
22:21  chalcedny: asking
22:21  ppasteau: I would like to put it in an array
22:21  greycat: so what's the hard part?
22:21  ppasteau: for the moment i got  array=($(<$1)) but it doesn't parse space
22:21  ferret: you're a question proxy?
22:21  greycat: !faq 5 > ppasteau
22:21  greybot: ppasteau: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
22:22  chalcedny: i think -R works
22:22  chalcedny: thank you :)
22:22  greycat: array=( $(<"$1") )    would perform word-splitting on the entire file
22:22  TheBonsai: y0
22:22  erUSUL: chalcedny: next time Red The Fine Manual or RTFM
22:23  ferret: o.o
22:25  sowell: i was curious if someone could help me solve a fairly complex problem... I am trying to write a shell script that will take a date YYYY/mm/dd OR a date range YYYY/mm/dd - YYYY/mm/dd, and actually grep a log directory structure that uses something like 2010/09/15 to store its logs
22:25  sowell: my complication is, when teh user enters the date through a case
22:25  sowell: how do i grep the right directory or directories and ONLY the right directories
22:25  sowell: (such as in a date range)
22:25  sente: example?
22:25  greycat: 1) parse the human-entered dates into epoch timestamps.  2) rewrite the logfile to use epoch timestamps (temp file or stream or whatever).  3) read line by line and compare the timestamps.
22:25 --- hunterm_ is now known as hunterm
22:26  greycat: Oh... it's not a FILE?
22:26  greycat: Bah.
22:26  sowell: heh, no it user input
22:26  greycat: No, no, no, the OTHER input.  The stuff on a disk.
22:26  sowell: so i can tell them what format to give me the range in....
22:26  ferret: the only way to deal with the date range in this case is to iterate through all of the dates between the two dates
22:26  greycat: "anything GNUdate -d can handle"
22:27  PythonNub: o/ all
22:27  sowell: i mean im just looking to grep 1 log file....but the tree structure is structured as 2010/09/16
22:27  greycat: Are the mtimes of the log files INSIDE the directories the same date as the directory names?
22:27  sowell: so the full path to my log file would be 2010/09/16/logs/log.log
22:27  sente: can you show with an example what your precisely mean?
22:27  ferret: no idea how to do that without a proper date handling program i.e. something not in posix shell utilities
22:27  chalcedny: erUSUL thank you for your kindness.
22:27  erUSUL: chalcedny: you are wellcome
22:27  greycat: In other words, can you just bloody IGNORE the pathnames and focus on the mtimes exclusively?
22:28  PythonNub: lol
22:28  sowell: yes
22:28  sowell: pretty much ;)
22:28  greycat: GOOD!  Then create start-stamp and end-stamp files whose mtimes are what you need, and then use find -newer
22:28  ferret: cool
22:28  ferret: that's a good idea
22:29  sowell: haha
22:29  sowell: i will check that out as an option
22:29  greycat: He'll probably decide or realize that the mtimes are not in fact reliable....
22:29  sente: friggin find, it needs an -older or a -newer-or-equal predicate
22:29  erUSUL: what if a bad backup restore r careless user messed the timestamps ?
22:29  sowell: i mean is there a better way to do it?
22:29  ferret: no
22:29  sowell: haha
22:30  greycat: You either iterate through the days, or you iterate through the directories.
22:30  ferret: if you want to find files based on dates, find is the best option
22:30  sowell: i was honestly trying to iterate through the directories.
22:30  ferret: for dates based on files, gnu date or similar as a minimum, perhaps perl
22:31  sente: so you're itereating through directories, looking for a file like YYYYMMDD which falls between your range?
22:31  greycat: 16:27  sowell> so the full path to my log file would be 2010/09/16/logs/log.log
22:31  sente: i don't see what is so difficult about this
22:31  sowell: here ill show you ;)
22:32  sente: sounds good to me :)
22:33  ferret: with gnu date this would be easy, since you can cheat and keep adding 1 to the day number and checking if you are out of the range yet
22:33  taylanub: i probably didn't get something. why not globs?
22:33  greycat: A glob cannot express "from March 1 2009 to February 16 2010".
22:34  ferret: # date -d '28 March 2009 +10 days' # like this
22:34  evalbot: ferret: Tue Apr  7 00:00:00 UTC 2009
22:34  ferret: which is really useful for iterating ranges... so that's the other way to do it
22:35  greycat: GNU date would practically be *required* to do this in a shell script.
22:35  greycat: (or some advanced date(1) command)
22:35  sente: why can't you just convert your start and end dates to a compatible format, and then use use a few pipes|greps to filter out the files not in range?
22:35  sowell: dpaste.com/257469
22:35  greycat: sente: grep what?
22:35  sowell: so  although the bottom code is probably absolutely TERRIBLE
22:35  sowell: this is a basic idea of what i am tryign to do.
22:35  ferret: you'd also have to convert the log file structure
22:36  ferret: and then create a mapping of some sort so after finding the answer you can work out which one it was
22:36  klauwhamer: hi folks
22:36  sowell: log files are put in a new dir everyday of format 2010/10/13
22:36  greycat: I still vote for the find -newer approach, unless/until it proves impossible to rely on mtimes.
22:36  klauwhamer: hi greycat
22:36 --- caemir_ is now known as caemir
22:36  geirha: sowell: The regular expression is unecessary and wrong
22:36  ferret: sowell: by "log files are put", do you mean, in a way that is beyond your control?
22:37  sowell: geirha, honestly thats why im in here
22:37  sowell: heh
22:37  geirha: !faq valid
22:37  greybot: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
22:37  sowell: i was trying a bunch of diff stuff and i knew i wasnt looking at the problem right
22:37  sowell: hence why i came in here.
22:37  geirha: !faq length
22:37  greybot: http://mywiki.wooledge.org/BashFAQ/007 -- Is there a function to return the length of a string?
22:38  sowell: ferret...i mean that the process that logs, logs this way
22:38  sowell: and i cant change the way it does its logging.
22:38  ferret: so you can't change that?
22:38  ferret: It doesn't have a log filename format option switch?
22:38  crocket: hmm
22:38  crocket: POSIX shell documentation is misleading in that it doesn't tell the exit status of a compound list.
22:39  greycat: it's whatever happens last
22:39  geirha: sowell: Also, since you've quoted the regex, it's the same as matching a regular string. i.e.  [[ $date =~ "[:digit:]\{8\}" ]]  will yield the same result as [[ $date = "[:digit:]\{8\}" ]]
22:39  taylanub: how about printing a sorted list, cutting the part you want, and feeding it back.  could i explain?
22:39  crocket: BASH documentation is better at explaining this.
22:39  sowell: ferret: i could lie and tell you no, but im sure it does.  the problem is that its not a solution ;)
22:40  greycat: sowell: 1) read start date from user, 2) read end date from user, 3) call gdate to convert start date to timestamp, 4) create file with that timestamp somewhere in TMPDIR, ....
22:40  sowell: ferret: in other words i cant change the way the program logs to make this script grep log files.
22:41  sowell: how would i calculate all the dates in between i guess then grecat?
22:41  sowell: like how would i differentiate between 30 day months / 31 day months
22:41  greycat: If you're using find -newer, you DON'T HAVE TO.  That's the point.
22:41  greycat: Doesn't matter!
22:42  sowell: if i use find -newer can i have it stop at a certain date?
22:42  greycat: touch -t "$(gdate -d "$userinput" +%s)" $startfile
22:42  greycat: touch -t "$(gdate -d "$userinput" +%s)" $startfile
22:42  greycat: touch -t "$(gdate -d "$userinput" +%s)" $endfile
22:42  ferret: crocket: it's implied
22:42  greycat: find . -newer $startfile ! -newer $endfile -name log.log
22:42  crocket: ferret, implied where?
22:42  ferret: crocket: every "simple command" sets $?
22:42  sowell: greycat...ahhhhhhhhhh
22:42  sowell: ;)
22:42  ferret: crocket: When a variable is set in sh, the previous value is lost
22:43  klauwhamer: is it possible to use these ' character in sed search replace string?
22:43  ferret: That is the behaviour of all variables, including special ones
22:43  nDuff: sowell, if you can do find -newer, you can do find -older as well
22:43  sente: here is my example, greycat sowell:
22:43  greycat: !quotes > klauwhamer
22:43  greybot: klauwhamer: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
22:43  taylanub: for dir in */*/*; do echo $dir; done | sed "\_$date0_,\_$date1_ ! d" | xargs or whatever ??
22:43  geirha: klauwhamer: Of course, ' is not special to sed
22:43  crocket: ferret, implication confuses people.
22:43  greycat: crocket: only you....
22:43  sente: http://sente.pastebin.com/waf2sgBB
22:44  crocket: greycat, only me?
22:44  ferret: crocket: I don't know why, but I didn't find this confusing
22:44  klauwhamer: greybot and geirha, do you have a example for me?
22:44  sente: sowell: is that more or a less what you're trying to do? albeit simplified
22:45  greycat: klauwhamer: sed "s/'/quote/g"
22:45  seanp2k: hello, I am wondering how I can capture the return code of a command ran within a subshell
22:45  greycat: seanp2k: it's in $?
22:45  geirha: klauwhamer: All you need it to learn how the shell handles quotes, and how you can make it pass a ' to sed.
22:45  klauwhamer: greycat: i want to put ' character in the text file
22:45  greycat: klauwhamer: Then do so.
22:45  greycat: Like I did.
22:46 --- muzer is now known as MuzerAway
22:46  seanp2k: i.e. results=$(ssh somesite "sudo -c 'lots of commands'")
22:46  seanp2k: i want to get the return value of the 'lots of commands'
22:46  greycat: seanp2k: it's in $?
22:46  seanp2k: greycat: not sure what you mean
22:46  greycat: assuming sudo passes it through.  I know ssh does.
22:46  sowell: uhmmmm sente, very close
22:46  greycat: seanp2k: results=$(blah) exitcode=$?
22:46  geirha: sudo does too
22:46  ferret: At worst you can 'lots of commands; echo $?'
22:46  seanp2k: greycat: ooh, i get what you mean.  no, my problem is that $? always returns 0
22:47  sowell: except it would need to be earching everyday in order
22:47  sente: sowell: i kept it simple to illustrate the point, i've done needed to do very similar to this in the past
22:47  sowell: not based on the filename itself...becaue every day that filename exists, if you know what i mean
22:47  seanp2k: ferret: right, but i'm capturing output from the commands ran on the servers for logging as well
22:47  seanp2k: ferret: which does work, right now
22:47  greycat: seanp2k: if one of ssh/sudo is broken on your system, then you will have to use a hack workaround like ferret showed
22:47  ferret: sudo DOES transmit the exit code of the program faithfully
22:47  sente: just have a listing of a logs of and test each one, sorted
22:47  seanp2k: greycat: OK, i think that will be a workable solution, thx
22:47  ferret: so it's a mystery why this doesn't work
22:47  seanp2k: let me pastebin this real quick
22:47  nDuff: seanp2k, it's very easy to lose your exit code if you don't store it immediately, or if you run any other command (or switch, or builtin, or anything) after -- any chance that might be happening?
22:48  ferret: seanp2k: as a test, try: results=$(ssh somesite "sudo -c 'exit 42'"); echo $?
22:48  sente: sowell: what is it based on then?
22:48  seanp2k: nDuff: http://pastebin.com/ms1vcAUv
22:48 --- MuzerAway is now known as muzer
22:48  ferret: if that gives 0 your ssh/sudo/bash is broken; if it gives 42 your 'lots of commands' is not doing what you think.
22:49  sowell: its based on a user inputed date.....so lets say the user says i want to see all logs from 2010/09/25 - 2010/10/13
22:49  nDuff: seanp2k, it's easier to run ferret's test than to try to comb through your code :)
22:49  seanp2k: nDuff: OK, i will do that then.  thx
22:49  sente: that part i  understand
22:49  greycat: cyclops:~$ var=$(ssh -t griffon sudo bash -c 'date; test; false; exit 42') exit=$?; echo "exit is $exit"
22:49  sente: taht part i solve
22:49  greycat: Enter passphrase for key '/home/greg/.ssh/id_rsa':
22:49  greycat: Connection to griffon closed.
22:49  greycat: exit is 42
22:49  sente: what is the addeds complication?
22:49  sowell: i need to go into every directory starting from 2010/09/25/log/log_with_date.txt - 2010/10/13/log/log_with_date.txt
22:49  sowell: and grep each file for instances of a username.
22:50  sente: okay..
22:50  cognitiaclaeves1: if you want to execute a command like 'rm $path/Aug*.log' in a script, how do you do it so that you don't get an error that the file just doesn't exist?  I know that '*' is being interpreted as all files in a directory, but I'm not sure how to work around that.
22:50  geirha: sente: sudo -c is wrong ... man sudo
22:50  greycat: cognitiaclaeves1: rm -f
22:50  sowell: is that what this is doing sente?
22:50  sowell: is it just that your logs dont roll into a new dir everyday?
22:50  geirha: seanp2k: sudo -c is wrong ... man sudo
22:50  geirha: sente: Sorry, tab-fail.
22:51  klauwhamer: greycat: i do sed "s/$/'/" textfile  i get message "Illegal variable name."
22:51  greycat: No you don't.
22:51  sowell: haha
22:51  cognitiaclaeves1: greycat: Ok, so I didn't get the error, but the file also wasn't removed.  This is a wildcard expansion issue;  The file does exist.
22:51  greycat: !exact
22:51  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
22:52  cognitiaclaeves1: fg
22:52  ppasteau: my read skip space and read only words
22:52  ppasteau: is it possitble to make it keep ' '
22:52  sowell: sente?
22:52  geirha: klauwhamer: That sed will put a ' at the end of each line
22:53  greycat: cognitiaclaeves1: if your globs are not being expanded, it's either because you quoted them, or you enabled "set -f"
22:53  sowell: sente: i think im going to try both your method and greycats and see which i like better ;)
22:53  greycat: !faq 1 > ppasteau
22:53  greybot: ppasteau: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
22:53  sowell: i feel like bash is a chizel instead of a pick axe when i need to break outta prison in this particular case/
22:54  cognitiaclaeves1: rm "$datapath/bugzilla_$1_*.sql.backup.tar.gz" ... rm: cannot remove `/home/bugzilla_setup/data/bugzilla_2010_Aug_*.sql.backup.tar.gz': No such file or directory
22:54  cognitiaclaeves1: so * can't be quoted at all, then?
22:54  greycat: It becomes a literal * if you quote it like that.
22:55  cognitiaclaeves1: How do I make it un-literal and still anticipate spaces in the path?
22:55  greycat: rm "$datapath/bugzilla_$1_"*.sql.backu.tar.gz
22:55  lhunath: that's sort of the whole point of using quotes at all.
22:55  geirha: # touch a b; echo '*' "*" *
22:55  evalbot: geirha: * * a b
22:58  sente: sowell: this does exactly that, i believe: http://sente.pastebin.com/x1ZfX81Z
22:59  klauwhamer: thanks
23:01  cognitiaclaeves1: ok.  I didn't realize that quotes could be broken up like that.  Thanks, greycat.
23:01  sowell: sente: ok im going to play with this and see how it works out
23:02  sowell: thank you greycat / sente
23:02  klauwhamer: it is indeed working
23:05  cognitiaclaeves1: Also, I see that there's a link right in the FAQ for my issue.  Sorry about that.
23:06  taylanub: sowell: couldn't follow the talk.  has a good solution been found?
23:07  sowell: taylanub: i have gotten three good things to try
23:07  sowell: so im going to give those a shot...
23:08  taylanub: have i got it right that logs are in a directory structure like year/month/day/logfile ?
23:09  sowell: taylanub: yep, exactly.
23:09  taylanub: now this is either super smart or (more likely) super stupid (but i fail to see why it would fail) :
23:09  taylanub: for dir in */*/*; do echo $dir; done | sed "\_$date0_,\_$date1_ ! d" | xargs or whatever ??
23:10  sowell: what is the "d"? and will that solve a range?
23:11  sowell: how does it know whats inbetween 2010/09/15 and 2010/10/13
23:11  taylanub: you don't know sed i guess?
23:11  sowell: heh
23:11  sowell: i know a bit of sed, i wanna say sed is delete, but let me man
23:11  taylanub: d is delete. also see the '!'
23:12  ferret: what's \_number_ supposed to mean?
23:12  taylanub: i use \_.._ instead of /../ for regex because $date will include /
23:12  ferret: putting \ in front of the first character makes it a /../ ?
23:12  taylanub: the $dates are assumed to be strictly year/month/day
23:12  taylanub: ferret: yes
23:12  ferret: the problem there is that you are depending on both dates existing
23:13  taylanub: with s/../../ you can also use any char and without \
23:13  ferret: he never said the logs existed for each day
23:13  ferret: but maybe they do
23:13  sowell: oh they do ;)
23:13  taylanub: (by the way i posted that line like 10 minutes ago and it probably didn't get noticed between all the noise)
23:14  ferret: well, you could use that approach, but the other ones are nicer I think :P
23:14  taylanub: i couldn't follow the conversation. might scroll up and read (it's messy there :P)
23:14  sowell: you sure did ;)
23:14  sowell: io missed it
23:17  tsolox: this .procmail recipe is not working ---> * ^From:.*\@lifehacker\.com
23:28 --- cthuluh_ is now known as cthuluh
23:28  lhunath: and I'm sure the procmail people will be happy to tell you why.
23:30  Aniar: lazyirc: is there an ssh option to say "ignore host checking inside dns domain name x or ip subnet y?
23:31  MTecknology: [[ ! $SERVER_DC ]] <-- is there any reason to quote that?
23:31  lhunath: Aniar: join #openssh
23:31  lhunath: MTecknology: no.
23:32  MTecknology: thanks :)
23:34 --- JmZ is now known as JmZ_
23:34  Cowmoo: I want to take each line from a file, and write $line + some other characters to another file.  What is most succinct way of doing this?
23:35  lhunath: !faq 1
23:35  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
23:35  lhunath: that, an echo or printf and a file redirection.
23:35  erUSUL: Cowmoo: sed 's/$/someotherchars/' file > newfile
23:36  lhunath: psh, cheats.
23:37  Cowmoo: thanks guys
23:37  Cowmoo: sorry for not reading faq :/
23:51  tsolox: test...
23:52  cthuluh: failed
23:52  tsolox: tsk .. aterm has refresh issues when TERM=xterm.
23:53  ppasteau: I give an array to a function but the syntax ${array[3]} doesn't work anymore
23:53  ppasteau: like i call it with $1 ${1[2]}
23:53  ferret: amazing
23:53  tsolox: it has no refresh issues when TERM=rxvt, but thin F1 key is map to 'P' ..and my other app need that F1 key
23:53  ferret: It has issues when you use the wrong TERM type
23:54  ferret: And other different issues if you use an other, different, still wrong TERM type
23:54 --- taylanub is now known as johnDouche
23:55  ferret: Why are you using random TERM settings that aren't aterm?
23:55  ferret: And why did you quit between the mockery and the help?
23:55  ferret: Why are you using random TERM settings that aren't aterm?
23:55  ferret: Maybe there is an alternative to doing that which doesn't suck
23:56  sowell: does bash have the ability to do something like this: [[:digit:]]\{8\}\s?-\s?[[:digit:]]\{8\}?
23:56 --- johnDouche is now known as taylanub
23:56  sowell: in a typical =~ test
23:57  lhunath: don't disable the meaning of {, and don't use \s
23:58  sowell: heh
23:58  lhunath: also, greedy is not suported afaik
23:58  sowell: i saw that on a site somewhere....
23:58  sowell: ugh, no greedy eh
23:58  lhunath: yeah, some crappy gnu sed site, probably
23:58  sowell: hahahaha
23:59  sowell: nah i saw it on some site with bash examples...ive not really used the =~ operator yet
23:59  sowell: so im just getting familiar with it.
23:59  lhunath: "this is BRE, where { has no meaning.  let's add a feature to GIVE it ERE meaning, by using the syntax that we currently use to TAKE AWAY meaning, eg. backslash escape it"
23:59  sowell: hahaha
23:59  sowell: so let me ask you this then
23:59  sowell: if i want a conditional space, how would i accomplish that?
--- Log closed Thu Oct 14 00:00:03 2010
