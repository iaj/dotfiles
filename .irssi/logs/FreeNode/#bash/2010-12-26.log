--- Log opened Sun Dec 26 20:31:30 2010
20:31 --- Users 522 nicks [0 ops, 0 halfops, 0 voices, 522 normal]
20:31  nDuff: taylanub, -s sorts on the whole line if all the keys match
20:31  nDuff: taylanub, err, stops it from doing that
20:32 * nDuff would have to read the POSIX spec to see the default behavior of doing last-resort comparison is standard-breaking
20:32  nDuff: I wouldn't be surprised if it was a grey area ie. undefined results
20:32 --- Channel #bash was synced in 81 seconds
20:34  nDuff: hmm. Using the keys if they're specified is a "shall" requirement, but what to do if they all match is indeed unspecified.
20:35 * nDuff is surprised, though -- he'd think last-resort comparison would make the sort _more_ stable, not less, as it would define ordering for lines between which it would otherwise be ambiguous.
20:37  taylanub: so last-resort means sorting all lines that are equal per keydef
20:39  nDuff: right
20:41  taylanub: b.2 b.1 a.2 a.1  |  -t. -k1,1  ->  a.1 a.2 b.1 b.2  ;   with -s  ->  a.2 a.1 b.2 b.1
20:43  tharkun: ...|sed -e 's/\"/\'/g'|... why doesn't it work?
20:44  taylanub: tharkun: because \ is not special inside ''
20:44  taylanub: you end it at \' and restart at g'
20:44  taylanub: (the quotation)
20:45  taylanub:  "s/\"/'/g"  is fine
20:45  bennyp: grop seemed to work
20:45  tharkun: taylanub: checking
20:45  taylanub: or   s/\"/\'/g
20:46  bennyp: now how can i get the script to repeat for dir as all arguments
20:46  taylanub: bennyp: what's it you're doing?
20:46  taylanub: and did you mean grep ?
20:47  bennyp: taylanub http://pastebin.ca/2030011
20:47  Josay: w!
20:47  Josay: oops
20:49  Epona: how do I get invite to #sh?
20:50  nDuff: POSIX sh is supported here (just specify it in your question)
20:50  Epona: oh ok
20:50  taylanub: bennyp: "${original/#Original/Processed}"  <-- is the # a typo?
20:50  bennyp: no
20:51  tharkun: taylanub: it worked as expected thx
20:51  taylanub: oh well i'm a bash noob
20:58  sultan2: I need a very basic help, if anyone may
20:58  taylanub: !ask
20:58  greybot: If you have a question, please just ask it. Don't look for topic experts. Don't ask to ask. Don't PM! Don't ask if people are awake, or in the mood to help. Just ask the question straight out, and be patient waiting for an answer. http://wooledge.org/mywiki/NetEtiquette
20:58  sultan2: I'm sorry, I'll just ask
21:00  sultan2: I commanded my conky to activate a script, the script should open an application (a media player), conky is about to activate the script time and time again, I'd like to have a script that will run the desired application as long as the application isn't already running, any help?
21:02  taylanub: !lock
21:02  greybot: http://wiki.bash-hackers.org/howto/mutex
21:03 --- cehteh` is now known as cehteh
21:03  sultan2: Thank you, taylanub :)
21:26  TheBonsai: y0
21:30  yitz_: y1
21:31  TheBonsai: wtf
21:31  TheBonsai: enter (w/o quotes) "the art of bash programming" on google.com
21:31  TheBonsai: no... nononono....nonononononono
21:33  go|dfish: no no there's no limit
21:33  TheBonsai: hrh
21:33  yitz_: Damn... :( That sucks
21:34 * yitz_ spams forums and twitter with wooledge
21:34  TheBonsai: let's start a new guide with topics for advanced bash users, dedicated to good style
21:34  TheBonsai: and call it "The Art of Bash Programming"
21:35  go|dfish: Rule 1. Must be wearing sunglasses.
21:35  go|dfish: YEEEEEEEEEAAAAAAAAAAAAAAAAAAAAH
21:35  prince_jammys: one pant leg should be pulled up, brooklyn style.
21:35  TheBonsai: go|dfish: that's implicit, and not a rule
21:36  go|dfish: :D
21:36  cthuluh: nice shit...
21:36  yitz_: gedit is not acceptable. Must use vi(m) or emacs
21:36  TheBonsai: i assume "advanced" users use these ;)
21:37  prince_jammys: ed
21:38  TheBonsai: uh, too advanced
21:38 --- hansel is now known as mindrape
21:38  go|dfish: edit.exe, sunglasses, one pant leg pulled up, white sports socks
21:39  prince_jammys: four finger ring
21:39  TheBonsai: and a unix.net mail address
21:39  sultan2: TheBonsai:
21:39  yitz_: I recall edit from them old days. That menu system was clunky as anything.
21:40  yitz_: Does anyone here really use ed on a regular basis?
21:40  mindrape: not ed but sed.
21:40  TheBonsai: yitz_: i though you did?
21:40  TheBonsai: sultan2: ?
21:40  go|dfish: I think people only say they use ed to impress the guys on IRC.
21:40  yitz_: I read the ed manual. That's about it....
21:40  TheBonsai: same here ;)
21:40  prince_jammys: doesn't work
21:40  sultan2: TheBonsai: you're from Ekiga
21:40  yitz_: I almost never use it. But I do know someone on IRC (blind) that uses ed regularly
21:41  TheBonsai: sultan2: yes, but inactive. how do you know?
21:41  TheBonsai: ah, i see. #ekiga
21:42  sultan2: I'm crying for you at freenode time and time again ;)
21:42  sultan2: TheBonsai: I talked with you one time at irc.gnome.org, though
21:43  TheBonsai: i lost connection to ekiga staff a year ago, or so. my sparetime situation gets better, probably i'll link again
21:43  sultan2: Okay :)
21:44  sultan2: TheBonsai: can you opt me up in the #ekiga room at freenode?
21:46  TheBonsai: sultan2: +o? yes. but i can't make it persistent, i lost foundership
21:46  sultan2: ok
22:28  kisielk_home: is there some way to read continuously from a pipe? according to tail documentation, tail -f doesn't work on pipes...
22:28  mtdewcmu: on a named pipe?
--- Log closed Sun Dec 26 22:32:59 2010
--- Log opened Sun Dec 26 22:38:19 2010
22:38 --- Users 529 nicks [0 ops, 0 halfops, 0 voices, 529 normal]
22:39 --- Channel #bash was synced in 78 seconds
22:46  JordiGH: What does this line mean? http://hg.savannah.gnu.org/hgweb/octave/file/tip/run-octave.in#l54
22:46  JordiGH: if [ "x$1" = "x-g" ]; then
22:47  JordiGH: It seems to be checking program params, but why does it work?
22:48  erUSUL: JordiGH: adding the x in front of the var is an old trick to workaround old shells iirc
22:48  EliasAmaral: how to find (recursively) all files under /dir, but with path relative to /dir? cd /dir; find * -type f works - unless /dir is empty (it should print nothing). cd /dir; find . -type f works, but then i need to get rid of ./, cd /dir; (find . -type f | sed s:^\./:: has the output i want, but i suspect this is unnecessary)
22:49  EliasAmaral: i was searching find man page, for a flag similar to patch's -p
22:49  JordiGH: erUSUL: Ah, just some ancient back-compatibility trick?
22:50  erUSUL: JordiGH: yes; trying to fnd the exact reference
22:51  erUSUL: JordiGH: is to avoid problems in old shells in case $1 is empty
22:51  JordiGH: I see.
22:51  JordiGH: But how could $1 be empty if $# -gt 0 ?
22:51  EliasAmaral: # if /usr/bin/[ '' = '' ]; then echo a; else echo b; fi
22:51  evalbot: EliasAmaral: bash: /usr/bin/[: No such file or directory
22:51  evalbot: EliasAmaral: b
22:52  EliasAmaral: JordiGH, i think he meant $1 be an empty string
22:52  EliasAmaral: that code prints a here
22:52  JordiGH: EliasAmaral: I know, can bash pass to this script empty $1 and also positive $# ?
22:52  erUSUL: JordiGH: i did not check the whole script only the line you posted here
22:52  EliasAmaral: but bash expands '' to an empty string (at exec), instead of deleting it
22:53  EliasAmaral: JordiGH, hmm yes o.o you get an array of nul-terminated strings, if the string begins with nul it is empty. one could have the first argument empty, and the other non-empty
22:53  yitz_: Is LINES not set in non-interactive-non-login shells?
22:53  erUSUL: JordiGH: probably just something the coder did automatically in all his/her scripts
22:54  JordiGH: erUSUL: Cargo cult code?
22:54  EliasAmaral: /usr/bin/[ '' = '' ] here works, but /usr/bin/[ = '' ] says missing argument
22:55  erUSUL: JordiGH: if you use bash it is; in those ancient systems with broken  [ not so. maybe it is there to avoid problems in legacy unixes? solaris?
22:55  prince_jammys: JordiGH: there's an explanation in the pitfalls page, i think
22:56  prince_jammys: !pitfalls
22:56  greybot: http://mywiki.wooledge.org/BashPitfalls
22:56  JordiGH: erUSUL: Well, this is supposed to be a highly compatible shellscript.
22:57  prince_jammys: the idea i think is for it not to break when $1 starts with a dash
22:57  erUSUL: JordiGH: if it works do not change it. add a comment for the next guy that comes acrross this
23:01  prince_jammys: pitfalls page isn't loading here, but i'm pretty sure that's what x$1 was intended to work around
23:01  JordiGH: erUSUL: Does it need a comment, or is this gonna be like foo="bar" ##assign bar to foo
23:01  erUSUL: proxy error here too
23:02  prince_jammys: nowadays '[' tests for number of args, so [ -f = foo ] is OK
23:02  JordiGH: Is that greycat's wiki?
23:02  prince_jammys: yes
23:03  JordiGH: I guess we'll wait for greycat to come back from his Christmas break. :P
23:03  prince_jammys: i suspect originally [ -f = foo ] might have errored due to number of args, or maybe nonexistent option for something like [ -g = -g ]
23:03  erUSUL: JordiGH: i would add the comment; but that's just me
23:05  prince_jammys: .. so any non-dash leading char was prepended, usually X
23:07  nDuff: any remotely modern UNIX  will handle [ "$foo" = "$bar" ] correctly
23:07  nDuff: it has to be _really_ legacy before that's a problem.
23:07  prince_jammys: grep '\[ "[xX]\$' /etc/*/*  gives many examples here
23:10  nDuff: right, it's still a common practice... doesn't mean it's a _good_ one
23:14  prince_jammys: EliasAmaral: gnu find has -printf, and there's a format string that'll trim the ./
23:14  prince_jammys: otherwise do your sed thing
23:18  jzacsh: hello, might someone suggest whats wrong with my use of find, here? filename: "09 - Re_ Stacks.mp3" and running: find /mnt/music/Bon\ Iver/ -type f -regex '^..\ -\ .*\.mp3$'
23:18  jzacsh: though, that's not a bash question... i suppose.
23:19  prince_jammys: i think regexes are anchored at the beginning of the full path. use a glob anyway
23:19  nDuff: for one, you don't want the backslashes before your spaces
23:19  nDuff: the whitespaces are already quoted by the outer single ticks
23:19  nDuff: and as prince_jammys says, a glob is fine for this
23:19  prince_jammys: -name '?? - *.mp3'
23:20  falconindy: jzacsh: you might benefit from the mindepth option
23:20  prince_jammys: or '[[:digit:]][[:digit:]] - *.mp3'
23:24  jzacsh: so, .* is not necessary, just * -- also, no need ot escape thespace... so this isn't right?   find /mnt/music/Bon\ Iver/ -type f -regex '.. - *.mp3$'
23:25  prince_jammys: .* is necessary in a regex. Use a glob instead; it's simpler.
23:25  prince_jammys: instead of -regex, use -name
23:25  jzacsh: ah, gotcha.
23:25  prince_jammys: -name '?? - *.mp3'
23:26  jzacsh: oh, okay -- didn't pic kup on '-name' at the start thefirst time.
23:26  prince_jammys: the ? is somewhat like a '.' in a regex
23:26  jzacsh: yup :) thank you -- that works perfectly
23:26  jzacsh: oh, wait - i thought ? _was_ regex syntax itself
23:27  prince_jammys: it is, also
23:27  yitz_: read with -n or -N doesn't honor EOF? :S
23:27  prince_jammys: regex and globs look alike sometimes, but they're totally different ways of matching string
23:27  falconindy: yitz_: help read says otherwise
23:27  prince_jammys: and -name matches against the basename (what you want), whereas -regex matches against the full path, i think.
23:28  jzacsh: prince_jammys: ah, okay. thnk you.
23:28  falconindy: prince_jammys: you would be correct. -regex is usually overkill given the flexibility of -name
23:28  prince_jammys: yep
23:28  prince_jammys: !regex
23:28  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
23:29  jzacsh: :P interesting
23:29  yitz_: falconindy: But: while read -n1 ; do echo "[$REPLY]" ; done   indicates otherwise, too
23:29  yitz_: Or, my-wise
23:29  prince_jammys: jzacsh: use 'em only when really necessary
23:30  falconindy: well -N explicitly mentions stopping at an EOF
23:30  falconindy: looks like -n only stops early on an EOL
23:31  yitz_: while read -N1 ; do echo "[$REPLY]" ; done <RETURN><^D>  ...
23:31  falconindy: and it seems to fail
23:31  prince_jammys: 4# printf 'fo\nbar' | { read -n3; echo "[$REPLY]"; }
23:31  yitz_: Doesn't quit for me. Can someone verify this behaviour/bug?
23:31  shbot: prince_jammys: [fo]
23:31  falconindy: i got 'sf^D^D$' in a REPLY variable for read -N4
23:31  falconindy: sounds like a bug
23:32  falconindy: unless ^D just isn't being interpreted properly as EOF
23:32  yitz_: Yay! I think.
23:32  yitz_: ^D works fine without the -n or -N as EOF
23:32  falconindy: yeah, that's what it is
23:33  falconindy: sort of... if i redirect a file with 2 characters to read -N4, it quits (with error) and REPLY is just 2 chars long
23:33  prince_jammys: 4# printf 'fo' | { read -N3; echo "[$REPLY]"; }
23:33  shbot: prince_jammys: no output within the time limit
23:33  yitz_: I got output for that ^^
23:34  falconindy: 4# read -N4 <<< "foo"; echo [$REPLY]
23:34  prince_jammys: 4# printf 'fo' >fooey ; read -N3<fooey; echo "[$REPLY]";
23:34  yitz_: Shouldn't that ; be &&  ?
23:34  shbot: falconindy: bash4: read: -N: invalid option
23:34  shbot: falconindy: read: usage: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
23:34  shbot: falconindy: []
23:34  shbot: prince_jammys: bash4: read: -N: invalid option
23:34  shbot: prince_jammys: read: usage: read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-p prompt] [-t timeout] [-u fd] [name ...]
23:34  shbot: prince_jammys: []
23:34  prince_jammys: hehe
23:34  falconindy: bash4 bot isn't bash 4?
23:34  prince_jammys: 4# echo $BASH_VERSION
23:35  shbot: prince_jammys: no output within the time limit
23:35  prince_jammys: 4# echo $BASH_VERSION
23:35  yitz_: lol
23:35  falconindy: wat
23:35  shbot: prince_jammys: no output within the time limit
23:35  yitz_: 4# echo $SHELL
23:35  falconindy: 4# bash --version
23:35  shbot: yitz_: /bin/bash
23:35  shbot: falconindy: GNU bash, version 4.0.33(1)-release (i486-pc-linux-gnu)
23:35  shbot: falconindy: Copyright (C) 2009 Free Software Foundation, Inc.
23:35  shbot: falconindy: etc... ( http://pastebin.com/3Kik7N90 )
23:35  falconindy: aha
23:35  falconindy: !faq version
23:35  greybot: http://mywiki.wooledge.org/BashFAQ/061 -- Is there a list of which features were added to specific releases (versions) of Bash?
23:37  prince_jammys: wiki's down, i think.
23:37  yitz_: So ... is there a bug or should ^D somehow not be EOF when -n/-N is used?
23:37  drake1: hello, how well does ( grep a & grep b ) < file work in bash?
23:37  falconindy: well the behavior does sort of contradict the help
23:38  lhunath: drake1: sorry?
23:38  drake1: does is even separate in newlines?
23:38  drake1: does it even*
23:39  lhunath: doubtful.
23:39  lhunath: there is no logic that would do that.
23:40  drake1: the standard libc buffer can newline delimit
23:40  lhunath: just two processes reading from an fd
23:40  nDuff: !wayttd > drake1
23:40  greybot: drake1: What Are You Trying To Do?
23:41  drake1: to distribute a grep over several cores
23:41  lhunath: whatever the heck you mean with "the standard libc buffer" is most likely irrelevant
23:41  nDuff: a _single_ grep?
23:41  nDuff: of a single stream?
23:41  lhunath: write a better grep.
23:42  drake1: might work better to split the file in two, first
23:42  falconindy: sounds like a better grep in the making
23:42  lhunath: or do the reading by a central process.
23:42  nDuff: ...I mean, you _could_ write a tool equivalent to tee which round-robins lines between output sinks
23:42  drake1: ie. grep a part1 & grep a part2
23:42  nDuff: but there'd be substantial overhead to that
23:42  nDuff: by the way, the parallel grep thing has been done before
23:43  drake1: oh
23:43  lhunath: while read a; read b; then echo "$a" >&3; echo "$b" >&4; done 3> >(grep a) 4> >(grep b)
23:43  drake1: then maybe you can give some hints
23:43  lhunath: not then, do.
23:44  drake1: what about to seek for the \n closest to the middle of the file, and split it there?
23:44  lhunath: then again; who's to say what process your OS affines each grep process to?
23:45  lhunath: I don't even know why I bother trying to figure you out.  /me wanders off.
23:45  drake1: at least it should not be disallowed to run several greps simultaneously
23:46  nDuff: it isn't disallowed
23:47  nDuff: it's just that writing code in which you have two processes trying to do buffered-line reads from the same input source is doomed to disaster. You need one arbiter to distinguish between the two -- thus the tee-like tool (which lhunath mocked u p for you), or the ahead-of-time split, or whatever else.
23:47  nDuff: think about how reading from files works --
23:48  nDuff: the file pointer doesn't move a line at a time, it moves in terms of how many characters each individual read() call returns
23:48  nDuff: it's the application responsible for buffering those values and making bytes out of them
23:48  nDuff: so if you have two tools reading from the same source to populate your buffers, the points when one app stops reading and another starts won't be at clean line boundaries unless you've extraordinarily lucky.
23:48  nDuff: drake1, ^^^\
23:48  drake1: all the greps don't have to run at the same time
23:49  nDuff: err, I thought making them run at the same time was the whole point.
23:49  drake1: maybe popen("grep a","w") and gets, puts is the best
23:49  nDuff: ...
23:50 * nDuff gives up.
23:50  drake1: but that would force both the greps to work which is no good in single core systems
23:51  drake1: then it's probably better to set up a line buffer with libpcre
23:51  nDuff: eh
23:52  nDuff: if what you have is a big-data problem, then grep is the wrong tool anyhow
23:52 * nDuff uses logstash+ElasticSearch for managing logs across nodes.
23:52  drake1: hm
23:53  drake1: that probably depends on the version of grep
23:53  yitz_: https://github.com/IsaacG/Scripts -> I wrote me a bash script to go through Tweets with... Good for processing lots of items, one by one?  :D
23:53  nDuff: "version of grep"?
23:53  nDuff: how would it?
23:53  drake1: some greps might fork and sh**
23:53  nDuff: grep does regex-based searching, Lucene-based engines like LogStash do ahead-of-time indexing
23:54  nDuff: spawning off children doesn't solve the underlying problem that you don't have your data indexed ahead-of-time
23:54  drake1: thats what grep should do
23:54  nDuff: what's what gerp should do?
23:54  nDuff: s/gerp/grep/
23:54  nDuff: certainly not ahead-of-time indexing
23:54  drake1: create the data branches
23:54 * nDuff gives up.
23:54  nDuff: no, I'm not talking about compiling the regex
23:55  nDuff: I'm talking about indexing the DATA
23:55  drake1: ok
23:55  nDuff: anyhow, enough of this productivity sink
23:55  drake1: grep should compile the pattern too
23:55  nDuff: *plonk*
23:56  drake1: since grep is good for branching similar patterns, it may be used for large data index directories
23:58  drake1: you know with special index types for special patterns
--- Log closed Mon Dec 27 00:00:04 2010
