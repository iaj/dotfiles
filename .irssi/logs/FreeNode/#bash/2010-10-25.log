--- Log opened Mon Oct 25 00:00:20 2010
--- Day changed Mon Oct 25 2010
00:00  xenol: hello guys, me again. is it a correct regex for multiple directories as parameters into case? [[:alnum:]/]*
00:00  xenol: the command where i am running it gets multiple directories as arguments
00:01  geirha: case does not take a regex
00:01  xenol: wrong explanation ><
00:01 --- mikeplus32 is now known as mikeplus64
00:02  xenol: http://pastebin.com/KzE7xhUb
00:03  xenol: this code, will it print out every argument if the $1 is made of a-zA-Z0-9/ ?
00:03  geirha: No, as I said, case does not understand regex. Only globs.
00:04  geirha: If you want to check if an argument is a directory, do a -d test
00:04  xenol: i know that, but can case take it?
00:04  xenol: i need some case for $1 to match and then test for directory
00:05  geirha: ...  *) if [[ -d $1 ]]; then echo "It's a dir"; fi;; esac
00:05  xenol: geirha: *) is for wrong parameters :>
00:05  xenol: (at least now)
00:06  geirha: !faq easily > xenol
00:06  greybot: xenol: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
00:06  geirha: Try doing it that way instead ^
00:06  xenol: thanks
00:08  cjc2010: please could someone help me with the general process of such a script, as above, what would be the stages + programs needed?
00:08  cjc2010: ^software components
00:12  Bushmills: cjc2010, at top you'd have:
00:12  Bushmills: !#!
00:12  greybot: Jargon, from "hash bang", or "#!". The shebang line is read by the kernel when a script is executed. See http://www.in-ulm.de/~mascheck/various/shebang/
00:14  cjc2010: oh sorry did I miss anything?
00:27 --- ricky is now known as Guest33288
00:29 --- ricky_ is now known as ricky
00:34  Nashenas: does anyone know how to make the PS1 change when you enter in a command?
00:35  Nashenas: as in i have the time that the PS1 was displayed, then i put `ls` then pressing enter rewrites the PS1with the time updated to the current time, then writes the command I entered
00:35  Nashenas: i know how to do everything except running one script before it runs the command
00:40  cjc2010: Hello, so say, I was to write a script to auto print new email what software components would I need?
00:41  Bushmills: as bash script? well, you need bash. and the external programs you intend to call from your script
00:41  cjc2010: ty, that is a start
00:42  cjc2010: maybe I should start by asking a different question: how do I read email from the terminal?
00:43  jordanm: cjc2010: "mail -f <mbox>"
00:43  jordanm: or any other console based MUA
00:44  cjc2010: hehe ok ty so the program is mail?
00:45  cjc2010: or any other console based MUA
00:45  cjc2010: ty
00:58  ritzt3ch: if i have a Comma i should be able to use awk print collum 2  .... when i do a cat /usr/local/bin/loc.map | grep NYC9799 | awk ' {print $2}'  It doesnt show but if i do a print 1 it does
--- Log closed Mon Oct 25 01:05:01 2010
--- Log opened Mon Oct 25 01:05:28 2010
01:05 --- Users 512 nicks [0 ops, 0 halfops, 0 voices, 512 normal]
01:05  geirha: shopt -s extglob  ...  if [[ $1 = *@(nyc|phl|bal)* ]]
01:05  geirha: !extglob > ritzt3ch
01:05  greybot: ritzt3ch: "Extended globs" (shopt -s extglob) allow you to say things like "all files that do not end in .jpg". See http://mywiki.wooledge.org/glob
01:05  geirha: case $1 in *nyc*|*phl*|*bal*) ... ;; esac
01:06  geirha: !faq location > Cam
01:06  greybot: Cam: http://mywiki.wooledge.org/BashFAQ/028 -- How do I determine the location of my script?  I want to read some config files from the same place.
01:06  Cam: greybot; thanks.
01:06 --- Channel #bash was synced in 92 seconds
01:18 --- JmZ is now known as JmZ_
01:19  ritzt3ch: im trying to do like if $1 contains nyc OR bdr OR nbw    if [[ $a = *nyc|bdr|nbw* ]] it only works on nyc Or do i have to make 3 individual IF thens
01:19  Cam: greybot; That didn't work.
01:24  Sonderblade: how can you get X number of random lines from a file?
01:25  foobar2: sort --random-sort file | head -n X
01:25  geirha: ritzt3ch: Read about extglob
01:26  foobar2: Sonderblade: it may not be particularly efficient for large files, though
01:26  Sonderblade: foobar2: nice
01:29  ttwj: hello, I'm using sed to do some regex
01:30  ttwj: how can I do sed -e 's/(\(.*\))/[ (.*) ]/'?
01:30  ttwj: I want the value of \(.*\) into the replace field..
01:30  ttwj: is it possible?
01:32  ttwj: nvm I got it
01:33  altF4_: hi
01:34  altF4_: why this print 0 -> (false && false) || true; echo $?
01:34  cthuluh: because the last executed command is true
01:34  altF4_: false=1, true=0 -> then (1 && 1 || 0) = 1
01:35  cthuluh: it doesn't work like that
01:35  altF4_: cthuluh, first part is 1, but second will not be executed because is 1
01:36  geirha: When first false fails, it skips to the || and executes true
01:36  doublehp: one thing I never understand: is it possible to make substitution on the fly for variables ? for example, ip=127.0.0.1 and i want to print it as 127_0_0_1 . *I* would do echo "$(echo $i | tr "\." "_" ) ... but I think there is a faster way, like echo ${i : ~.......} isn't it ? any tuto about that ?
01:36  cthuluh: ''(false && false)'' means the same as ''(false)'' and also the same as ''false''
01:36  cthuluh: (speakin of return values)
01:37  geirha: doublehp: ${i//./_}
01:37  geirha: !faq 100 > doublehp
01:37  greybot: doublehp: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
01:39  geirha: With   true || false && false  it will first execute true, and since it returns true, it skips to the && and executes the false after it.
01:39  doublehp: can i replace two patterns in the same shot ?
01:39  doublehp: let say .>- and 0>8
01:40  geirha: No, two PEs or one tr
01:42  doublehp: i=127.0.0.1 ; echo "$(echo ${i//./-}|sed 's/0/8/g')" .......... anything faster ?
01:43  geirha: i=127.0.0.1 i={i//./-}; echo "${i//0/8}"
01:45  ribasushi: I want to do the following:
01:46  ribasushi: for ... ; do rm -rf ./* ; do more stuff ; done
01:46  ribasushi: how do I make the * re-evaluate on every loop instead of expanding right away?
01:47  geirha: ribasushi: It expands each time rm runs. But the first rm probably removed everything during the first iteration.
01:47  doublehp: ribasushi: it's expanded when you launch the line; it will do it on loop basis is you store this in a script
01:48  ribasushi: geirha: yes, this is what I want, it's to clean the dir before "do more stuff" runs
01:48  ribasushi: doublehp: what if I do this on the cli?
01:49  doublehp: ribasushi: i think, on CLI, * will always send the same value as first loop; aka, if looping takes time, second pass ... will not delete files created in the mean time; i expect different behaviour in a stored script
01:49  geirha: It'll still expand each time it executes the rm command
01:49  ribasushi: excellent
01:49  geirha: # touch file; for i in 1 2; do echo *; rm file; done
01:49  evalbot: geirha: file
01:49  evalbot: geirha: *
01:49  evalbot: geirha: rm: cannot remove `file': No such file or directory
01:50  doublehp: ribasushi: if in each loop, you Want to remove newly created files, you need to change things; but i am not expert enough to tell what you need
01:50  doublehp: ribasushi: add sleep1 and date based files to see what's up
01:51  doublehp: like touch plop-$(date +%Y-%m-%d_%H-%M-%S)
02:01  ritzt3ch: i took the lazy route and added like 100 lines of code by copying 5 differnt chunks of if [[ $a = *phl* ]]  OR if [[ $a = *nyc* ]] Wait cant i do an else hmmmmmmm
02:05  geirha: !guide > ritzt3ch
02:05  greybot: ritzt3ch: http://mywiki.wooledge.org/BashGuide
02:07  azizLIGHTS: how do i start the shell on ~/win7/Desktop
02:07  azizLIGHTS: default start path
02:07  geirha: Change dir, then start the shell, or put a cd in the rc file
02:08  geirha: !dotfiles
02:08  greybot: http://mywiki.wooledge.org/DotFiles or - for a technical explanation - the INVOCATION section of man bash.
02:09  azizLIGHTS: cd good idea
02:09  azizLIGHTS: thx
02:12  azizLIGHTS: !faq 1
02:12  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
02:24  Colloguy: how do I check in a script which version of a utility is on a system (gnu? bsd?)
02:27  Colloguy: do I like grep the man page...
02:30  krzie: when in the man page
02:30  krzie: type /string
02:30  krzie: it will jump to the next instance of string
02:31  krzie: then / and enter will jump to next one
02:34  Colloguy: was wondering if there was a correct way to check utility provenance from a script
02:35  Colloguy: so far I have "try options until it explodes" :D
02:46  hax0r1: anybody knows the code for orange color in bash, e.g. bold green is '\e[1;32m]'
02:54  doublehp: is it possible, using CLI, to start a script named A, in a way that printing $0 from A will show B, without doing ln -s A B ?
02:54  azizLIGHTS: how should i compare the current time to given time? i want to decide if 5:53pm is before or after $(date +'%I:%M%P')
02:54  doublehp: note: A is written in perl
02:55  doublehp: azizLIGHTS: you need to convert to absolute seconds ...
02:55  azizLIGHTS: how do i do that
02:55  doublehp: azizLIGHTS: work on this rebour script: http://dpaste.com/263324/
02:56  azizLIGHTS: its in french?
02:56  doublehp: azizLIGHTS: bash has no lang
02:56  doublehp: but yes
02:58  doublehp: azizLIGHTS: an other example : http://pastebin.com/6qXvzdQ6
02:58  azizLIGHTS: hmm i dont see why i should convert to absolute seconds
02:58  azizLIGHTS: im trying to compare relative time
02:58  azizLIGHTS: like: now its 6pm, this is after 5pm, and the bank is closed
02:58  ChrisRut_: I have a VERY simply for loop to find directories (http://pastebin.com/40p9Laje) however I want to exclude a single directory from the loop, what would be the best way to accomplish this?
02:59 --- ChrisRut_ is now known as ChrisRut
03:00  doublehp: azizLIGHTS: you do, always; for example, to take care about winter saving time ... you need to call system libs
03:00  ChrisRut: I've tried: if [ -d "$i" ] && [ "$i" != "exclude"]
03:00  ChrisRut: but that didn't do it
03:01  doublehp: ChrisRut: echo $i | grep "idontwantthis"
03:01  doublehp: ?
03:01  ChrisRut: but I want to exclude it from the loop
03:01  doublehp: u can't
03:01  doublehp: not this way
03:02  ChrisRut: so how can I take action against every directory except one in a for-loop ?
03:02  doublehp: you need something like while read line ; do ..... ; done <<<$(ls | grep -v "ffobar")
03:03  Colloguy: ChrisRut:  [ "$i" = evildir ] && continue
03:03  doublehp: this will loop !
03:05  ChrisRut: nvm, I got it: if [ -d "$i" ] && [ "$i" != exclude]
03:05  ChrisRut: the quotes around "exclude" killed it
03:05  ChrisRut: Thanks for the nudges doublehp and Colloguy
03:05  ChrisRut: :)
03:05  doublehp: why do u use if ?
03:06  ChrisRut: doublehp: http://pastebin.com/7Wskv3RE
03:06  doublehp: there is a faster way
03:06 * ChrisRut interested
03:07  doublehp: [ -d "$i" ] && [ "$i" != "exclude" ] && echo "$i"
03:07  doublehp: maybe
03:07  doublehp: [[ -d "$i" ]] && [[ "$i" != "exclude" ]] && echo "$i"
03:07  doublehp: in new bash, not sure
03:07  ChrisRut: the quotes areound "exclude" won't work, but yes
03:08  ChrisRut: that would be faster
03:08  ChrisRut: however, I don't plan on "just" echoing these directories, it's just a proof-of-concept
03:08  doublehp: then
03:08  ChrisRut: but Thanks for the insight, much appreciated
03:08  doublehp: [[ -d "$i" ]] && [[ "$i" != "exclude" ]] && { many commands ;}
03:08  ChrisRut: true
03:08  Colloguy: use continue statements and save yourself a nesting :P
03:09  Znuff: Hi.
03:09  doublehp: or reject it before the variable is assigned !
03:09  doublehp: is it possible, using CLI, to start a script named A, in a way that printing $0 from A will show B, without doing ln -s A B ? note: A is in perl
03:10  Znuff: how would I check if a file named something.part01.rar exists? where "something" is random?
03:10  ChrisRut: Znuff: find . -type f -name *.part01.rar
03:10  doublehp: ls *.part01.rar && echo ok
03:10  Znuff: in an if [] statement
03:11  Znuff: let's try that, then :P
03:11  doublehp: [ "*.part01.rar" != "" ] && echo ok ?
03:11  doublehp: no
03:12  doublehp: Znuff: stupid question: is there only one random, or may there be several ones ?
03:12  doublehp: if only one: [ -f *.part01.rar ] may work
03:12  Znuff: usually just one file named part01.rar
03:12  doublehp: but if several, you MAY get a bash error
03:12  Znuff: oh, right, if I add part01.rar then I won't get error
03:12  Znuff: an error
03:12  go|dfish: !faq empty
03:12  greybot: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
03:13  doublehp: [ -f *.part01.rar ] will make a strange error if there are two files
03:13  Znuff: too many argumens
03:14  Znuff: I'll try go|dfish's sugestion
03:15  doublehp: [ "$(ls *.part01.rar 2>/dev/null)" != "" ] && echo ok
03:18  azizLIGHTS: if [[ "$hours_dinner_open" < "$todayshour" ]] && [[ "$hours_dinner_close" < "$todayshour" ]]
03:18  azizLIGHTS: am i doing wrong
03:18  go|dfish: azizLIGHTS: < is for string comparison, use -lt
03:18  Znuff: what was bash's else if? elif or plain else if?
03:18  go|dfish: or alternatively, you can use (( )) for numbers
03:18  Znuff: I can never remember that?
03:19  Znuff: and that wasn't a question
03:19  go|dfish: elif
03:19  go|dfish: that wasn't an answer?
03:20  azizLIGHTS: what do you mean go|dfish ?
03:20  azizLIGHTS: those variables contain numbers
03:20  azizLIGHTS: so which do i use
03:20  Znuff: good answer!
03:20  doublehp: azizLIGHTS: if dinner goes over midnight, yes
03:20  azizLIGHTS: what?
03:20  azizLIGHTS: not following you doublehp
03:20  doublehp: azizLIGHTS: if there is a day change, you have a glitch
03:21  go|dfish: azizLIGHTS: you can use either. you can use: if (( foo < bar && foo < baz )) ... of if [[ $foo -lt $bar && $foo -lt $baz ]]
03:21  azizLIGHTS: doublehp: oh i see
03:21  go|dfish: < inside [[ ]] (or [ ]) means: True if STRING1 sorts before STRING2 lexicographically.
03:21  azizLIGHTS: oh
03:22  azizLIGHTS: doublehp: no im in the same day, thankfully
03:22  doublehp: azizLIGHTS: as i said long time ago, you need to convert to UNIX seconds since 1960
03:22  azizLIGHTS: i decided to use juse date +'%H'
03:22  doublehp: azizLIGHTS: believe me, one day, it will break
03:22  azizLIGHTS: *just
03:22  azizLIGHTS: its simpler for my purposes
03:22  Znuff: hmmm, how to check for the existance of a directory, case insesitive?
03:23  azizLIGHTS: doublehp: how come u think so
03:23  doublehp: if dinner starts at midnight, and you have a summer to winter time saving change, time will go backward
03:23  doublehp: azizLIGHTS: life sux, life *ALWAYS* sux . Murphy !
03:24  doublehp: you don't want to play with Murphy.
03:24  azizLIGHTS: is it ok if my hours never go beyond the same day
03:24  azizLIGHTS: 7pm (19) is the latest
03:24  doublehp: then as he said, use digital comparison: man test, thiungs like -gt and so
03:25  azizLIGHTS: hm ok
03:27  Znuff: Can this be improved? http://pastebin.com/mMkNUjdM
03:27  Bronze: yes
03:27  doublehp: what do u call improovement ?
03:27  azizLIGHTS: can -lt not compare decimals
03:27  Znuff: no idea, I'm expecting stuff like "stop using XYZ FOR THE LOVE OF GOD, IT'S DEPRECATED" or something similar
03:28  doublehp: space ? readability ? CCCCC ? speed ?
03:28  doublehp: azizLIGHTS: nver decimals in bash
03:28  Bronze: too terse? add more commenst
03:28  Bronze:  too many comments? make it more tyerse...
03:28  Znuff: let's say... can the logics of this be improved?
03:28  azizLIGHTS: so i have to use the (( foo < bar && foo < baz )) format to compare numbers?
03:28  azizLIGHTS: with decimals
03:29  azizLIGHTS: where foo is a variable containing a number with a decimal
03:29  doublehp: azizLIGHTS: we usually deal decimals with bc
03:32  Znuff: !regexp
03:32  greybot: Regular Expressions are used to *match* certain patterns of occurances in strings. There are several different "dialects" of regex syntax. Bash only supports EREs (using [[ string =~ pattern ]]). Sed uses BREs. Perl uses PCREs. (See !ere, !bre or !pcre)
03:32  Znuff: !ere
03:32  greybot: Posix Extended Regular Expressions: http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_04
03:34  Znuff: !bre
03:34  greybot: Posix Basic Regular Expressions: http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html#tag_09_03
03:35 * Znuff scratches head
03:35 * Znuff should have learned regular expressions
03:39  Znuff: How would I grab only the imdb id from a file containg, amongst others, an imdb link like this     ?   ?????              http://www.imdb.com/title/tt1620446/                                                                                                                                                                              ? ?
03:39  Znuff: uh
03:40  doublehp: azizLIGHTS: http://mywiki.wooledge.org/BashFAQ/022
03:40  yitz_: !html
03:40  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
03:40  azizLIGHTS: ah ok
03:40  azizLIGHTS: thanks
03:40  Znuff: yitz_, not parsing (X)HTML
03:41  Znuff: yitz_, it's a textfile
03:41  doublehp: how can i alter the basename of a perl script, from bash, without doing symlink ?
03:42  yitz_: With the move command?
03:42  yitz_: mv
03:42  doublehp: no
03:42  Znuff: then you can't
03:43  doublehp: an equivalent of "." in bash
03:43  doublehp: . can do it for bash scripts
03:46  azizLIGHTS: i want to show all lines after a specific string in a file, im using sed -n '/Dairy/,$p' but it shows the line itself too
03:47  azizLIGHTS: should i just pipe to another sed and rm that line
03:47  azizLIGHTS: or is there a better way
03:49  go|dfish: 1,/Dairy/d
03:49  azizLIGHTS: sed: -e expression #1, char 10: unknown command: `,'sed: -e expression #1, char 10: unknown command: `,'
03:49  azizLIGHTS:  sed -n '1,/Dairy/,$p' ?
03:49  azizLIGHTS: er
03:49  azizLIGHTS: nbm
03:49  azizLIGHTS: nvm
03:51  azizLIGHTS: sed -n '1,/Dairy/d'
03:51  azizLIGHTS: right?
03:51  go|dfish: drop the -n
03:51  azizLIGHTS: oh i see thank you
03:55  Znuff: !empty
03:56  Znuff: hmmm, how do I check if a string is empty or not?
03:56  go|dfish: Znuff: you mean a variable?
03:57  Znuff: yes, variable
03:57  Znuff: oh if [ $var ] seems to work fine
04:04  Znuff: Hmmm, I have an issue
04:05  Znuff: http://pastebin.com/nYi9avea I have this script, and even though there are no part01.rar files, it tries to extract them
04:17  azizLIGHTS: whats that thing you do when debugging?
04:17  azizLIGHTS: set +x?
04:17  doublehp: Znuff: in which section ? first or last ?
04:18  Znuff: doublehp, last 3rd condition, after it can't find CD1 and/o DVD1
04:18  Znuff: http://pastebin.com/1uWXukT4
04:18  Znuff: there
04:19  doublehp: why do u use parenthesis instead of square brackets ?
04:19  doublehp: i ve never seen this syntax in my life, and i think you are wrong about it
04:19  Znuff: that was the example? :-/
04:19  doublehp: from ?
04:19  Znuff: http://mywiki.wooledge.org/BashFAQ/004
04:20  azizLIGHTS: Znuff: lemme paste u mine
04:21  doublehp: Znuff: really, u should do ... while read line ; do ... done <<<$(ls *parts 2>/dev/null )
04:21  azizLIGHTS: Znuff: http://pastebin.ca/1972382
04:23  azizLIGHTS: so how do i see what sgoing on in my script? what is the debug option
04:23  falconindy: doublehp: no, he shouldn't. please don't suggest that people parse ls
04:23  falconindy: !ls
04:23  greybot: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
04:24  go|dfish: azizLIGHTS: set -x
04:24  Znuff: oh, I was doing something stupid
04:24  Znuff: I was negating the condition
04:24  Znuff: just mindlessly copy/pasted the example
04:31  Znuff: azizLIGHTS, doesn't your script fail 10% of the time?
04:31  ChrisRut: how can I output a list of directory names using find, without the full path?  For example; find src/sites/ -type d will output the full path of "src/sites/site1" instead of JUST "site1"
04:32  azizLIGHTS: idk i havent used it in a while, it used to work great with scene style rars
04:33  azizLIGHTS: Znuff: theres more to that script btw
04:35  Znuff: yeah, but based on what I know and inspecting that script, stuff should fail about 10% of the time :P
04:35  Znuff: just an intuition
04:35  azizLIGHTS: theres a chunk missing from it
04:35  azizLIGHTS: dunno
04:36  azizLIGHTS: if its useful, see if it helps u
04:36  Znuff: ChrisRut, awk of sed, I guess
04:37  Znuff: brb
04:37  azizLIGHTS: Znuff: http://pastebin.ca/1972391
--- Log closed Mon Oct 25 05:05:09 2010
--- Log opened Mon Oct 25 05:05:29 2010
05:05 --- Users 501 nicks [0 ops, 0 halfops, 0 voices, 501 normal]
05:06  optraz: ?
05:06 --- Channel #bash was synced in 90 seconds
05:09  optraz: what's the command to check if a file is currently open?
05:11  Znuff: [06:02:28] <ferret> lsof maybe
05:21  jordanm: optraz: fuser on linux
05:43  azizLIGHTS: i got a var with lots of lines in it, how do i read each line by line of the variable
05:44  optraz: jordanm: thanks
05:44  eboyjr: !faq read
05:44  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
05:44  Znuff: azizLIGHTS, while read line ; do ... done
05:44  azizLIGHTS: oh
05:44  azizLIGHTS: same way
05:45  Znuff: input doesn't have to be a file, so yeah
05:45  eboyjr: !faq substr
05:45  greybot: http://mywiki.wooledge.org/BashFAQ/041 -- How do I determine whether a variable contains a substring?
05:46  eboyjr: How can I get a substring of a variable? (from the beginning to a specified index)
05:46  Znuff: eboyjr, this might sound silly, but... cut ?
05:47  eboyjr: Thanks it's not silly lol I'm not familiar with a lot of the gnu programs
05:48  epicure: # myVar=abcdefghi; index=4; echo "${myVar::index}"
05:48  evalbot: epicure: abcd
05:48  eboyjr: ahh much better
05:48  eboyjr: Thanks epicure
05:49  eboyjr: I'm elipsizing text that is too long
05:49  epicure: !pe > eboyjr
05:49  greybot: eboyjr: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
05:54  azizLIGHTS: i got this file with lines in it, some lines have "status" written, and following lines have details, then another "status" line, followed by details. i want to grp each status update and its details with a for loop and put to array somehow?
05:54  azizLIGHTS: suggestions?
05:56  amerinese: got a pretty dumb question: how can i make little shortcuts to strings that i can readily use for inserting into other commands.  So instead of typing find / -iname "somefile" 2>/dev/null, I'd like to be able to write find / -iname "somefile" n where n stands for 2>/dev/null
05:56  amerinese: or similar
05:57  azizLIGHTS: would a alias in .bashrc work for that?
05:57  amerinese: i don't think so, for a partial command?
05:57  Znuff: amerinese, global variables?
05:57  Znuff: export n="2>/dev/null", find ... $n ?
05:57  Znuff: not sure if it would work
05:57  eboyjr: So I have more elipsize function, but I don't understand the error:
05:57  eboyjr: http://pastie.org/1246417
05:58  Znuff: actually pretty sure that won't work :-/
05:58  amerinese: Znuff: no it doesn't work
05:58  azizLIGHTS: amerinese: thats a good idea though, i need that too
05:58  Znuff: works only if you evaluate it
05:58  eboyjr: The error is on line 4, not 10
05:59  amerinese: yeah i guess sticking an eval in front works, but that's not ideal since eval is extra typing too
05:59  amerinese: would it be weird to auto eval anything you typed on the prompt?
06:00  azizLIGHTS: eboyjr: how did you say error on pastie.org
06:00  amerinese: it's going to be eval'd anyways but just adds an extra layer of pre-eval eval
06:00  eboyjr: azizLIGHTS: You can mark sections with ##
06:00  azizLIGHTS: so u just did ##error ?
06:00  azizLIGHTS: on a line
06:00  eboyjr: ## Error [plain_text]
06:00  eboyjr: Yup
06:00  eboyjr: Can you help me with the error though? lol
06:01  azizLIGHTS: idk bout that :(
06:01 * eboyjr thought 37 *was* unary
06:03  eboyjr: !test
06:03  greybot: help test <Enter> http://mywiki.wooledge.org/BashGuide/TestsAndConditionals | http://bash-hackers.org/wiki/doku.php/commands/classictest
06:03  azizLIGHTS: can you pipe in this line: while read -r line
06:03  azizLIGHTS: | grep
06:03  azizLIGHTS: no?
06:04  Znuff: while read -r line; do ... done <<<$(command | grep | whaever) ?
06:04  micols: how is it I log 'time' bash built-in output for a cmd?
06:04  eboyjr: while read -r line; do echo "Line: $line"; done <<< $(command)
06:04  micols: should I use script(1) for this?
06:05  micols: (or perhaps there is a better way of getting cpu time for my cmd, and logging it to a file)
06:07  eboyjr: I replaced -gt with > and I get 'ambiguous redirect' http://pastie.org/1246417
06:08  yitz_: !(( > eboyjr
06:08  greybot: eboyjr: ((...)) is an arithmetic command, which returns an exit status of 0 if the expression is nonzero, or 1 if the expression is zero. Also used as a synonoym for "let", if side effects (assignments) are needed. See <http://mywiki.wooledge.org/ArithmeticExpression>.
06:09  Coded1: is there a way to use vim to execute the script im working on rather than saving and executing on another terminal?
06:09  TheBonsai: y0
06:10  eboyjr: yitz_: i dont understand why you mentioned that
06:10  eboyjr: i kind of need like a context?
06:10  yitz_: The > needs (( ))
06:10  yitz_: Not [[ ]]
06:11  eboyjr: Okay I don't have [[ ]] though
06:11  yitz_: Hm. Not [ ], then
06:11  eboyjr: All I need is do execute the if statement if ${#1} is greater than $2
06:12  eboyjr: So if [ ((${#1})) > (($2)) ]; then?
06:12  eboyjr: Or if ((${#1} > $2)); rather
06:13  TheBonsai: if you take the one that works, you got it
06:13  TheBonsai: and remove your files named like $2 :)
06:13  eboyjr: Neither works.. for the second one I get line 10: ((: 15 > : syntax error: operand expected (error token is "> ")
06:14  TheBonsai: # set -- 1 2;  ((${#1} > $2)); echo $?
06:14  eboyjr: I'm comparing integers guys
06:14  evalbot: TheBonsai: 1
06:16  yitz_: eboyjr: Execute if the length of the first arg is bigger than the value given byu the second arg?
06:16  eboyjr: Yes
06:16  eboyjr: It looks like if [[ ${#1} -gt $2 ]]; then works
06:17  eboyjr: All I needed was to use [[ instead of [ but I don't know the difference
06:17  yitz_: Is $2 set?
06:17  eboyjr: $(shorten "${BASH_REMATCH[1]}" $COLS)
06:17  eboyjr: Oh wow no it's not
06:18  TheBonsai: set -x
06:18  TheBonsai: useful
06:18  yitz_: Maybe check for that, first
06:18  eboyjr: I have to rely on variables that dont exist being "" in my script :p
06:20  yitz_: If you expect $2 to be an integer ... check it
06:20  yitz_: # var="" ; echo $(( var ))
06:20  evalbot: yitz_: 0
06:20  TheBonsai: !faq number
06:20  greybot: http://mywiki.wooledge.org/BashFAQ/018 -- How can I use numbers with leading zeros in a loop, e.g. 01, 02?
06:20  yitz_: And "" is 0
06:20  TheBonsai: erm
06:20  TheBonsai: !faq integer
06:20  greybot: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
06:20  TheBonsai: hell...
06:20  TheBonsai: !faq digit
06:20  greybot: TheBonsai: No matches found at http://mywiki.wooledge.org/BashFAQ
06:20  TheBonsai: damn
06:21  yitz_: !faq valid
06:21  greybot: http://mywiki.wooledge.org/BashFAQ/054 -- How can I tell whether a variable contains a valid number?
06:21  TheBonsai: aaaah
06:21  eboyjr: great
06:25 --- shatt_ is now known as shatt
06:26  eboyjr: I wonder if there are any higher-level tools that compile to bash cuz the whole syntax of everything is like it was all hacked together
06:28  optraz: i have a file which start with %; example %foo and a new line. then follow by a lot of text until the ext coming %baz. how can we process such file with the preceeding % ?
06:31  yitz_: Line by line?
06:32  eboyjr: !faq line by line
06:32  greybot: http://mywiki.wooledge.org/BashFAQ/089 -- I'm reading a file line by line and running ssh or ffmpeg, but everything after the first line is ignored!
06:32  yitz_: !faq 1
06:32  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
06:33  eboyjr: I like how it searches for the faq page with your query instead of making you  remember numbers
06:36 --- itmorr is now known as rromti
06:42  Znuff: I wonder
06:43  Znuff: is it possible to make a script to "diff" dirs?
06:43  Znuff: Hmmm, I shall think on that :-)
06:45  tuxdev: Znuff, I know GNU diff has an option for recursion
06:46  tuxdev: -r or -R or something
06:46  Znuff: actually I was thinking of directory contents
06:46  Znuff: like, list a directory, compare $today to $yesterday, and spit out what's new
06:47  tuxdev: uh, yeah.  most versions of diff should have an option to Just Do It.
06:48  Znuff: ($todaylisting to $yesterdaylisting)
06:52  TheProf: Good day. I hope everyone is well.  Hopefully I'm in the right place.  I wanted to know please how to recursively go through a list of folders and rename a subfolder called Download to Downloads. Possible?
06:53  tuxdev: certainly possible
06:53  tuxdev: find -name "Download" -type d
06:54  tuxdev: that'll get you all the directories named "Download"
06:54  TheProf: tuxdev: good to hear it's possible :)  I had to move all the users from one server to a newer one when the old one crashed and the new server's directory structure requires they be named Downloads while the old was Download
06:54  Znuff: for i in $(find -name "Download" -type d); do mv "$i" "$i"s; done
06:54  Znuff: :-)
06:54  tuxdev: Znuff, bad
06:55  Coded1: bad?
06:55  Znuff: why?
06:55  Znuff: because I hate xargs?
06:55  tuxdev: word splitting
06:55  tuxdev: xargs is broken too
06:56  Znuff: xargs is terrible
06:56  Znuff: oh, right, that won't work if your directories have spaces in their names
06:57  TheProf: None of the directories have a space
06:57  TheProf: these are all /home/* directories.
06:57  Znuff: go ahead them :P
06:57  Znuff: but, first
06:57  tuxdev: find -name "Download" -type d -exec /bin/sh -c 'mv "$1" "$1s"' "{}" ";"
06:57  Znuff: replace mv with "echo mv"
06:58  TheProf: Znuff: I see - to see the output before it happens.
06:58  TheProf: tuxdev: what does that line do?
06:58  tuxdev: "there's no spaces, *this time*" is no excuse for doing it wrong
06:58  Znuff: yeah, always safe to do that when moving stuff around
06:58  TheProf: ah I see it now tuxdev
06:58  Znuff: ofcourse, tuxdev's version is way beter
07:00  mouche: so, I'm familiar with the stack and heap in C, but I'm curious how vars are stored in bash scripts
07:00  mouche: Are all variables normally on the stack or something? Or are they just treated as environment variables?
07:00  tuxdev: I don't really know the exact implementation, but I suspect it's a big hash
07:01  TheBonsai: on the heap i'd guess. environment is environment. special parameters are "special", i.e. there might be a generating function behind it
07:01  mouche: what do you mean by environment is environment?
07:01  TheProf: tuxdev: I thought to follow your instructions so I can do it correctly -- it spit out an error for each occurrence of the directory: mv: cannot stat `': No such file or directory
07:02  TheBonsai: mouche: unix process environment. it has access functions provided by the system library. wherever it may be stored physically.
07:02  Znuff: TheProf, think your chat client messes up ` and '
07:03  TheProf: ah. I understand.
07:03  mouche: thebonsai, ok
07:03  Znuff: did you type exactly this? http://pastebin.com/gucJQDDc
07:04  TheProf: Znuff: yes I cut-paste it out of the pastebin
07:05  Znuff: same error?
07:05  TheProf: Yup. weird
07:05  TheProf: let me try typing it in straight
07:05  TheBonsai: you miss a delimiter here
07:05  TheBonsai: sh -c "text" DELIM ARG1 ARG2 ... ARGn
07:06  tuxdev: oh yeah, $0
07:06  mouche: thebonsai, with some googling, I was able to find a lot about memory layouts for C/C++ programs, but nothing for BASH. are you aware of any resources?
07:06  TheProf: typing it in straight gives same error. weird. silly question maybe, but does it matter if the directory is empty or not?
07:07  TheBonsai: mouche: does it matter? i mean for anything else but curiosity? you can't control it from the programmer's point of view, anyways
07:09  TheBonsai: TheProf: $1 is not set in the pastebin example. add some fake text between -c "..." and {}
07:10  mouche: thebonsai, nope. I'm just interested in how things work.
07:11  TheBonsai: mouche: then you should check bash's source code. internally, it's just like any other C program with good/bad practises. from the bash language's point of view there is nothing like a "memory layout"
07:11  TheBonsai: mouche: well, there is: everything goes to variables :)
07:11  mouche: right
07:12  TheBonsai: mouche: the automatically assigned and released memory can't be influenced, anyways. for example the memory allocated to do command substitution. from the bash languages point of view it "just happens". sort of automatic memory managemenr
07:13  TheProf: TheBonsai: I'm sorry I am confused by your instructions. Do you mean it should be: find -name "Download" -type d -exec /bin/sh -c 'mv "Download" "Downloads"' "{}" ";"
07:14  TheBonsai: TheProf: it should be something like -exec /bin/sh -c 'mv -- "$1" "${1}s"' -- {} \;
07:14  TheBonsai: and consider a (GNU) maxdepth
07:15  TheProf: the directory in question is 1 level below /home. it's a new installation so the directories are pretty much empty.
07:17  TheProf: TheBonsai: Thank you very much - worked just as needed!
07:17  TheProf: Znuff tuxdev thank you both very much also!
07:18  TheBonsai: the key was the missing fake word after -c "...", in the original version, {} became $0, not $1
07:18  TheProf: Right I see what you mean.
07:20  Znuff: I don't :P I never understood find's -exec
07:20  TheBonsai: Znuff: it's not find. it's sh
07:21  TheBonsai: Znuff: "-c string If the -c option is present, then commands are read from string.  If there are arguments after the string, they are assigned to the positional parameters, starting with $0."
07:21  TheBonsai: Znuff: (bash manpage)
07:22  TheBonsai: Znuff: thogh slightly incorrecxt, since $0 is not a positional parameter. but that doesn't really matter here
07:22  TheBonsai: my typing sucks.
07:27  optraz: yitz_: im not using line by line
07:27  optraz: am using awk
07:28  Znuff: so, how would I write this: for i in $(ls /path/); do echo $i; done considering I have dirs with spaces in them?
07:29  optraz: Znuff: what are you trying to do?
07:29  Znuff: trying to write a script to walk a directory and spit out what's new for each day
07:30  optraz: why dont using find /path ?
07:30  selckin: !ls
07:30  greybot: Don't try to parse ls output. http://mywiki.wooledge.org/ParsingLs
07:30  tuxdev: Znuff, just use diff
07:31  Znuff: I have different conditions for every dir I try
07:31  Znuff: I have a directory with movies, one with series, movie directories like Movies\2010-10 October\Movie1; movie2; movie3 etc.
07:32  Znuff: then, I have series, like Series/NameOfSeries1/Season1/file, Series/NameOfSeries2/Season1/file etc.
07:32  Znuff: and I'm not sure how to process that with diff, seeing that I eventually want to return the path of the file somehow
07:33  Znuff: Did that make sense, or it's just in my head? ;-)
07:33  optraz: lol
07:35  optraz: sounds complicated on what you are trying to do
07:35  Znuff: So I thought of doing something like, parse base directory (Movies) for each month/year, then parse each month/year directory for new directories
07:35  Znuff: So I need some sort of recursive diff's if that makes sense
07:36  optraz: i dont know; you could probably use find with time option
07:36  karthee: Znuff: What do you want to do with diff ?
07:37  karthee: to add use -path  with find command ..
07:38  Znuff: well, as far as I thought it this far, I'll create a file for each directory I'm tracking, like .movies.october.today .movie.october.new, diff them, get the result, manipulate paths and whatever
07:39  Znuff: find is not an option, atimes/mtimes are not reliable in my current setup
07:39  Znuff: a box could skip a day of not running the script, for example, so I'd lose some day(s) between updates
07:40  manhunter: hello,http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-3.html
07:40  Znuff: thanks for the link
07:40  manhunter: are all these correct ? are those depricated?
07:41  Znuff: that stuff is usually backwards compatible, so not likely that they'll ever change
07:41  TheBonsai: manhunter: what are you searching for? a good guide?
07:41  manhunter: so can you post a recent/good example for this?
07:41  Znuff: bash4 added &>>2 I think, but other than that...
07:42  manhunter: TheBonsai, good guide for >&2 ,>&1 redirection
07:42  TheBonsai: !redirtut
07:42  greybot: Learn about redirections! Syntax: http://bash-hackers.org/wiki/doku.php/syntax/redirection and http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection ## Illustrated tutorial: http://bash-hackers.org/wiki/doku.php/howto/redirection_tutorial
07:42  TheBonsai: it's useless to learn redirection syntax without understanding what redirection is, though. so check the "tutorial" first
07:44  manhunter: TheBonsai, redirection is the result of some command will be piped to another file , am i correct?
07:44  TheBonsai: manhunter: not quite. just read it
07:45  TheBonsai: redirection is about file descriptors, not about natural files per se
07:45  TheBonsai: redirection sources and targets CAN be natural files, but not only
07:46  TheBonsai: manhunter: beside the "tutorial", there's the syntax overview page at http://wiki.bash-hackers.org/syntax/redirection
07:47  Znuff: so, question
07:47  Znuff: why is ls -1 | while read line; do echo $line; done different than while read line; do echo $line; done <<<$(ls -1) ?
07:47  manhunter: TheBonsai, what is descriptor?
07:48  TheBonsai: an internal (unix) memory structure representing a data source/sink. shouldn't matter
07:52  Znuff: !trim
07:52  Znuff: !faq trim
07:52  greybot: http://mywiki.wooledge.org/BashFAQ/067 -- How can I trim leading/trailing white space from one of my variables?
07:58 --- nadir is now known as Guest47529
08:03  manhunter: TheBonsai, ?
08:14  manhunter: what's the difference between #!/bin/sh #!/bin/bash ?
08:15  Znuff: bash is bash, sh is sh
08:15  Znuff: on some systems, sh is linked to bash
08:15  manhunter: bash=bourne again shell, and sh=?
08:15  Guest47529: while sometimes sh is linked to bash.
08:15  Znuff: on others, like debian/ubuntu, sh is linked to dash
08:15  Znuff: so if you write for bash, use /bin/bash
08:15  Znuff: if you write for generic unix shells, use /bin/sh
08:15  twkm: and on some it is sh.  ''man sh'' should be useful.
08:15  pgas: sh = posix shell or bourne shell on older systems
08:16  Znuff: is there something like awk {'print $2+'} to print collumns 2 and... beyond?
08:16  pgas: sh might be bash in compatibility mode or ksh in compatibility mode or dash or just another implementation of sh
08:17  pgas: Znuff: not really http://awk.freeshell.org/RangeOfFields
08:18  Znuff: bah, /me will just use sed
08:18  Znuff: or meh, cut
08:19  twkm: won't work the same though.
08:19  Znuff: yeah, but I just need to print a list of directories
08:19  twkm: *shrug*
08:20  Znuff: makes sense in my head :P
08:21  twkm: how awk and cut find column boundaries differ.
08:28  Znuff: so, why am I getting too many arguments @ line 18 on this script? http://pastebin.com/quLsKHJu
08:29  twkm: you have too many arguments.
08:29  twkm: set -x is your friend.
08:29  Znuff: so how would I check if a var is empty or not? :-/
08:29  twkm: "USE MORE QUOTES!"
08:30  twkm: funnily enough, you seem to like using them where they aren't needed, but not where they are.
08:30  Znuff: I'm weird
08:30  twkm: as an aside, don't us all upper-case variables for purely internal purposes.
08:31  twkm: e.g., P="..." but not "$P".
08:31  twkm: or, NEWSTUFF="$(...)" but not "$NEWSTUFF".
08:31  Znuff: aren't variable names case sensitive?
08:31  kingsley: # echo -e "bat cat fat\nhat mat pat" | while read first rest ; do echo $rest ; done
08:31  evalbot: kingsley: cat fat
08:31  evalbot: kingsley: mat pat
08:31  twkm: yes, which is why you should avoid potentially changing one that changes how other programs work.
08:33  kingsley: Znuff: Look above for a way to print column 2 and beyond.
08:35  Znuff: kingsley, didn't really need collumn 2 and beyond, just needed to print everything after a >
08:35  Znuff: and first thing I tought of was collumns
08:35  Jitu: hello everyone :)
08:36  Jitu: not really a newbie, but putting my hands back on linux after a very long time ...
08:36  Jitu: so getting many doubts ...
08:36  asfjio: hello guys! i have this situation - i have folders with a lot of files that are created every day. so i decided to delete the old one with "find -ctime +3 -daystart -exec ...". my problem is that i want to have at least 10 files in the directory. but when few days there are no files they would be deleted. can i achieve this? delete files older than n days, but keep at least 10 files in the directory.
08:38  kingsley: asfjio: Something like: find -ctime +3 -daystart | sed 1,10d | while read filename ; do rm $filename ; done
08:38  twkm: Znuff: parameter expansion.
08:39  twkm: asfjio: ctime isn't creation time.
08:39  Znuff: You totally lost me :-)
08:41  kingsley: asfjio: You may also want to consider how to prioritize which 10 files to keep. For example, should the most recent be kept?
08:41 * kingsley needs to go soon.
08:41  Znuff: I have an idea, but it's kind of scratching your left ear with your right hand
08:45  Znuff: uh, how would I delete a directory named "~" ?
08:46  Znuff: \~
08:47  Kharec: Znuff: rm -rf "~" ?
08:47  Znuff: \~ did the job
08:49  Kharec: Znuff: :)
08:50  Znuff: So there we go, I actually managed to do that directory script! :P
08:50 --- hemanth_ is now known as hemanth
08:50  Znuff: http://pastebin.com/DXpSHjNa
08:56 --- kizoku_ is now known as kizoku
--- Log closed Wed Oct 27 13:15:55 2010
