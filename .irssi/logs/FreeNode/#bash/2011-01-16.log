--- Log opened Sun Jan 16 00:00:51 2011
--- Log closed Sun Jan 16 00:10:19 2011
--- Log opened Sun Jan 16 00:10:39 2011
00:10 --- Users 562 nicks [0 ops, 0 halfops, 0 voices, 562 normal]
00:10  pyther: guampa: hi
00:10  guampa: is there something i can use to add "command history" to this loop ?   http://pastebin.com/ZdnS1NLP
00:11  guampa: like, recalling list command with the arrow more than anything
00:12  guampa: s/list/last
00:12 --- Channel #bash was synced in 98 seconds
00:12  falconindy: guampa: you can append to history via the 'history' builtin
00:13  pyther: What is the best way to read a variable in from a file
00:13  pyther: all the file is going to have is UPDATE=1 or UPDATE=0
00:13  pyther: should I source it? should I just use awk?
00:14  cthuluh: source it
00:14  falconindy: # echo "1" > file; read var < file; echo $var
00:14  erUSUL: guampa: in bash4 you have -e for read. that will use radline and you will have history search/retrival aviable
00:14  guampa: falconindy: will i be able to use that history from the loop?
00:14  evalbot: falconindy: 1
00:14  erUSUL: !faq 1 > pyther
00:14  greybot: pyther: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
00:14  cthuluh: pyther: don't listen to them, just source it ;)
00:14  erUSUL: pyther: if you control the contents of the file may be safe to source the file
00:15  falconindy: guampa: sure, history is scoped within the while loop
00:15  falconindy: # help history | sed -n '/append/{p;q;}'
00:15  evalbot: falconindy:     append the contents to the history list instead.  `-a' means
00:15  falconindy: uggh... bash 3.2 help isn't anything like mine
00:15  pyther: falconindy: cheers, that'll work just fine
00:16  emilsedgh: im trying to use shelldorado's script 'dtox' to conver EOL styles from dos to unix. it throws this error: sed: -e expression #1, char 2: unterminated `s' command
00:16  guampa: erUSUL: i'm using -e , though somehow it won't recall commands with the arrow
00:16  emilsedgh: i'd appreciate any help :)
00:16  falconindy: yeah you need to append to history yourself
00:16  erUSUL: guampa: ^
00:17  falconindy: invoking read with -e just gives you readline bindings. history is always separate
00:17  guampa: falconindy: will try that
00:18  guampa: worked great :D thank you falconindy, erUSUL
00:18  erUSUL: emilsedgh: sed1liners --> sed 's/\x0D$//'  infile > outfile
00:19  prince_jammys: emilsedgh: you probably pasted the script, and it contains a literal CR.
00:19  prince_jammys: ... which somehow got converted to newline.
00:19  emilsedgh: thank you both
00:19  prince_jammys: wget -O- http://shelldorado.com/scripts/quickies/dtox|cat -e
00:20  emilsedgh: prince_jammys: you were right, thanks :)
00:34  poisonbit: long life to bash
00:42 --- Lpine_ is now known as Lpine
00:56  pyoor_: what's the wiki page for if-grep clauses?
00:56  pyoor_: !if
00:56  greybot: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
00:57  cthuluh: !ifgrep
00:57  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
01:00  pyoor_: cthuluh: thanks.  trying to grep the contents of a variable.  wasn't sure if i had to echo it.
01:07  cthuluh: pyoor_: are you sure that you need grep?
01:07  cthuluh: anyway, grep foo <<< "$bar" saves you the echo bit
01:07  pyoor_: cthuluh: not sure.  i need to check if variable contains a string.  the variable contains a long line and my original grep would match on 1 word.
01:08  cthuluh: [[ $var = *string* ]]
01:08  pyoor_: thanks!
01:09  cthuluh: yw
01:10  thomaschaaf: http://pastie.org/1465265 can some one help a beginer?
01:11 --- grop_ is now known as grop
01:12  cthuluh: thomaschaaf: var=$(some command | some other command)
01:12  cthuluh: !pf > thomaschaaf , read this
01:12  greybot: cthuluh: No matches found at http://mywiki.wooledge.org/BashPitfalls
01:13  geirha: !guide > thomaschaaf, don't guess on syntax, read this
01:13  greybot: thomaschaaf, don't guess on syntax, read this: http://mywiki.wooledge.org/BashGuide
01:13  geirha: Looks more like php than bash
01:30 --- nemie is now known as Nemie
01:31 --- hagebake is now known as hagabaka
01:54  Esine: Hey. I have a small problem with passing n arguments to a command. I'm trying to build a menu where the user can select the item but the list of items is fetched from a postgresql database. I can do the data fetching part fine and in any format, but /usr/bin/dialog requires me to pass the variables as arguments in pairs of two. e.g. /usr/bin/dialog --menu "Choose an item" 0 0 0 "one" "Option one" "two"
01:54  Esine: "Option two" "three" "Option three"
01:55  Esine: Say I have a variable $out which contains the parameters as is with strings with spaces quoted. I try to do  dialog --menu "Choose an item" 0 0 0 $options  but running with  bash -x  I get these extra single quotes everywhere
01:56  Esine: ok, here's a test case: options="one \"First option\" second \"Second option\"" dialog --menu "Choose an item" 0 0 0 $options
01:56  Esine: it bugs out. The arguments get split when they shouldn't.
01:56  Esine: how do I go around this?
01:57 --- Caelum_ is now known as Caelum
01:58  vkues: !arrays > Esine
01:58  greybot: Esine: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
01:58  vkues: options=(one "First option" second "Second option"); dialog .. 0 0 0 "${options[@]}"
02:00  Esine: vkues: ok that's better. thanks.
02:00  Esine: now the problem is getting the data into an array, but I suppose  can do that.
--- Log closed Sun Jan 16 02:10:38 2011
--- Log opened Sun Jan 16 02:11:01 2011
02:11 --- Users 550 nicks [0 ops, 0 halfops, 0 voices, 550 normal]
02:11  vkues: instead of "command | while" do "while .. done < <(command)"
02:11  Esine: ty.
02:11  vkues: faqs 1 and 24 deal with that, see the links above
02:11  vkues: :)
02:12  Esine: Thanks a bunch, it works better now :)
02:12 --- Channel #bash was synced in 95 seconds
02:12  vkues: :)
02:12  vkues: cool
02:15  otzi: is there a way to drop the last parameter passed to a program, sort like a reverse shift?
02:16  geirha: set -- "${@:1:$#-1}"
02:18  otzi: wow, thanks :-)
02:34  PCChris: Is there a way to echo/cat the contents of a file, but have a delay between each line?
02:35  taylanub: while read -r line; do echo "$line"; sleep 1; done < file
02:35  vkues: less file
02:35  taylanub: vkues: not what he asked but...
02:35  taylanub: !wayttd > PCChris
02:35  greybot: PCChris: What Are You Trying To Do?
02:35  cthuluh: taylanub: while IFS= read -r line; ... ;)
02:36  taylanub: cthuluh: oh yes
02:36  PCChris: taylanub, Um, I'm not sure how to be more specific really
02:36  taylanub: PCChris: what's the reason you want that?
02:36  PCChris: taylanub, I will try your first command you gave
02:36  taylanub: PCChris: see what cthuluh said
02:37  taylanub: while IFS= read -r line; do echo "$line"; sleep 1; done < file  # corrected
02:39  PCChris: awesome
02:39  PCChris: taylanub, cthuluh thank you so much
02:50  pyoor_: Hey all.  I've have a small script that works as expected (though looks terrible).  I'm wondering if anyone can give me any tips on cleanin up my code: http://pastebin.com/Qi064s5Q
02:50  taylanub: !wiki > pyoor_
02:50  greybot: pyoor_: http://mywiki.wooledge.org/ - http://bash-hackers.org/wiki/
02:50  taylanub: read it all! :P
02:51  pyoor_: hah, on it :)
02:51  taylanub: use read -r, unless you want pre-newline \ interpreted
02:52  taylanub: think what happens when a line is '-e'
02:52  pyoor_: pre-newline?
02:52  taylanub: foo \
02:52  taylanub: bar
02:52  taylanub: right before a newline
02:52  pyoor_: gotcha.  there are none since the output is from od with | tr -d '\n'
02:53  pyoor_: ^sudo code
02:53  pyoor_: pseudo
02:53  pyoor_: sheesh
02:53  taylanub: if the input has no \n at all, what's the point of while read ?
02:53  vkues: pyoor_: [[ instead of grep, "<<<" instead of "echo |", printf '%s\n' "$var" instead of echo "$var", "IFS= read -r"  instead of "read", maybe printf -v instead of $(printf), no $ inside of $(()), ((var=..)) instead of var=$((..)), quotes around assignments are usually not necessary
02:54 * taylanub keeps forgetting IFS= read
02:54  pyoor_: taylanub: sorry there actually are newlines that i've added but no blank lines.
02:55  pyoor_: od |tr -d '\n' | sed 's/delimeter/\n/g'
02:55  pyoor_: and thanks vkues
02:56  pyoor_: vkues I tried if [[ $line == "*20 6f 62 6a*" ]] but each line resulted as false (which is not the case).
02:56  pyoor_: that's why I abandoned that and opted for <<<
02:56  taylanub: hrmm, IFS= doesn't change anything when you read into a single var i guess
02:57  pyoor_: vkues: also changing the printf results in printf: 21553\n: invalid number
02:57  vkues: # read singlevar <<< ' one '; echo ">$var<"
02:57  evalbot: vkues: ><
02:57  vkues: # read singlevar <<< ' one '; echo ">$singlevar<"
02:57  evalbot: vkues: >one<
02:57  vkues: # IFS= read singlevar <<< ' one '; echo ">$singlevar<"
02:57  evalbot: vkues: > one <
02:57  vkues: pyoor_: what I said was supposed to be pointers
02:57  vkues: pyoor_: for further investigation, reading, learning, that kind of bitches
02:58  pyoor_: oh gotcha.  I was curious about the printf line as well but no i hadn't looked up a work around
02:58  pyoor_: i do understand why it prints that error but just haven't investigated it yet
02:58  vkues: pyoor_: [[ $line = *"20 .. 6a"* ]]
02:59  vkues: pyoor_: about the printf i don't know, would have to see again how the code looks now
03:00  pyoor_:  vkues: the [[ works.  thanks
03:01  pyoor_: i had encapsulated the glob inside ""
03:01  vkues: yep
03:02  prince_jammys: pyoor_: if you don't need the variable 'c', then just printf and remove the echo.
03:03  pyoor_: prince_jammys: I will need 'c' as I add more functionality to the app
03:03  pyoor_: er script
03:03  pyoor_: not my brightest of days
03:04  prince_jammys: then $(printf ) is fine, as is printf -v (though the latter requires a more recent bash)
03:04  prince_jammys: though i doubt you'd want 'c' to contain all the padding
03:05  prince_jammys: c=$b; print '%010d\n' "$c"
03:05  prince_jammys: *printf
03:05  pyoor_: i do want c to always be a 10 character value
03:05  pyoor_: ahh i see what you are saying.  but yes, i'm going to use c to replace a value in a file that is always 10 characters
03:06  pyoor_: wow, i gotta say thanks.  so many recommendations on less than 16 lines of code.  exactly what i was looking for.
03:08  prince_jammys: while read -ra words; do a=${#words[@]}; if [[ "${words[*]}" = *"blah blah"* ]] ...
03:09  prince_jammys: that should drop one invocation to wc per line
03:11  pyoor_: thanks prince_jammys, I hadn't considered storing it in an array
03:11  prince_jammys: (also, ((b+=a)) need not be inside an if..else as it happens in both cases)
03:12  pyoor_: prince_jammys: so I tried moving it to the beginning of the 'do' and just calling $b at the if and else, but it tried executing "$b" as a command
03:12  pyoor_: I thought that looked wrong to have it issued twice
03:13  prince_jammys: (( b+=a ))  should do
03:14  pyoor_: so (( b+=a )) after the 'do' then "$b" at the if and else?
03:14  prince_jammys: huh?
03:15  pyoor_: i guess I'm not following you.
03:15  prince_jammys: while read -ra words; do a=${#words[@]}; ((b+=a)); if [[ "${words[*]}" = *"blah blah"* ]]; then c=$b; printf '%10d\n' "$c"; fi; ((b+=a)); done <file
03:15  prince_jammys: err, oops
03:15  pcard: is there a portable way to get the last modified time of a file (a way that works on most UNIX-like systems, like Linux, BSD, sysV, etc)
03:16  prince_jammys: while read -ra words; do ((b += ${#words[@]} )); if [[ "${words[*]}" = *"blah blah"* ]]; then c=$b; printf '%10d\n' "$c"; fi; done <file
03:16  prince_jammys: there, no 'a'
03:17  Synthead: I'm trying to make a more efficient way of doing this:
03:18  Synthead: # a=4; echo "$a thing$((( a > 1 )) && printf "s")"
03:18  evalbot: Synthead: 4 things
03:18  Synthead: # a=1; echo "$a thing$((( a > 1 )) && printf "s")"
03:18  evalbot: Synthead: 1 thing
03:18  Synthead: basically detecting plurals
03:18  Synthead: I can do this:
03:18  e36freak: ahh, interesting
03:19  Synthead: # a=4; echo "$[(a)?1:2]"
03:19  evalbot: Synthead: 1
03:19  Synthead: # a=0; echo "$[(a)?1:2]"
03:19  evalbot: Synthead: 2
03:19  vkues: Don't write shorter but longer code.
03:19  e36freak: heh
03:19  Synthead: 1 and 2 for the sake of demonstration
03:19  vkues: Do that on sentence, not on word-level.
03:20  Synthead: I don't want to have two nearly identical statements wrapped with if; then; else, that's a lot of wasted lines
03:20  vkues: yeah
03:21  vkues: wasting lines certainly kills the rain forrest
03:21  Synthead: I was basically poking my nose in here to ask if the $[(#)?#:#] thing can be used with strings, or is there another similar way that can be used?
03:21  prince_jammys: # plur=s things=4; echo "You have $thing thing${plur:0:things>1}"
03:21  evalbot: prince_jammys: You have  things
03:21  prince_jammys: # plur=s things=4; echo "You have $things thing${plur:0:things>1}"
03:21  evalbot: prince_jammys: You have 4 things
03:21  prince_jammys: # plur=s things=1; echo "You have $things thing${plur:0:things>1}"
03:21  evalbot: prince_jammys: You have 1 thing
--- Log closed Sun Jan 16 12:29:55 2011
--- Log opened Sun Jan 16 12:30:16 2011
12:30 --- Users 548 nicks [0 ops, 0 halfops, 0 voices, 548 normal]
12:31 --- Channel #bash was synced in 95 seconds
12:44  thm: is there an easy way to get a comma-separated list of basenames of files in a directory
12:46  taylanub: basename means anything up to first dot?
12:46  thm: yes
12:46  taylanub: for file in dir/*; foo "${file%%.*}"; done
12:47  taylanub: now to make it comma separated...
12:48  taylanub: (oh also remove the dir/ part...)
12:49  lhunath: list=(dir/*); list=("${list[@]%.*}")
12:49  thm: for i in *.py ; do a=${a:+$a,}${i%%.py} ; done ; echo $a
12:49  taylanub: aye, i suck at bash specifics
12:49  thm: looks reasonable?
12:50  lhunath: why are you putting it in a comma-delimited string ?
12:50  thm: some command needs it
12:50  thm: as argument
12:50  lhunath: files=(*.py); command --list "$(IFS=,; echo "${files[*]}")"
12:50  TheBonsai: scary
12:51  tmr: How does your command handle files with commas in names?
12:51  thm: don't ask. it is not my command ...
12:51  lhunath: how would you expect it to?
12:51  thm: lhunath: how would I get rid of the dir part in your variant?
12:51  lhunath: # files=(moo.py  moo,cow.py); IFS=,; echo "${files[*]}"
12:52  evalbot: lhunath: no output within the time limit
12:52  lhunath: # files=(moo.py  moo,cow.py); IFS=,; echo "${files[*]}"
12:52  evalbot: lhunath: no output within the time limit
12:52  lhunath: rawr.
12:52  lhunath: look alive, bot.
12:52  taylanub: why does that fail?..
12:52  lhunath: 3# files=(moo.py  moo,cow.py); IFS=,; echo "${files[*]}"
12:52  shbot: lhunath: moo.py,moo,cow.py
12:52  lhunath: at least shbot is more alive
12:52  tmr: Slow bot.
12:53  lhunath: thm: there is a dir part?
12:53  lhunath: you can get rid of it with a PE operation.
12:53  taylanub: or just cd into the dir
12:53  thm: echo "$(IFS=,; echo dir/*.py)"
12:53  lhunath: # files=(dir/moo.py  otherdir/cow.py); IFS=,; echo "${files[*]##*/}"
12:53  evalbot: lhunath: moo.py,cow.py
12:54  lhunath: so that would be:   command --list "$(IFS=,; echo "${files[*]##*/}")"
12:55  lhunath: "basename" means, the filename part of a path.  so I guess this is indeed what you asked for
12:55  thm: yes
12:56  thm: can I combine ## and %% ?
12:56  lhunath: not in one operation.
12:57  lhunath: files=("${files[@]##*/}")
12:57  lhunath: notice when I use * vs. @ inside the array subscript.
12:58  lhunath: * is when you want to make a STRING out of the array, @ is when you need to expand ELEMENTS.
12:58  thm: i c
12:58  lhunath: you almost always want @
12:59 --- Cain` is now known as Cain
13:00  TheBonsai: however, how to tag a , in a name? :)
13:02  thm: finally, can I filter __init__ out of the list?
13:03  TheBonsai: !b0
13:03  greybot: The questioner will never tell you what they are really doing the first time they ask.
13:03  TheBonsai: !b2
13:03  greybot: bashphorism 2: The questioner will keep changing the question until it drives the helpers in the channel insane.
13:03  thm: :)
13:04  thm: the questioner didn't know he has to filter something unless he actually tried
13:04  TheBonsai: hehe
13:04  TheBonsai: what's your current code? are there already multiple steps?
13:06  thm: files=(foo/bar/*.py) ; files=("${files[@]##*/}") ; cmd --list="$(IFS=,; echo "${files[*]%%.py}")"
13:06  thm: works (and thanks for the help so far)
13:07  TheBonsai: hm, IMHO just possible with individually filtering files[@] elements
13:09  thm: ok
13:10  TheBonsai: t_files=("${files[@]}"); files=(); for file in "${t_files[@]}"; do [[ $file != __init__ ]] && continue; files+="$file"; done
13:11  TheBonsai: something like that
13:11  TheBonsai: i.e. copy over to a temporary buffer and re-fill the main buffer with the filter process
13:15  tmr: 3# touch foo.py bar baz.py __init__.py; files=( !(__init__).py ); printf '<%s> ' "${files[@]}"
13:15  shbot: tmr: <baz.py> <foo.py>
13:16  TheBonsai: even better
13:16  Esmil: What is the difference between [ expression ] and [[ expression ]], if any?
13:16  tmr: Requires extglob.
13:16  TheBonsai: ![[
13:16  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
13:16  Esmil: TheBonsai: Ahh, thanks
13:16  TheBonsai: tmr: naturally. does the bot have it enabled by default?
13:16  tmr: TheBonsai, yeah.
13:17  TheBonsai: ah
13:17  tmr: That's why I thought it might be good idea to point out :)
13:17  TheBonsai: well, since you can't pass the extglob switch in the same line than the extglob, it makes sense
13:19  adaptr: what if you WANT ['s expansion to happen
13:19  TheBonsai: expansion happens
13:19  TheBonsai: just not the wordsplitting
13:34  TheBonsai: !factoids
13:34  greybot: You can see my factoid "database" on the web, at http://wooledge.org/~greybot/ (Actually, this is the metadata database, so you can see the deleted ones here as well as the active ones.)
13:37  Kottizen: So.
13:37  Kottizen: I'm on SSH: Can I someone hook up to someone else's bash and see what's going on?
13:37  Kottizen: We're on the same account.
13:38  lhunath: you sound terribly lost and mislead.
13:39  TheBonsai: let the other one open a new session in a GNU screen, then do some multihead screen session
13:39  lhunath: "see what's going on" is rather vague a problem to solve.
13:43  ruben23: hi guys how do i setup my time not into military time but standard time
13:44  lhunath: !bashis > ruben23
13:44  greybot: ruben23: Bash is a shell. That's a program which can do simple math, logic and run other programs. It's NOT a terminal, it's not a kernel, it doesn't manage the system's authentication or environment, it's not your OS and it's not X, KDE or Gnome.
13:44  ryan_au: I tried using "source" to include a shell script in another shell script, but it only worked when I used "."
13:44  lhunath: also, "standard" to most of the world means 24-hour time.  that's probably what you refer to as "military" time.
13:45  tmr: ryan_au, source is bash specific command.
13:45  ryan_au: According to the man pages, "." is an alias for "source", so why don't they do the same thing?
13:45  tmr: !sh > ryan_au
13:45  greybot: ryan_au: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
13:45  ruben23:  lhunath: yes i prefer am/pm type of hour
13:45  ryan_au: tmr: thanks mate!
13:45  lhunath: ruben23: so tell whatever the heck you're talking about what to format its time as.  this has nothing to do with bash.
13:49  ryan_au: !bash > ryan_au
13:49  greybot: ryan_au: The Bourne-Again Shell. Read the channel topic or type /msg greybot links for lots of links.
14:26  afman: Does anyone know how wget grabs the path? For instance how does it know what the path is for something that just pops up as something www.something.com and doesn't have anything like /index.html.
14:26  taylanub: !nabq
14:26  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
14:27  TheBonsai: whatever you want to ask, i don't understand it
14:27  tmr: /join #wget
14:27  TheBonsai: anylways, check how webservers are configured, along with DNS configuration
14:29  afman: @tmr thanks :-D
14:31  adaptr: afman: an HTTP client requests the path you give it. it is up to the web server what to respond with.
14:33  afman: @adaptr hmmm well the problem I'm trying to figure out is that for wget you can do something like wget icq.com but with a scripting language you have to specify the path which for icq would by icq.com/en.html. How does wget just figure it out for you? (They were right though it's probably more appropriately addressed in the wget channel)
14:33  afman: be*
14:34  prince_jammys: does wget really figure it out or does it just use 'index.html' when no path was in the url?
14:34  adaptr: afman: wget doesn't do anything.
14:34  adaptr: afman: re-read what I said above
14:34  geirha: afman: The web server probably gives a "redirect to this url"
14:34  TheBonsai: that's why i said he should read about DNS and webserver configuration
14:34  adaptr: DNS doesn't enter into it
14:35  afman: Ya I don't think it has anything to do with resolving an IP. But I'll probably have to go to the Ruby forum for the rest
14:35  adaptr: and if he doesn't have access to the web server in question, neither does the web server configuration :)
14:35  TheBonsai: depends
14:35  adaptr: TheBonsai: not really
14:35  afman: In Ruby I have to specify a path I can't just say http.get(www.something.com)
14:35  adaptr: afman: / is a path
14:35  adaptr: in any default web server config, not specifying a path means you are requesting the root
14:36  TheBonsai: adaptr: his "blah somethiong blubb something" COULD also imply a example.net -> www.example.net on DNS level.
14:36  adaptr: www.google.com is equal to www.google.com/
14:36  adaptr: TheBonsai: how would that happen "on DNS level"
14:36  TheBonsai: adaptr: usually a CNAME
14:36  adaptr: it could be an HTTP redierect, sure
14:36  afman: @adaptr ooooohhhh duh let me go try that
14:36  adaptr: TheBonsai: CNAMEs are not intrazone
14:37  TheBonsai: adaptr: CNAMEs are what i make them.
14:37  adaptr: you'd be doing it wrong
14:37  TheBonsai: adaptr: though this direction was misleading. make it www.e.n -> e.n
14:37  adaptr: TheBonsai: that is impossible with a cname
14:38  afman: @adaptr Thank you so much! I've been teaching myself socket programming and while that is incredibly obvious now it wasn't something I would have thought of before O.o worked like a champ lol
14:38  afman: I've been trying to figure that out forever lol
14:38  adaptr: afman: if you're "doing" network programming, perhaps you need to read the relevant RFCs
14:38  adaptr: ach, enough OT
14:39  TheBonsai: adaptr: the other way round is impossible, that the domain name is a CNAME
14:39  afman: Ya sorry about that, thanks again though :-D
14:39  geirha: A request for / at icq.com responds with "HTTP/1.1 302 Moved Temporarily" followed by a "Location: en.html" in the header
14:40  geirha: That's how wget knows to send another request for en.html
14:40  adaptr: TheBonsai: you're right, brianfart
14:40  adaptr: *brainfart
14:41  TheBonsai: adaptr: anyways, i'm not a friend of this http://example.net without specifying a machine, so let's silently ignore it :)
14:41  afman: @geirha Thanks that would make sense that it would just have a way to catch redirects.
14:41  danst__: hey guys, how do I limit output string length!
14:41  TheBonsai: with the program you use to output, if possible, or a cut before you output
14:42  danst__: oh well
14:42  danst__: I get curl http://somelink
14:42  adaptr: afman: every HTTP client is required to implement the HTTP protocol. that's what a protocol is for. it doesn't "catch" redirections. it executes the action dictated by the RFC
14:42  danst__: and there's always one string output
14:42  danst__: so I want to cut it's length like for 50 symbols max
14:44  afman: @adaptr I'm going to go look that up thanks for the point in the right direction. I've just been googling everything at the lower levels of abstraction lol
14:44  adaptr: HTTP is a fairly low level of abstraction
14:45  afman: Ya to be honest most of my knowledge of the inner workings of HTTP have come from wikipedia
14:46  adaptr: seriously, read the RFC
14:46  afman: Doing it now ;-)
--- Log closed Sun Jan 16 14:52:29 2011
--- Log opened Sun Jan 16 14:52:50 2011
14:52 --- Users 547 nicks [0 ops, 0 halfops, 0 voices, 547 normal]
14:54 --- Channel #bash was synced in 95 seconds
14:57  dustybin: has anybody here heard of a tool called 'shlock'
14:57  danst__: oh
14:57  danst__: geirha: thank you very much
14:59  dustybin: and dotlockfile
15:15 --- DustyDin1o is now known as DustyDingo
15:48  jk4_: hi, what is the point of `eval'?
15:48  cthuluh: !eval
15:48  greybot: 'eval' is a common misspelling of 'evil'. If eval is the answer, surely you are asking the wrong question. See http://mywiki.wooledge.org/BashFAQ/048
15:51  jk4_: hum, scary
15:55  jk4_: # eval eval
15:55  evalbot: jk4_: no output within the time limit
15:56  jk4_: well at least I know what eval is now
15:59  jk4: is xargs better than eval?
16:00  jk4: cos I can do the same thing with it.
16:00  taylanub: they're fundamentally different
16:01  jk4: well as long as xargs is not evil then I'm happy
16:02  fruight: i want to do a more or less complex bulk rename: insert a _ in every occurrence of a small letter directly followed by a capital letter or a number, any ideas how to do this?
16:02  jk4: grep and sed
16:02  taylanub: jk4: -exec is usually the best way. what are you trying to do?
16:03  taylanub: hell no for grep and sed for filename manipulation
16:03  taylanub: !faq rename
16:03  greybot: http://mywiki.wooledge.org/BashFAQ/030 -- How can I rename all my *.foo files to *.bar, or convert spaces to underscores, or convert upper-case file names to lower case?
16:03  fruight: jk4: could you please be a bit more specific, i'm rather new to bash scripting
16:03  taylanub: fruight: follow the link above
16:04  jk4:  fruight: ask taylanub, he is clever
16:04  taylanub: ...
16:04  fruight: taylanub: thx
16:05  jk4: taylanub: I'm compiling a zenity command from an array
16:05  jk4: using a for loop
16:05  jk4: and then executing it
16:05  taylanub: array?  foobar "${array[@]}"  ?
16:06  jk4: for program in "${programs}" ; do command="${command} TRUE ${program}" ; done ; selected_programs=$(echo ${command} | xargs zenity)
16:08  taylanub: "$programs" will always be one string
16:08  taylanub: you mean "${programs[@]}" maybe
16:08  jk4: yes that what I mean
16:08  jk4: typo
16:08  jk4: zenity asks which programs to open
16:08  taylanub: you're making command a single string. optimally it should be an array
16:09  jk4: taylanub: OK, so how do I execute an array?
16:10  taylanub: for prog in "${programs[@]}"; do command=("${command[@]}" TRUE "$prog"); done; selected_progs=$(zenity "${command[@]}")  # not sure about the last part...
16:10  vkues: !guide > jk4
16:10  greybot: jk4: http://mywiki.wooledge.org/BashGuide
16:10 * taylanub installs zenity
16:11  taylanub: jk4: how does $command look before that loop?
16:11  jk4: taylanub: you'll need to do this first for that command to work: declare command='--list --title="Which programs should be re-launched?" --checklist --column="Launch?" --column="Program"'
16:11 --- emma is now known as em
16:12  taylanub: jk4: you see, that will break because you have double quotes in single quotes; those will be passed directly into the variable and thus into zenity, and you probably don't want that
16:13  taylanub: command=(--list '--title=Which programs should be re-launched?' --checklist --column=Launch\? --column=Program)
16:14 * jk4 eats a ham and cheese slice, 2 minutes
16:17 * jk4 finnish eating slice
16:17  jk4: taylanub: I want to ask a thing
16:17  jk4: when I type this:
16:18  jk4: echo "hello I am Joe"
16:18  jk4: no, hang on
16:18  jk4: echo "hello I am Joe" "foo bar"
16:19  jk4: I know that is two arguments
16:19  steve___: ugh
16:19  jk4: but... OK, I think I get it
16:19  steve___: taylanub: If you want to spoon feed him, why not PM?
16:21  jk4: well how rude
16:25  fruight: taylanub: it looks like i could do the rename with some sort of 'for f in *; do mv -- "$f" "${f//.../...}"' but i have no idea how to make a regex like  /([a-z])([A-Z0-9])/\1_\2/ work in bash :P
16:25  fruight: i tried around and i couldnt get grouping and backreferences to work
16:26  jk4: fruight: sed is the mighty regex thingy
16:35  taylanub: !pe > i'm not sure myself
16:35  greybot: i'm not sure myself: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
16:38  taylanub: maybe use a tool like mmv, fruight
16:42  fruight: taylanub: im hacking around a bit, i think i figured something out... :P
16:42  taylanub: actually if this is a one-time thing and your filenames are sane, using sed would be just fine
16:43  taylanub: for file in *glob*; do mv "$file" "$(sed 's/\([a-z]\)\([A-Z0-9]\)/\1_\2/g' <<<"$file")"; done  # or so
16:44  fruight:  for f in *; do mv -- "$f" "$(echo "$f" | sed 's/\([a-z]\)\([A-Z0-9]\)/\1_\2/g')";done
16:44  fruight: works like a charm :)
16:44  vkues: use [[:lower:]], [[:upper:][:digit:]]
16:45  fruight: but there might be a more elegant way instead of echo | sed :P
16:45  fruight: vkues: what is the advantage of that?
16:45  vkues: fruight: it does work, the other does not
16:45  vkues: fruight: [a-z] may contain uppercase characters
16:46  fruight: vkues: for which cases? i tried it on some testfiles and it worked just as expected...
16:46  vkues: fruight: for locales that have other characters than lowercase characters between a and z
16:47  vkues: fruight: for example, those that order them like AaBbCc..Zz
16:47  fruight: so in case i have LC_ALL=C i dont need to worry, but i should use [[:x:]] for portability?
16:48  fruight: ok, i'll change that then
16:48  vkues: depends on whether you only want to match lowercase ascii or also other lowercase characters
16:57  fruight: how do i express alternatives in sed regex syntax? pipe, like in 's/foo|bar/baz/g' doesnt work
16:57  geirha: You either need the non-standard -E/-r, or use two substitutions for the portable version
16:58  fruight: geirha: ok, thx
16:58  cthuluh: or you can use non-standard extension such as \|
16:58  gnubien: fruight: foo\|bar
16:58  geirha: Oh, and there's that :)
16:58  fruight: gnubien: even better :)
16:58  geirha: 's/foo/baz/g;s/bar/baz/g'
16:59  fruight: wow, lined up smileys :)
16:59  fruight: argh the ',' broke it :P
17:00  geirha: huh?
17:01  fruight: why does the following not replace a ditit followed by an uppercase letter?
17:01  fruight:  for f in *;do mv -- "$f" "$(echo "$f" | sed 's/\([[:lower:]]\)\([[:upper:][:digit:]]\)\|\([[:digit:]]\)\([[:upper:]]\)/\1\3_\2\4/g')";done
17:01  fruight: /ditit/digit
17:03  geirha: You match with either the re before \|, or the re after, not both.
17:04  fruight: geirha: thats done on purpose
17:04  fruight: or do you mean that the i dont need to use \3 and \4 ?
17:05  fruight: what i'm trying to do is insert _ in cases like: FileNameWithoutSpaces2 ThisNumber4ShouldBeFollowedBy1Space etc.
17:06  fruight: the first one works already and becomes 'File_Name_Without_Spaces_2'
17:06  geirha: r4S, with this input string, The first re will match r4. The 4 cannot be matched any more after that
17:06  fruight: but the secong one becomes 'This_Number_4Should_Be_Followed_By_1Space' obviously missing _ in 2 places
17:07  geirha: fruight: Use two substitutions
17:07  geirha: 's/\([[:lower:]]\)\([[:upper:][:digit:]]\)/\1_\2/g; s/\([[:digit:]]\)\([[:upper:]]\)/\1_\3/g'
17:08  geirha: err \1_\2 on the last one too
17:08  fruight: in this case that's of course the easiest way now, but in case of really complex regexes using \| could make things a lot more readable, so i was just interested how it could be used properly... for now i'll just use 2 subs
17:09  geirha: At any rate, more in-depth help on sed should go to ##sed
17:17 --- Varazir_ is now known as Varazir
17:18  gnubien: fruight: echo "ThisNumber4ShouldBeFollowedBy1Space" |sed 's/[[:upper:]]\|[0-9]/_&/g'  #prints _This_Number_4_Should_Be_Followed_By_1_Space
17:19  jk4: if I make this array: declare -A array=([cow]=grass [donkey]=carrot [mouse]=cheese [cat]=milk [pig]=mud)
17:19  jk4: how to find out which animal eats carrot?
17:19  gnubien: silly wabbit ;)
17:20  geirha: for key in "${!array[@]}"; do [[ ${array[$key]} = carrot ]] && break; done; echo "$key"
17:21  geirha: Hm. Not quite, but you get the idea.
17:21  jk4: awesome
17:21  geirha: for key in "${!array[@]}"; do if [[ ${array[$key]} = carrot ]]; then animal=$key; break; fi; done; echo "$animal"
18:32 --- stardotc_ is now known as stardotc
18:39  MrUnagi: i am having trouble figuring out why this fails........for FILE in "$(find * -type d)"; do NEW=$(echo "$FILE"| sed 's/ /_/g'); mv $FILE $NEW; done......gives usage: mv [-f | -i | -n] [-v] source target..........am i missing something simple?
18:40  dioda11: you need to add && between the sed and mv
18:41  Tumulte: Hi y'all
18:41  MrUnagi: -bash: syntax error near unexpected token `do'
18:41  Tumulte: I guesse I'm in the right place for bash script issue :)
18:42  MrUnagi: does the && make quotations needed aorund do?
18:42  teurastaja: tumulte ca va?
18:42  humpty: yes, for loop repeats commands for each given element; if `find` returns file names containing spaces, for will loop over each element of filename
18:42  Fatal: MrUnagi: oh god, that looks dangerous on may levels, first you pass the entire output of find into FILE, so the for loop is rather pointless
18:42  e36freak: !wordsplitting > MrUnagi
18:42  greybot: MrUnagi: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
18:42  e36freak: !faq 1 > MrUnagi
18:42  greybot: MrUnagi: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
18:42  erUSUL: MrUnagi: do not do for i in $( ); do ...; done
18:42  Tumulte: oui et toi? teurastaja :)
18:42  MrUnagi: whoa that is a lot of highlights lol
18:42  erUSUL: !faq rename > MrUnagi
18:42  greybot: MrUnagi: http://mywiki.wooledge.org/BashFAQ/030 -- How can I rename all my *.foo files to *.bar, or convert spaces to underscores, or convert upper-case file names to lower case?
18:43  erUSUL: !quotewhen > MrUnagi
18:43  greybot: MrUnagi: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
18:43  teurastaja: ca va ca va.... jme reveille... t dla france?
18:43  Tumulte: yup
18:43  Fatal: MrUnagi: I'd suggest you only care about the two lines given to you by erUSUL
18:43  teurastaja: moi qc
18:43  teurastaja: la ville
18:43  Tumulte: enchanté ;)
18:44  Fatal: teurastaja: please keep it in english in here
18:44  Tumulte: Fatal: that was casual talking
18:44  felicity: hey, how can i use a pipe to do something like a change directory?what i'm trying to do is ls | grep -i "some directory" | cd "some directory" is that possible?
18:44  Tumulte: but you are right ;)
18:44  MrUnagi: what exactly is ${}
18:44  teurastaja: yeah sorry, i was saying hey to my cousin
18:44  e36freak: !pe > MrUnagi
18:44  greybot: MrUnagi: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
18:44  MrUnagi: thanks ill read it
18:45  e36freak: !wayttd > felicity
18:45  greybot: felicity: What Are You Trying To Do?
18:45  e36freak: !ls > felicity
18:45  greybot: felicity: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
18:45  teurastaja: MrUnagi: ${} is parameter expansion
18:46  teurastaja: oops.... the bot was fast ;)
18:47  MrUnagi: !ifs
18:47  greybot: Internal Field Separator (or Input Field Separator), used to break things into words. See http://mywiki.wooledge.org/IFS and http://mywiki.wooledge.org/BashFAQ/001 and http://bash-hackers.org/wiki/doku.php/syntax/words
18:47  Tumulte: I'm trying to launch several applications with options in the launcher.... But the launcher won't work : here's an exemple http://fpaste.org/6c5w/
18:47  geirha: Tumulte: Lose ` ` and ls
18:48  Tumulte: unnecessary?
18:48  Tumulte: I'll lose em
18:48  geirha: Tumulte: And don't put more than one argument in a variable.
18:48  e36freak: ls should never be needed in a script
18:48  e36freak: !faq complex
18:48  greybot: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
--- Log closed Sun Jan 16 18:52:39 2011
--- Log opened Sun Jan 16 18:53:03 2011
18:53 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
18:53 * Tumulte is happy to learn all those stuffs
18:53  Tumulte: :)
18:53  e36freak: MrUnagi: try it with find . -type d -depth -print0
18:54  MrUnagi: crap i read about -depth a few minutes ago too
18:54 --- Channel #bash was synced in 95 seconds
18:54  geirha: find . -depth -type d -exec bash -c 'base=${1##*/}; mv "$1" "${1%/*}${base// /_}"' _ {} \;
18:54  e36freak: well, find . -depth -type d -prith0
18:54  e36freak: there you go :)
18:55  MrUnagi: ah there it goes
18:55  teurastaja: yay im almost at node 6 from the info bash!
18:55  geirha: Slightly easier with GNU find.  find . -depth -type d -execdir bash -c 'mv "$1" "${1// /_}"' _ {} \;
19:00  geirha: Maybe add a -name "* *"
19:02  e36freak: geirha: ahh, good point there
19:04  Tumulte: I corrected the script based on your advacies, yet the app isn't launched : http://fpaste.org/NHNV/
19:06  geirha: Make it #!/bin/bash, and try with   jackrack_launcher=(--tab -x jack-rack "$fx_rack"); ...; gnome-terminal "${jackrack_launcher[@]}"
19:07  MrUnagi: !while
19:07  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
19:08  MrUnagi: !read
19:08  greybot: help read <ENTER> read http://wiki.bash-hackers.org/commands/builtin/read
19:08  cherwin: quit
19:08  MrUnagi: the while documentation seems confusing to me =/
19:09  MrUnagi: or at least while read
19:10  geirha: read reads one line of input and returns true if it read a line terminator (\n by default)
19:11  geirha: while executes a command, and if that command returns true, it executes the part between do and done
19:12  MrUnagi: so while $(ls /); do echo "yes"; done will echo yes until / is deleted?
19:12  e36freak: !ls > MrUnagi
19:12  greybot: MrUnagi: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
19:12  e36freak: MrUnagi: ls does not belong in a script. ever.
19:13  erUSUL: third time the charm?
19:13  MrUnagi: could i get a layman's example of while?
19:13  e36freak: !while
19:13  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
19:13  MrUnagi: yea im reading that.....still lost lol
19:13  erUSUL: MrUnagi: while true; do echo yes; done
19:14  e36freak: # x=0; while (( x < 10 )); do ((x++)); printf "%s " "$x"; done
19:14  evalbot: e36freak: 1 2 3 4 5 6 7 8 9 10
19:14  geirha: # x=0; ((x < 10)); echo "command returned with exit status $?"
19:14  evalbot: geirha: no output within the time limit
19:14  geirha: # x=0; ((x < 10)); echo "command returned with exit status $?"
19:14  evalbot: geirha: command returned with exit status 0
19:14  geirha: # x=11; ((x < 10)); echo "command returned with exit status $?"
19:14  evalbot: geirha: command returned with exit status 1
19:15  geirha: So as long as ((x < 10)) returns true, the part between do and done is executed (with e36freak's example)
19:19  MrUnagi: x++ adds 1 to x?
19:20  erUSUL: MrUnagi: in math context yes
19:21  e36freak: same as ((x+=1)) or x=$((x+1))
19:21  MrUnagi: hmmm
19:22  MrUnagi: ok so while makes sense but i see while read  a lot and i don't exactly understand what that is doing......you said read reads one line of input and returns true if it read a line terminator, where would simply while read f; read anything?
19:23  e36freak: !guide > MrUnagi
19:23  greybot: MrUnagi: http://mywiki.wooledge.org/BashGuide
19:23  e36freak: it reads from stdin
19:23  MrUnagi: i read about stdin stdout stderr yesterday, i didnt quite understand what they were.....ill start there thanks
19:24  teurastaja: why do all shells base themselves on sh? (or so it seems). sh is a good basic shell, but extensions to it just feel like extensions....
19:25  erUSUL: teurastaja: POSIX compat. mainly; i guess
19:25  teurastaja: shouldnt one person stand up and write something that makes a little more sense?
19:26  erUSUL: teurastaja: like?
19:26  erUSUL: teurastaja: a shell with perl as language? fish ; with scheme? scsh ; with "insert favourite scripting lang here" ? ...
19:26  teurastaja: being naturally attracted to scheme, everything else feels like bundled features (high level)
19:27  erUSUL: teurastaja: ipython has a shell mode too ...
19:27  teurastaja: scsh feels incomplete
19:27  teurastaja: isnt scsh dead?
19:28  erUSUL: teurastaja: revive it ;P
19:28  teurastaja: i would if i could yet
19:29  teurastaja: but id have to make a major cleanup for at least supporting r5rs
19:29  teurastaja: but r6rs is better for shell purposes
20:01  Tumulte: geirha: your solution works
20:01  Tumulte: however I can't launch more than one app with --tab -x
20:01  Tumulte: geirha: I thank you for your help
20:06  Tumulte: geirha: can this work with a "-e" instead of the "-x" jackrack_launcher=(--tab -x jack-rack "$fx_rack"); ...; gnome-terminal "${jackrack_launcher[@]}"
20:06  Tumulte: ?
20:06  e36freak: maybe? gnome-terminal has nothing to do with bash
20:06  Tumulte: actually it doesn't
20:07  Tumulte: the way it is written
20:07 --- abstract3d is now known as tzorvas
20:07  Tumulte: there must be a trick somewhere
20:09  Tumulte: --Argument to "--command/-e" is not a valid command:
20:09  e36freak: ...gotcha
20:09  e36freak: try #gnome or something
20:10  h0ho: how would I go about repeating a char a set about of times? like "perl -e "printf "A"x100"" in perl?
20:10  erUSUL: !faq hr
20:10  greybot: http://mywiki.wooledge.org/BashFAQ/023 -- I want to launch an interactive shell that has special aliases and functions, not the ones in the user's ~/.bashrc.
20:10  erUSUL: !hr
20:10  greybot: http://bash-hackers.org/wiki/doku.php/snipplets/print_horizontal_line
20:11  erUSUL: is that what you want?
20:12  h0ho: erUSUL: yeah thanks
20:18  shurane: So if I can't undo/redo, go to bottom of history with G (which is mainly why I want vi-mode), what other reasons should I use 'set -o vi' in bash? Is there say.. a more complete vi interpretation, or is that something I don't want?
20:19  geirha: Tumulte: Try with   jackrack_launcher=(--tab -e "jack-rack $(printf %q "$fx_rack")")
20:20  e36freak: shurane: basic commands and movement apply
20:20  e36freak: w, b, $, dd, etc
20:21  e36freak: yy, p
20:23  geirha: Tumulte: If you're gonna append several such --tab -e, just append it to the same array.
20:24  geirha: Tumulte: gtargs+=(--tab -e "xdg-open $(printf %q "$fx_rack")")
20:26  Tumulte: geirha: this is the syntax to append a variable into an array?
20:26  e36freak: shurane: also, you can disable histexpansion and don't have to deal with all the ! bs
20:26  geirha: Tumulte: No, it's the syntax to append elements to the array
20:26  geirha: !arrays
20:26  greybot: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
20:30  shurane: e36freak,  I was hoping for something more than just movement. It's alright, though. Hm, histexpansion? Isn't that kind of unrelated?
20:30  Tumulte: geirha: do you have a clue why the options  output this :  "Failed to parse arguments: Unknown option -K"
20:32  e36freak: shurane: well yeah, but it's one of the reasons i use vi mode
20:33  geirha: Tumulte: Whatever command you're trying to run doen't accept -K ?
20:34  Tumulte: it does
20:34  Tumulte: if I run it separatly
20:34  geirha: And how are you running it now?
20:34  geirha: (when it fails)
20:35  Tumulte: yoshimi_launcher=(--tab -e "yoshimi -K -L $(printf %q "$yoshimi_synth")")
20:35  geirha: And then you have gnome-terminal "${yoshimi_launcher[@]}" ? (WITH the quotes. Without, it would likely cause an error message like that)
20:37  Tumulte: the quote indeed
20:37  geirha: quotes are vital
20:37  geirha: !arguments
20:37  greybot: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
20:37  shurane: e36freak, while we're at it: two more things that are in vim-style, I guess: 1. How do I make dashes and underscores count as words? When I do ctrl-w, it only breaks on white spaces.
20:37  Tumulte: brb :)
20:37  shurane: e36freak, 2. Can I get tab-completion as it is in vim? That is, when I press tab, bash cycles through possible completions -- and ctrl-d will show a list of possible completions (like tab in regular tab-completion)
20:38  Tumulte: geirha: you're the man
20:38  Tumulte: you definitly made my day
20:42  geirha: shurane: "\t": menu-complete    in .inputrc will give the tab-behavior at least.
20:43  geirha: "\C-d": possible-completions might work for the second part.
20:43  geirha: But you probably have to set eof to something else, then, with stty.
--- Log closed Sun Jan 16 20:59:03 2011
--- Log opened Sun Jan 16 21:12:12 2011
21:12 --- Users 565 nicks [0 ops, 0 halfops, 0 voices, 565 normal]
21:16  tgunr: VAR=`run command`
21:16 --- Channel #bash was synced in 416 seconds
21:16  taylanub: !`
21:16  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
21:22  jef91: if my command as an arguement after it
21:22  jef91: do I need to put quotes around it?
21:23  geirha: !arguments > jef91
21:23  greybot: jef91: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
21:23  jef91: profile=$(enlightenment_remote -default-profile-get)
21:23  jef91: like that?
21:26 --- y3llow_ is now known as y3llow
21:28 --- cuba33ci_ is now known as cuba33ci
21:29  geirha: jef91: Yes, that looks correct
21:29  geirha: It's run a command with one argument, and store whatever it outputs to stdout into the variable named profile.
21:29  geirha: s/It's/It'll/
21:30 --- nolimitsoya__ is now known as nolimitsoya
21:30  geirha: Though trailing newlines will be stripped, but that's probably not a problem.
21:48  latenite: Hi, what is wrong with my string comparison? http://pastebin.com/L78KuxAw all I get ist ALWAY "yes" http://pastebin.com/cWvqYJeB
21:50  geirha: Yes, [ "string" ] returns true if string is non-empty. Which it is since it always contains ==
21:50  geirha: If you want string comparison, you need three arguments instead of one, the second one being =
21:51  latenite: geirha, Hi :D, so like this : if [ "$alreadsetitem"="$item" ]; then ?
21:51  geirha: In addition to that you are using deprecated features, and lack many qutoes.
21:52  geirha: latenite: No, that's one argument, not three
21:52  geirha: arguments are separated by whitespace.
21:52  Tumulte: see you
21:52  Tumulte: thanks again geirha
21:52  latenite: geirha, ahh whitespace was my error. thank you.
21:53  geirha: latenite: You should not use [ in bash though
21:53  geirha: !tests
21:53  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
21:53  latenite: geirha, what kind of  deprecated features can I avoid?
21:53  geirha: !$[
21:53  greybot: $[...] is an obsolete, deprecated syntax for math. Don't use it. Use $((...)) instead.
21:53  geirha: !`
21:53  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
21:54  geirha: alreadyset[${#alreadyset[@]}+1]=$(grep ...)
21:54  geirha: Or, alreadyset+=("$(grep ...)")
21:55  geirha: Oh, wait, did you mean to make it sparse?
21:55  jef91: Is there an "if in" type check for a value inside a string for bash?
21:55  jef91: I want to see if a word is in a certain var
21:56  geirha: if [[ $string = *"$foo"* ]]; then echo "<$string> contains <$foo>"; fi
21:56  gniourf_gniourf: # var="are you in there?"; if [[ $var = *"in"* ]]; then echo "in is in var"; fi
21:56  evalbot: gniourf_gniourf: in is in var
21:57  latenite: geirha, thanks I corrected it to: http://pastebin.com/LZ6YuYKa
21:58  geirha: excellent. Now you just need quotes around "${lxckernelconfigs[@]}"
21:59  geirha: You don't need that \ on line 8 ... though it doesn't hurt either.
21:59  latenite: geirha, ok I did taht , too. What "differece do they make" ?
21:59  gniourf_gniourf: line 40, a single = sign will do as well
22:00  geirha: # array=( "elem 1" ); for e in "${array[@]}"; do echo "$e"; done
22:00  evalbot: geirha: elem 1
22:00  geirha: # array=( "elem 1" ); for e in ${array[@]}; do echo "$e"; done
22:00  evalbot: geirha: elem
22:00  evalbot: geirha: 1
22:00  geirha: latenite: See the difference? ^
22:01  gniourf_gniourf: and isn't line 41 supposed to be before the if? maybe with the -n option (or use printf) ?
22:01  geirha: !$@
22:01  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
22:01  latenite: geirha, it "ommits" whitespace?
22:01  geirha: latenite: No it avoids whitespace inside elements being treated as word-separators
22:01  latenite: geirha, oh thats what I ment :)
22:02  latenite: So I gess I will alway use " more often..
22:02  ferret: good idea
22:02  gniourf_gniourf: yes, use " as much as you can
22:02  latenite: :D
22:02  geirha: Whenever you have a $, you generally want it inside ""
22:03  latenite: so even alreadyset+=("$(grep ".*${item}" /usr/src/linux/.config)") would better be alreadyset+=("$(grep ".*"${item}"" /usr/src/linux/.config)")
22:03  latenite: ? right?
22:03  jef91: This is not working - if [ $profile = *"Bodhi"* ]; then echo "<$profile> contains Bodhi"; fi
22:03  jef91: Any ideas why?
22:03  geirha: latenite: the first one was fine
22:04  geirha: ![[ > jef91
22:04  greybot: jef91: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
22:04  gniourf_gniourf: # profile="hello Bodhi"; if [[ $profile = *"Bodhi"* ]]; then echo "<$profile> contains Bodhi"; fi
22:04  evalbot: gniourf_gniourf: <hello Bodhi> contains Bodhi
22:04  gniourf_gniourf: it does work
22:04  jef91: ahh thank you
22:04  geirha: latenite: The second one is broken, because $item is now NOT inside "" quotes
22:04  latenite: geirha, gniourf_gniourf brilliant help...thanks a lot :)
22:06  taylanub: it seems like my inputrc is ignored and the bind command is effectless
22:06  geirha: latenite: $() starts a new quoting context, so with "$(foo "bar")" it is not  "$(foo " + bar + ")" ... the quotes are nested.
22:06  taylanub: bind -u unix-word-rubout; bind '"\C-w": unix-filename-rubout'  # no effect
22:07  latenite: geirha, oh ok..let me play with it a little...
22:07  geirha: taylanub: What's the line in .inputrc then?
22:07  taylanub: geirha: the argument passed to the second
22:09  taylanub: bind -p output indicates no change
22:13  geirha: Hm. Yeah, odd. bind -u unix-word-rubout doesn't appear to do anything
22:13  jk4: how to assign to the next empty space in an indexed array?
22:13  geirha: array+=( "new element" )
22:14  jk4: thanks
22:28  latenite: I am having "logical" dificulties with http://pastebin.com/Gf4Ywzub . I want to opposite output. What I want is thise elements of ${lxckernelconfigs[@]} that are NOT in ${alreadsetitem}
22:28  latenite: I just dont see how to put it together...
22:30  geirha: latenite: Do you have bash4?
22:31  Bartzy: How can I save to file all the running processes (over time) that contain my_script_name ?
22:31  latenite: geirha, 4.1 yes. but I d loike my script to be as "sh" as possible
22:31  Bartzy: I tried watch but it's only for real time.. how can I save with it ?
22:31  geirha: anyway, if [[ "${alreadsetitem}" != "${item}" ]]; then echo "$item"; fi
22:31  geirha: Err, wait, no.
22:32  geirha: !ising > latenite
22:32  geirha: !isin > latenite
22:32  greybot: latenite: Check whether a value is in an array: inarray() { local q=$1 e; shift; for e; do [[ $q = "$e" ]] && return; done; } # Usage: inarray "$value" "${array[@]}"
22:32  geirha: latenite: Well, you're already using arrays, which you don't have in sh.
22:33  latenite: geirha, ohh ok *did n know*. So I use this cool function you pasted?
22:33  Bartzy: geirha you surely know how :)
22:33  geirha: for item in "${lxckernelconfigs[@]}"; do if ! inarray "$item" "${alreadyset[@]}"; then echo "$item is not set"; fi; done
22:34  geirha: Bartzy: Maybe, if I understood the question.
22:35  Bartzy: geirha: What I want to accomplish is to fetch over time, to 1 file, all proccess (in ps format.. or whatever.. just want to see the entire command), that contain "my_script.pl" for example
22:36  geirha: Then you may want top or run ps in a loop. Though there's always a chance you never catch one.
22:37  Bartzy: loop ? That won't kill the server to run ps so many times ?
22:38  geirha: An easier option is to just have your script write the data to the file itself.
22:39  latenite: geirha, cool it works and I understand it ...feels great :) thank you
22:39  latenite: http://pastebin.com/5XuWzjgz
22:40  Bartzy: geirha: But if I loop it means that I constantly see the command running (until it ends)
22:43  geirha: Bartzy: Wasn't that what you wanted?
22:43  Bartzy: geirha: I want to show it only once :|
22:44  geirha: Bartzy: Then have the script write it to the file
22:45  geirha: echo "I am myscript, and my arguments are: $@" >> /tmp/somefile
23:53  marvin2: Hi, is there a way to run bash just to check the syntax of a script file?
23:53  twkm: not really, but you can try -n.
--- Log closed Mon Jan 17 00:00:47 2011
