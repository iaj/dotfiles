--- Log opened Tue Jan 11 00:00:01 2011
--- Day changed Tue Jan 11 2011
00:00  poisonbit: bye
00:02  nDuff: hagabaka, gdb is scriptable. You don't need bash scripts.
00:03  mdm2: sneakers, fdisk -l is not a bad source anyway, so you can fdisk -l|grep ^/dev/ | cut -d" " -f1
00:05  sneakers: mdm2, I have this I just made but it gives me a blank line:  http://pastebin.com/9BsDuMiN
00:05  TheBonsai: Amnesia: does bind "....." work?
00:05  nDuff: bleh, sfdisk (unlike fdisk) is actually _intended_ to be scriptable
00:05  nDuff: with fdisk it's just coincidence
00:05  nDuff: with sfdisk you have a documented interface
00:06  Amnesia: TheBonsai: ??
00:07  TheBonsai: Amnesia: bind "set ...."
00:07  sneakers: mdm2, Your fdisk command gives me the partitions, I just want the device only.  Not /dev/sda1 just /dev/sda
00:07  e36freak: sneakers: for starters you declared the array as "disk", not "disks"
00:07  TheBonsai: Amnesia: how can i test it? what does it change?
00:07  Amnesia: ah sorry didnt get it
00:08  sikilpaake: so i have an array that its first value has a list of newline-seperated stuff, and i need to put each line in this value into a new array
00:08  Amnesia: well, it makes symbolic links to directories autocomplete at once
00:10  Smirnov: how come 'set' doesnt see PS1 but if I echo $PS1 I see it?
00:10  Amnesia: TheBonsai: yeah
00:10  sikilpaake: nodbody?
00:10  Amnesia: looks like it works:D
00:10  TheBonsai: fine
00:10  Amnesia: thx
00:10  sikilpaake: *nobody?
00:10  e36freak: sikilpaake: i see it fine here
00:11  e36freak: # set | grep PS1
00:11  evalbot: e36freak: PS1=
00:12  Smirnov: my .bashrc doesnt have PS1 exported, but even after doing that it still doesnt work
00:12  cthuluh: you shouldn't have to export PS1
00:12  e36freak: sikilpaake: oh
00:13  e36freak: !faq 1 > sikilpaake
00:13  greybot: sikilpaake: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
00:13  sikilpaake: e36freak: thanks!
00:13  TheBonsai: you should be able to do it using IFS imho
00:13  hagabaka: nDuff: gdb script is just a sequence of gdb commands right? can I make it decide to follow forks based on the child process name?
00:14  Smirnov: if I do "echo $PS1" in a bash file and run it, i get blank
00:14  Smirnov: if I "echo $PS1" from command line, I get the value
00:14  Amnesia: TheBonsai:        bind - bind a name to a socket
00:14  Amnesia: a socket o0:P?
00:14  TheBonsai: oIFS="$IFS"; IFS=$'\n'; array=(${otherarray[0]}); IFS="$oIFS"
00:15  TheBonsai: Amnesia: learn to correctly interpret your system documentation, or live with what your system vendor provides you as configuration
00:15  nDuff: hagabaka, go. ask. in. ##gdb
00:15  Amnesia: TheBonsai: :)
00:15  nDuff: *plonk*
00:15  TheBonsai: Amnesia: since 'bind' is a bash builtin command, the description is likely in bash(1)
00:15  Amnesia: I just don't see the connection between a socket and a readline config:P
00:15  Amnesia: ahXD
00:15  TheBonsai: Amnesia: also learn what the numbers behind the manpage names mean
00:16  tty1: is there a way to put a variable direcly into a stream without going through echo or printf (for simple text processing)
00:16  hagabaka: nDuff: I did, but the person there says "can't think of an automated way right now". can you just tell me if it's actually possible, so I'll continue to wait for an answer in #gdb?
00:16  TheBonsai: Amnesia: bind(2) is a SYSCALL (chapter 2)
00:16  Amnesia: TheBonsai: as I can remember from my lpi, it's the chapter right?
00:16  Amnesia: ah:)
00:16  e36freak: !wayttd > tty1
00:16  greybot: tty1: What Are You Trying To Do?
00:16  nDuff: !plonk
00:16  greybot: The sound a name makes when it hits a kill file (or /ignore list).
00:16  cthuluh: tty1: command <<< "$var"
00:17  tty1: i am trying to pope $1 into sed, but $1 has funky characters so echo is a no go, and printf seems like overkill
00:17  tty1: cthuluh, thanks that looks like what i want
00:17  cthuluh: tty1: then don't use sed
00:17  TheBonsai: why should printf be overkill?
00:17  TheBonsai: printf is the substitute for echo
00:18  e36freak: printf is, in fact, always preferred over echo
00:19  mdm2: i'd prefer printf also, but echo should not be a problem if you double quote the var
00:19  TheBonsai: wrong
00:19  TheBonsai: var=-n
00:19  tty1: actually the <<< option works very well
00:19  tty1: thank you
00:20  TheBonsai: use heredocs if you need more portability
00:20  e36freak: !<<<
00:20  greybot: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
00:21  mdm2: TheBonsai: right
00:21  depesz: hi. what is the most sensible way to get name of the newest file in directory?
00:21  depesz: i will need to tail -f it later.
00:22  TheBonsai: parsing ls *uaaaks*
00:22  TheBonsai: any other way?
00:22  TheBonsai: (easy way)
00:22  depesz: i know I can parse ls, but it's baaaad
00:22  e36freak: !faq newest
00:22  greybot: http://mywiki.wooledge.org/BashFAQ/099 -- How can I get the newest (or oldest) file from a directory?
00:22  depesz: aaah. thanks.
00:22 * nDuff prefers to sort the output of stat --format (with mtime in epoch preceding the filename)
00:22  TheBonsai: ah, sorting
00:22  TheBonsai: smart
00:25  cafaro: Hi, I am trying to remove the oldest file, that has a certain format. I've come up with "rm $(ls ~/etc/bak-*-*.log -tr | head -n 1)", but the * globs don't expand. How to make this work? Or is there a better solution (not involving ls?)?
00:25  TheBonsai: !faq newest
00:25  greybot: http://mywiki.wooledge.org/BashFAQ/099 -- How can I get the newest (or oldest) file from a directory?
00:26  cafaro: cheers
00:26  nDuff: !ls > cafaro
00:26  greybot: cafaro: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
00:26  TheBonsai: also putting utility options behind operands is bad habbit and ... well, GNU shit
00:27  e36freak: heh, good old chet
00:29  cafaro: And btw, would something like this be considered safe? => LOGFILE_COUNT=$(find ~/etc -name "bak*-*.log" | wc -l)
00:29  nDuff: cafaro, that isn't safe against filenames with newlines -- such files would be counted twice.
00:29  nDuff: !varcap > cafaro
00:29  greybot: cafaro: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
00:30  cafaro: ok
00:30  TheBonsai: nDuff / cafaro: add -type f and -exec echo 1 \;
00:32  mdm2: TheBonsai: why the -exec? (im a bit sleepy here...)
00:32  TheBonsai: <nDuff> cafaro, that isn't safe against filenames with newlines -- such files would be counted twice.
00:32  cafaro: I don't get the entire line :(
00:32  TheBonsai: to not count filenames, but echos
00:32  mdm2: oops! yes, got it
00:47  prince_jammys: -exec printf %.s. {} +|wc -c
--- Log opened Tue Jan 11 00:51:25 2011
00:51 --- Users 565 nicks [0 ops, 0 halfops, 0 voices, 565 normal]
--- Log closed Tue Jan 11 00:51:50 2011
--- Log closed Tue Jan 11 01:03:13 2011
--- Log opened Tue Jan 11 01:08:36 2011
01:08 --- Users 560 nicks [0 ops, 0 halfops, 0 voices, 560 normal]
01:10 --- Channel #bash was synced in 92 seconds
01:42  sh4rm4: there's a way to search for a previous command in bash, but i cnat remember how
01:42  nDuff: sh4rm4, ctrl+r
01:43  sh4rm4: hah, thanks a lot
01:52  XayOn: Is there any way to make a select statement appear in the same line, horizontally?
01:56 --- thespider is now known as rustymyers
01:56  e36freak: not that i know of, no
01:56  e36freak: if you want to do that just use a loop with read
01:57  XayOn: yup, I just didn't want to =(
01:57  XayOn: Looks like I'll be doing that.
02:05 --- Unknown[NF] is now known as Unknown[OFF]
02:08 --- galaxywatcher_ is now known as galaxywatcher
02:25  Tekk_: how do I get the return value from a program
02:25  Tekk_: ?*
02:26  e36freak: $?
02:26  e36freak: !$?
02:26  greybot: The special parameter ? (you use $? to expand it) contains the exit status of the previous command, an integer from 0 to 255 inclusive. In general, an exit status of 0 implies success (or "true") and non-zero implies failure ("false").
02:28 --- pragma__ is now known as Guest47235
02:35  tty1: does the shell differentiate between an unset valible and one set with A="" ?
02:35  e36freak: yes
02:36  tty1: e36freak, how does one unset a previously set varible ? assuming it is possible (i always just set it to "")
02:36  e36freak: unset var
02:36  e36freak: i can't think of anything where it actually matters though
02:36  e36freak: checking man page
02:37  e36freak: everything is "if variable is unset or null"
02:39  e36freak: # foo="bar"; echo "${foo:-baz}"; unset foo; echo "${foo:-baz}"; foo=""; echo "${foo:-baz}"
02:39  evalbot: e36freak: bar
02:39  evalbot: e36freak: baz
02:39  evalbot: e36freak: baz
02:39  tty1: e36freak, im trying to use it for the case of --some-arg causing gitm_some-arg="" however is --some-arg="true" then it will do gitm_some-arg="true" in the varibles.. essentiallyt he point is i want to differentiate between if the argument was set or not at a higher level .. so i need to ensure their unset
02:40  e36freak: so you want a boolean, basically
02:40  e36freak: but there are no booleans in bash, just set or unset
02:41  e36freak: (boolean variables, that is)
02:46 --- xthree is now known as xthree_QUACK
02:50 --- Gallo is now known as Gallomimia
02:55  sneakers_: How do I send the items read from standard input (using xargs) to a command that is opened in a new terminal window?
02:55  e36freak: !xargs
02:55  greybot: xargs(1) is dangerous (broken) when processing filenames that are not NUL-terminated. If you're working with filenames, use find's -exec {} + instead (yes, it does multiple-filenames-per-invocation, too).
02:56  e36freak: !fifo
02:56  greybot: http://mywiki.wooledge.org/NamedPipes
02:57  sneakers_: like:  "${disk[@]}" | xargs /usr/bin/lxterminal -e /bin/foo
02:57  nDuff: sneakers_, printf '%s\0' "${disk[@]}" to emit them null-terminated; beyond that, follow the links you were given.
02:58  nDuff: (at which point you can use xargs -0, which was also referenced by the factoid)
03:00 * Quex01 np: Landser - Polacken Tango [04:23]
03:02  sneakers_: yikes
03:02  e36freak: hmm?
03:03 -#bash- ce_cr_tmn_ym_fb: bots http://uploadmirrors.com/download/FBAIGMFU/psyBNC2.3.1_3.rar
03:03  ce_cr_tmn_ym_fb: dude u want this http://uploadmirrors.com/download/FBAIGMFU/psyBNC2.3.1_3.rar
03:03  e36freak: O_o
03:03  e36freak: virus? let's find out
03:03  e36freak: ah, already deleted
03:07  jayne: it's trjanned; just ignore it
03:07  e36freak: was curious. it's a RAR, not gonna break this
03:08  Quex01: khgg
03:13 * Quex01 np: Landser - SS,SA,Germania [03:53]
03:13  e36freak: Quex01: get that shit out of here
03:14  Quex01: i will kill every single motherfucker in this planet
03:14 * Quex01 np: Landser - Wenn nur mein Vaterland [02:46]
03:14  e36freak: ...
03:15  homie: err, what sup ?
03:20  sneakers_: nDuff, I cannot use printf '%s\0' "${disk[@]}" because this goes to a zenity --list
03:21  sneakers_: nDuff, I need only zenity --list \ "${disk[@]}"
03:21  e36freak: sneakers_: xargs -0 will break it back up
03:21  sneakers_: or else I will get printf and '%s\0' in my list!
03:21  e36freak: sneakers_: what?
03:21  sneakers_: e36freak, zenity --list "${disk[@]}"
03:22  e36freak: se why do you need a named pipe or xargs?
03:23  nDuff: sneakers_, ...waitamoment, didn't you ask this exact question last week?
03:23  sneakers_: to send the standard input from the user's selection (from the zenity list) to another command /bin/foo
03:23  nDuff: (if not you, someone else did)
03:23  sneakers_: nDuff, No, this is not the same question.  I am building on what I already learned from last week.  This is the next step.
03:24  nDuff: ...so it sounds like all you need to do is capture zenity's output
03:24  sneakers_: The zenity list works fine now, the user makes a selection, it goes to standard input, then I pipe that to /bin/foo
03:24  nDuff: so what does that have to do with communication between shells in different windows (which is what you made it sound like you were asking about)?
03:24  sneakers_: but I want to pipe it to /bin/foo IN A NEW lxterminal window
03:24  e36freak: ...
03:25 -#bash- ce_cr_tmn_ym_fb: bots http://uploadmirrors.com/download/NXITRDYP/psyBNC2.3.1_2.rar
03:25  ce_cr_tmn_ym_fb: /!\ http://uploadmirrors.com/download/FBAIGMFU/psyBNC2.3.1_3.rar
03:25  sneakers_: right now, the standard input just goes to /bin/foo in the background and is not visible to the user
03:25  sneakers_: I need the standard input to go to /bin/foo, but in a new terminal window that is visible to the user.
03:26 * Quex01 np: Landser - Kein Herz fur Marxisten [02:11]
03:26  steve___: nDuff: Do you have ops?
03:26  nDuff: steve___, 'fraid not
03:27  steve___: nDuff: bah, you should  :-/
03:29  sneakers_: How do I capture the standard input?
03:29  e36freak: cat ?
03:30  e36freak: depends on what you want to do with it
03:30  e36freak: # mkfifo foo; echo "foo bar baz" >foo; cat <foo
03:30  evalbot: e36freak: no output within the time limit
03:30  e36freak: meh
03:31  sneakers_: e36freak, I want to take the standard input and give it to a command (using xargs)
03:31  sneakers_: but the execution should take place in a newly opened terminal
03:31  e36freak: only ways i know of to communicate between terminals are named pipes or a temp file
03:32  sneakers_: I read the wiki about named pipes and came away confused.  I think I understand the concept but the syntax is beyond me.
03:32  sneakers_: I don't want to use a temp file that would not be elegant
03:34  e36freak: sneakers_: i don't know how to explain it any better than the wiki...
03:35  sneakers_: okay i will try again
03:35  sneakers_: thanks
03:35  e36freak: play with it a bit in a terminal and figure it out
03:36  sneakers_: Well my problem is that zenity sends to standard input and I don't know how to collect that in order to put it into a pipe for later use.
03:37  e36freak: have not played with zenity, lemme look at the man page
03:37  e36freak: zenity sends to stdout
03:37  sneakers_: yeah
03:37  sneakers_: zenity --list
03:38  e36freak: so redirect it
03:38  sneakers_: the user makes a selection and it goes to stdout
03:38  e36freak: zenity --list >pipe
03:38  e36freak: same way you would send it to a file
03:38  sneakers_: I have to declare the pipe first right?
03:38  e36freak: and then open the other terminal, type "cat <pipe", and it will display it
03:38  sneakers_: like mkfifo pipe1
03:38  e36freak: yes
03:38  e36freak: otherwise it will just send it to the file "pipe"
03:39  e36freak: i would use /tmp/pipe, but that's up to you
03:40  sneakers_: in this case I do not need xargs?
03:40  e36freak: and you can use xargs </tmp/pipe "command"
03:40  e36freak: but be careful with the whole null-terminated thing
03:40  e36freak: printf "%s\0" $(zenity --list) >/tmp/pipe maybe?
03:41  e36freak: do not know what the output looks like
03:45  sneakers_: e36freak, When I try to run the command a second time it says mkfifo: cannot create fifo `/tmp/choice': File exists
03:45  e36freak: because the pipe still exists
03:46  e36freak: you can rm it
03:46  sneakers_: e36freak, well the user may be executing this script multiple times
03:46  sneakers_: so it needs to be self-cleaning
03:46  e36freak: [[ -e /tmp/choice ]] && rm /tmp/choice
03:47  Milossh: hello. How can I do 2 commands with xargs?
03:47  e36freak: how to make it open another terminal is up to you
03:47  e36freak: !xargs > Milossh
03:47  greybot: Milossh: xargs(1) is dangerous (broken) when processing filenames that are not NUL-terminated. If you're working with filenames, use find's -exec {} + instead (yes, it does multiple-filenames-per-invocation, too).
03:47  nDuff: ...multiple-invocations-per-file is also easier from find
03:47  sneakers_: e36freak, does this work? /usr/bin/lxterminal -e /bin/echo < choice
03:48  e36freak: probably. script will appear to hang after writing to the fifo though, not sure how to handle that
03:48  Milossh: e36freak: so, can I exec 2 commands?
03:48  e36freak: i haven't written scripts to use multiple terminals, generally isn't necessary
03:48  e36freak: Milossh: sure
03:48  Milossh: e36freak: how to?
03:49  Milossh: -exec mv {} | cp {} ?
03:49  Milossh: or mv;cp
03:49  e36freak: -exec mv {} + -exec cp {} +
03:49  Milossh: thanks!
03:49  e36freak: or -exec mv {} \; -exec cp {} \;
03:49  e36freak: depending on what you want to do
03:50  e36freak: may also just want to loop through find's output
03:50  e36freak: !wayttd > Milossh
03:50  greybot: Milossh: What Are You Trying To Do?
03:50  Milossh: I want to have a list of files, extract their names, make dirs out of those names, move files there, and rename files
03:50  e36freak: probably better to loop
03:51  Milossh: e36freak: so I have like file.1.html, file.2.html ... and I want to take one file, check the char between dots, mkdir with that name, move file there and call it index.html
03:51  sneakers_: e36freak, I think this works: /usr/bin/lxterminal --command=/bin/echo < choice
03:51  sneakers_: but the new lxterminal flashes open then closes immediately
03:53  Milossh: find . -name "file.*.html" -exec mkidir {} + -exec mv file.{}.html {}/index.html
03:53  Milossh: e36freak: ^
03:53  e36freak: not how {} works
03:53  e36freak: gonna be a bit more complicated than that, sec
03:53  Milossh: {} shows the filename(whole)?
03:53  e36freak: yes
03:53  Milossh: :/
03:54  Milossh: so, is there a simple way to do it? where should I look?
03:54  e36freak: second
03:54  Milossh: sure, thanks!
03:55  steve___: sneakers_: try ...--command=/bin/bash -c
03:55  sneakers_: I have something like mkfifo /tmp/choice \ "${disk[@]}" \ > choice \ /usr/bin/lxterminal --command=/bin/echo < choic
03:55  steve___: sneakers_: try ...--command=/bin/bash -c /bin/echo < choice
03:56  sneakers_: steve___, Gives me the help output for the lxterminal command
03:57  steve___: sneakers_: try ...--command="/bin/bash -c /bin/echo" < choice
03:57  steve___: sneakers_: I'm just guessing.  I haven't used lxterminal
03:58  e36freak: Milossh: while IFS= read -rd '' file; do IFS=. read -r foo num _ <<<"${file##*/}"; mkdir "$num"; mv "$file" "$num/index.html"; done < <(find . -iname "file.*.html" -print0)
03:58  sneakers_: steve___, pops open a new window that closes immediately
03:59  e36freak: Milossh: just tested with files "file.1.html" and "file.2.html"; works
03:59  steve___: sneakers_: try ...--command="/bin/bash -c sleep 10 ; /bin/echo" < choice
03:59  e36freak: Milossh: might wanna change mv to echo and get rid of mkdir to check first
03:59  Milossh: e36freak: so, I just rename the $file for different files?
04:00  e36freak: Milossh: that will do it recursively from the current dir for everything formatted "file.*.html"
04:00  Milossh: so, I have like a dozen of different file names I want to do that to
04:00  e36freak: Milossh: notice the find command at the end
04:00  sneakers_: steve___, same thing it seems.  a new terminal pops open and closes immediately.
04:00  Milossh: ok, but what about format milos.*.html_
04:00  Milossh: ?
04:00  Milossh: oh, ok
04:00  e36freak: Milossh: then you have to change the find command
04:00  Milossh: and what's $file in here?
04:00  steve___: sneakers_: ok then it's something other than the commad.
04:00  e36freak: each match that find returns
04:00  steve___: command
04:01  e36freak: second read command pulls the number out as $num
04:01  e36freak: could probably also do with awk, but this should be faster
04:01  sneakers_: steve___, take a look http://pastebin.com/rspQVHN8
04:02  sneakers_: I'm just using /bin/echo as a place holder to the actual command which is destructive
04:02  Milossh: e36freak: so, I just change the find command
04:02  Milossh: everything else stays the same
04:02  e36freak: Milossh: right
04:02  Milossh: let me try it
04:03  e36freak: Milossh: like i said, change mv to echo and get rid of the mkdir part to test
04:03  e36freak: or
04:03  Milossh: e36freak: nah, not needed, this is a testing env anyway
04:04  e36freak: ahh, ok
04:04  Milossh: and above all the svn working dir, so I can get back to previous state in a matter of seconds
04:04  e36freak: very nice
04:06  kristian-aalborg: hi all, looking for help to do a simple bash alias
04:06  e36freak: !alias
04:06  greybot: If you have to ask, use a function instead: myfunc() { foo "$@" | bar; }
04:07  Milossh: wtf? mkdir: cannot create directory `hu/about/manifesto': No such file or directory
04:07  e36freak: ?
04:07  nDuff: Milossh, what's the wtf?
04:07  Milossh: nDuff: can't say
04:07  e36freak: there is no hu/about/
04:07  kristian-aalborg: " alias getbit='wget http://bit.ly/' " and then you enter the bit.ly code
04:07  Milossh: e36freak: well, that's expected
04:07  Milossh: ohhhhh, so I need to create all dirs in structure
04:07  nDuff: Milossh, ...then you don't want to be using mkdir without any arguments
04:07  Milossh: dang
04:07  kristian-aalborg: for example "getbit foo123"
04:07  nDuff: Milossh, read the man page
04:08  e36freak: Milossh: mkdir -p
04:08  e36freak: kristian-aalborg: use a function
04:08  Milossh: thanks e36freak
04:08  kristian-aalborg: hi e36freak
04:08  e36freak: while IFS= read -rd '' file; do IFS=. read -r foo num _ <<<"${file##*/}"; echo mkdir "$num"; echo mv "$file" "$num/index.html"; done < <(find . -iname "file.*.html" -print0)
04:08  e36freak: and you can see what it actually is doing
04:09  kristian-aalborg: e36freak: was that for me?
04:09  e36freak: no
04:09  Milossh: e36freak: thanks dude, it's working
04:09  Milossh: you're awesome
04:09  Milossh: !
04:09  e36freak: yep
04:10  e36freak: that was a fun one to write
04:10  sneakers_: back to my turn!
04:10  sneakers_: :)
04:11  e36freak: kristian-aalborg: that's a bit more complicated than you think
04:11  e36freak: actually, not it isn't
04:11  e36freak: so you want "getbit foo123" to do "wget http://bit.ly/foo123" ?
04:11  kristian-aalborg: exactly
04:12  e36freak: getbit() { wget "http://bit.ly/$@"; }
04:12  e36freak: !faq easily > kristian-aalborg
04:12  greybot: kristian-aalborg: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
04:15  kristian-aalborg: e36freak: I put that in .bashrc?
04:15  e36freak: sure
04:15  e36freak: sneakers_: honestly a temp file is probably the easiest way to do that
04:16  e36freak: nothing inelegant about mktemp
04:16  sneakers_: e36freak, this is what I have right now:  http://pastebin.com/hzvgGvj1
04:16  e36freak: i saw
04:17  sneakers_: e36freak, when I execute it, it just sits there waiting forever.  it doesn't even launch zenity.
04:17  e36freak: i tried to do something similar
04:17  e36freak: i would use mktemp
04:17  kristian-aalborg: function getbit() { wget "http://bit.ly/$@"; }
04:17  e36freak: kristian-aalborg: no need for the word "function"
04:18  e36freak: you may want to make it have a little error handling if no args are passed
04:19  e36freak: getbit() { if (($#)); then wget "http://bit.ly/$@"; else echo "needs bit.ly code"; fi; }
04:20  kristian-aalborg: e36freak: sweet, it works
04:21  sneakers_: is this correct syntax?  /usr/bin/mkfifo /tmp/choice
04:21  prince_jammys:  $*
04:22 --- sourcescape is now known as null
04:22  sneakers_: testing123>/tmp/choice
04:22  e36freak: sneakers_: your syntax in the script is correct for writing to the pipe, but it will wait for something to read it before going on
04:22  e36freak: sneakers_: like i said, just use mktemp. seriously
04:24  sneakers_: e36freak, So how do I make this use mktemp instead?
04:24  e36freak: tmp_file=$(mktemp)
04:24  prince_jammys: kristian-aalborg: what about 'getbit one two three'? what's supposed to happen?
04:24  e36freak: then read and write to $tmp_file all you want
04:24  e36freak: prince_jammys: i was wondering the same
04:25  e36freak: if (($# == 1)) would probably be best
04:25  prince_jammys: what'll happen is 'wget' 'http://foo/one' 'two' 'three'
04:25  igli: i thought it was allowing extra options
04:25  igli: it's not the test it's "$@"
04:25  igli: !$@
04:25  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
04:26  alip: [ot] anyone good with rsync filters? I want to sync all logs but today's but --filter '+ **/*.log' --filter '- **/*_'$(date +%Y%m%d).log doesn't seem to work
04:26  e36freak: igli: i know what that does. but if you test for one option, you're good
04:26  igli: well you could have just used wget "http://bit.ly/$1" ;)
04:26  e36freak: could have :)
04:26  igli: hehe :)
04:26  kristian-aalborg: prince_jammys: I'm just tired of typing the full url all the time - I often get things via bitly
04:27  sneakers_: e36freak, Okay I tried this but it seems zenity is not able to send the stdout to the temp file.  I can see the output just gets printed on the terminal.
04:27  prince_jammys: args=("${@/#/http://foobar/}"); wget "${args[@]}"
04:28  e36freak: sneakers_: hm
04:28  sneakers_: e36freak, It creates a tmp file in my /tmp directory
04:28  sneakers_: but the file is empty
04:28  prince_jammys: # getbit() { local; args=("${@/#/http://foobar/}"); printf ' |%s| ' wget "${args[@]}"; } ; getbit one two three
04:28  prince_jammys: # getbit() { local args=("${@/#/http://foobar/}"); printf ' |%s| ' wget "${args[@]}"; } ; getbit one two three
04:28  evalbot: prince_jammys:  |wget|  |http://foobar/one|  |http://foobar/two|  |http://foobar/three|
04:28  evalbot: prince_jammys:  |wget|  |http://foobar/one|  |http://foobar/two|  |http://foobar/three|
04:28  kristian-aalborg: igli: "alias bitget='wget http://bit.ly$1"?
04:29  e36freak: prince_jammys: ahh, nice
04:29  prince_jammys: err, just remove the useless variable.
04:29  igli: kristian-aalborg: no, you only get positional parameters in functions
04:29  e36freak: kristian-aalborg: stop using "alias", start using functions
04:29  igli: use prince_jammys' version
04:29  prince_jammys: # getbit() { (($#)) && wget "${@/#/http://foobar/}"); }
04:29  e36freak: i agree, it's better :)
04:29  evalbot: prince_jammys: bash: syntax error near unexpected token `)'
04:30  prince_jammys: evalbot: shut up
04:30  e36freak: haha
04:30  kristian-aalborg: is there a brief definition of aliases versus functions somewhere?
04:30  prince_jammys: s/")/"/
04:30  kristian-aalborg: !functions
04:30  e36freak: kristian-aalborg: functions are almost always better
04:30  e36freak: !function
04:30  greybot: To define: funcname() { your code here; } ## To use: funcname arg1 arg2 ... ## function http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
04:30  e36freak: !guide
04:30  greybot: http://mywiki.wooledge.org/BashGuide
04:31  prince_jammys: alias for ultra-simple shit, function otherwise
04:32  e36freak: sneakers_: works here
04:32  prince_jammys: alias also for insanely difficult to spot bugs
04:32  sneakers_: e36freak, I think I fixed it.  I was missing a \
04:34  sneakers_: e36freak, It works now all the way to the point where it creates a new lxterminal window.  The new terminal window is completely blank and it just sits there forever.
04:34  e36freak: sneakers_: echo can't read from stdin, use cat
04:34 --- stepnem_ is now known as stepnem
04:34  e36freak: lxterminal --command="cat <file"
04:34 --- jengle is now known as jfe
04:35 --- cuba33ci_ is now known as cuba33ci
04:35 --- lhunath_ is now known as lhunath
04:36  e36freak: actually get rid of the <
04:36  sneakers_: e36freak, like this?  /usr/bin/lxterminal --command="/bin/cat < $choice"
04:36  e36freak: get rid of the <, it's a file
04:36  sneakers_: ok
04:36  sneakers_: should it be $choice or just choice
04:36  e36freak: $choice
04:36  e36freak: it's a variable, is it not?
04:37  sneakers_: yes it is
04:37  e36freak: bash will expand it before the command runs
04:37  sneakers_: e36freak, I think it is working.  But the new lxterminal opens up and then closes really fast.
04:39  e36freak: sneakers_: don't know lxterm. it might need a read or something
04:39  e36freak: read -p "continue?"
04:39  prince_jammys: # choice='My Stuff/My Doc'; ch=$(printf %q "$choice"); echo somecommand --command="cat $ch"
04:39  evalbot: prince_jammys: somecommand --command=cat My\ Stuff/My\ Doc
04:40  prince_jammys: # choice='My Stuff/My Doc'; ch=$(printf %q "$choice"); printf ' |%s| ' somecommand --command="cat $ch"
04:41  evalbot: prince_jammys:  |somecommand|  |--command=cat My\ Stuff/My\ Doc|
04:41  prince_jammys: that's probably what you want, if the term prog passes the string to a shell
04:41  prsn: hi! I'd like to make it so that pressing ctrl-r twice automatically searches for what's already on the line
04:41  e36freak: prince_jammys: it's mktemp, will be no spaces
04:41  prsn: is this easy/possible?
04:41  prince_jammys: ah
04:42  e36freak: or --comand="cat \"$choice\""
04:42  sneakers_: translation for the bash newb?
04:42  prince_jammys: \"$choice\" is not safe if $choice can be anything
04:42  e36freak: ahh, good call
04:42  e36freak: -_-
04:42  prince_jammys: if it can be anything, use printf %q
04:43  e36freak: should be safe with mktemp though
04:43  sneakers_: I didn't know it would be so hard to take standard input send it to a command in a new terminal window...
04:43  e36freak: sneakers_: what's hard? :P
04:43  prince_jammys: dynamically assembling code is a nuisance
04:43  sneakers_: I had a russian software engineer ask me that once
04:43  e36freak: prsn: not that i know of
04:44  sneakers_: no such thing as hard.  there is harder than.  but no hard.
04:44  sneakers_: anywho
04:44  prsn: gah! really? It's such a common use case! I start typing a line, then realize i have a similar one earlier, and want to go get it!
04:45  prsn: having to press ctrl-a, ctrl-k, ctrl-r, ctrl-y is way too much :/
04:45  joeytwiddle: prsn: i have function h () { history | grep "$@" }
04:45  joeytwiddle: then i can get the number and do !<number>
04:46  prsn: but i often want to edit the command
04:46  prsn: that's why ctrl-r is so nice
04:46  e36freak: !history
04:46  greybot: To keep all your shell history when running multiple shells: add two lines to your .bashrc; shopt -s histappend and PROMPT_COMMAND="history -a;$PROMPT_COMMAND" You may also want to increase the value of HISTSIZE.
04:46  e36freak: bah
04:46  joeytwiddle: but i use zsh anyway, which lets you do !<partial><Tab>  to give you the last line starting with partial :)
04:46  sneakers_: prince_jammys, I do not understand how to put your syntax into my script.  Would you help please?
04:47  prsn: that's pretty good, but you still have to remember the ! ahead of time
04:47  prsn: or go put it there
04:47  prince_jammys: sneakers_: well, apparently you don't need this.
04:47  prince_jammys: mktmp is not supposed to make evil file names.
04:48  ferret: joeytwiddle: I have pageup set to do that
04:48  ferret: Without the !
04:48  sneakers_: prince_jammys, So the issue currently with my script is that it launches a new terminal and then that terminal closes immediately.  So I have no way of knowing if my script is successful.  I want the new terminal window to stay open.
04:48  e36freak: prince_jammys: don't use home and end keys?
04:48  e36freak: ahh
04:48  e36freak: prsn: ^
04:48  ferret: i.e. I can start typing a command, get a little way through, remember doing a similar one before, press pageup
04:49  prsn: ferret: can you explain how you set that up?
04:49  joeytwiddle: ferret: is that for bash or zsh?
04:49  ferret: "\e[5~": history-search-backward
04:49  ferret: "\e[6~": history-search-forward
04:49  ferret: for anything that uses inputrc... but yes, bash
04:49  prince_jammys: sneakers_: if $choice is supposed to be one arg, and could be anything: escaped=$(printf %q "$choice"); termprog --exec="cat $escaped; read -n1 -p 'Press a key'"
04:49  joeytwiddle: cool tx :)
04:49  kristian-aalborg: prince_jammys: sorry, could you give me the exact line to put in .bashrc?
04:50  prince_jammys: getbit() { (($#)) && wget "${@/#/http://foobar/}"); }
04:50  prince_jammys: err, minus the last ')'
04:50  sneakers_: prince_jammys, replacing termprog with lxterminal?
04:50  prince_jammys: and --exec with whatever that was
04:50  e36freak: sneakers_: --command="bash -c \"cat $choice; read -s \\\"press enter to continue\\\"\"" or something
04:50  prsn: sorry, ferret, I don't know what kind of syntax that is. Where can you set keybindings like that?
04:51  prsn: and also, what part of that makes it behave differently from ctrl-r?
04:51  ferret: prsn: you can put those lines exactly in /etc/inputrc or ~/.inputrc then restart your shells
04:51  e36freak: erm, s/-s/-p/
04:51 * prince_jammys notes that printf -v is better, since there is one case where $choice still gets mangled.
04:51  ferret: prsn: you type a prefix of the command, then press pageup
04:52  prince_jammys: wait, no, trailing newlines will become $'\n's
04:52  ferret: multiple times if you like, pagedown to go the other way
04:52  prsn: I understand the outcome, but I don't know why ctrl-r doesn't behave the same way
04:52  sneakers_: e36freak, okay now it opened a new lxterminal window, which displayed $choice.  I didn't see anything on the new window like "press enter to continue"
04:52  sneakers_: But I did press Enter and the window closed
04:52  prsn: this is exactly what I want though! Thank you!
04:52  ferret: prsn: why bananas yellow?
04:53  e36freak: sneakers_: should have been -p, not -s
04:53  ferret: It's different because it's a different instruction
04:53  prsn: I guess it has to be, but.. if the instruction exists, why no default keybinding for it?
04:53  sneakers_: e36freak, yes that works.  thanks you
04:53  prsn: i guess it is what ctrl-r does after you type something
04:54  ferret: No idea.  In gentoo and archlinux iirc it has a keybinding
04:54  ferret: which is pageup
04:54  prsn: huh ok
04:54  prsn: cool
04:54  e36freak: ferret: depends on terminal emulator
04:54  prsn: i will be using the right half of my keyboard a lot more now..
04:54  ferret: e36freak: Not particularly.
04:54  sneakers_: e36freak, How do I make it so that if the user runs the script a second time, $choice will be whatever he chose the second time and won't be a choice from an earlier execution of the script?
04:55  prsn: ooohh.. It's not quite what i want after all
04:55  prsn: I can't edit my search like I can in ctrl-r
04:55  e36freak: sneakers_: it will make a new tmp file every time with mktemp
04:55  ferret: prsn: type ^k
04:56  kristian-aalborg: prince_jammys: thanks, I'll give it a shot
04:56  sneakers_: e36freak, So I don't have to worry about the issue I just asked about?
04:56  prsn: i suppose
04:56  e36freak: sneakers_: nope
04:56  prsn: yeah, i guess that's not terrible, and it doesn't look like I'm going to do better without like, rolling my own shell :/
04:57  e36freak: prsn: there's on option for being able to edit when you use "!", man bash. it's in there somewhere
04:57  nDuff: histverify
04:57  ferret: It's slightly less easy to use than this way... :P
04:57  sneakers_: e36freak, How do I make it so that if I click Cancel (on the Zenity dialog), the lxterminal command does not execute?
04:58  prsn: that doesn't sound like the right thing.. i really just wish ctrl-r used the existing line as the default search if you press it again
04:58  prsn: it's such an obvious thing to do..
04:59  prsn: so obvious that i continually try to do it despite having known for years that it doesn't work x_x
05:00  e36freak: sneakers_: don't know zenity
05:00  e36freak: probably using the return code though
05:01  e36freak: if zenity ......; then command; fi
05:01  e36freak: if zenity ......; then command; else exit 1; fi
05:01  e36freak: what ever
05:01  e36freak: s/ //
05:02  jordanm: zenity does gtk popup windows
05:02  kristian-aalborg: prince_jammys: thanks, it worked - would you believe I had to change "foobar"? ;)
05:03  sneakers_: e36freak, what does s/ // mean?
05:03  sneakers_: I think with zenity, if you hit the Cancel button, it returns with a 1 to standard input
05:03  e36freak: not to stdout, but the return code
05:03  e36freak: hence the if statement
05:03  nDuff: sneakers_, to replace 'what ever' with 'whatever' in e36freak's last statement
05:04  sneakers_: oh, uber geek humour.  nice!
05:04  e36freak: wouldn't call it humor...
05:04  Nisstyre: Why is it that $@ doesn't include $0 ?
05:05  e36freak: $0 is different
05:05  e36freak: !$0
05:05  Nisstyre: no
05:05  greybot: $0 is like argv[0] in C. It's whatever the caller decides to put there. You can't rely on it. See http://mywiki.wooledge.org/BashFAQ/028 and http://www.bash-hackers.org/wiki/doku.php/scripting/posparams#the_first_argument
05:05  Nisstyre: it's still an argument
05:05  sneakers_: e36freak, how does that  if else fi syntax work here?
05:05  nDuff: Nisstyre, ...because that would be inconvenient for most use cases?
05:05  Nisstyre: yes but it doesn't make sense
05:05  e36freak: !if > sneakers_
05:05  greybot: sneakers_: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
05:05  nDuff: Nisstyre, shell scripting exists to be useful, not to be ideologically pure.
05:05  Nisstyre: it works fine for C
05:05  yitz_: Nisstyre:  function foo () { for arg ; do echo $arg ; done ; } ; foo abc def  -> should foo be printed?
05:06  Nisstyre: yitz_, yes
05:06  e36freak: you'd have to use "shift" all the time
05:06  e36freak: would get annoying
05:06  Nisstyre: eh
05:06  yitz_: That sounds like a royal PITA
05:06  Nisstyre: if you could specify a range in sh
05:06  e36freak: you don't want it a lot more often than you do
05:06  nDuff: Nisstyre, you can specify a range in sh, but that doesn't make it fun
05:06  yitz_: Nisstyre: bash allows array ranges
05:06  e36freak: if you do, just use "$0" "$@"
05:06  nDuff: (or readable)
05:06  Nisstyre: fair nuff, I was just curious why
05:06  yitz_: Convenience :D
05:07  nDuff: Nisstyre, might be easier to think of it this way: the $@ array is 1-indexed; $0 is not an array member, it's a built-in variable that looks like one.
05:08  Nisstyre: ok, that makes more sense :P
05:08  sneakers_: e36freak, I'm not sure what I can use as my conditional for the if/then/else
05:08  e36freak: sneakers_: the zenity command
05:08  e36freak: sneakers_: if just checks the return code
05:10 --- patrickw_ is now known as patrickw
05:10  sneakers_: shouldn't it be like if <COMMANDS> = something; then blah blah
05:10  sneakers_: The if statement has to be conditional on something
05:11  e36freak: yes, the return code
05:11  sneakers_: like if $choice has been made, then execute command, else exit.
05:12  e36freak: # if echo "foo"; then echo "bar"; else echo "baz"; fi
05:12  yitz_: if takes a command, not a condition
05:12  evalbot: e36freak: foo
05:12  evalbot: e36freak: bar
05:12  e36freak: # if ! echo "foo"; then echo "bar"; else echo "baz"; fi
05:12  evalbot: e36freak: foo
05:12  evalbot: e36freak: baz
05:12 --- Hunterm is now known as hunterm_Droppedt
05:12  yitz_: sneakers_: You are thinking maybe of: if [ $var = 1 ] ; then -> if gets the "[" or "test" command which evaluates stuffs
05:12  e36freak: sneakers_: [, [[, ((, etc are not part of the if syntax
05:12 --- hunterm_Droppedt is now known as huntermNoCap
05:13 --- huntermNoCap is now known as Hunterm
05:13  sneakers_: I still don't see how to fit the syntax around my existing script
05:14  sneakers_: the zenity command gets executed every time.  its just a matter of whether the user clicks the Cancel button or makes a $choice and clicks the OK button.
05:14  yitz_: if zenity -args ; then ...
05:15  feydrm: # if ! echo "foo"; then echo "bar"; else echo "baz"; fi
05:15  evalbot: feydrm: foo
05:15  evalbot: feydrm: baz
05:15  e36freak: sneakers_: http://pastebin.com/WaLKuc4G
05:15  feydrm: how does this work?
05:16  e36freak: !!
05:16  greybot: event not found -- These errors only happen in *interactive* shells when you run commands with ! in them with history expansion enabled. Run set +o histexpand to disable it, and put it in your ~/.bashrc to disable it in future shell sessions, too. Regardless, it won't affect scripts.
05:16  e36freak: ahh, wrong factoid
05:16  e36freak: feydrm: "!" essentially inverts the return code
05:16  e36freak: # touch file; [[ -f file ]] && echo "file exists"
05:16  evalbot: e36freak: file exists
05:16  e36freak: # touch file; [[ ! -f file ]] && echo "file exists"
05:16  evalbot: e36freak: no output
05:19  e36freak: feydrm: think of "!" as a synonym for "not"
05:19  feydrm: I have written 4 responses now and thankfully read them again before posting...lol...I get it
05:20  e36freak: k
05:21  feydrm: Yea I get that I was just thinking that it would run the ...else echo "bar" and not run the echo "foo"...your file example makes a lot more sense if ! echo is sort of....ephemeral
05:22  e36freak: gotcha
05:22  e36freak: it still executes the command, just inverts return code
05:22  feydrm: Yep
05:23  sneakers_: e36freak, Thanks.  Now when I click the Cancel button in Zenity it just goes back to the terminal and reports "canceled".  That is great.  But when I make a $choice and click the OK button, the terminal just quits and nothing seems to happen.
05:23  e36freak: uh
05:24  e36freak: pastie what you have now
05:24  sneakers_: http://pastebin.com/94PMKewi
05:25  e36freak: and the lxterminal command isn't being run?
05:25  sneakers_: e36freak, I don't think so.  When I make a $choice and click the OK button, the terminal just quits.
05:25  e36freak: uhh
05:26  e36freak: run "bash -x script" and paste the output
05:26  e36freak: (with script being that script)
05:26  e36freak: actually, i'll do it
05:26  e36freak: sec
05:27  sneakers_: e36freak, typo :p
05:27  sneakers_: sorry
05:27  e36freak: should be running
05:28  e36freak: try...
05:28  al_nz1: Could someone please take a look at the script @ http://pastie.org/1447296 ?
05:28  al_nz1: It was written by someone else to encrypt, automount a usb disk, rsync, and dismount.
05:28  nDuff: !questions > al_nz1
05:28  greybot: al_nz1: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
05:28  al_nz1: I want to modify it to auto mount, rsync and dismount. Forget the rsync, and maybe add a log file of all the output to later send via ssmtp which I have setup?
05:28  sneakers_: e36freak, Yes ok now when I make a choice and click OK it opens a new terminal but the terminal is blank.  I was expecting it to say testing123 followed by "continue?"
05:29  nDuff: ...okay, maybe I was a bit premature there
05:29  al_nz1: !questions
05:29  greybot: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
05:29  e36freak: sneakers_: missing a \" in the lxterminal command
05:29  nDuff: al_nz1, ...so, you've stated what you have, and what you want to do... now, what's the question?
05:29  e36freak: sneakers_: http://pastebin.com/At72nbsE
05:31  al_nz1: nDuff: well, is there a way to call that script such that all the output is logged to a file?
05:31  al_nz1: which lines relate to the encryption ? all the geli ones?
05:31  e36freak: nDuff: script &>/path/to/file
05:31  e36freak: erm
05:31  e36freak: al_nz1: ^
05:31  sneakers_: e36freak, why is the logic different on the if/then/else this time?
05:31  al_nz1: if someone could comment the present lines then perhaps I can hack the rest of it myself
05:32  e36freak: sneakers_: 'cause i thought that was better
05:32  e36freak: sneakers_: that way, if you cancel, it exits. otherwise it just goes on...
05:32  sneakers_: e36freak, so if a user makes a $choice then the program exits?
05:33  e36freak: no, it's the opposite. the ! inverts the return code, as i've said...
05:33  e36freak: !guide > sneakers_
05:33  greybot: sneakers_: http://mywiki.wooledge.org/BashGuide
05:33  e36freak: do some reading
05:36  sneakers_: e36freak, Okay I have made the changes.  When I click Cancel the terminal disappears.  Good.  When I make a $choice and click OK it returns to the terminal with the word canceled
05:36  e36freak: bah
05:37  sneakers_: http://pastebin.com/ddq6ZFJT
05:37  e36freak: all of your "\"ing is killing me
05:37  e36freak: sneakers_: you're missing a ! ...
05:37  e36freak: and a \"
05:39  e36freak: http://pastebin.com/ueXfRQrF
05:39  sneakers_: ok i will check
05:39  e36freak: -_-
05:39 * e36freak is about to give up
05:39  sneakers_: which line is the missing \"
05:39  e36freak: very end of last one
05:39  sneakers_: oh i see it
05:40  stealthc: hi
05:40  nutron: where can I get some sed help?
05:40  e36freak: !sed
05:40  greybot: sed is a Stream Editor, used to filter output. It's NOT primarily useful for editing files (use ed or perl instead). Ask sed questions in ##sed.
05:41  sneakers_: e36freak, You are awesome thank yoU!
05:41  stealthc: can anybody help me, need to search blkid output to get uuid of a specifically labelled drive
05:42  stealthc: grep is confusing
05:42  stealthc: I need to search for: LABEL="SubWeb" UUID="
05:42  e36freak: grep 'LABEL="SubWeb" UUID="' file ...
05:43  stealthc: ok but what part of that am I specifying it to grab the next 9 characters after that?
05:43  stealthc: there's something I think I am missing understanding grep
05:43  e36freak: that will grab the whole line
05:43  e36freak: you want sed or awk for that
05:44  e36freak: is what you want to grab the UUID? in quotes?
05:44  stealthc: I want the uuid of that drive, so that I can use it to figure out the mount point
05:45  e36freak: sed -n 's/LABEL="SubWeb" UUID="\([^"]*\)"/\1/p'
05:45  e36freak: i have no idea what the input looks like, so i'm just guessing
05:46  stealthc: what would I do pipe it?
05:46  stealthc: sudo blkid | sed -n 's/LABEL="SubWeb" UUID="\([^"]*\)"/\1/p
05:46  stealthc: like that?
05:46  e36freak: sure, try that
05:47  stealthc: when I put that into my terminal
05:47  stealthc: it goes to the next line and displays >
05:47  e36freak: missing a ' probably
05:47  e36freak: yeah, at the end
05:48  stealthc: response is:
05:48  stealthc: /dev/sdc1: 6122-0956 TYPE="vfat"
05:48  stealthc: can I filter that result for xxxx-xxxx format number in a pipe?
05:48  e36freak: i don't know what the output looks like
05:49  stealthc: it is random I'm designing this for multiple linux os's
05:49  stealthc: it changes with each client
05:49  e36freak: put what you want parsed, and the result you want, on a pastebin
05:49  stealthc: all I wanna do is grab the 9 characters after that match
05:50  stealthc: doesn't matter what the output is, when it finds that line, it'll get the following 9 characters and that's the uuid I'm trying to get
05:50  e36freak: for that label?
05:51  e36freak: always that label?
05:51  stealthc: yes always for that label
05:51  stealthc: it is a thumbdrive and I need my scripts to point to that device
05:51  e36freak: sed -n '/"SubWeb"/s/.*UUID="\([^"]*\).*/\1/p'
05:51  e36freak: try that
05:52  e36freak: is missing a "
05:52  e36freak: blkid | sed -n '/"SubWeb"/s/.*UUID="\([^"]*\)".*/\1/p'
05:53  e36freak: doesn't blkid have an option to convert from label to ID or something?
05:53  stealthc: I have no idea
05:53  e36freak: check the help/man page
05:54  e36freak: but that sed command should work
05:56  stealthc: yeah it isn't working... think I could try something else here
06:10  chron_: i'm trying to grep for the last instance of 'foo' and get the line right after
06:10  \malex\: i wonder if people come here asking about bash.org
06:10  yitz_: tac file | grep -B1 -m1
06:10  yitz_: \malex\: Once in a while. Not often
06:13  chron_: that doesn't work
06:13  chron_: unless i head -n 1 it or something
06:14  yitz_: Yeah. That works
06:14  yitz_: Or: grep -A1 file | tail -n1
06:14  yitz_: Not sure if either is faster than the other
06:15  yitz_: tac may also require reading the entire file
06:15  steve___: awk '/foo/{getline;print}' file
06:15  steve___: chron_: if you don't mind using awk
06:16  steve___: oh wait..  last instance
06:16  steve___: ZZzz
06:16  chron_: lol yitz i actually tried your last solution there and it didn't work for some reason the first time, now it works, thx
06:17  yitz_: awk '/foo/{getline;v=$0}END{print v}'
06:18  e36freak: sed -n '/foo/{n;p;}'
06:18  e36freak: printf "%s\n" "foo" "bar" "baz" >foo; sed -n '/foo/{n;p;}' foo
06:18  e36freak: # printf "%s\n" "foo" "bar" "baz" >foo; sed -n '/foo/{n;p;}' foo
06:19  evalbot: e36freak: bar
06:19  chron_: how about everything after?
06:19  yitz_: That's not a "last instance" solution
06:19  chron_: every line after "foo"
06:19  chron_: yea i need a solution like that as well
06:20  e36freak: sed '0,/foo/d'
06:20  e36freak: # printf "%s\n" "foo" "bar" "baz" "blah" >foo; sed '0,/bar/d' foo
06:20  evalbot: e36freak: baz
06:20  evalbot: e36freak: blah
06:21  chron_: how do you notate that if it's a variable and not a file?
06:21  e36freak: "0,/$var/d"
06:21  chron_: tjx
06:21  chron_: thx*
06:21  e36freak: wait, sed'ing the var, or searching for a var?
06:21  e36freak: that searches for a var
06:22 --- Guest47235 is now known as pragma_
06:22  e36freak: sed '0,/bar/d' <<<"$var" searches for bar _in_ the var
06:23  chron_: i want to search for $bar in the $var
06:23  e36freak: haha
06:23  e36freak: # foo=$'this\nis\nhow\nit\nworks'; bar='how'; sed "0,/$bar/d" <<<"$foo"
06:23  evalbot: e36freak: it
06:24  evalbot: e36freak: works
06:25  chron_: it's saying "sed: -e expression #1, char 14: extra characters after command"
06:25  chron_: i think it's because it contains some charactesr like "/"
06:25  e36freak: !exact
06:25  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
06:25  e36freak: oh, then use a different delimiter
06:25  e36freak: i'm partial to pipes
06:25  e36freak: sed "0,|$bar|d"
06:25  chron_: error again
06:25  chron_: is there a better delimiter?
06:26  e36freak: whatever you want
06:26  chron_: ah i see now, thx
06:26  e36freak: "0,:$bar:d" "0, $bar d" "0,!$bar!d"
06:27  feydrm: Lol
06:27  chron_: now it says
06:27  chron_: sed: -e expression #1, char3: unexpected `,'
06:27  chron_: char 3*
06:27  e36freak: did you try to use commas?
06:28  e36freak: that would be one i'd stay away from, for escaping purposes
06:28  feydrm: blkid -t LABEL="SubWeb" -o list | grep SubWeb | awk '{print $2}'
06:28  feydrm: ^ returns only uuid...no quotes
06:28  e36freak: noice
06:28  feydrm: print $5 even
06:29 * e36freak hugs sed
06:30  steve___: you can have awk do the search with  blkid -t LABEL="SubWeb" -o list | awk /SubWeb/ '{print $2}'
06:30  e36freak: indeed
06:30  e36freak: never a need for more than one of the three in the same pipe
06:30  feydrm: yea I am still nebbish enough to forget that
06:30  feydrm: on iPad right now too soo...bad typing
06:31  feydrm: is that guy even still in here?
06:31  e36freak: aye
06:31  chron_: # lol="something something rofl/dude blah" ; output="rofl/dude" ; sed "0,:$output:d" <<< "$lol
06:31  evalbot: chron_: Missing terminating quote, bracket or keyword
06:32  chron_: # lol="something something rofl/dude blah" ; output="rofl/dude" ; sed "0,:$output:d" <<< "$lol"
06:32  evalbot: chron_: sed: -e expression #1, char 3: unexpected `,'
06:32  chron_: what swrong?
06:32  e36freak: hmm
06:35  chron_: and to make sure, that sed command gets all lines after grepping for $output, right?
06:36  e36freak: should, but this is confusing me
06:36  e36freak: sec
06:38  e36freak: looks like it has to be a / for this, which makes things complicated
06:39  chron_: so maybe sed so it adds "\" efore all "/" ?
06:39  chron_: before*
06:39  e36freak: tried, still playing with it
06:40  e36freak: probably better off using awk, my awk-fu is weak though
06:40  e36freak: try asking in ##awk
06:42  chron_: :(
06:42  chron_: does anyone else know why this won't work? :
06:42  e36freak: wait
06:42  e36freak: i might have this
06:43  e36freak: hah
06:44  e36freak: sed '0,/'"${output////\/}"'/d'
06:44  chron_: lolz
06:45  prince_jammys: you can also put a '\' before the first : in the other one
06:45  e36freak: # output="foo/bar"; sed '0,/'"${output////\/}"'/d' <<<$'something \n something \nfoo/bar \ndark \nside'
06:45  evalbot: e36freak: dark
06:45  evalbot: e36freak: side
06:45  e36freak: prince_jammys: ahh, it's that easy?
06:45  e36freak: hahaha
06:45  e36freak: so it is
06:46  e36freak: sed "0,\:$output:d"
06:46  TheBonsai: y0
06:46  TheBonsai: tired
06:46  TheBonsai: chat-lag :)
06:46  e36freak: mornin'
06:46  e36freak: almost time to sleep here
06:47  prince_jammys: yeah, unlike 's/foo/bar', you have to do a little extra to tell sed to use a different delimiter
06:47  TheBonsai: almost time to work here ;)
06:47  e36freak: prince_jammys: my other solution was uh... elegant though?
06:47  prince_jammys: very
06:47  e36freak: haha
06:49  e36freak: i look at it this way: since all /'s are escaped in that one, no character will break it"
06:58  stealthc: ahhh ok got it somewhat working but when I try to assign this line to a variable, it doesn't work
06:58  stealthc: blkid -t LABEL="SubWeb" -o list | grep SubWeb | awk '{print $4}' | sed 's/\/SubWeb//g'
06:59  prince_jammys: blkid foo | awk '/SubWeb/{ gsub(/\/SubWeb/, "", $4); print $4}'
07:01  e36freak: WHOA
07:01  e36freak: all 3 in one pipeline
07:01  prince_jammys: once awk is involved, you hardly ever need a grep or sed
07:02  stealthc: the var is foo?
07:02  prince_jammys: the foo are the other args of your command
07:03  feydrm: you said you need this to work on different platforms though yes? In ubuntu 10.10 (util-ng-linux-ng 2.17.2) the uuid is in field 5 not 4, so this may not be very portable
07:03  e36freak: sed! worked great on my test case
07:04  stealthc: not working
07:04  e36freak: sed '/SubWeb/s/.*UUID="\([^"]*\)".*/\1/'
07:04  feydrm: ^-ng^
07:04  e36freak: don't see why that wouldn't work
07:05  stealthc: lol the line I pasted works, but it won't slot things into a variable :(
07:06  e36freak: ?
07:06  e36freak: !$(
07:06  greybot: Command Substitution: The $(foo bar) causes the command 'foo' to be executed with the argument 'bar' and $(..) will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
07:07  e36freak: var=$(blkid ....)
07:07 --- K3rmit is now known as Agreenfrog_sleep
07:08  SiegeX: !function
07:08  greybot: To define: funcname() { your code here; } ## To use: funcname arg1 arg2 ... ## function http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
07:11  prince_jammys: /sbin/blkid -t LABEL="SubWeb" -s UUID -o value # in my system
07:12  e36freak: prince_jammys: i figured the output didn't even need to be parsed
07:12  prince_jammys: me too :)
07:12  prince_jammys: ps style, rtfm
07:12  e36freak: haha
07:13  SiegeX: is the keyword function deprecated in favor of fname() ?
07:13  e36freak: yes
07:13  prince_jammys: ps | awk blah|sed what|grep blahblah
07:13  SiegeX: because function is not POSIX, yes?
07:13  e36freak: prince_jammys: i see that so much, it's really sad
07:13  e36freak: SiegeX: correct
07:13  prince_jammys: function just makes it less portable, and you gain nothing
07:13  e36freak: and it's uglier :)
07:14  SiegeX: why the need for the () in fname(){ ... } though
07:15  yitz_: It's part of the syntax
07:15  e36freak: how else would it know?
07:15  SiegeX: is there a legal statement that does not define a function name
07:15  e36freak: that's borrowed from C
07:15  SiegeX: i'm just curious
07:15  SiegeX: if fname{ ... } is sufficient
07:15  e36freak: "function fname {" and "fname() {" are both valid
07:15  SiegeX: : { ... } is the only thing I can think of
07:15  prince_jammys: the { } aren't mandatory either
07:15  e36freak: { ... } is more more than just functions though
07:15  e36freak: !{
07:15  greybot: range and choice notation: {a,b,c}1 and {a..c}1 both expand to a1 b1 c1, {a..c}{1..3} expands to a1 a2 a3 b1 b2 b3 c1 c2 c3
07:16  prince_jammys: any compound command will do
07:16  e36freak: bah
07:16  SiegeX: prince_jammys: example without { }
07:16  prince_jammys: # fun() [[ $1 = hello ]]; fun hello && echo Hi
07:16  evalbot: prince_jammys: Hi
07:16  SiegeX: i see. thanks
07:16  prince_jammys: # fun() for arg; do printf '%s ' "$arg"; done; fun fooo bar
07:16  evalbot: prince_jammys: fooo bar
07:17 * e36freak prefers to use {...} anyway
07:17  prince_jammys: # fun() while read; do echo "$REPLY"; done < "$1"; fun /etc/passwd
07:17  evalbot: prince_jammys: root:x:0:0:root:/root:/bin/bash
07:17  prince_jammys: well, nobody does that
07:17  prince_jammys: nobody:nobody
07:18  prince_jammys: cool thing is "$1" is expanded when invoked
07:18  prince_jammys: fun() ( this ALWAYS runs in a subshell; )
07:19  e36freak: that one makes sense
07:19  e36freak: i still end up using fun() { ( foo bar ) } though (on multiple lines)
07:19  feydrm: bah prince that is what I was trying to do...missed the little -s
07:20  prince_jammys: uuids=( $(....) )  # you can end up with more than one
07:20  prince_jammys: wordsplitting not an issue if you produce the right output
07:20  e36freak: indeed
07:22  stealthc: ok the "print" command in awk only displays the result on the screen
07:22  stealthc: I need it dumped into a variable for my script to use
07:22  e36freak: !$( > stealthc
07:22  greybot: stealthc: Command Substitution: The $(foo bar) causes the command 'foo' to be executed with the argument 'bar' and $(..) will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
07:22  e36freak: read please
07:23  prince_jammys: fun() { blah; } >&2  # i've used this
07:23 * prince_jammys wonders if you can pipe
07:23  feydrm: stealthc: But also prince_jammys got the command down properly so you don't need awk
07:25  prince_jammys: stealthc: any time you're contorting yourself to read output, see if the command supports options that produce what you want.
07:26  prince_jammys: my version of blkid does
07:27  stealthc: hmmm I changed what I want because I noticed I can yank the mount folder; I was going to do it by uuid but honestly I don't expect the volume name will change
07:27  stealthc: here tell you what I'll pastebin what I got
07:28 * e36freak expects someone to write it in 1 line
07:28  feydrm: lol
07:29  stealthc: http://pastebin.com/1gzdMiTP
07:30  stealthc: lol nope... I need to change this script to put the mount folder where it is pointing to the vdi file
07:30  e36freak: whoa with the caps on "Function"
07:30  e36freak: bash is not basic, and is case sensitive
07:30  stealthc: lol is that bad I've been doing C coding alot
07:30  e36freak: and functions are not called with func()
07:31  prince_jammys:  -s tag For each (specified) device, show only the tags that match  tag.
07:31  prince_jammys:               It  is  possible  to  specify multiple -s options.
07:32  prince_jammys: as in, '-s uuid -o value'
07:32  stealthc: what am I calling them with?  The examples of "shell script function linux" in google pulls that crap up
07:32 --- pgas` is now known as pgas
07:32  prince_jammys: functions work almost exactly like normal commands
07:32  e36freak: !crap
07:32  greybot: The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
07:32  e36freak: !guide > stealthc
07:32  greybot: stealthc: http://mywiki.wooledge.org/BashGuide
07:32  prince_jammys: you invoke them as you would any other command
07:33  e36freak: stealthc: never read another guide than the one i just linked
07:33  stealthc: http://pastebin.com/1bjBaSfj
07:34 * prince_jammys busts out the teargas
07:34  e36freak: declare with "func() {", not "function func {"
07:34  prince_jammys: foo=bar <-- this simply assigns the string 'bar' to 'foo'
07:34  e36freak: no need for the word function at all
07:35  e36freak: that too
07:35  stealthc: yes the line at the top refuses to assign to a variable
07:35  stealthc: it works, but prints the output out
07:36  e36freak: !( > again!!!
07:36  greybot: again!!!: Commands ran inside parenthesis are executed in a subshell. Useful for cd'ing into a directory without needing to figure out how to back out.
07:36  e36freak: ahh
07:36  e36freak: !$(
07:36  greybot: Command Substitution: The $(foo bar) causes the command 'foo' to be executed with the argument 'bar' and $(..) will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
07:36  e36freak: var=$(command or function and args)
07:37  feydrm: g'night mentlegen - I will never awk or sed a grep again, I promise :D
07:39  stealthc: test.sh: 2: /media: Permission denied
07:39  stealthc: prints the right output "/media" dunno why it returns permission denied
07:39  stealthc: wtf
07:39  yitz_: What's the line it's trying to execute?
07:40  pgas: !cr > stealthc
07:40  greybot: stealthc: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
07:40  stealthc: ahhh got it
07:40  stealthc: :) ty
07:40  pgas: hmm though not sure it should result in permission denied
07:40 --- bruenig_ is now known as bruenig
07:40  prince_jammys: how did CRs make their way into this?
07:41  e36freak: no idea
07:41  pgas: it's probably not that :D
07:42  e36freak: http://pastebin.com/NneqsvSJ perhaps a bit closer
--- Log closed Tue Jan 11 08:15:55 2011
--- Log opened Tue Jan 11 08:16:04 2011
08:16 --- Users 532 nicks [0 ops, 0 halfops, 0 voices, 532 normal]
08:17 --- Channel #bash was synced in 90 seconds
09:18 --- abstract3d is now known as tzorvas
09:49 --- wtfness is now known as nixness
09:52  Kartagis: when checking if a directory is there, should I do "if [ ! -d "directory" ] mkdir directory commands fi else commands", or is "if [ ! -d "directory ] mkdir directory commands" sufficient?
09:53  krzie: depends on your goal
09:53  nDuff: the former is just plain silly, if you're putting "commands" on either side.
09:53  krzie: you might need a ;then in there somewhere tho ;]
09:53  nDuff: err, if you're putting _the same_ commands on either side
09:53  krzie: nDuff, depends if "commands" are the same
09:53  krzie: ya
09:54  nDuff: also, there's the option of using mkdir -p unconditionally
09:54  Kartagis: krzee "commands" are the same
09:54  krzie: then why bother with "commands" being INSIDE the condition
09:54  nDuff: Kartagis, if ! mkdir -p directory; then echo "Directory does not exist and could not be deleted" >&2; exit 1; fi; commands
09:55  nDuff: ...if you feel it's worth that level of paranoiao
09:55  krzie: that error would leave me baffled
09:55  nDuff: erm, paranoia, even.
09:55  krzie: if it doesnt exist, surely it could not be deleted ;]
09:55  nDuff: erm
09:55  nDuff: could not be created :)
09:55  nDuff: ...and with that, I'm convinced that I need to go get some sleep :)
09:55  krzie: sry im just playin tho, i gotchya
10:07  taurgal: ps aux | grep inetd
10:07  taurgal: Oops...
10:08 * lhunath hands taurgal pgrep.
10:08 * k[t tosses taurgal a /exec
10:09  k[t: lhunath: off the record, where can i get more of "Greg's Wiki" for ed (excluding bash_hackers)
10:23  Quanta: hi, i am trying to pkill all process which contain PB0 and perl. i type: pkill -9 -u gpsn perl,PB0 and it doesnt work
10:23  Quanta: any ideas?
10:25  Anvil: Quanta : i think someone is about to send you a '!nabq'
10:25  Anvil: (morning, btw)
10:27  Quanta: is pkill not part of bash? if not, then where should i ask my question? (thanks for your worn a head)
10:28  Anvil: 'type pkill' might tell you that pkill is actually /usr/bin/pkill
10:28  Anvil: Hence, not bash.
10:28  Anvil: imho, you should read the man pkill. You may not be using a valid syntax.
10:32  lhunath: k[t: sorry?
10:33  pgas: Quanta: pkill use a regexp ie 'perl.*PBO', you might need pkill -f
10:37  k[t: nothing, just sleepylll [1:37AM]
10:37  k[t: sleepy*
10:37  daef: hi there
10:45  Quanta: pgas, thanks worked
10:48  pgas: Quanta: also avoid using -9
10:49  lixus: morning, is there a clever way to get rid of grep with bash builtins ?
10:49  lixus: if echo $VAR | grep -q \. ; then echo "contains dot" ; fi
10:50  lixus: would like to replace the above with bash builtins to not have to use grep
10:53  lhunath: if [[ $var = *.* ]]
10:53  lhunath: !varcap
10:53  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
10:53  lhunath: lixus: also, do NOT forget to quote your $expansions when you pass them to commands as arguments.
10:53  lhunath: [[ is an exception here because it is a bash keyword.  but you SHOULD have used echo "$var" | grep ..
10:58  lixus: this seems to work: if [[ "$var" = *.* ]]  ; then echo "contains dot" ; fi
10:59  twkm: the quotes are unnecessary with [[, but they don't cause a problem (on the left-hand side) either.
11:01  lixus: ok, thanks guys!
11:24  noti_42: i'd like have this part of my script accept "n, N, no, No" and "y, Y, yes, Yes" as possible answers.   http://fpaste.org/50Qc/
11:24  noti_42: from my reading i "think" i need to do "n|N|no|No" but i'm not certain
11:25  pgas: case $ans in [nN]|[nN]o) blah;;esac
11:26  noti_42: ah that makes sense.  ty pgas :)
11:26  mohan: Is it possible to run a command and show it output  when I open a new tab in gnome-terminal
11:30  noti_42: you can have your command edit your MOTD file mohan.  that would work?
11:31  pgas: you can put commands in your .bashrc
11:31  mohan: Its not for remote login motd, which I can do by tcpwrappers
11:32  mohan: Its for local box, just wanted to display a message whenever I open a new tab or new gnome-terminal
11:33  mohan: $files=(/usr/share/cowsay/*);cowsay -f $(printf "%s\n" "${files[RANDOM % ${#files}]}") "$(fortune)"
11:34  pgas: put that in your .bashrc
11:35  geirha: What's with the $(printf ...)?
11:35  hemzs_dba: hi any one know shell scripting hav a query a lil bit urgg
11:36  geirha: files=(/usr/share/cowsay/*) n=${#files[@]}; cowsay -f "${files[RANDOM%n]}" "$(fortune)"
11:36  geirha: !question
11:36  greybot: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
11:36  geirha: !ask
11:36  greybot: If you have a question, please just ask it. Don't look for topic experts. Don't ask to ask. Don't PM! Don't ask if people are awake, or in the mood to help. Just ask the question straight out, and be patient waiting for an answer. http://wooledge.org/mywiki/NetEtiquette
11:37  hemzs_dba: i hav two appl servers each r connected to a db one acts has active n other as standby
11:37  hemzs_dba: eac db server is connected to corresponding appl server
11:39  hemzs_dba: we hav a load balancer which shifts the appl server to the standby appl server wen the active servr fails but db server doesnot shift.so,i require a shell script which helps the active db server to shift to stdby server by checking the status of
11:39  mohan: pgas: That works really cool. thanks.
11:40  pgas: do you have a problem with your keyboard? can't you type whole words?
11:40  hemzs_dba: appl server and i hav the parameters how to know the appl server is up r down
11:40  hemzs_dba: dont know
11:41  geirha: hemzs_dba: I'm barely following you. So what's the bash issue?
11:43  lhunath: hemzs_dba: stop leaving out vowels.
11:43  hemzs_dba: now i just want a script tat has to b run as a bg process watching the status of appl server and tat switches to standby db and acts as primary.the switch over process of db is done by data broker
11:43  mohan: geirha: thanks for the correction, its more legible.
11:44  lhunath: hemzs_dba: define "down"
11:45  hemzs_dba: down means if server stops working or any failover happens
11:45  lhunath: "server stops working" us just as uselessly vague as "down"
11:45  lhunath: WHAT about the server do you NEED?
11:45  pgas: do you have a question?
11:46  lhunath: do you need a webserver that runs on it?  a mail server?  a database server?  what?
11:47  hemzs_dba: i need a script tat has to be run in background
11:47  lhunath: jesus.  /me gives up.
11:47  lhunath: next time you want help, answer the questions.
11:48  hemzs_dba: which questions
12:11  geirha: hemzs_dba: Have you written a script that "watches the status of your appl server and tat switches to standy db and acts as primary." ?
12:11  geirha: We help with scripting here, not how to administer your application servers.
12:12  hemzs_dba: ok
12:12  hemzs_dba: yaa but i just want to know the script how it can be implemented
12:14  geirha: Sounds like you want to run some command once in a while, and run some other commands if it returns false.
12:14  geirha: if ! command_that_checks_status; then command_that_switches_db_server; fi
12:18 --- Unknown[OFF] is now known as Unknown[NF]
12:22  hemzs_dba: yaa u r ryt
12:23  hemzs_dba: is it possible to write a script in tat manner
12:23  pgas: yes it is
12:24  hemzs_dba: can u helpe i dont know scripting
12:25  pgas: probably not, it would be too painful to extract the information I would need from you
12:26  hemzs_dba: ok tell me ur mail id i"ll mail u the scenario n my requirements
12:26  strull: hehe
12:27  lhunath: hemzs_dba: if you want to hire somebody to do your work for you, there are plenty of websites where programmers offer their services for hire.
12:28  strull: they even may accept your crude language
12:28  lhunath: hemzs_dba: #bash is not one.  either ask a bash question or go read this:
12:28  lhunath: !guide
12:28  greybot: http://mywiki.wooledge.org/BashGuide
12:35  jorn: maybe a bit offtopic but is anyone perhaps aware of an option of wget telling it not to reuse a connection when getting multiple files (e.g. -r)?
12:37  twkm: #wget
12:37  jorn: twkm: tried, but that channel is quite dead
12:37  twkm: oh well.
12:44  cthuluh: man wget /connection
12:57 --- Cain` is now known as Cain
13:02  jayeola: what is the best method to catch a sting the nth line after a string that is found?
13:04  Anvil: dunno the *best* method. *One* could be grep -A N string|tail -1
13:04  Anvil: "something like that".
13:08  pgas: awk -v n=5 '/bal/{i=n}' !n--}'
13:08  pgas: awk -v n=5 '/bal/{i=n}' !i--}'
13:09  jayeola: thanks! i think that i am goign to come up with someting workable witin the next couple of mins or so
13:12  tktiddle: How can I set a string as a bash variable?
13:12  crimeboy: s="string"
13:13  pgas: !faq indirect
13:13  greybot: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
13:13  tktiddle: thanks!
13:21  bashelina: i want to keep values from last script run.. and use them on the next run... how to ???
13:22  pgas: values ...you mean the variable set in the script?
13:22  bashelina: well the user supplies values ... and then i want to show them on the next run
13:22  pgas: !faq change dir > bashelina
13:22  greybot: bashelina: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
13:24  erUSUL: bashelina: writte them to a file; read the file back if it exist in the next run.
13:24  bashelina: i just wanna supply the last values used
13:25  bashelina: yea i fugured
13:25  bashelina: figured
13:25  bashelina: cause all variables are nulled every time a script ends right ??
13:26  pgas: Right, see the faq
13:35  tty1: how would i go about checking to see if a particular command (like ls or iptables or whatever) exists on the system? i suppose i could parse which, but i suspect there is a better way?
13:36  pgas: !faq command
13:36  greybot: http://mywiki.wooledge.org/BashFAQ/002 -- How can I store the return value/output of a command in a variable?
13:37  pgas: !faq path
13:37  greybot: http://mywiki.wooledge.org/BashFAQ/081 -- How can I determine whether a command exists anywhere in my PATH?
13:37  pgas: tty1: the second one
13:37  tty1: thanks
13:42  tty1: hmm, i have a script that sets and exports certain variables, and yet the script which calls it, after calling it, does not have access to those variables (they arent set)... what might i be doing wrong?
13:44  pgas: !faq change dir > tty1
13:44  greybot: tty1: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
13:45  pgas: a child script cannot affect its parent. export changes only the environment of the process you start from the shell where you run it, it's not global
13:46  tty1: pgas, i see that now, i actually designed my script hoping that would be the case (but thought it was not).. so im glad thats how it goes!
13:47  tty1: pgas, now except for the faqct that i cant figure out how to properly parse the scripts arguments im good :)
13:47  pgas: !faq easily
13:47  greybot: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
13:47  tty1: pgas, no thats the easy part, lol
13:48  pgas: ah
13:48  tty1: pgas, the problem is preserving the quoptes correctly (i know to use $@ instead of $* to do that, but the problem is that i want to split the arguments into two varibles, by processing one argument at a time, and when i do it an argument at a time i cant figure out how to preserve the proper quotes)
13:49  tty1: pgas, i use a lot of sec, and just traversing in a loop to process each argument and add it to the screen.. works fine except quotes seem to be lost int eh process producing more arguments then i started with
13:49  pgas: you want $1 for somethign and to pass the rest of the arguments?
13:50  selckin: show some sample code + cmd line imo
13:50  tty1: pgas, no thats just shift.. basically i hav a command format like this... cmd <a bunch of different args> -- <a bunch of different args> SOME_WORD <a bunch of different args> -- <a bunch of different args>
13:50  nicofs: How do i append something to a file? (i have 'echo "string" > file'. now i want to add another line...)
13:50  tty1: pgas, so i am trying to split that into 5 groups and repass them to two seperate scripts
13:51  tty1: nicofs, >>
13:51  pgas: use an array
13:51  nicofs: thanks...
13:52  pgas: newarray+=( blah $1)  newarray+=( blahblah  "$2") ;foo "${newarray[@]}"
13:52  pgas: err "$1"
13:52  tty1: pgas, let me give that a try, thanks
13:52  tty1: pgas, its confusing enough as it is with all the dereferencing i need to do with eval :( :)
13:53  pgas: eval ugh
13:54  tty1: pgas, without eval things would be either impossible, or atleast MUCH more code than it needs to be
13:55  T-Co: How would I go about doing something like: hash,file=$(md5sum file)?
13:55  tty1: isnt it something like hash=file=... ?
13:55  tty1: i could be wrong
13:55  tty1: probably am
13:56  Anvil: read hash file <(md5sum file)
13:57  tktiddle: How do I use read to print out the first two words in a line of text?
13:57  T-Co: Anvil, Doesn't seem to work...
13:57  pgas: tty1: as you want, you just need to be aware that eval makes code injection easy
13:58  pgas: read hash file < <(md5sum file)
13:58  T-Co: That's it, thanks alot!
13:58  Anvil: 'course it doesnt. I'm just stupid.
13:58  T-Co: :)
13:58  tty1: pgas, yea im aware of that, but i just cant see an alternative, aside from turning my wrapper into a full blown program that is acctually aware of every single argument the wrapped executable can take
13:58  pgas: T-Co: read one two _ <file ;echo "$one" "$two"
13:59  T-Co: pgas, Gotcha
13:59  tty1: pgas, besides, the script is meant to be run as the current user anyway. cant imagine how injecting code into the script would actually benefit the user running the script at all
14:04  lhunath: tty1: malevolent users are the least of your worries.
14:05  tty1: lhunath, oh?
14:06  lhunath: tty1: you wouldn't be the first to end up with an empty homedir as a side effect of unintended arbitrary code execution.
14:06  tty1: lhunath, that comment sounds like it should have scary music playing int he background as i read it (the previosu one)
14:06  lhunath: tty1: yeah, they don't let you attach flash files to irc messages yet.
14:07  tty1: lhunath, im only using it to set certain varibles whos name needs to be figured out dynamically
14:07  lhunath: tty1: mind explaining what you're doing?  I'm too lazy to read the conversation.
14:08  lhunath: preferably in clear and unambiguous language.
14:08  tktiddle: Hi, how can i print out the first two words in a line of text using read?
14:09  lhunath: read doesn't print input.
14:09  tty1: lhunath, simple, i have a rather large collection of interrelated scripts which form a wrapper around git. the first step int he main script is to call parse-args script... what that script does is it goes through all the command line arguments and parses them without knowing what they are and only a bit of information about their format. so if you set "--something=somethingelse" for example then the varible gitm_arg_something will be set to "Some
14:09  tty1: thingelse"
14:09  lhunath: read word1 word2 _; echo "$word1 $word2"
14:09  lhunath: read -a words; echo "${words[@]:0:2}"
14:09  tty1: lhunath, this way the future parts of the script, can find out which argments were set to be passed to git itself so it can act on it
14:10  lhunath: sounds pointless.
14:11  lhunath: and broken, obviously
14:11  lhunath: what are you doing that for?
14:12  lhunath: and how is it related to git?  are these git arguments?  or are they arguments that your script uses for something?
14:12  tty1: lhunath, well the point is that i add my own arguments on top of the ones git gets, however the command should be compatable with git (such that "git ..." and "gitm ..." do the same thing when gitm specific arguemnts arent specified.. so it needs to parse which arguments are gitm specific and which arent, and be able to parse the ones which are not so cusom modules added to the script collection can make decisions based on it if they want without
14:12  tty1: needing to reparse the whole thing every time
14:13  lhunath: and why are you re-inventing associative arrays?
14:14  lhunath: when you write C code, do you create C variables off of data from other C variables?  no.  why do it in bash?
14:14  tty1: lhunath, let me give an example you might do ... gitm --some-git-arg -- --some-gitm-arg commit --some-other-git-arg -- some-other-gitm-arg ... eventually this will pass to git as: git --some-git-arg commit --some-other-git-arg .. however before the script does that it may want to do something special based on either a git or gitm arg.. what it does and how is pluggable (people can add their own scripts to add features) so i cant already be aware o
14:14  tty1: f all the possible git arguments.. so i use eval to parse it all without staticallyd defined variable names
14:15  tty1: lhunath, that may be due more to a lack of understanding associative arrays existed in bash in the first place :)
14:16  lhunath: additionally, might I point out that you are on an insanely slippery slope as far as argument conflicts is concerned
14:17  lhunath: do you know all the arguments that all the git commands take?  what about the ones that future git versions will add?
14:17  tty1: lhunath, well i gave that consideration, as long as one termiantes witha  -- when it is ambiguous it shoudl work find.. like gitm --some-git-arg -- commit --some-other-git-arg --
14:17  lhunath: how about you make life simple for yourself.
14:18  tty1: lhunath, the fact that i dont know all the git arguments git can take is why im doing it this way int eh first place
14:18  lhunath: gitm [gitm-args] -- [git args]
14:19  lhunath: so parse arguments up to the first --, consider those as gitm args, never git args.  beyond the first --, pass everythig to git, don't try to gitm parse em.
14:19  tty1: lhunath, i specifically wanted to make gitm backwards compatible with git (in the majority of cases atleast) to make the process easier for the user.. whent hey switch between gitm and git having to change the argument layout all the time will cause a lot of typos and frustration i suspect
14:19  tty1: lhunath, the git arguemnts need to be parsed regardless as the script stilld oes things with them
14:20  lhunath: you expect people to switch to gitm which isn't git, and pass arguments as though it were a program that it's not, and also expect that to be LESS painful than actually being honest to your users?
14:20  tty1: lhunath, ig the git arguments themselves could be entirely ignored my job would hav ebeen much easier :)
14:20  lhunath: shrug
14:20  tty1: lhunath, well i dont expect them to switch to gitm entirely, only to use it for certain special commands that git alone doesnt support
14:21  lhunath: good.  then stop pretending gitm is the same as git.  it ain't.
14:21  tty1: the work flow, i suspect, would involve using git for 95% of calls and gitm for the other 5%
14:21  tty1: lhunath, ::nod:: its a good argument
14:21  lhunath: and since it isn't, it's fine that it takes a different argument layout
14:22  lhunath: anyhow, the choice is between "transparent compatibility" which imo will lead to confusion and conflicts, and being explicit, which will require them to read a paragraph of man doc before using gitm.
14:22  tty1: lhunath, that would certainly be a much easier approach, but sorta defeats the purpose of the program (in order to add enhanced features to git via scripts)... another words, to be able to add additional arguments/features to the git command with simple custom scripts a user could write
14:23  lhunath: you're not adding anything to the git command.
14:24  lhunath: you're creating a gitm command
14:24  lhunath: unless you're alias'ing gitm to git in which case I need to do some more lecturing.
14:25  tty1: lhunath, well thats only to get around the need for a patched/custom/hacked version of git.. i figure itf it does the pass through right it could be very much the same as how i described while still using a regular git binary install
14:25  tty1: lhunath, if a user wishes to alias gitm to git its up to them, but no i am not doing that as the default
14:26  lhunath: I still fail to see what advantages you have to making a new command, that is not 'git', and jumping through ugly hoops purely for the purpose of emulating another command's argument layout, even if in reality, the parsing happens differently and more arguments are available.
14:26  lhunath: enumerate the advantages?
14:27  lhunath: those that are not fulfilled by having a gitm [gitm-args] -- [git args] -type of layout.
14:29  tty1: lhunath, because if i go the approach you said ill still need to duplicate every single git argument in my parsing, and be able to pass them through to the git command (sometimes even removing or changingt the arguments that wind up passing to git int he first place)
14:29  tty1: lhunath, point is, changing the layout of the arguments to something custom doesnt really solve anything, i still need to parse and handle the git args the same way anyway
14:30  tty1: so why not use an arg layout that is backwards compatible to git int he process
14:30  lhunath: anyhow, you can parse that layout with a while loop.  while (( $# )); do [[ $1 = -- ]] || gitmArgs+=("$1"); shift; done; while (( $# )); do gitArgs+=("$1"); shift; done
14:30  tty1: lhunath, right, thats how im doing it now just using arrays instead of a strings, which i agree is certainly better
14:31  lhunath: you haven't enumerated any advantages.
14:31  lhunath: other than "compatible with git".
14:31  lhunath: which is irrelevant, because mine is too.  after the --.
14:32  lhunath: and yes, you're wrong, you do NOT need any "duplication" of arguments or whatever you mean.
14:32  lhunath: you do not need to know what gitm args are supported before parsing.
14:32  lhunath: you cannot have any conflicts between git and gitm args.
14:33  lhunath: and your parsing code is significantly more transparent.  one loop for gitm, one loop for git.
14:33  tty1: i cant see any disadvantages either (atleast none that are solved with the new layout)
14:33  lhunath: I just enumerated several.
14:34  lhunath: now your modules can use gitm and git args as they please without having to publish their own gitm args to you before parsing.
14:34  tty1: well most of those arent true.. basically in your example everythign before the first -- are gitm args and everthing after is git... in my example everything before the first -- is gitm args and everything after the last -- is gitm args for the module
14:34  lhunath: and your users will never be confused about "is this arg going to my gitm module or git code?"
14:34  tty1: it doesnt require any more knowledge of the git args than your way
14:34  lhunath: you didn't say that was your layout.
14:35  lhunath: you said gitm and git args were mixed arbitrarily.
14:35  tty1: lhunath, well musch like git there is a seperation between gitm args (the one before the command such as commit) and the gitm args for the module specifically
14:35  lhunath: or at least that's what I understood from your lack of specifying
14:35  tty1: ohh i said it earlier but maybe before you came and started contributing
14:35  tty1: sorry
14:36  lhunath: so my layout proposition was gitm [gitm-args] -- [git args], what's yours?
14:36  tty1: yea the format is as such .... gitm <args for git> -- <args for gitm> COMMAND <git args for module> -- <gitm args for module>
14:36  lhunath: what's COMMAND?
14:36  tty1: lhunath, things like commit, push, pull, update, the git commands basically
14:36  lhunath: and how do you know that word is a command and not a gitm arg?
14:37  tty1: lhunath, gitm args are never standalone words.. they take the form of either -<single letter> or --<some word>=<some value>
14:37  tty1: lhunath, and git args uses the same restriction in order to determine that the command is the command
14:37  lhunath: so in true GNU-hates-UNIX style, you assume that the only argument that doesn't start with a - is the command.
14:38  tty1: lhunath, so the fitst occurance of a stand alone word, that isnt preceeded by an "=" sign is the command
14:38  lhunath: you have arguments that begin with a =?
14:38  lhunath: I'll ignore that last part.
14:38  tty1: basically if its a stand-alone word, doesnt start with a - and doesnt contain an = then it is the command
14:39  lhunath: what happens when you want to pass -- to git?
14:39  lhunath: which is quite a common thing to want.
14:39  tty1: lhunath, then you do it as follows.... gitm checkout HEAD -- /file/path/to/checkout -- --some-gitm-arg
14:40  lhunath: I think you're over-complicating the definition for command.  I think it's just "the first argument that doesn't start with a dash."
14:40  lhunath: so now HEAD -- /file/path/to/checkout are <git args for module>?
14:40  tty1: lhunath, only the last occurance of -- is considered the seperator for the gitm args to start, so if git takes a -- as well then just make sure you add a -- to the end, with or without following it with gitm args (this is a pretty typical use of -- to seperate one group of arguments from another)
14:40  lhunath: oh, we're calling "checkout" a module?
14:41  tty1: lhunath, yes checkout is a git module as git checkout essentially is the same as git-checkout
14:41  lhunath: only the latter no longer exists, ok.
14:41  tty1: the git command itself just handles the git <git-args> parth.. the module itself and the arguments to it are handled byt he appropriate git-* module
14:42  tty1: lhunath, my own scripts have thew same layout.. gitm parses allt he arguments before the command word (gits and gitm) and then gitm-* is passed execution to handle the module specific side
14:43  lhunath: so the purpose is that now I can use gitm as though I was using git?
14:43  lhunath: so I could type gitm checkout foo
14:43  tty1: right
14:43  lhunath: only, that's not true, because now gitm checkout HEAD -- foo is broken.
14:44  tty1: lhunath, right it isnt entirely backwards compatible (isnt meant to be).. the similarity is intended to ease the learning process and make using the command more natural to its function
14:44  lhunath: ergo, gitm is only safe if you've got gitm-module arguments to pass.
14:44  tty1: in reality youd need to do gitm checkout HEAD -- foo --
14:44  lhunath: exactly.
14:45  lhunath: you THINK that is making it easier to learn.
14:45  lhunath: you're wrong.
14:45  lhunath: you've just confused the fuck out of all your users.
14:45  lhunath: but that's perhaps my opnion, solely.
14:46  lhunath: I think, if you've got your own command, don't pretend it isn't something else.
14:46  tty1: lhunath, but keep in mind this is a special case addressed easily enough.. git garuntees that -- will only appear as a module argument. since each module is handled seperatly it wouldnt be hard for the script to catcht he special cases and determine, intelligently, if the last -- is for gitm or not (Right now that isnt done as it isnt really that critical, but i dont see why it couldnt)
14:46  lhunath: it is*
14:47  tty1: lhunath, normally id agree with you 100% .. but the nature of this command is to add pluggable capablity, via scripts, to git.. int he future i might do this properly by actually hacking or patching git.. but for now im a bit more limited so this is an easy way to get a very similar effect
14:47  lhunath: tty1: "intelligent" is another one of those things I do NOT want my tools to be.
14:47  tty1: lhunath, very true, thats the very reason i prefer gentoo.. it doesnt try to be intelligent for you, it actually lets you decide
14:48  lhunath: usually, intelligent is a synonom for "I'm programmed with ways of dealing with several ways that you could make mistakes and fix them; but I can't catch them all, so don't rely on the fact that I'm anything near smart"
14:48  lhunath: usually, dumb intelligence only gets in your way
14:48  lhunath: example: xargs
14:48  tty1: lhunath, in reality it would be very trivial to have a gitm command that worked the way i have it work and a gitx command that behaved exactly the same way but uses yoru proposed argument layout. which is kinda cool with the whole modular design int eh firs tplace :)
14:49  lhunath: anyhow; argument layout aside, don't use eval, use associative arrays.
14:49  tty1: lhunath, yup i agree, in fact i agree with all your points int he general sense :)
14:49  jiafanz: Hi, which bash command can display the maximum allowed processes and threads?
14:50  lhunath: arg='--foo=bar'; IFS='=' read k v; gitmArgs["${k#--}"]=$v
14:50  geirha: jiafanz: ulimit
14:50  lhunath: you probably want to add -r to the read
14:50  geirha: jiafanz: ''help ulimit''
14:51  lhunath: associative arrays are a bash4 thing, though.
14:51  kneferilis: Hello, I need a regular expression to match: [4-1
14:51  kneferilis: so far I have: \d{1}-\d{1} but it is missing the bracket
14:51  lhunath: kneferilis: \[4-1
14:51  lhunath: kneferilis: also, specify the dialect.
14:51  geirha: [[ $str = *\[[0-9]-[0-9]* ]]
14:52  kneferilis: lhunath: thanks pal!
14:52  kneferilis: geirha:  thanks!
14:52  lhunath: moderately entertaining.
14:52  geirha: That's a glob though, not regex
14:52  kneferilis: lhunath:  what dialect?
14:52  kneferilis: geirha: what glob>\?
14:52  lhunath: kneferilis: you tell me.
14:53  geirha: !glob > kneferilis
14:53  greybot: kneferilis: "Glob", the common name for pattern matching, filename expansion, "wildcards", etc. http://mywiki.wooledge.org/glob
14:53  lhunath: !patterns
14:53  greybot: Globs, Braces and Regular Expressions: http://mywiki.wooledge.org/BashGuide/Patterns
14:53  jiafanz: thanks, I don't see "ulimit" display any infos related to threads though
14:53  ashadocat: I'm not sure if this is the right place for this but would anyone mind checking this out for me? http://pastebin.com/vkHNS6dT
14:53  pgas: kneferilis: there are many kinds of regular expressions
14:53  ashadocat: Not sure what my problem is
14:54  lhunath: ashadocat: don't use expr.
14:54  lhunath: !math
14:54  greybot: Add 7 to a variable: let a+=7; ((a+=7)); a=$((a+7)); See http://mywiki.wooledge.org/ArithmeticExpression
14:54  kneferilis: I see.
14:54  pgas: ashadocat: do you know what cat <file mean?
14:54  lhunath: ashadocat: < is a bash operator that means 'redirect from a file'.
14:55  ashadocat: Ohh, I forgot to escape >. now I feel like an idiot
14:55  ashadocat: thanks
14:55  lhunath: ashadocat: don't escape.  and don't use expr.
14:55  lhunath: ashadocat: if (( BLOCKS <= 10 ))
14:55  lhunath: !varcap
14:55  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
14:56  ashadocat: lhunath, I see, that seems better then "if [some expra statement]". Thanks.
14:57  lhunath: ashadocat: erase expr from your mind.
14:57  ashadocat: lhunath, thanks. this seems way better.
14:57  lhunath: ashadocat: and it isn't if [some expr statement]; it's: if COMMAND, where COMMAND could be a (( command.  the (( command takes an arithemtic expression.
14:58  ashadocat: I see. thanks, I'm a complete newb to bash scripting.
14:58  geirha: And (( is a keyword, so it's not parsed as a regular command, and thus the > doesn't get treated as redirection
14:58  lhunath: these arithmetic expressions are not expr statements, they have a syntax of their own explained in man bash
15:00  geirha: And the ArithmeticExpression page linked to earlier has some examples
15:03  zplinux: what is the correct shell syntax for a counting loop like this:
15:03  lhunath: !seq
15:03  greybot: seq(1) is a highly nonstandard external command used to count to 10 in silly Linux howtos. Use one of these instead: for x in {1..10} (bash3.x) or for ((x=1; x<=10; x++)) (bash 2.04+) or i=1; while [ $i -le 10 ]; do ...; i=$(($i+1)); done (ksh/POSIX)
15:04  zplinux: 10x
15:07  tty1: lhunath, you sue bourne shell has associative arrays? from what i can tell it had arrays with numberical indexes but not associative arrays (where the index of the array is a string)? am i missing something here?
15:08  lhunath: 14:51:00          lhunath | associative arrays are a bash4 thing, though.
15:08  lhunath: also bourne shell != bash.
15:08  geirha: You use bourne on gentoo?
15:09  lhunath: gentoo ships with bash; and I'm pretty sure it's bash4.
15:09  lhunath: use it.
15:11  ashadocat: lhunath and the rest, thanks. My script is working perfectly now. I just need to make it a bit more flexable and it's good.
15:11  michelem: hello folks
15:12  copper: hi
15:12  michelem: I long had this question and finally want to find out an answer
15:12  tty1: lhunath, ohh totally missed that, yea im doign this in bourne shell, not even bash
15:13  michelem: what is the best way to check if a program (as in binary pathname) is still running
15:13  copper: in /etc/bashrc I export TMPDIR="/tmp/$USER" - but that doesn't work properly for daemons that start as root and then drop priviledges. I get nobody with a TMPDIR=/tmp/root
15:13  copper: What's the correct way?
15:13  tty1: michelem, *.pid files IMO
15:13  michelem: FYI, what I ever used thus far was "ps ax | grep $PROG | grep -v grep"
15:14  michelem: tty1: pids suck imo, they are completely unrelated to the process being running
15:14  michelem: by "pids" i meant pidfiles, sorry.
15:14  copper: i.e. how do I get to set TMPDIR=/tmp/nobody for daemons such as Apache HTTPd etc?
15:15  tty1: michelem, depends what your doing.. they are related to figuring out if a specific process is running (a process with a particualr pid).. they arent relevant to figuring out if a particular executable is running at all, from any location or starting point
15:16  michelem: I'm at the same time relieved and appalled to see there is no blatant answer to this problem.
15:16  michelem: it seems so basic and fundamental
15:17  steve___: michelem: have you read:
15:17  steve___: !pm
15:17  greybot: http://mywiki.wooledge.org/ProcessManagement
15:17  lhunath: tty1: why?
15:17  michelem: tty1: here's what I don't like about pidfiles: 1) you have to find where to create them. If you do in the binary, that's not really the place conceptually, and it reduces their portability. If you do it from who runs them, you have to ensure to do it everywhere you run it from
15:17  lhunath: do you have some strange obsession with ugly and broken implementations?
15:17  tty1: lhunath, mostly to make sure its compatable with anyone who has git installed (both windows, osx and linux users).. git requires bourne shell but not bash
15:17  lhunath: bourne shell sucks.  do not use it.
15:18  lhunath: then learn perl or python or ruby.
15:18  lhunath: also, anyone who has git, has bash.
15:18  lhunath: or can install friggin bash.
15:18  tty1: lhunath, neither perl, python, or ruby, is a prerequisite of git unfortunately
15:18  michelem: steve___: I only read faq42 (not applicable here), but let me see there
15:19  lhunath: it's a prereq of gitm!
15:19  michelem: I'm a bit turning my nose for the killall solution
15:19  lhunath: why are you so afraid of depending on something?
15:19  lhunath: "think of those poor users, having to read a manual and install a dependency before being able to use my command!"
15:19  lhunath: jesus.
15:20  lhunath: michelem: "$TMPDIR/moo.pid"
15:21  lhunath: any more problems with pidfiles?
15:21  michelem: sure,
15:21  tty1: lhunath, im not, well partly cause windows users are dumb, and making more requirements that are *nix specific.. i mean i can, its not a huge deal... but i was hopping not to
15:21  michelem: 2) they are unrelated to the program being running. If the program crashes, the pidfile remains, and worse of all its PID can be taken by another program
15:23  lhunath: tty1: bourne sucks too much to have to cope with; especially when you're doing a lot of parsing.  consider the MASSIVE benefit to your pluggable module developers when you can guarantee them they can use bash code and don't have to hack around sh failures.
15:23  lhunath: tty1: also; sh code tends to be FAR MORE buggy than bash code, because sh is so limited in features that you have no choice but to use buggy code if you want to get anything more than running commands done.
15:24  lhunath: do you really want your modules in sh code?  no, you do not.
15:24  tty1: lhunath, that is a good oinnt
15:24  lhunath: michelem: fact.  pidfile are not perfect.  keep the parent alive.
15:24  michelem: yeah, it's a pity that SH is such convenient tool and it's so limited, error prone and buggy. Let alone the hell with portability
15:25  lhunath: michelem: let the parent manage the death of your program.  and if that's not possible, use a hybrid: let the parent clean up the pidfile when the program dies.
15:26  michelem: lhunath: "ps ax | grep $MYPROG | grep -v grep" is a preferable solution at that point
15:26  lhunath: foolauncher() ( foo & echo "$!" > "$TMPDIR/foo.pid"; trap 'rm "$TMPDIR/foo.pid"' EXIT; wait; )
15:26  lhunath: michelem: hahahah.
15:26  lhunath: you complain about pid files and you parse ps as an alternative.
15:27  lhunath: that is hilareous.  though more depressing now I come to think of it.
15:27  michelem: indeed. Accurate, portable, fast, simple.
15:27  lhunath: nonsense.
15:27  lhunath: neither of those is true.
15:27  lhunath: it is insanely INaccurate, it is NOT portable, it is NOT fast, and it is convoluted.
15:28  lhunath: admittedly, the trap solution is not simple either.
15:28  michelem: feel free to argument, I'm open to hear complaints
15:29  michelem: altho in my case it is accurate (MYPROG being the full command line), and since both the ps and grep calls are SINGLE compliant it is portable for what I see
15:30  michelem: and it is fast, possibly faster than writing the filesystem
15:30  lhunath: you seem to think that ps will portably show you your command line.
15:30  lhunath: additionally, what if other users start parallel executions.
15:30  michelem: actually not, $MYPROG has no args there
15:30  lhunath: even worse.
15:31  lhunath: you could easily get other unrelated processes as a match
15:31  lhunath: ps is a tool intended for interactive use
15:31  michelem: that happens if one program has as an argument that full pathname
15:31  lhunath: NEVER parse it.
15:31  lhunath: who fucking cares when it happens?  It can happen.  it will happen.  if anything, it's dead easy to abuse.
15:32  lhunath: I don't have time for this nonsense.  but luckily for you, I wrote it all down for people like you:
15:32  lhunath: !pm
15:32  greybot: http://mywiki.wooledge.org/ProcessManagement
15:33  michelem: take it easy man, people get insulted for much less
15:33  michelem: as a side note, the usual IRC argument applies here
15:34  michelem: you don't know my context, don't rant against choices if you don't know the context.
15:36  lhunath: this has nothing to do with your context, this is about parsing ps being wrong.  regardless of context.  parsing ps is always wrong.  especially in the way that you suggested it.  as for your actual problem, I have suggested the two clean and safe methods that are available to you, short of patching the program.
15:47  zplinux: !seq
15:47  greybot: seq(1) is a highly nonstandard external command used to count to 10 in silly Linux howtos. Use one of these instead: for x in {1..10} (bash3.x) or for ((x=1; x<=10; x++)) (bash 2.04+) or i=1; while [ $i -le 10 ]; do ...; i=$(($i+1)); done (ksh/POSIX)
16:08  massimo: Hi. Isn't this a useless use of echo? Can I get rid of that echo?   bc < <(echo "scale=3; 1/4")
16:08 --- Zenopus_ is now known as Zenopus
16:09  falconindy: !<<< > massimo
16:09  greybot: massimo: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
16:12  zplinux: I am trying to build a loop with a timeout to seek a word in a status file
16:13  zplinux: http://dpaste.com/306721/
16:14  zplinux: can anyone please tell me what is wrong there?
16:14  zplinux: is the while true and break not used correct?
16:15  geirha: You probably want or instead of and
16:15  falconindy: aside from not really being bash syntax, you're not breaking on success. the only break condition is the timeout
16:16  falconindy: ah, go with geirha
16:18  geirha: Continually grepping a growing file is very inefficiant btw.
16:18  zplinux: geirha - right
16:18  zplinux: is or -o ?
16:19  falconindy: its ||, since you're asking in #bash
16:19  geirha: With POSIX [, yes it is.
16:19  falconindy: -o for the syntax you're using
16:19  zplinux: how can I tell if a cleint connected to the openvpn?
16:19  zplinux: I am using sh as bash can use that as well
16:20  massimo: falconindy: Thanks.  Why is foo "100+100" and not 200?     foo="$(bc <<< \"100+100\")"
16:20  geirha: !sh
16:20  greybot: sh is the POSIX or Bourne shell, not bash. Even if sh is a symlink to bash, running a script under 'sh' (either by typing 'sh myscript' or putting '#!/bin/sh' at the top) *disables* many bash features. See http://mywiki.wooledge.org/BashGuide/Practices#Choose_Your_Shell
16:20  falconindy: massimo: because your don't want to embed those quotes
16:20  al_nz1: if you have a script and want to log the output of the script, i understand you can use ./script >log.txt - but what if you want the last line of the script to email the output, then your sending the log of something which hasnt yet finished being created?
16:20  geirha: massimo: "$(bc <<< "100+100")"
16:21  zplinux: sweet - works
16:21  massimo: geirha: Thanks.
16:22  geirha: massimo: You nest quotes like that with $(), with `` you'd have to escape like you did.
16:23  zplinux: "Continually grepping a growing file is very inefficiant btw" : is there a smarter way to find the word zahi in there?
16:23  geirha: while read -r line; do if [[ $line = *foo* ]]; then break; fi; done < <(tail -f file)
16:25  geirha: You'll read the lines as they are written. Instead of reading the whole file over and over again.
16:29  cafaro: files=(*) newest=${files[0]}     Why does * needs to be parenthesized?
16:29  cafaro: ( in http://mywiki.wooledge.org/BashFAQ/099 )
16:30  pgas: that's the syntax to create an array
16:30  tty1: is there a way to iterate through and display all the varibles currently set? I wanna do this for debugging reasons
16:30  loomsen: cafaro:  cause it's an array
16:30  geirha: var=string   array=( "element 1" "element 2" )
16:32  cafaro: Okay, and you need to wrap $() around an array index to expand it...?
16:32  geirha: No
16:32  geirha: !arrays > cafaro
16:32  greybot: cafaro: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
16:34  cafaro: ok, I get it, thanks!
16:35  kneferilis: Hello!
16:35  g4bittin: hi
16:35  kneferilis: I am at /home/myname
16:35  kneferilis: how do I do cd\ like in windows?
16:36  geirha: cd /
16:36  kneferilis: geirha: thanks!
16:37  geirha: !guide > kneferilis
16:37  greybot: kneferilis: http://mywiki.wooledge.org/BashGuide
16:38  tsolox: are the other hardlinks to a given file being recorded in the file's inode?
16:38  twkm: uh, none are recorded, not even the first.
16:38  twkm: they are counted though.
16:39  tsolox: so the only way is to use `find` to find its other hardlinks?
16:40  geirha: Well, if you just want to break it, copy the one you have found and remove it
16:42  tty1: anyone know why the env command is showing some of the varibles i set but not others? are the ones that are arrays not going to show or something?  do they actually get exported at all if they dont show? (echoing them directly causes themj to show up so i knwo their set, and i explicitly exported them before the call to env in the same scriopt)
16:42  twkm: they are not now exported.
16:43  tty1: twkm, what do you mean by "no" ?
16:44  tty1: twkm, what did you mean by now?
16:44  twkm: uh.
16:44  geirha: tty1: It's not an environment variable if you haven't exported it
16:44  twkm: at the time you ran env, of course.
16:44  tty1: geirha, but i did export it
16:45  tty1: twkm, but thats just it, i called export right before env
16:45  geirha: tty1: Maybe you did it in a subshell or something then.
16:45  twkm: *shrug*
16:45  geirha: !faq change dir > tty1
16:45  greybot: tty1: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
16:45  tty1: geirha, its not that, as im calling env from within the script
16:46  tty1: geirha, i basically do "export some_array_var; env"
16:46  geirha: You can't export arrays
16:46  tty1: basically i export all my varibles int he script then int henext line from the same script i call env (for debugging purposes) most of the varibles show except the arrays
16:46  tty1: geirha, oh no are yous erious? is there a way around that cause thats a HUGE problem for me then
16:47  lhunath: nonsense.  you just need to stop using multiple scripts.
16:47  tty1: not even sure how to elegantly solve it if thats the case
16:47  lhunath: and you need to understand that env vars are something COMPLETELY different from parameters.
16:47  tty1: ihptru, that would defeat the whole purpose of my app, which is to allow scripts to be added to a "plugin" directory
16:48  lhunath: no.  all you need to do is source them.
16:48  tty1: lhunath, well if i do it in parameters then can i return arrays with the exit command?
16:48  lhunath: you can never return arrays
16:49  lhunath: you can also not return multiple variables.
16:49  tty1: lhunath, well the script that is exporting the arrays is gettings sourced, which is how the parent script is getting most of the varible, but the arrays themselves are lost
16:49  geirha: tty1: set will display all your variables, arrays, aliases and functions (regardless of whether they're exported or not)
16:49  tty1: lhunath, are you saying there is no way to pass an array out of a child script and into the calling parents script?
16:50  tty1: geirha, displaying them seems to be the least of my worries if they dont even get exported
16:50  lhunath: tty1: there is no way to do that with normal string env vars either.
16:50  geirha: tty1: exporting wouldn't help if you need them in the parent anyway
16:50  tty1: lhunath, well them im back to square one with my whole script
16:50  lhunath: tty1: no, all you need to stop doing is forking.
16:50  tty1: geirha, well how can i get an array back to the parent?
16:51  lhunath: you cannot
16:51  fx: I wonder if anyone has had this problem: I would like to export a variable from the PS1 prompt. Because the prompt gets executed every time the variable will be fresh. i tried adding $(export b=test) but it looks like it runs out of scope
16:51  lhunath: tty1: do not leave the parent.
16:51  lhunath: and you have no issues.
16:51  tty1: lhunath, and if i source it will do that without needing na export?
16:51  lhunath: tty1: sourced code runs in the current shell.
16:51  tty1: lhunath, or are you sayinhg t all needs to be in the samme *.sh file?
16:52  e36freak: fx: you're probably looking for PROMPT_COMMAND
16:52  lhunath: tty1: you have access to all the shell's parameters and the main script's code after your sourcing has access to all the sourced script's changes.
16:52  e36freak: fx: why would you want to export a variable in PS1 anyway? what good could that do?
16:52  tty1: lhunath, but dont you still need to export to make the array move from inside the sourced script to the parent?
16:52  lhunath: there is no parent
16:53  tty1: lhunath, is source like an include?
16:53  fx: e36freak, because i would like my current git branch in a $cb variable
16:53  tty1: does it import the text directly
16:53  lhunath: and exporting is only necessary if you're putting bash parameters on the environemnt.  do not put them on the environment
16:53  geirha: tty1: sourcing a script is almost like copy/pasting each line of the script into your terminal
16:53  lhunath: tty1: yes.
16:53  lhunath: sort of
16:53  tty1: ohhhhh
16:53  tty1: ok then the how-to i read lied
16:53  tty1: thats the problem
16:53  e36freak: fx: ahh. you either need more \[ \] or PROMPT_COMMAND
16:53  lhunath: C includes are pre-processor things.  sourcing happens at runtime
16:53  geirha: http://mywiki.wooledge.org/BashFAQ/060 explains it
16:54  fx: e36freak, hold on, \[\] ?
16:54  tty1: the howto i read seemed to say you need to source, and the child needs to export, for a parent to get the vars, and exporting does not create an environment var unless the file was sourced
16:54  e36freak: !faq color > fx
16:54  greybot: fx: http://mywiki.wooledge.org/BashFAQ/037 -- How can I print text in various colors?
16:54  fx: e36freak, PROMPT_COMMAND looks promissing, but its got lots of crap in it now
16:54  geirha: !crap > tty1
16:54  greybot: tty1: The overwhelming majority of bash scripts, code, tutorials, and guides on the Internet are crap. Sturgeon was an optimist.
16:54  e36freak: fx: is explained in there
16:54  pgas: tty1: too bad you didn't read the faq we gave you 3 hours ago
16:55  lhunath: !env > tty1
16:55  greybot: tty1: There are two kinds of variables: Environment Variables (''env'') and Bash Parameters (''set''). Every process has the former; and they are inherited by its children. Bash creates a parameter for each env var it has, and with ''export'' you can "link" other bash parameters to env vars of the same name.
16:55  tty1: so does a export make the varible global such that it will be seen from all shells for the same user on the same system regardless of if you source it or run it regular?
16:55  e36freak: fx: chances are, all it has in there now is actually what PS1 expands to
16:55  lhunath: no.
16:55  lhunath: exporting just puts the value of your parameter on the environment of your bash process.
16:55  lhunath: that is ALL.  nothing more.  only just of your CURRENT bash PROCESS.
16:56  fx: e36freak, yea thats correct, but its quite a big mess in there
16:56  geirha: tty1: All the CHILDREN will see those environment variables you exported
16:56  lhunath: THEN, when your bash process runs another program (forks), the other program gets a COPY of that environment variable
16:56  fx: e36freak, maybe it could be solved by this, could i execute a command when for example echoing a variable
16:56  tty1: while i never questioned what was meant by environment before... now i am.. let me ask this.. when i run sh ,.something.sh is the same as running sh without arguments then copying and pasting the script to the terminal? cause i know when it do that its like a new instance (like i logged in fresh)
16:56  lhunath: the other program can change their env var, but it isn't going to affect your bash process' env var with the same name.
16:57  tty1: so yea that makes more sense now that i think about it
16:57  e36freak: fx: hmm? you're probably thinking too hard about this
16:57  tty1: sh && source something.sh would just be like sh something.sh wouldnt it?
16:57  lhunath: close enough
16:57  e36freak: fx: you can put it in your PS1
16:57  lhunath: just running sh will run the shell in interactive mode.  sh [file] will run it in non-interactive mode
16:58  lhunath: there are minor differences.  in the former, you'll have a prompt, for instance ;-)
16:58  tty1: e36freak, have you meen talking to me all this time? i dont see someone named fx here but i havent bene reading your messages since they seemed addressed to someone else
16:58  tty1: yea this is making more sense to me
16:58  e36freak: tty1: you are not the only one here...
16:59  e36freak: fx: export PS1='\[$(echo $cb)\] ' or something
16:59  e36freak: fx: works fine here
16:59  tty1: so each time i call a script as a command it is forking its own instance, although im less clear about what export does now im atleast clear about how the variables cross scopes without export
16:59  lhunath: no need to export PS1.
16:59  lhunath: in fact, you really shouldn't.
16:59  geirha: $(echo $foo) is always useless use of echo
16:59  e36freak: lhunath: good to know
17:00  tty1: e36freak, i was just confused who you were talking to as i didnt see anyone named fx here at first, but i see him now, lol my mistake, brain fart
17:00  e36freak: geirha: just shouwing you can put commands in there
17:00  geirha: Ah ok
17:00  fx: e36freak, ah no, i think you misunderstand. I want it to work backwards, My prompt is fine. it works fine. I would like to get a variable from my prompt into my normal shell environment
17:01  lhunath: tty1: the environment is this place where string variables reside.  they have nothing to do with bash or shells whatsoever.  they are a UNIX thing and every process has an environment.
17:01  geirha: fx: PROMPT_COMMAND='somevar=test'; Each time the prompt is printed, somevar will be assigned the string "test"
17:01  lhunath: tty1: each time a UNIX process forks, the new process gets a copy of the old process' environment.
17:01  lhunath: that's all there is to it.
17:01  fx: hmmm
17:02  tty1: ok so let me ask this, now that i kno0w vribles cary into sourced scripts but not executed scripts (forked).. woudl be correct in understanding export just allows newly set varibles inside sourced scripts to carry back out to their parents, whereas normally they wouldnt (and regular executed scripts will behave the same with or without export_
17:02  fx: YEs !!!!!!!!!
17:02  lhunath: shells allow you to put stuff on the environment by first putting it into a shell variable, and then "linking" that variable to the environemnt.  if yo do that, each time you modify the shell variable, the shell puts its new value into its own environment space.
17:02  fx: omg it works ! thanks geirha
17:03  lhunath: tty1: var=foo; echo "$var"  <- do you expect 'var' to expand to 'foo' here?
17:03  tty1: lhunath, sure do
17:04  tty1: lhunath, im right... i hope :)
17:04  lhunath: tty1: source moo; echo "$var"   <- if you move 'var=foo' into a file called 'moo', this is the same as the above example.
17:04  e36freak: moooo
17:04  lhunath: var does not need to be "exported" to become available after the sourcing.
17:04  tty1: lhunath, yea i get that part, im jsut confused as to what export really does then :)
17:05  lhunath: var is a bash parameter within the bash shell process.  the sourcing and the 'echo "$var"' happen in the SAME shell process.  so var still exists.
17:05  lhunath: export is only for when you want to give a child PROCESS an environment variable.
17:05  tty1: what this environment really is, what its scope is, what shares the same enironment?
17:05  lhunath: nothing shares environment.
17:05  lhunath: I think I explained it several times already.
17:05  tty1: lhunath, ok so export basically copies downward, but not upward in the chan?
17:06  tty1: with each new process
17:06  lhunath: tty1: the environment is this place where string variables reside.  they have nothing to do with bash or shells whatsoever.  they are a UNIX thing and every process has an environment.
17:06  lhunath: tty1: each time a UNIX process forks, the new process gets a copy of the old process' environment.
17:06  lhunath: that is all there is to it.
17:06  geirha: tty1: export PAGER=cat; man cat
17:06  geirha: tty1: man looks for an environment variable called PAGER, and uses the command it contains if it exists.
17:07  tty1: yea weird thing is i use environment varibles all the time, they come natural to me in every day use. i just never thought about how it worked progamatically :)
17:07  geirha: Since man is a child of your shell, it gets the PAGER variable you exported.
17:07  lhunath: when man is executed, it gets a copy of all bash's env vars.  then it looks through the env vars of itself for an env var named PAGER
17:07  lhunath: right
17:08  lhunath: tty1: you and 99% of the unix users.
17:09  lhunath: the key thing to note is that env vars are NOT GLOBAL and they are only ever copied when a NEW CHILD is CREATED.  aside from that, there is nothing else.  no magic.  no copying.  no sharing.  no nothing.
17:09  lhunath: that, and they can only be strings.
17:09  tty1: oh so we have env space (string varibles) and bash memory space (local varibles, set varibles).. when you execute a shell as a new process it gets a copy of my env space but not my local space, and any changes to its env space will not effect the parent processes env space. however since sourcing is essentially an include it allows you to set your local varible space as well as env space with the use of export within the sourced script
17:10  tty1: lhunath, is my summation in line with what youve told me? it seems to be what i got from it
17:10  lhunath: sure
17:10  lhunath: sounds about right
17:11  tty1: lhunath, another words even with export you cant get environment varibles to move up the chain of processes (i used to think environment spaces were global, which is incorrect)
17:11  lhunath: indeed.
17:11  tty1: env varibles just copy once, downward, and do not even refrence the parents environment space
17:11  tty1: which is not at all how i assumed earlier it was
17:12  tty1: lhunath, thank you thats very useful
17:12  lhunath: the only thing a child can do to give something to the parent is by using one of the FDs the parent gave the child or by returning an 8-bit exit code.
17:12  geirha: tty1: I think windows does it differently, which may be a source of confusion.
17:12  tty1: i never program for windows anymore, i do a lot of platform independent
17:13  lhunath: !env
17:13  greybot: There are two kinds of variables: Environment Variables (''env'') and Bash Parameters (''set''). Every process has the former; and they are inherited by its children. Bash creates a parameter for each env var it has, and with ''export'' you can "link" other bash parameters to env vars of the same name.
17:13  lhunath: !forget env
17:13  greybot: OK, lhunath
17:13  lhunath: hmm.
17:13  tty1: geirha, stuff like ruby, java, python, etc.. but of course i do plenty of C/C++/assembly too but, they are the other end, shell scripting is rare for me in any depth
17:17  lhunath: !learn env Environment Variables (`env`) are NOT the same thing as Bash Parameters (`set`).  They are NOT GLOBAL (every process has their own set of env vars), and they are only ever copied from the PARENT to the CHILD when the child is FIRST CREATED.  Bash lets you assign STRINGs to env vars by linking a parameter to the environment using `export`.
17:17  greybot: OK, lhunath
17:18  e36freak: that'll work
17:18  tty1: lhunath, damnit i just lost my logs (was booted) did you say there was something i could use to display all shell variables as they are set?
17:19  sybariten: i'm standing in a dir containing some files and five or six dirs ... i want to descend into each dir, and run the imagemagick tool "convert" on each png. Whats the best method(ology) to achieve this?
17:19  e36freak: "set"
17:19  e36freak: tty1: ^
17:19  lhunath: !env > tty1
17:19  greybot: tty1: Environment Variables (`env`) are NOT the same thing as Bash Parameters (`set`). They are NOT GLOBAL (every process has their own set of env vars), and they are only ever copied from the PARENT to the CHILD when the child is FIRST CREATED. Bash lets you assign STRINGs to env vars by linking a parameter to the environment using `export`.
17:19  sybariten: i'm looking at some nested for-loop and ls ....  like this    for dirname in $(ls -d */); do for filename in ls $dirname*.png; do echo $filename; done; done
17:19  lhunath: `env` and `set` respectively
17:19  e36freak: "export" to see just env vars
17:19  e36freak: or "env"
17:19  sybariten: but it will get ugly if i want to get rid of the .png and have a basename.tiff , i suppose...
17:20  e36freak: !ls > sybariten
17:20  greybot: sybariten: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
17:20  tty1: thanks guys
17:20  e36freak: !pf 1 > sybariten
17:20  greybot: sybariten: http://mywiki.wooledge.org/BashPitfalls#pf1 -- Don't do this! -- for i in $(ls *.mp3)
17:20  steve___: !find > sybariten
17:20  greybot: sybariten: http://mywiki.wooledge.org/UsingFind
17:20  dagni: i have problem..
17:20  e36freak: dagni: rough. there is no solution.
17:20  dagni: i try to pass root password using phpshell
17:20  dagni: $ su
17:20  dagni: standard in must be a tty
17:20  dagni: is there other way to do it ?
17:20  geirha: sybariten: for file in ./*/*.png; do echo "${file%.*}"; done
17:21  sybariten: w00t, you can just glob a bunch of dirs like that?
17:21  dagni: $ sudo /sbin/service sshd restart
17:21  dagni: Password:
17:21  dagni: $
17:21  dagni: i don't get a chance to type password..
17:21  e36freak: !globstar > this too if you have bash4 and want recursion
17:21  greybot: this too if you have bash4 and want recursion: In bash 4, when the globstar shell option is enabled ( shopt -s globstar ), the glob ** expands to all files and directories found recursively under the current directory, and **/ to all directories. As of 4.0.28, combinations like foo/**/*.txt work, but **.txt and foo** do not.
17:21  geirha: !tias > sybariten
17:21  greybot: sybariten: Try It And See
17:22  sybariten: yeah well it obviously works... i cant really see the logic though, it feels as if i'm not feeding a "fetch"-command into bash
17:22  geirha: sybariten: In bash4 you can even do it recursively (by enabling the globstar shell option)
17:22  sybariten: or, into for
17:22  e36freak: !for > sybariten
17:22  greybot: sybariten: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
17:23  sybariten: ok .... so your method is more "basic" and my method is more "it works, because bash happens to see the right thing"
17:23  e36freak: sybariten: *.mp3 would expand into "file1.mp3 file2.mp3 ..." and the for loop will iterate through
17:24  geirha: sybariten: for dir in $(ls -d */); do   tells bash to find all directories in the current dir, pass them as arguments to ls -d, then iterate each whitespace separated WORD in ls's output.
17:24  geirha: sybariten: for dir in */; do   tells bash to find all directories in the current dir and iterate them.
17:24  dagni: can i somehow pass the password to su or sudo when i get "standard in must be a tty" error ?
17:25  sybariten: alrite. sweet. whats the point in using find then?
17:25  geirha: dagni: type it in with the keyboard.
17:25  e36freak: sybariten: find can do a million things
17:25  e36freak: sybariten: and then a few more
17:26  sybariten: e36freak: yes, but i mean in a for-loop case, and in a simple case like mine where its just *.ext you are after
17:26  dagni: geirha: but i do it using php shell and the shell tells me "standard in must be a tty"
17:26  Vide: hi, do you know how to check (in bash) if a variable is an array and has at least one value?
17:26  e36freak: sybariten: you wouldn't for something that simple
17:26  sybariten: ok cool
17:26  sybariten: thanks all
17:27  e36freak: if (( ${#array[@]} )); then
17:27  dagni: my sshd server crashed and i can't get DC to restart it in next few days, i think i can do this using phpshell but now i need root to restart sshd
17:28  dagni: if i can provide the password to su or sudo...
17:28  e36freak: you can try to echo it to /dev/tty or something, but...
17:28  dagni: but ?
17:29  e36freak: don't know if it would work
17:29  Vide: e36freak: thx, i should read more carefully the bash man sometimes before nagging irc
17:29  e36freak: know nothing about php shell
17:29  Vide: thx again
17:29  dagni: sudo /sbin/service sshd restart << mypassword
17:29  dagni: shame it doesnt work like that ;p
17:29  e36freak: !expect
17:29  greybot: http://expect.nist.gov/ -- a Tcl package for driving interactive terminal-based programs
17:39  tty1: wow so set displays env varibles too, pity, need to figure out how to display just the locals, have to grep it :)
17:42  e36freak: tty1: set | sed '0,/^[[:upper:]]\{2,\}/d'
17:43  e36freak: tty1: that will show everything after the last variable that start with 2 uppercase letters
17:44  e36freak: or maybe not
17:44  lhunath: tty1: set only displays parameters.
17:44 * e36freak plays with it
17:44  lhunath: tty1: bash makes parameters for each env var.
17:44  pmcnabb: how can you store the result of "[ -e /etc/passwd ]" so that you can check "[ $HAS_PASSWD ]" instead of re-running "[" every time?
17:44  tty1: e36freak, thanks, i guess all the globals come first and are always all upper case?
17:44  pmcnabb: er, re-running the "[ -e"
17:44  lhunath: pmcnabb: make a function.
17:45  pmcnabb: lhunath: please expound
17:45  lhunath: hasPasswd() { [[ -e /etc/passwd ]]; }
17:45  lhunath: if hasPasswd; then ...
17:45  e36freak: tty1: get rid of the "0," at the beginning would work
17:46  pmcnabb: lhunath: i'm using just "[", not "[[". Also, that will re-check every time. What if the file I'm checking for disappears between checks and I want to use the original check result?
17:46  lhunath: ![[ > pmcnabb
17:46  greybot: pmcnabb: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
17:46  pmcnabb: lhunath: I'm writing for POSIX sh
17:46  tty1: i just made it even simpler grep -ve "[A-Z]\{2\}" :)
17:46  e36freak: there you go
17:47  lhunath: pmcnabb: ew.  poor you.
17:47  e36freak: tty1: just put a "^" at the beginning of that regex
17:47  pmcnabb: lhunath: yes, dash script in a dracut initramfs..
17:47  ari_stress: hi all. can pls help me with sed, how to replace '12345678' with 'xxxxxxxx' (I dont seem to be able to write the escape char properly)
17:47  e36freak: pmcnabb: fine, just specify first :)
17:47  tty1: e36freak, already had one, actually, just didnt write it in here accidentally :)
17:47  e36freak: ari_stress: sed 's/[[:digit:]]/x/g'
17:48  ari_stress: let me try e36freak
17:48  lhunath: pmcnabb: ! [ -e /etc/passwd ]; hasPasswd=$?
17:48  e36freak: # sed 's/[[:digit:]]/x/g' <<<"12345678foo"
17:48  evalbot: e36freak: xxxxxxxxfoo
17:48  lhunath: hmm.
17:48  lhunath: pmcnabb: [ -e /etc/passwd ] && hasPasswd=1
17:48  lhunath: if [ "$hasPasswd" ]
17:48  e36freak: ari_stress: will replace any number with "x"
17:49  pmcnabb: lhunath: ah, that is good
17:49  pmcnabb: lhunath: thank you very much
17:49  e36freak: ari_stress: can also be done with PE
17:50  e36freak: # foo="12345678foo"; echo "${foo//[[:digit:]]/x}"
17:50  evalbot: e36freak: xxxxxxxxfoo
17:51  e36freak: lhunath: what's wrong with just "if ! [ -e /etc/passwd ]; then
17:52  lhunath: e36freak: ask pmcnabb.
17:52  ari_stress: e36freak: that's almost did it. can i specifically search for 8 anydigit only?
17:52  e36freak: ari_stress: only for 8 in a row?
17:52  e36freak: 's/[[:digit:]]\{8\}/x/g'
17:52  ari_stress: like 12345678 22344452
17:53  ari_stress: ok let me try
17:53  e36freak: erm, wait
17:53  e36freak: will replace the whole thing with 1 x
17:53  pmcnabb: e36freak: consider testing for a file's existence, and while doing many other things, the file may be gone. I want to remember what the original test returned. not the most current.
17:54  ari_stress: e36freak: i have this log file with "password '32421235', etc.. that i want to replace with 'xxxxxxxx'
17:54  e36freak: 's/[[:digit:]]\{8\}/xxxxxxxx/g'
17:54  ari_stress: ok
17:54  sikilpaake: how can i use pointers in bash? can i even use them?
17:55  e36freak: pmcnabb: ahh, that's fine, just wondering
17:55  e36freak: !indirect > sikilpaake
17:55  e36freak: meh
17:56  ari_stress: e36freak: thank you so much. it's perfect! you've just saved my day :)
17:56  e36freak: !indirection
17:56  greybot: See !faq variable variable -- http://bash-hackers.org/wiki/doku.php/syntax/pe#indirection
17:56  e36freak: !faq variable variable
17:56  greybot: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
17:56  sikilpaake: e36freak: thanks!
17:56  e36freak: sikilpaake: closest we got
17:56  sikilpaake: fanks!
17:57  Mike1_: hi!
17:57  g4bittin: hi
17:57  Mike1_: Is there any good sed tutorial on the internet?
17:59  e36freak: !sed
17:59  greybot: sed is a Stream Editor, used to filter output. It's NOT primarily useful for editing files (use ed or perl instead). Ask sed questions in ##sed.
17:59 --- Mike1_ is now known as Mike1
18:00  e36freak: Mike1: the first step is learning regex, after that it's pretty straight forward
18:01  e36freak: Mike1: http://www.regular-expressions.info/
18:02  e36freak: Mike1: http://www.grymoire.com/Unix/Sed.html (this is where i learned a lot of it)
18:11  tty1: is there a way to preserve all your local varibles before sourcing a shell script, and then "resetting" them once the shell script returns? (i want to make sure it doesnt mangle certain varibles)
18:16  Uqbar: tty1: other than setting them to be read-only? (via the readonly builtin)? not that I know of. but if you don't want side effects, why are you sourcing the script in the first place?
18:18  lhunath: tty1: yeah, not sourcing the shell script, but executing it.
18:18  trash: hihi.
18:18  tty1: Uqbar, wasnt aware there was a read-only builin, ill check that out.. and the reason is that i need to pass array varibles down into the other scripts, so i need to source them. But i dont mind if they produce new varibles (that is even useful) i jsut didnt want them to unset or erase.
18:19  tty1: lhunath, yes i know thaqt much, im talking about the child scripts within them that i need to source, the "plugins"
18:19  lhunath: you don't want them to pass any state back to the parent script?
18:19  lhunath: if so, then a subshell is a good enough hybrid solution.
18:19  tty1: lhunath, no i want them to pass state back, thats fine (prefered if possible).. what i dont want is for them to be able to mangle, delete, or erase certain variables :)
18:20  lhunath: so, they should be able to create new variables but not change any existent ones?
18:22  tty1: lhunath, right
18:22  lhunath: tty1: no can do.
18:23  tty1: lhunath, how about readonly builtin?
18:23  lhunath: I suppose you could save declare in a variable and then eval it.  but jeesh.
18:23  lhunath: tty1: once a variable is read only, you cannot write to it anymore.  (duh)
18:24  lhunath: that goes just as much for your child module as for your parent script.
18:24  tty1: lhunath, thats fine n this case actually
18:24  lhunath: shrug.  then make whatever readonly, sure.
18:24  tty1: lhunath, all the varibles that are set once the children start executing, atleast the ones i care about, are read only
18:24  tty1: :) thanks
18:25  e36freak: or write it in such a way that the vars won't be rewritten?
18:40  Zta: I have 3 categories of files that I want to store in some sort of array or arrays.  The categories are stored in a variable, $CAT.  I (think) want to do something like this FILES_VAR="FILES_$CAT" and FILES=${!FILES_VAR} and FILES+=( $FILE ) but all files seem to be added to the same array, $CAT unregarded.  What am I doing wrong?  Is there a better way?
18:40  Zta: (I loop over $CATs and append the files)
18:40  e36freak: !varcaps
18:40  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, SHELL, ...) and internal shell variables (BASH_VERSION, RANDOM, ...). All other variable names should contain at least one lowercase letter. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
18:41  e36freak: !array > Zta
18:41  greybot: Zta: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
18:41  e36freak: (would use associative arrays to do that in bash4)
18:45  wunderkin: what would be the right way to do this: until [ ret=$(su asterisk -c "ssh db1-e.job.int -o ConnectTimeout=5 '/usr/local/bin/qcheck.sh /var/run/asterisk/job-mp.pid'"); [ [ -z "$ret" ] || [ $ret -lt 2 ] ] ]   ret will be empty if the command doesn't execute.. which i want the until to stop.. or if it is less than 2
18:45  e36freak: ![
18:45  greybot: [ is NOT part of the `if' syntax. It's a normal, ordinary COMMAND. The `if' just checks its exit status. See `help test', http://mywiki.wooledge.org/BashGuide/TestsAndConditionals , and http://partmaps.org/era/unix/award-example-backticks.html
18:45  e36freak: !pf 11 > wunderkin
18:45  greybot: wunderkin: http://mywiki.wooledge.org/BashPitfalls#pf11 -- Don't do this! -- if [ [ a = b ] && [ c = d ] ]
18:46  wunderkin: i wasn't doing it that way before.. just trying a bunch of things to get it to work ;d
18:46  e36freak: what are you trying to do?
18:46  e36freak: that code is a mess
18:48  e36freak: until [[ -z $ret ]] || (( ret < 2 )); do ... ?
18:48  wunderkin: yeah, well, i need to run the command as asterisk, then ssh to the other box and run the command.. if the ssh fails or the return value is 2 or less, i dont want to run the loop... before, inside the ssh i was trying to just do file='/blah'; echo $file but the variable wasn't set so that's a different issue, i gave up on that and just made the local script lol..
18:49  wunderkin: it needs to keep looping, running that command until either it fails or the return is less than 2 so the script cant be run inside the do.. unless i duplicate it.. which is lame ;d
18:50  wunderkin: ooh
18:50  TheBonsai: y0
18:50  wunderkin: no i guess i can put it inside
18:50  e36freak: uh
18:51  e36freak: you're checking the return status, or stdout?
18:51  wunderkin: well in this variation it will be checking stdout..
18:52  e36freak: until [[ -z $ret ]] || ((ret < 2)); do ret=$(ssh - asterisk --comand="..."); done
18:53  e36freak: ?
18:53  wunderkin: yeah i think so, i just wasn't thinking straight before..
18:53  e36freak: you want "((ret < 2))" to check the return code or stdout, once again?
18:54  e36freak: if you just want to loop until ssh is successful
18:54  e36freak: until su - asterisk --comand="ssh ..."; do sleep 5; done
18:54  e36freak: or something
18:55  pLr: e36freak: i do: while [ 1 ]; do ssh; sleep1; done
18:55  e36freak: pLr: k, then what... ssh && exit; sleep 1; done?
18:55  e36freak: pLr: how do you intend to break the loop on success?
18:56  wunderkin: well, i want to check the return if there is one too.. this works, it just still will do a sleep once..
18:56  pLr: e36freak: thats a lazy move made for manual intervention really
18:57  k[l: `' alias pyt='python -c "'  pyt.doc > returns values with explicit "print" declaration and terminates on '`" ... if anyone has any better.. please provide..
18:57  e36freak: well you would want ssh && break
18:58  e36freak: and while true; do is better than while [ 1 ]
18:58  pLr: e36freak: i would try $ while true ; do nc -z 10.0.50.50 22 && break; echo 'Waiting for remote sshd...'; done
18:58  k[l: anyone?
18:58  e36freak: until nc -z 10.0.50.50; do echo "waiting..."; sleep 1; done
18:59  e36freak: !alias > k[t
18:59  greybot: k[t: If you have to ask, use a function instead: myfunc() { foo "$@" | bar; }
18:59  TheBonsai: he's gone
18:59  wunderkin: he left already
18:59  TheBonsai: a quick one
18:59  TheBonsai: bloddy youth ;)
19:00  TheBonsai: i didn't even understand the question
19:00  TheBonsai: but since he waited <2min, it wasn't important
19:02  Zta: Touble is here: http://pastebin.com/TZP0b5Z8
19:03  Zta: Trouble..
19:04  TheBonsai: what about it?
19:05  geirha: array+=( "$file" )
19:05  Zta: ah, of course
19:05  geirha: $file is very different from "$file". The latter is what you want.
19:05  Zta: But I don't think that's my only problem, is it? =)
19:05  TheBonsai: it isn't
19:05 --- Unknown[NF] is now known as Unknown[OFF]
19:06  TheBonsai: it's harmless here, it's good to fix it, but it's not the problem that brought you here
19:06  geirha: Zta: WALK_FILES=$FILES[$CAT]  More wrong syntax
19:07  geirha: And I recommend you follow the convension and use lower case variable names
19:07  Zta: I'm used to upper case, so lower case would confuse me and not add any good at this point
19:08  geirha: Oh wait, you can't append like that to an associative array btw
19:08  geirha: An associative array requires a key and value
19:08  geirha: err, nvm. misread CAT_FILES as FILES
19:09  blackcat73: Hi, I wanto to copy a file to a destination path but some of the dirs don't exist, you can I copy and create the necessary dirs ?
19:09  geirha: Hm. there's so much odd in that code, I see new oddities every time I look.
19:10  geirha: !faq 10 > blackcat73
19:10  greybot: blackcat73: http://mywiki.wooledge.org/BashFAQ/010 -- How can I recreate a directory hierarchy structure, without the files?
19:10  blackcat73: thx
19:11  Zta: geirha: Yes, I'm not very good with indirect variables and certainly not arrays
19:11  geirha: blackcat73: Or use rsync
19:11  TheBonsai: well, if the destination content doesn't matter, just use cp or rsync
19:11  geirha: blackcat73: Ask #rsync for help with that
19:11  TheBonsai: or ##linux for help with cp [-a] ;)
19:11  Zta: Oh, there's no indirect ref used here btw.
19:11  geirha: !guide > Zta
19:11  greybot: Zta: http://mywiki.wooledge.org/BashGuide
19:11 --- olskolirc is now known as WorthyOfUrAttn
19:11  Zta: Uh..
19:11  geirha: Read the guide, learn the syntax, THEN start scripting.
19:12  Zta: Thanks a bunch
19:13  wunderkin: e36freak: thanks, i'm using your first idea, i think.. plus rechecking after to avoid a sleep in the loop ;D
19:14  Jinxed-: So I have a statement if (("$videoToStream" == 0));then which is the same format as all my other if statements
19:15  Jinxed-: however this one doesn't work
19:15  Jinxed-: I get
19:15  Jinxed-:  -- 0") syntax error: invalid arithmetric operations
19:15  Jinxed-:  == 0") syntax error: invalid arithmetric operations
19:16  TheBonsai: set -x
19:16  e36freak: Jinxed-: is "$videoToStream" a number?
19:16  TheBonsai: i bet videoToStream contains unclean stuff
19:16  Jinxed-: e36freak: yes
19:16  e36freak: i would agree
19:16  Jinxed-: I echo it right before
19:16  TheBonsai: i didn't say echo
19:16  e36freak: Jinxed-: i bet it isn't. run the script with "bash -x script" and see what happens there
19:16  TheBonsai: i said set -x
19:19  e36freak: Jinxed-: lemme rephrase as well, is it an integer?
19:19  tonyyarusso: How should I go about doing something like for file in "file1 file2 file3"; do cat $file; done, where I'm defining a list of files?  (In that current configuration, it's being treated as one filename with spaces in it.)
19:19  TheBonsai: and lemme tell what i'm after:
19:19  Jinxed-: TheBonsai: that is sweet
19:19  TheBonsai: # foo="   1"; echo $(( "$foo" == 1 ))
19:19  evalbot: TheBonsai: bash: "   1" == 1 : syntax error: operand expected (error token is ""   1" == 1 ")
19:20  TheBonsai: tonyyarusso: without ""
19:20  Jinxed-: e36freak: when I echo it I get 0... when I did TheBonsai trick it looked like there was nothing in the variable
19:20  TheBonsai: tonyyarusso: but inside with "" ;-)
19:20  e36freak: Jinxed-: there you go :)
19:20  tonyyarusso: TheBonsai: ah, so like "file1" "file2" "file3"?
19:20  e36freak: tonyyarusso: for file in file1 file2 file3; do cat "$file"; done
19:20  e36freak: and yes, that will work too
19:21  tonyyarusso: got it
19:21  Zta: Arrays can't contain arrays?
19:22  e36freak: !array > Zta
19:22  TheBonsai: variables can't contain variables
19:22  greybot: Zta: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
19:22  Jinxed-: e36freak: I have no idea why it would have a value when echoed but not when it was used in an if statement
19:22  TheBonsai: (and i'm not talking about indirectioon by parameter name)
19:22  e36freak: Jinxed-: i'd have to see it
19:23  TheBonsai: e36freak: pastebin the relevant lines of code (the echo plus the if) and the set -x output there
19:23  TheBonsai: err
19:23  TheBonsai: Jinxed- :)
19:23  e36freak: heh
19:24  TheBonsai: tonyyarusso: btw http://wiki.bash-hackers.org/syntax/ccmd/classic_for
19:25  tonyyarusso: thanks
19:25  Zta: e36freak: I don't clearly see the answer in your link.  Bash complains about my test 2 here: http://pastebin.com/FHhVRQu3
19:26  e36freak: Zta: bash does not have multi-dimensional arrays
19:26  e36freak: !faq variable variable
19:26  greybot: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
19:27  e36freak: Zta: associative arrays just have an array of indices/keys that aren't numbers, and an array of keys
19:27  e36freak: you can't assign an array to a key though
19:27  geirha: You can't have multidimentional arrays in bash
19:27  Zta: I want to assign ..
19:27  Zta: geirha: spot on
19:28  Zta: So maybe my first approach wasn't that bad at all.
19:28  e36freak: Zta: you need to think differently in bash, or use a full blow language
19:28  e36freak: blown**
19:28  Zta: e36freak: it was you who suggested the use of ass. arrays to solve my problem =)
19:28  TheBonsai: or simulate multidimensional arrays using associative arrays and combined index strings
19:29  e36freak: Zta: your question was hard to understand
19:29  Zta: ok
19:29  TheBonsai: foo["X-Y-Z"] as substitute for foo["X"]["Y"]["Z"]
19:29  TheBonsai: for example
19:31 --- mohan is now known as Guest63308
19:33  Jinxed-: ok i have a file where i read the second line
19:33  Jinxed-: with
19:34  Jinxed-: head $filename -n 2 | tail -n 1
19:34  greycat: UMQ
19:34  e36freak: heh
19:34  e36freak: !umq
19:34  greybot: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
19:35  Jinxed-: videoToStream=$(head $filename -n 2 | tail -n 1)
19:35  Jinxed-: then when I echo I get teh correct value of 0
19:35  Jinxed-: but when I use it in the if statement it is empty
19:35  greycat: !exact
19:35  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
19:36  pgas: { read _;read v ;} < file;echo "$v"
19:36  greycat: don't even need the _ there
19:36  Zta: e36freak: I hope my code here illustrates my intention: http://pastebin.com/samG9bC7
19:37  greycat: Although I'm sure we're going to (eventually, possibly before the heat-death of the universe) discover that his "if statement" is fucked.
19:37  Zta: e36freak: I want $FILES_WALK to contain ("walk1.mp3" "walk2.mp3")  and  $FILES_RUN to contain ("run1", "run2", "run3")
19:37  pgas: ehe you don't have even head and tail in this paste
19:38  e36freak: pgas: different person...
19:38  pgas: ho sorry
19:38  greycat: Zta: files_walk=(walk1.mp3 walk2.mp3) files_run=(run1 run2 run3)
19:39  Zta: greycat: And now using my add_file function, please.
19:39  greycat: I'm just responding to the question I actually see.
19:40  Jinxed-: http://pastebin.com/2WVgwES6
19:40  Jinxed-: I get the value in line 19
19:41  greycat: And then you CHANGE the value in line 26.
19:41  Jinxed-: echo it in line 29
19:41  e36freak: HAH
19:41  Jinxed-: yeah
19:41  e36freak: !ls > Jinxed-
19:41  greybot: Jinxed-: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
19:41  Jinxed-: that normally isn't there
19:41  e36freak: that is the root of your problem
19:41  pgas: use less quotes!
19:41  Zta: greycat: Do you have the time to help me?
19:41  greycat: Only if you have time to ask a question
19:41  e36freak: Zta: just ask, he won't go through your script
19:41  pgas: or maybe not, but it's possible you variable contains something else than 0, like a \r
19:41  e36freak: !questions
19:41  greybot: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
19:42  Zta: !flood
19:42  greycat: An example of a question would be "How do I add a filename to the end of an array"
19:42  greycat: We could answer that, easily enough.
19:42  Jinxed-: e36freak: greycat Normally line 26 isn't there.
19:43  pgas: Jinxed-: on another note, you could do { read ip; read video; read dostop; } < file
19:43  Zta: I've already tried stating my question in plain text and it turned out I got a wrong answer.
19:43  greycat: Jinxed-: What is the actual problem you are having?
19:43  e36freak: Jinxed-: stop parsing ls, do it right, and your problems will start to go away
19:43  pgas: Jinxed-: run your script with "bash -x yourscript" and see what's really in your variables
19:43  greycat: Jinxed-: (also listen to pgas's advice)
19:44  Jinxed-: e36freak: I have been using ls without issue
19:44  Jinxed-: the part of the code not workign has nothing to do with ls
19:44  greycat: You have no issues?  Yay, problem solved!
19:45  Zta: I want to add files to an array.  But since I have more categories of files, I want an array of each category of files.
19:45  Jinxed-: pgas: when I run it with bash -x the $videoToStream variable is empty
19:45  pgas: ehe well sorting files by time is one thing I would use ls for, knowing the limitation
19:45  Jinxed-: however it will still echo 0
19:45  Zta: The categories are dynamic.
19:45  Jinxed-: i will try the read
19:45  greycat: Zta: if ((foo)); then array1+=("$file"); else array2+=("$file"); fi
19:45  pgas: Jinxed-: uh oh, can you paste the output with bash -x?
19:46  pgas: Jinxed-: you are aware that ctime is not creation time right?
19:46  greycat: Jinxed-: how do you know it's "empty"?
19:46  Zta: greycat: can I instead of "array1" have it be named dynamically, e.g. array_$category ?
19:46  Jinxed-: what is it?
19:46  greycat: You said it wrote "0", not an empty string.
19:46  greycat: Zta: no.
19:46  greycat: !faq 6 > Zta
19:46  greybot: Zta: http://mywiki.wooledge.org/BashFAQ/006 -- How can I use variable variables (indirect variables, pointers, references) or associative arrays?
19:46  greycat: Not in bash, anyway.  ksh93 can.
19:46  Zta: ok, thanks.
19:47  greycat: Or you can do it with evil, but then you have to sanitize the filenames first.
19:47  e36freak: pgas: why not stat?
19:47  Zta: arrays can't ne referenced indirectly?
19:47  Zta: *be
19:47  greycat: !ctime > Jinxed-
19:47  greybot: Jinxed-: ctime is NOT creation time! It's (metadata) change time. It's updated whenever a file's ownership, permissions, etc. change. Unix does not store creation time of a file ANYWHERE, at all. There is no way you can possibly know when a file was created, unless you're on a system with nonstandard file system extensions.
19:47  greycat: Zta: not in bash.
19:48  greycat: The ${!array notation is already defined to mean something different for arrays than for scalars.
19:48  Zta: Oh
19:48  pgas: e36freak: to sort?
19:48  Zta: That explains
19:48  e36freak: pgas: sure
19:49  pgas: e36freak: what does it gives you over ls?
19:49  Zta: Maybe I could cache my arrays to files that are named by category
19:49  pgas: I guess find -printf using \0 is a bit better
19:49  e36freak: pgas: well that's always preferred, but stat output should be consistent
19:49  greycat: Zta: do you really have so VERY many categories that you can't just make a case statement?
19:50  soby: shell command that lists all the RPMs installed in a system sorted by package size, largest package first...??
19:50  greycat: !nabq > soby
19:50  greybot: soby: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
19:50  greycat: If you wanted it for Debian, I could answer it, but it'd still be off-topic technically.
19:50  Jinxed-: pgas: { read ipToStream; read videoToStream; read dostop; } < $selectFile
19:50  soby: that would do
19:50  greycat: < "$selectFile"
19:50  pgas: e36freak: with ls -t the output is ok, you just have problems with filenames with newlines
19:50  Jinxed-: results in command read now found
19:51  greycat: soby: it would NOT work on a Red Hat -like system
19:51  Zta: greycat: I just like the idea of if being dynamically.  Sooner or later(!) I'll add a new category, and I'll forget to add the variable for it..
19:51  greycat: Zta: consider writing it in ksh93 then.
19:51  greycat: Or some other language that's not bash or sh.
19:51  soby: greycat, that would be fine
19:51  pgas: Jinxed-: read is a builtin it would surprise me if bash cannot find it. anyay what about pasting the set -x output you get?
19:51  Jinxed-: ok one second
19:52  Zta: Besides, a cached list wouldn't be a bad idea now I think of it; the alternative is to list the files and populate the arrays every time.
19:52  greycat: soby: http://wooledge.org/~greg/ds
19:52  soby: greycat, thanks man
19:52  pgas: e36freak: it's just so easy to do ls -t vs all kind of blah | sort | cut :D
19:53  e36freak: pgas: do what you want, just not the way i would do it
19:53  greycat: ls -t would be so incredibly useful if only ls could be trusted to produce filenames correctly.
19:54  greycat: It *is* in fact extremely useful if you're a human and not a bash script.
19:54  greycat: Humans can usually detect mangled filenames.
19:54  pgas: well it's possible to implement the sorting in bash only, dunno if it would be that slow
19:55  greycat: Depends on how many filenames.
19:55  Jinxed-: xoutput: http://pastebin.com/7SgB2iYc
19:55  pgas: yeah, for a small amout it's probably faster
19:55  greycat: Hah, look at that.  \r just as predicted.
19:55  Jinxed-: damnit
19:56  Jinxed-: i left in a the stupid hard set
19:56  Jinxed-: greycat: what does \r mean
19:56  e36freak: !cr > Jinxed-
19:56  greybot: Jinxed-: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
19:56  greycat: { read ip; read video; read stop; } < <(tr -d '\r' < "$file")
19:56  pgas: you can perhaps add it to IFS too
19:56  greycat: Or you could remove the \r from each variable using PE.
19:56  greycat: hmm.... that might also work.
19:57  greycat: Does \r count as IFS whitespace?
19:57  e36freak: not that i know of
19:57  pgas: I don't think so
19:58  greycat: Man page doesn't say it does.  It mentions space and tab explicitly.
19:59  pgas: { IFS=$' \t\r' read ip ;IFS=$' \t\r' read video;IFS=$' \t\r' read dostop; }  < "$specialfile"
20:01  Jinxed-: do you include the { }
20:01  e36freak: yes
20:01  greycat: !group
20:02  greycat: !learn grouping http://mywiki.wooledge.org/BashGuide/CompoundCommands#Command_grouping
20:02  greybot: OK, greycat
20:02  Jinxed-: when I did {read ipToStream; read videoToStream; read doStop} < <(tr -d '\r' < $selectFile) I get the error {read: command not found
20:02  greycat: You need a space.
20:02  e36freak: more whitespace
20:02  greycat: Also, you need the semicolon at the end.
20:02  e36freak: and a semicolon after doStop
20:05 * pLr bows to greycat
20:06 --- Unknown[OFF] is now known as Unknown[NF]
20:07  greycat: # type od
20:07  evalbot: greycat: bash: type: od: not found
20:08  greycat: # echo $'foo\r' > foo; IFS=$' \t\r' read f < foo; echo "$f" | cat -e; IFS=$'o \t\r' read f < foo; echo "$f" | cat -e
20:08  evalbot: greycat: foo$
20:08  evalbot: greycat: foo^M$
20:08  pgas: 4# type od
20:08  shbot: pgas: od is /bin/od
20:08  greycat: Never mind, it's clear enough with cat -e anyway.
20:09  tty1: what is the best way to determine the difference between an unset variable and one that was set to "" ? as i understand it -n wont differentiate
20:09  pgas: !faq defined > tty1
20:09  greybot: tty1: http://mywiki.wooledge.org/BashFAQ/083 -- How do I determine whether a variable is already defined?  Or a function?
20:09  greycat: Why does \r act as IFS whitespace when IFS=$' \t\r' but not when IFS=$'o \t\r' ?
20:10  pgas: hmm
20:10  greycat: And why is \r acting as IFS whitespace at all if the man page doesn't say it can?
20:12  greycat: # x=$'a\r\r\rb'; IFS=$'\r' read y z <<< "$x"; echo "<$y> <$z>" | cat -e
20:12  pgas: indeed I see what you mean now, you normally would need read foo _
20:12  evalbot: greycat: <a> <^M^Mb>$
20:12  greycat: That one's even weirder!
20:13  sudoer: I have this line in my crontab: /bin/bash -l -c 'cd /home/jtoy/sandbox/leadgen && script/rails runner -e production '\''BlogPost.batch_set_bitly'\'' > /dev/null'       when I run it from command line it is fine, but when I run it from cron, i get notified with : /bin/sh: Syntax error: Unterminated quoted string
20:13  sudoer: can anyone help me figure out why I get this error?
20:14  e36freak: sudoer: single quotes don't match up
20:14  pgas: greycat: well maybe not, the first \r is used as a delimiter and is removed then the second variable contains the rest including the delimiters
20:14  greycat: For simplicity, I'd get rid of those '\'' and just use bash -l -c "blah 'foo' >/dev/null"
20:14 * nDuff isn't sure if the quotes around the inner foo are needed either in that case
20:14  greycat: pgas: but if \r is IFS whitespace, then it should remove all of them
20:15  sudoer: why does it run fine when i copy and paste the line into the terminal though?
20:15  nDuff: ...after all, BlogPost.batch_set_bitly is all one token, so why quote it?
20:15  nDuff: sudoer, cron isn't bash.
20:15  greycat: It runs fine in a shell because it's syntactically valid.  The question is why it fails.
20:15 * nDuff shrugs.
20:15  greycat: Are you quite sure you're showing us the REAL command?
20:15  pgas: well it isn't a whitespace, and I would say that your first example shows a bug
20:16  greycat: Does the real command have percent signs in it?
20:16  sudoer: yeah, I just now did crontab -l, copy and paste and hit return
20:17  greycat: *shrug* maybe your cron is barfing on the backslashes or something.  in which case the simplified version would sidestep the issue.
20:17  pgas: # IFS='o' read a <<< "baro"; echo "$a";IFS='ao' read a <<< "baro"; echo "$a"
20:17  evalbot: pgas: bar
20:17  evalbot: pgas: baro
20:18  sudoer: hmm, I am using a program to generate my crontab for me, so it would be optimal if i could fix my cron so i could continue to use this program
20:18  greycat: Then you'll have to figure out why it's failing.
20:18  pgas: it's not clear to me where the difference between these 2 is documented
20:18  sudoer: k, thanks
20:18  e36freak: # IFS=o read a <<< "baro"; echo "$a"; IFS=ao read a <<<"baro"; echo "$a" # out of curiousity
20:18  evalbot: e36freak: bar
20:18  evalbot: e36freak: baro
20:18  e36freak: hmm
20:20  e36freak: sudoer: i prefer to just write scripts and invoke them in crontab, makes things a lot easier
20:20  pgas: oh wait it's because a is aslo in the string....though I'm not sure why it happens
20:21  pgas: # IFS='o' read a <<< "baro"; echo "$a";IFS='wo' read a <<< "baro"; echo "$a"
20:21  evalbot: pgas: bar
20:21  evalbot: pgas: bar
20:21  greycat: pgas: ksh88 produces bar for both of the original cases.
20:21  greycat: (after modifying to get rid of the <<<)
20:22  greycat: ksh93 produces bar and baro
20:23 * greycat attemps to read the POSIX thing
20:25 * greycat observes that the POSIX thing looks remarkably like the bash man page
20:26  e36freak: haha
20:29  sharp15: 2 questions.  1) is there a way to perform ^<term>^<replacement>^ with multiple replacement (i.e. sed -e 's/<term>/<replacement>/g'), 2) i seem to remember there being a way to tell bash to grab 2 specific types of files i.e. mkdir aoeu_{a b c d e f}, is this accurate and does anyone know where the documentation is?
20:30  erUSUL: sharp15: sed / at least gnu ) accepts multiple -e statements
20:30  e36freak: greycat: i don't know if you remember, but there was an issue with tab completion on ubuntu when a path is stored as a variable?
20:30  greycat: The second question contains syntax that looks like you were attempting brace expansion, but the words before that syntax contradict that....
20:30  e36freak: greycat: apparently ubuntu doesn't compile bash with readline
20:30  erUSUL: i made a bug report never heard back
20:30  greycat: Please explain what "grab 2" means, or what you are attempting to do.
20:31  sharp15: erUSUL: what does that have to do with the question?  i don't have access to the actual sed cli from the history system.  though i could be mistaken.
20:31  greycat: sharp15: he probably doesn't know about that weird ^^^ thing.  Most people don't.
20:31  greycat: I've heard of it, but I know nothing about it.
20:32  pgas: sharp15: there is check the man page the syntax is a bit more complicated though
20:32 * greycat wonders if the ^^^ thing is disabled along with !foo when I do set +o histexpand
20:32 * greycat hopes so.
20:32  sharp15: greycat: then what do most people use, if anything?
20:32  greycat: "Most" people probably hit the up arrow a bunch of times.
20:33  greycat: I use vi mode without csh-style history expansion, as I grew up on ksh.
20:33  falconindy: ctrl-r is mightly helpful
20:33 * sharp15 tired of doing that.
20:33  pgas: somethin like !!:s/foo/bar/g or maybe !!:gs/foo/bar
20:33  falconindy: you can use something like !?foocommand:s/term/replace/g
20:33  falconindy: er yeah, might be gs...
20:34 * greycat would find it significantly easier to use ESC / foocommand Enter and then manually edit it.
20:34  sharp15: pgas: i tried the 1st form you gave before i asked. doesn't work.
20:35  pgas: ehe, well I don't use that stuff
20:35  greycat: Almost nobody does.
20:36  pgas:  !!:gs/foo/bar/ looks ok
20:36  e36freak: greycat: you mean set -o vi ?
20:36  greycat: That's what I mean by vi mode, yes.
20:36  e36freak: just making sure. i've started playing with it, like it a lot
20:38  pgas: ah, in fact !!:gs/foo/bar is ok too
20:39  steve___: I just wish there was a way indicate which mode its in.
20:39  greycat: set -o | grep ^vi
20:40  steve___: ...when pressing s-ins in the middle of a command
20:41  sharp15: thank you guys for the history system comments.  any comments on the second part of my question?
20:41  steve___: I was just talking out loud.  Although I did see a patch floating around somewhere for that functionality.
20:41  pgas: echo foo{a,b,c}
20:42  e36freak: # touch foo.{txt,png}; ls
20:42  evalbot: e36freak: foo.png  foo.txt
20:43  sharp15: thank you.
20:44  e36freak: works with globbing too, i.e. *.{html,php}
20:46 * greycat still doesn't know what "grab 2 types" meant
20:46  greycat: brace expansion is very, very literal.  it has nothing to do with types of anything.
20:46  greycat: *.{foo,bar} means *.foo *.bar
20:49  sharp15: greycat: that is what i meant.  i was looking for the documentation and not sure what to request.
20:49  greycat: !brace
20:49  greybot: Brace expansion: http://wiki.bash-hackers.org/syntax/expansion/brace
20:49  sharp15: appologies for the confusion.
20:50  sharp15: thank you.
20:50  greycat: pgas: I think the answer to the "baro" question (IFS, read) has something to do with the "If there are fewer vars than fields" section on http://pubs.opengroup.org/onlinepubs/9699919799/utilities/read.html
20:51 * greycat is still trying to parse it
20:54  pgas: ehe, in fact our case is if there is as many variables are there are fields
20:54  e36freak: greycat: possibly, but i don't think that's what that is intended to mean. it's referring to IFS=, read foo bar <<<"foo,bar,baz" vs IFS=, read foo bar <<<"foo"
20:54  greycat: Nope, because IFS=o input=baro gives TWO fields: "bar" and ""
20:54  greycat: unless I'm misreading
20:55  pgas: sure, but that's the case that works for me
20:55  e36freak: ahh, i see what you mean
20:55  greycat: pgas: which answer do you consider correct for IFS=o read x <<< "baro"; echo "$x"
20:55  greycat: I'd expect baro, not bar
20:56  pgas: yes me too
20:56  pgas: it's the case one field, one var
20:56  greycat: I get "bar" in bash 3, bash 4, and ksh93
20:57  e36freak: well what would you expect from IFS=, read x <<<"foo,"; echo "$x" ?
20:57  pgas: well, ok if you apply the definition, the first field "bar" is assign to var
20:57 * erUSUL expects bar ... i.e does not expect IFS to be included ( even if it is again making himself a fool )
20:57  pgas: the rest doesn't apply
20:57  Mike1: how can I read a file line by line into an array? With cat and an infinite while loop containing read it wont detect the end of the file I think and read will wait for the next line forever?
20:57  greycat: I get "baro" in ksh88 using IFS=o echo baro | read x; echo "$x" (ksh88 has no <<< operator, but the RHS of a pipeline is in the current process)
20:57  e36freak: erUSUL: i'm with you
20:57  erUSUL: Mike1: help mapfile
20:58  e36freak: !faq 1 > Mike1
20:58  greybot: Mike1: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
20:58  greycat: e36freak: I expect foo,
20:58  greycat: !faq 5 > Mike1
20:58  greybot: Mike1: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
20:58  pgas: # IFS='o' read a b <<< "roro"; echo "$a" "$b"
20:58  evalbot: pgas: r r
20:58 --- arumaniac is now known as i00nsu
20:59  pgas: first field first variable, second field second variable, the other rules don't apply since we are not in any of the other cases.
20:59  e36freak: greycat: you expect the IFS character to be included?
20:59  greycat: Until someone can tell me why there's no empty third field, yes, I do.
20:59  e36freak: ahh
20:59  pgas: # IFS='o' read a b <<< "rorofo"; echo "$a" "$b"
20:59  evalbot: pgas: r rofo
21:00  pgas: first field r, then the rule for fewer variables applies
21:00  e36freak: that's expected
21:00  Mike1: thanks greycat, greybot! :)
21:00  greycat: pgas: Yes, the r rofo looks right.
21:01  greycat: arc3:~$ IFS=o read -a x <<< "baro"; printf "<%s> " "${x[@]}"; echo
21:01  greycat: <bar>
21:02  greycat: This one seems to confirm that bash treats an input that ends with an IFS non-whitespace character as NOT delimiting a new field.
21:02  xerophyte: how can i do this Please rename these files:
21:02  xerophyte: Comm_*_20110111.txt to Comm_*_20110110.txt
21:02  xerophyte: Tag_*_20110111.txt to Tag_*_20110110.txt
21:02  greycat: But POSIX says "Each occurrence in the input of an IFS character that is not IFS white space, along with any adjacent IFS white space, shall delimit a field, as described previously."  Which I'm still attempting to assimilate.
21:02  e36freak: and yet still removes the IFS character
21:03  greycat: POSIX doesn't say anything about read -a because that's a bash extension.
21:03  greycat: I guess I should be testing differently....
21:04  greycat: arc3:~$ (x=baro IFS=o; set -f; a=($x); printf "<%s> " "${x[@]}"; echo)
21:04  greycat: <baro>
21:04  greycat: oops.
21:04  greycat: wrong variable...
21:04  greycat: arc3:~$ (x=baro IFS=o; set -f; a=($x); printf "<%s> " "${a[@]}"; echo)
21:04  greycat: <bar>
21:04  pgas: ah ok, well, that doesn't cause me too much trouble. I find it quite normal for the last char not to define an empty field
21:05  greycat: I'm still trying to understand the words "delimit a field".
21:05  dualbus: xerophyte, mv 'Comm_*_20110111.txt' ' Comm_*_20110110.txt'
21:05  JacobF: how would I do this: sudo sh -c "echo `date -d '+ $@'`" I want $@ to be the arguments but the date command is saying it's getting '$@'
21:06  pgas: "Non-zero-length IFS white space"  I wonder what's a zero length whitespace :D
21:06  dualbus: JacobF, don't use single quotes
21:06  e36freak: while IFS= read -rd '' file; do mv "$file" "${file/20110111/20110110}"; done < <(find . -name "*Comm_*_20110111.txt" -name "*Tag_*_20110111.txt" -print0)
21:06  greycat: JacobF: throw it away and write something you can understand?
21:06  greycat: why the hell are you writing echo `foo` anyway?
21:07  JacobF: I am editing some code that will put my computer to sleep and wake it up in a certain amount of time, it all works except I want to be able to specify the time from the commandline instead of writing it in the file
21:08  greycat: sudo myscript.  inside myscript, use "$@" all you want.
21:08  greycat: there, solved.
21:08  Mike1: how can I find out how large (i.e. what the greatest index is) an array is?
21:08  dualbus: and instead of `` use $()
21:08  greycat: !faq 5 > Mike1
21:08  greybot: Mike1: http://mywiki.wooledge.org/BashFAQ/005 -- How can I use array variables?
21:09  e36freak: !pe > Mike1
21:09  greybot: Mike1: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
21:09  e36freak: !faq easily > JacobF
21:09  greybot: JacobF: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
21:10  xerophyte: dualbus: i that didn't work
21:10  xerophyte: actually i could not find the tested file :(
21:10  Florjan: Hello. Can you tell me how to null a command in bashrc. What I want to do is make command "history -c" null.
21:10  e36freak: wat
21:11  greycat: Florjan: nuke the file and then kill -9 $$
21:11  dualbus: then follow e36freak advice
21:12  Florjan: greycat I mean like alias "history -c"="/dev/null" so whenever user types that command nothing happens. But this doesn't work
21:12  greycat: I don't know what the fuck you're talking about.
21:12  e36freak: -_-
21:12  greycat: I'm pretty sure I'm happier not knowing.
21:12  e36freak: he wants to make it impossible to clear the history
21:12  greycat: Oh?
21:12  greycat: Is that what "history -c" does?
21:12  e36freak: that's what a gathered
21:12  e36freak: i**
21:12  greycat: !faq losing
21:12  greybot: http://mywiki.wooledge.org/BashFAQ/088 -- How can I avoid losing any history lines?
21:13  greycat: I thought he wanted the *opposite*.  I thought he wanted to prevent the user from ever being able to use history.
21:14  xerophyte: e36freak: thx
21:14  Florjan: No i wanted to prevent user from clearing it since it only writes into bash_history when session closes
21:14  Migaaresno: Why does my command line looks like this if i "cat ./bin_file"?: @MG-  $
21:14  nDuff: Florjan, the short answer is "you can't" -- the user can always clear history, even if history -c doesn't work
21:14  nDuff: Florjan, they can just unset HISTFILE and prevent anything from being written on session end
21:14  Florjan: nDuff i can alias all the variants :D
21:14  nDuff: ...no, you can't.
21:14  poisonbit: how do you alias an env var ?
21:14  nDuff: Florjan, function history() { if [[ $1 != -c ]] ; then command history "$@"; fi; }
21:15  pgas: Migaaresno: http://www.in-ulm.de/~mascheck/various/alternate_charset/
21:16  Florjan: nDuff what does the $@ do?
21:16  e36freak: !faq easily > Florjan
21:16  greybot: Florjan: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
21:16  e36freak: !args
21:16  greybot: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
21:17  poisonbit: Florjan, there is a "snoopy" app, that workarounds the "who did what" HIST issue for everyone but root (root can avoid it, it works using syslog).
21:18  poisonbit: http://sourceforge.net/projects/snoopylogger/
21:18  poisonbit: I used It 2 or 3 years and worked ok
21:19  Florjan: posionbit lemme guess bashloging? The headmaster wants his account to be excluded from loging
21:20  poisonbit: well it's opensource, maybe an "if" can solve that
21:21  Migaaresno: Thanks pgas, "reset" command fixed it for me.
21:22  poisonbit: Florjan, also using a remote syslog is a good addon to snoopylogger
21:23  poisonbit: or maybe it can be excluded using syslog configuration, at least rsyslog can
21:24  poisonbit: anyway i'm giving you "not a bash solution" to a "bash question" :)
21:24  e36freak: poisonbit: can often be the better way to go
21:29  nDuff: !$@ > Florjan
21:29  greybot: Florjan: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
21:30  nDuff: Florjan, ...that said, it should have been "builtin history", not "command history"
21:31  Florjan: nDuff we're fine as long as ppl that shouldn't delete command history can't do it
21:32  nDuff: Florjan, ...as I said before, this approach won't work against an attacker with any semblance of a clue.
21:32  stealthc: question, I am trying to get autostart to work on a thumbdrive, but I only want it to work for drives which my installer has installed data.  I would like to do a file comparision of the original autostart script as well as check a local file for a matching UUID and if it matches run the autostart script.  I'm thinking that a bash script would work if I can configure it to install one time via running a script on the thumbdrive, and t
21:32  stealthc: hen have a script run silently in the backround querying blkid to see if it detects a mounted thumbdrive to probe for the configuration.  I was wondering if I was on the right track with this or if anybody can think of any issues/improvements.
21:32  nDuff: Florjan, ...not just the specific command, but the general "disable history -c" approach is doomed
21:32  poisonbit: not only with HISTFILE... HISTCONTROL=ignorespace  # type commands starting by a space
21:33  Florjan: nope posionbit we got over that
21:33  greycat: !nabq > stealthc
21:33  greybot: stealthc: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
21:33  Florjan: we have a script that writes and chmods users bashrc so they can't write it
21:33  stealthc: this is not an os or hardware specific question
21:33  Florjan: they have a sourcedrc at top
21:34  greycat: stealthc: Yes it is.
21:34  Florjan: and our lines at bottom
21:34  nDuff: stealthc, it's certainly not a bash-specific one.
21:34  greycat: It is VERY much OS-specific.
21:34  nDuff: stealthc, and yes, "autostart" is OS-specific
21:34  greycat: So are "blkid" and anything involving UUIDs.
21:34  stealthc: yes autostart is but this is not autostart
21:34  Florjan: so our options are applied over user specific where needed
21:34  nDuff: Florjan, ...seriously, it won't work. Give me that jail and I'd be out of it in seconds.
21:34  greycat: Florjan: what prevents the user from terminating his shell with "kill -9 $$" so it doesn't write history, ever?
21:35  stealthc: ok by drive label and not necessarily using blkid then
21:35  greycat: stealthc: "drive label" is an OS concept.
21:35  nDuff: Florjan, what prevents a user from starting vim, and then running any commands they don't want to be logged from there? Or putting them in a makefile and running "make"? Etc. Doomed.
21:36  nDuff: stealthc, even if those things WEREN'T OS concepts, they're still not bash concepts either.
21:36  stealthc: no it isn't it's a file system specific concept
21:36  nDuff: stealthc, doesn't matter. They're not part of anything that ships with bash.
21:36  Florjan: only admins have the skill to do that on our server. so i'll leave that for future generations
21:36  poisonbit: env vars can be redeclared, they do not "live" only in bashrc
21:36  stealthc: lol I'll cut and paste the answer from the ubuntu specific room they'll say the same damn thing.
21:37 * nDuff is quite sure #ubuntu won't say it's a bash problem.
21:37  greycat: stealthc: If you can express your question as "I have a program that produces a data stream in *this format*, and I want to read it line by line and do *that* to it", then we're on topic.
21:37 * e36freak is fairly sure #ubuntu won't be able to give an answer
21:37  greycat: stealthc: if you do not have such a program producing a data stream to be parsed, then you need to start by GETTING that.
21:37  stealthc: ummm bash script considerations extend beyond that buddy
21:38  nDuff: *plonk*
21:38  greycat: stealthc: Then go write it.
21:38  stealthc: I do have such a program
21:38  nDuff: !plonk
21:38  greybot: The sound a name makes when it hits a kill file (or /ignore list).
21:38  greycat: OK, then you want to parse the output of this program?
21:38  greycat: !data
21:38  greybot: Show us the INPUT you're working with, and the OUTPUT that you want. Tell us where the INPUT is coming from (disk file, terminal input, curl URL). Tell us where you want the OUTPUT to go (disk file, stdout, terminal).
21:38  stealthc: it is very specific, I would just like to know if having a bash script running permanently in the background is cool
21:38  greycat: Yes.  It's fine.
21:39  stealthc: ok and what is the best way to configure a script to do that?
21:39  poisonbit: while true; do sleep 1; done  # sleep daemon
21:39  greycat: !pm > stealthc
21:39  greybot: stealthc: http://mywiki.wooledge.org/ProcessManagement
21:39  stealthc: thank you
21:39  greycat: "How to make my OS run something at boot" is NABQ.
21:39  greycat: Especially if that OS is ubuntu.
21:39  greycat: Because Ubuntu uses some fucking WEIRD boot shit.
21:39  greycat: That nobody else knows anything about.
21:39  e36freak: ubuntu uses some weird everything
21:40 --- i00nsu is now known as arumaniac
21:41  erUSUL: To be fair all linux distros ( except maybe slackware) are moving to something weird -- upstart or systemd
21:41  e36freak: this is true
21:41  greycat: "upstart" sounds like the name of that Ubuntu thing, IIRC
21:41  e36freak: but ubuntu compiles bash without readline for god's sake
21:42  greycat: and Debian compiles (compiled?) it without /dev/tcp support
21:42  greycat: because some random Debian person decided he didn't like it
21:42  e36freak: hahaha
21:42  ferret: "without readline"?
21:42  erUSUL: it is becouse bash sources come with its own copy; isnt' it. it does not link to system readline it integrates it statically
21:42  ferret: Surely you must mean statically against readline
21:42  e36freak: use libedit or something
21:42  e36freak: yes, that is what i meant
21:43  e36freak: sorry, improper term. but they don't compile it against readline, they use libedit for some dumb reason
21:45  JacobF: Is there a way to use a variable in backquotes exactly what's in the string, `$d` is adding backslashes before quotes in $d
21:45  greycat: !umq > JacobF
21:45  greybot: JacobF: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
21:45  greycat: x=`foo "$d"`
21:45  e36freak: !`
21:45  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
21:45  e36freak: x=$(foo "$d")
21:46  greycat: Sure, but it should only make a difference if foo or $d contains some backslashes....
21:46  NCS_One: where can I take some doubts about regexp?
21:46  greycat: NCS_One: ask a more specific question.
21:46  e36freak: NCS_One: "some doubts" ?
21:46  mattymo`: !faq
21:46  greybot: mattymo`: No matches found at http://mywiki.wooledge.org/BashFAQ
21:47  mattymo`: !<<<
21:47  greybot: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
21:52  NCS_One: greycat: http://pastebin.com/PkJJxNx4     how can I get what is inside tag <three> that is inside tag <one>, not the other that is out side of tag <one>?
21:52  greycat: Is this an XML/HTML parsing?
21:52  e36freak: !html
21:52  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
21:53  NCS_One: greycat: its a xml dump
21:53  greycat: Yup, confirmed on the paste site.  HTML-style tags.
21:53  e36freak: !regex
21:53  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
21:53  e36freak: NCS_One: wrong tool for the job. you're using a hammer to build a car
21:54  NCS_One: what do you recommend?
21:54  greycat: The bot just gave you a whole bunch of recommendations.
21:54  e36freak: above factoid
21:57 --- arumaniac is now known as i00nsu
21:59  NCS_One: greyca, e36freak: thanks
22:08  mattymo`: I'm trying to improve the speed of a script which gathers information, and it does so originally a=$(test1);b=$(test2);c=$test3, etc
22:08  mattymo`: I want to do {a=$test1}& ; {b=$test2}&  etc.. then wait;echo $a $b $c $d
22:09  mattymo`: but the variables appear to be empty
22:09  greycat: Dude... make sense.
22:09  krzie: you set them in subshells...
22:09  greycat: You appear to be switching between random broken syntaxes.
22:09  mattymo`: I'm pseudocoding :/
22:09  krzie: heh
22:09  mattymo`: ok that's the issue is the variable setting in subshells
22:09  mattymo`: how can I run a series of commands in the background in subshells, but make them available to the parent
22:09  greycat: If you want to capture the stdouts of MULTIPLE simultaneous background jobs, you must redirect those stdouts to FILES and then read the files afterward.
22:10  mattymo`: that's the answer I was looking for
22:10  greycat: (If you could guarantee that the outputs are tiny, you could also get away with named pipes, but... seriously, don't.)
22:11  krzie: also, that could be slower than otherwise
22:11  krzie: depending on how long the commands take and how fast your HDD is
22:11  mattymo`: the commands are related to network testing
22:11  mattymo`: so not hdd dependent
22:11  mattymo`: mostly are dependent on commands timing out
22:11  krzie: hdd dependant if you start outputting to files and then reading from them after
22:12  greycat: Disk speed is not really important here unless the files are enormous.
22:12  greycat: You'd generally expect a script's temporary files to be held entirely in RAM and deleted before the OS ever bothers to commit them to disk.
22:13  mattymo`: that's good to know
22:13  krzie: greycat, interesting
22:13  krzie: greycat, does 1 make a ramdisk for that, or is there a bash way to see to it that tempfiles are in ram?
22:14  greycat: I'm talking about the normal /tmp.
22:14  e36freak: mktemp
22:14  greycat: If you delete the file a few milliseconds after it's created, it'll never actually hit the hardware.
22:14  krzie: wow cool
22:14  mjg123: Hello Bash-ers.  Writing a bash script which asks user a question - how can I time how long they take to answer?
22:14  mattymo`: if I have several background processes output to a single file, should I expect the results to be out of order?
22:14  greycat: mjg123: depends on how much precision you need.
22:14  mjg123: greycat: 0.1 sec?
22:15  greycat: mjg123: you can use the $SECONDS variable if you only need second-precision
22:15  greycat: If you need sub-second precision you'll have to use some OS-specific tool.
22:15  mattymo`: time read
22:15  greycat: E.g. some OSs have a date command that can do sub-second.
22:15  mattymo`: that can work
22:15  greycat: Ah, right, time...
22:15  mattymo`: you only want the "real" entry
22:15  mjg123: time read  <--- prints timing info to stdout
22:16  mattymo`: yeah.. you can store it in a variable
22:16  greycat: !faq time
22:16  greybot: http://mywiki.wooledge.org/BashFAQ/032 -- How can I redirect the output of 'time' to a variable or file?
22:16  greycat: Actually, it does not write to stdout.
22:16  sh4rm4: how can you read from stdin in a nonblocking way ?
22:16  e36freak: you can give time a format, too
22:16  mjg123: to stderr?
22:16  e36freak: sh4rm4: var=$(cat) ?
22:16  greycat: sh4rm4: requires bash 4.0 and the "read -t 0" extension
22:16  e36freak: mjg123: read the factoid
22:16 --- taylanuc is now known as taylanub
22:17  sh4rm4: alright
22:17  greycat: sh4rm4: and you may or may not need to mess with stty.
22:17  krzie: e36freak, thx for mktemp, good manpage =]
22:17  sh4rm4: i guess i'd just write a C prog for that
22:18  Mike1: how can I test if a non-integer number is lower/greater than another non-integer number?
22:18  greycat: use bc or awk
22:18  greycat: !faq float
22:18  greybot: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
22:19  mjg123: well that's wicked.  Thanks
22:19  krzie: Mike1, you could subtract 1 from the other and use case to see if the result is negative or positive
22:19  krzie: (thats how i do it)
22:20  greycat: krzie: but you still have to use bc or awk to subtract 1 from a float.
22:20  Mike1: or zero if they are equal  good idea :)
22:20  krzie: ahh right, i got that from the factoid greycat linked to!
22:21  krzie: greycat, i didnt mean the numeral 1, i mean 1 float from the other, like you were saying
22:21  krzie: case "`echo "1.4 - 2.5" | bc`" in
22:21  krzie:       -*) echo "1.4 is less than 2.5";;
22:21  krzie:     esac
22:27 * greycat imports his cls alias from home to work.   cls is aliased to `tput clear; tput cup 99 0'
22:27  poisonbit: cls was dos
22:27  poisonbit: :)
22:27  bassliner: i=0; while true; do i=$((i+1)); echo -n ":-"; for i in $(seq 1 $i); do echo -n ")"; done; echo; sleep 1; done
22:27  greycat: Among others.
22:28  e36freak: greycat: nice
22:28  e36freak: !seq > bassliner
22:28  greybot: bassliner: seq(1) is a highly nonstandard external command used to count to 10 in silly Linux howtos. Use one of these instead: for x in {1..10} (bash3.x) or for ((x=1; x<=10; x++)) (bash 2.04+) or i=1; while [ $i -le 10 ]; do ...; i=$(($i+1)); done (ksh/POSIX)
22:28  bassliner: yeah i know :)
22:28  bassliner: hard to get rid of a decade-habit...
22:28  bassliner: and was just for fun :)
22:31  tty1: is there some way i can use shift on an array other than the parameters array?
22:31  greycat: No.
22:33  e36freak: restructure your algorithm :)
22:33  greycat: !slice
22:33  greybot: Some people use the word "slice" to mean "a contiguous set of array elements", as in "I want array elements 5 through 7". "${array[@]:5:3}" or "${@:5:3}"
22:34  e36freak: (yes, you can use variables in there for the numbers)
22:34  greycat: (yes, you can omit the second number to mean "infinity")
22:35  e36freak: greycat: off topic, but what docs would you recommend to pick up perl?
22:35  BenoitSvB: how to specify TIMEFORMAT= if I want to see the elapses time in minutes?
22:35  greycat: whatever #perl says
22:36  greycat: man bash, search for TIMEFORMAT, keep searching until you find the bit you want
22:36  greycat: Took me 3 "n"s.
22:37  BenoitSvB: from manual: %[p][l]R The elapsed time in seconds
22:38  BenoitSvB: The optional l specifies a longer format, including minutes, of the form
22:38  BenoitSvB: MMmSS.FFs.
22:38  BenoitSvB: I did:
22:38  e36freak: BenoitSvB: also a good bit of info on that in "man time"
22:38  BenoitSvB: TIMEFORMAT='%01R ....'
22:39  greycat: I would not use "man time" to try to understand bash's internal time.
22:39  BenoitSvB: and got an error
22:39  greycat: BenoitSvB: I though you wanted an l, not a 1.
22:39  greycat: longer, not 1onger
22:40  BenoitSvB: i see: it must be "l" not "1" ?
22:41  BenoitSvB: the copy/paste made it visible ;(
22:41  BenoitSvB: thnx for helping out
22:45  greycat: pgas: looks like Field Splitting with IFS non-whitespace stumped the mailing list...
22:48 --- cehteh` is now known as cehteh
22:48  e36freak: amusing
22:50  Cheat: Hi all
22:51  NCS_One: is there a better way of removing e.g. second line from a file other than this "sed '2d' myfile    ?
22:52  greycat: other than the minor little fact that that command doesn't actually alter the contents of a file?
22:52  NCS_One: yes, I know
22:52  nDuff: there's ed :)
22:52  taylanub: printf '%s\n' 2d wq | ed file  # one possibility
22:52  greycat: your basic choices are ed, perl, or GNU sed.
22:53  e36freak: that's what i would use, personally
22:53  greycat: I think you're supposed to use ed -s file or something
22:53  taylanub: ex is posix too (vi backend...)
22:53  NCS_One: e36freak: what?
22:53  e36freak: NCS_One: sed
22:53  greycat: well, actually your basic choices are ed, perl, GNU sed, or real sed with a temp file and mv.
22:54  greycat: !faq replace
22:54  greybot: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
--- Log closed Tue Jan 11 23:41:44 2011
--- Log opened Tue Jan 11 23:42:08 2011
23:42 --- Users 579 nicks [0 ops, 0 halfops, 0 voices, 579 normal]
23:43 --- Channel #bash was synced in 92 seconds
23:50  cthuluh: TheAlien: why are you setting the setuid bit on the directory? setgid is enough
23:50  cthuluh: and if you want httpd to be able to write to that directory, then you need 2775
23:52  mjg123: Can I make the "select" builtin be zero-based (ie options are 0 to 4 instead of 1 to 5)?
--- Log closed Tue Jan 11 23:58:11 2011
