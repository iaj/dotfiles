--- Log opened Sat Nov 20 13:48:31 2010
--- Log closed Sat Nov 20 13:48:46 2010
--- Log opened Sat Nov 20 13:49:18 2010
13:49 --- Users 522 nicks [0 ops, 0 halfops, 0 voices, 522 normal]
13:50 --- Channel #bash was synced in 82 seconds
13:58  cga: !heredocument
13:59  juanmabc: # document here
13:59  evalbot: juanmabc: bash: document: command not found
14:02  alek{xmb}{bottz}: heh
14:02  alek{xmb}{bottz}: schittie
14:04  cga: mmmm how can i redirect a here document with cat << EOF ....... EOF  to an external file?
14:05  trash: cga: cat > file <<
14:05  cga: thanks trash
14:06  alek{xmb}{bottz}: >>file kommand <<<hd
14:14  trash: Welcome to ignore again.
14:17  juanmabc: a trash that ignores people, hoho ^^
14:20  cga: trash: me?
14:20  trash: No, xmb.
14:20  cga: oh ok =)
14:25  alek{xmb}{bottz}: haha
14:25  alek{xmb}{bottz}: i own co much
14:30  poisonbit: Is there a way to run a code each time a new function is declared ?
14:33  alek{xmb}{bottz}: hmm
14:33  alek{xmb}{bottz}: yeah
14:33 --- Weust`afk is now known as Weust`
14:33  alek{xmb}{bottz}: with smart trap .. DEBUG code
14:34  alek{xmb}{bottz}: trap ' if funk_count++ then run funk' DEBUG
14:34  poisonbit: nice !
14:35  alek{xmb}{bottz}: yeah
14:35  alek{xmb}{bottz}: though
14:35  alek{xmb}{bottz}: u gotta expand the counter count
14:35  alek{xmb}{bottz}: kounter koud
14:35  poisonbit: I'm using /bion/bash, so maybe I can rely on  declare -F count
14:36  poisonbit: /bin/
14:37  poisonbit: this add procesing to ach cmd the script runs... but at least makes it posible
14:37  poisonbit: s/ach/each/
14:37  alek{xmb}{bottz}: yecsz
14:38  alek{xmb}{bottz}: i have always some debug koud
14:38  alek{xmb}{bottz}: laik
14:38  alek{xmb}{bottz}: # >>$echoes e !!
14:38  evalbot: alek{xmb}{bottz}: bash: $echoes: ambiguous redirect
14:38  alek{xmb}{bottz}: vgg
14:38  alek{xmb}{bottz}: yeah your grandma evalbotz
14:41  alek{xmb}{bottz}: poisonbit: check //xmb.root.pe/xf
14:46  poisonbit: alek{xmb}{bottz}, too much for my lemming status, yesterday night I drunked some... and today my brain/body is swapping
14:47  poisonbit: I see some interesting funcs there
14:49  geirha: I only see gibberish
14:49  ferret: That's because it is...
14:54  alek{xmb}{bottz}: yeah meit
14:54  alek{xmb}{bottz}: its koud
14:54  alek{xmb}{bottz}: ' kot'
14:55  geirha: Keep going, maybe you'll accidentally write an actual word
14:57  tmr: I are you provoking it? You'll just get same old crap flood sooner or later..
14:57  tmr: s/I/Why/
14:58  alek{xmb}{bottz}: heh
14:58  alek{xmb}{bottz}: wrait ac jyou spieak itcsz
14:58  alek{xmb}{bottz}: im a macter of sutsch
14:59  alek{xmb}{bottz}: or schpiik acsz jyouz wrait it, mor sthupid
15:00  geirha: Damn, you were right.
15:02 --- Weust` is now known as Weust`afk
15:03  alek{xmb}{bottz}: ahaha
15:04  alek{xmb}{bottz}: 016
15:04 --- Weust`afk is now known as Weust`
15:11  alek{xmb}{bottz}: whatcszownteh
15:19 --- Weust` is now known as Weust`afk
15:27  alek{xmb}{bottz}: where is b 0 nsai
15:27  alek{xmb}{bottz}: brenner
15:48 --- xx is now known as xy
15:59  poisonbit: is there other way to write?  var="$var more things"     ?
16:00  go|dfish: var+="more things"
16:01  poisonbit: that was... nice :)
16:01  go|dfish: !faq features
16:01  greybot: http://mywiki.wooledge.org/BashFAQ/061 -- Is there a list of which features were added to specific releases (versions) of Bash?
16:02  go|dfish: works in bash 3.1 and upwards ...
16:02  poisonbit: 3.1 is acceptable for my usage, thanks for the information
16:15  ron_: the guys at #sed are dead, can I ask my question here?
16:16  twkm: sure.  but i'll ignore it.
16:17  ron_: That's too bad
16:18  ron_: Anyway, how do I append "x" to lines ending with "y"?
16:18  ron_: wait nevermind
16:18  ron_: they woke up
16:18  geirha: ;P
16:19  twkm: the final part of their topic ... amazing.
16:25  ferret: [freenode] -!- #sed No topic is set.
16:26  twkm: -!- mode/#sed [+intf]
16:26  twkm: so check ##sed instead.
16:27  ferret: hm.
16:49 * hashashin nas
16:50  lonelyibex: hi,everyone
16:51  lonelyibex: how to find the position of a substring?
16:51  clyphox: i dont know what a substring even is lol
16:51  geirha: Why do you need the position?
16:52  lonelyibex: I tried expr index,but the result seems wrong
16:52  lonelyibex: expr index "hello,world" "world"
16:52  lonelyibex: give me 3
16:53  geirha: Well don't use expr
16:53  lonelyibex: geirha: cause I want to extract some string
16:53  TheBonsai: because "index" does what the documentation says
16:54  TheBonsai: the first index in the string where one of the characters occurs
16:54  geirha: How would the position of a substring help "extracting some string"?
16:54  lonelyibex: TheBonsai: oh
16:55  geirha: Bash can do everything expr can, and better, so don't use expr
16:56  lonelyibex: geirha: geirha : oh
16:56  TheBonsai: localhost2: what geirha means: flush your brain, forget that you wanted an index into a string, and tell us the whole story (i.e. why did you get the idea, that you need the index, what's its purpose)
16:56  TheBonsai: XY problem..
16:56  TheBonsai: likely
16:56  xy: what?
16:56  geirha: Yeah
16:56  geirha: !xy
16:56  greybot: http://mywiki.wooledge.org/XyProblem -- "I want to do X, but I'm asking how to do Y..."
16:56  TheBonsai: xy: :D
16:56  xy: oh... :D
16:57  lonelyibex: geirha: I want to extract some string in the html txt,html has many tag,so I need to locate some tag
16:57  TheBonsai: xy: we named a common newbie problem after your nickname, think about it :)))
16:57  geirha: lonelyibex: Then you want an htmlparser
16:57  geirha: !html
16:57  greybot: You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/001311.html
16:58  clyphox: +cat+grep+sed+xmlint
16:59  lonelyibex: TheBonsai: geirha : thanks
16:59  geirha: lynx is useful if you want to grab all the urls from the anchors
--- Log closed Sat Nov 20 17:05:14 2010
--- Log opened Sat Nov 20 17:05:40 2010
17:05 --- Users 537 nicks [0 ops, 0 halfops, 0 voices, 537 normal]
17:06 --- Channel #bash was synced in 84 seconds
17:08  lonelyibex: geirha: TheBonsai : awk can do the work,the result is just what I want
17:08  lonelyibex: echo "hello,world" | awk '{print index($0,"world")}'
17:08  lonelyibex: give me 7
17:08  TheBonsai: and what if the html is html'is correct but nothing you can parse?
17:10  lonelyibex: I'm a little confused
17:11  TheBonsai: xml syntax is relatively tolerant, no idea if you can catch all variants with your method
17:13  lonelyibex: oh
17:18  bolt: TheBonsai: think that might be the answer, yes
17:18 * bolt hates eval :(
17:20  geirha: Avoid indirection at all cost
17:21  TheBonsai: good advise
18:33  nick4: (Preferably a solution that works with sh) I'm trying to detect whether a USB stick is inserted. I'm checking whether the device exists but it fails: if [ -f /dev/sdd1 ]; then...
18:34  erUSUL: nick4: help test --> -f FILE        True if file exists and is a *regular* file. ( emphasis mine )
18:35  nick4: ohhhh
18:35  erUSUL: nick4: -b FILE        True if file is block special.
18:35  nick4: ahhhhh :D
18:35  nick4: thanks :)
18:35  nick4: is that the "orthodox" way of checking whether a USB stick is inserted?
18:37  erUSUL: nick4: well; usb stick do not get persistent device names; not in linux anyway
18:37  nick4: that's true
18:37  erUSUL: nick4: why it it gets /dev/sde1 instead?
18:37  erUSUL: what if it ...
18:38  nick4: erUSUL I actually have a list of typical node names the USB stick "assumes" on my PCs. But it's a hack! I'm open the suggestions.
18:39  erUSUL: nick4: why not use an udev rule that runs whatever you want to run when the device is inserted?
18:40  nick4: I don't know how to do that. I can of cource google it, but a link would be very helpful. Also, it's a simple script that resides in a dir on ~, just checking whether is gets run from the Stick or the home dir and syncs a bunch of text files.
18:43  erUSUL: nick4: why not check mount point? this days udisk etc... should give stable mount points based on uuid or filesystem labels
18:43  nick4: oh
18:44  nick4: well, I've.... I'll think about it :)
18:57  catsup: i have a pipeline that looks like a|b|c.  when c() detects an error in its input, i want to kill the whole pipeline and exit the script.  but b() runs forever.  so how do i do it?
18:59  twkm: b will die when it tries to write stdout.
19:00  taylanub: b should die from a 'broken pipe' signal when c terminates
19:00  catsup: but only if it keeps writing, right?
19:01  geirha: Try  c < <(a|b) instead
19:01  geirha: When c dies, it'll bring down a and b with it
19:02  catsup: hmm
19:03  catsup: geirha: that works great, but it's a bashism :/
19:03  catsup: i'll see if i can get it working the other way too
19:03  catsup: but thanks guys :)
19:04  geirha: Here in #bash we assume you're scripting bash unless you say otherwise
19:04  catsup: well, i am, but so far this script should theoretically run in standard shell
19:05  catsup: i may or may not leave that #!/bin/bash in there, at this point
19:05  geirha: Use a fifo then
19:06  geirha: a|b > fifo & pid=$!
19:07  geirha: c < fifo || kill $pid
19:08  taylanub: in that case, c would exit nonzero on the erronous input, i guess
19:08 --- Weust`afk is now known as Weust`
19:09  taylanub: if c is a shell function or so, it could also internally kill $pid
19:16  catsup: hm.  no luck so far on the broken pipe approach.
19:17  nongol: is there a way to send a string of input into stdin of a command without having to first press enter and start typing?
19:18  nongol: (trivial) example, if I want to put "hello world" into a file using cat...can I do it all as one command, not having to do cat > file, hit enter, then type hello world, then Ctrl-D    ?
19:18  Riviera: echo "hello world" | cat > file
19:18  Riviera: cat <<< "hello world" > file
19:18  catsup: nongol: i think you're looking for the 'read' builtin
19:19  nongol: awesome, does <<< mean send stdin straight to that command?
19:19  Riviera: No.
19:19  Riviera: A command that reads from stdin reads from stdin, not the shell's business.
19:20  catsup: <<< causes stdin to be magically manifested from argument on the command line
19:20  geirha: !<<<
19:20  greybot: Here strings. Similar to here documents: The word after <<< and a newline are passed to the standard input of a command. Syntax: ''command <<< "some sentence"'' (Like ''echo "some sentence" | command'', but without the overhead of the subshell)
19:20  catsup: nongol: the behavior you want wrt reading stdin requires the terminal settings to be changed.  'read' will do that for you
19:21  catsup: ('cat' won't)
19:21  Riviera: What. 8)
19:21  nongol: that's great, that's what I wanted, I was just being imprecise when I asked if it sent stdin into the command
19:21  nongol: <<<
19:21  catsup: oh
19:21  nongol: thanks
19:21  catsup: nongol: you can just use 'echo' you know
19:22  catsup: echo 'hello world' > file
19:22  taylanub: it was an example case i guess
19:22  nongol: yeah just an example
19:22  catsup: heh, well i still don't know what you're trying to do, but it doesn't matter
19:23  nongol: I'm trying to use base64 to ASCII-sanitize gpg-encrypted data so I can encrypt inline in a text-editor
19:23  nongol: but I need to write a plug in for the editor so I need to be able to send atomic exec commands to do everything needed for base64 and gpg
19:25  alek{xmb}{bottz}: riv hai
19:25  geirha: nongol: Uhm. Why don't you just ascii armor the pgp?
19:25  catsup: but <<< doesn't do anything echo can't...
19:25  geirha: gpg --armor iirc
19:25  nongol: word, I didn't know about that option
19:26  ferret: # cat <<<'-e'
19:26  evalbot: ferret:
19:26  ferret: o.o
19:26  geirha: What?!
19:26  catsup: heh
19:26  ferret: yeah, about that
19:26  taylanub: catsup: it does. it prevents a subshell being opened that normally happens when a pipe is used
19:26  geirha: # cat <<< -e \t
19:26  evalbot: geirha: cat: t: No such file or directory
19:26  geirha: # cat <<< '-e \t'
19:26  evalbot: geirha: -e \t
19:27  ferret: erm
19:27  ferret: this is a massive bug
19:27  catsup: ok, then printf
19:27  geirha: 4# cat <<< '-e'
19:27  ferret: 4# cat <<<'-e'
19:27  shbot: geirha:
19:27  shbot: ferret:
19:27  geirha: hehe
19:27  geirha: 2# cat <<< '-e'
19:27  shbot: geirha:
19:27  taylanub: catsup: you mean me? it's the same as long as you use a pipe
19:27  ferret: it works fine on my system's bash 4
19:28  geirha: same here
19:28  ferret: 4# cat <<<'-e '
19:28  shbot: ferret: -e
19:28  geirha: 4# echo "$BASH_VERSION"
19:28  shbot: geirha: 4.0.33(1)-release
19:28  geirha: Maybe it got fixed in 4.1
19:28  catsup: taylanub: it may be more efficient, but that's not what i'm talking about
19:28  ferret: catsup: I was going to be smart and say it was something <<< could do that echo couldn't
19:28  ferret: but turned out that that wasn't the case :D
19:29  taylanub: catsup: not only efficiency... watch it:
19:29  taylanub: # printf '\n\n\n' | while read line; do i++; done; echo $i
19:29  evalbot: taylanub: bash: i++: command not found
19:29  evalbot: taylanub: bash: i++: command not found
19:29  evalbot: taylanub: bash: i++: command not found
19:29  taylanub: damnit :P
19:30  taylanub: # printf '\n\n\n' | while read line; do i=$((i+1)); done; echo $i
19:30  Riviera: # i+=1; echo $i
19:30  evalbot: taylanub: no output
19:30  evalbot: Riviera: 1
19:30  catsup: oh yes, that's a good point
19:30  Riviera: Mine? Not really :)
19:30  catsup: taylanub's
19:30  Riviera: Good :)
19:31  catsup: except uh
19:31  catsup: how do you produce the newlines in <<<
19:32  taylanub: use a here-doc instead perhaps...
19:32  taylanub: which is uglier though
19:32  catsup: (all you need though for your example is 'read a <<<abc')
19:32  taylanub: or you can stuff it into a variable first
19:34  ferret: # cat <<<$'one\ntwo'
19:34  evalbot: ferret: one
19:34  evalbot: ferret: two
19:34  taylanub: ah, nice
19:34  ferret: or use a pipe from printf
19:34  taylanub: which is what we try to avoid in first place :P
19:35 --- taylanub is now known as joeNub
--- Log closed Sun Nov 21 18:48:51 2010
