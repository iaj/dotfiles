--- Log opened Sun Nov 21 18:48:51 2010
--- Log closed Sun Nov 21 18:48:54 2010
--- Log opened Sun Nov 21 18:49:13 2010
18:49 --- Users 534 nicks [0 ops, 0 halfops, 0 voices, 534 normal]
18:49  paissad: when i do set -x; echo $version, here is what i have
18:49  paissad: 2k4-0
18:50  paissad: in the script , after doing version=$(echo $version | tr '-'  '_'), here is what i have
18:50  trash: Use PE for that.
18:50  paissad: echo $'2k4_0\302\240
18:50 --- Channel #bash was synced in 78 seconds
18:50  paissad: i don't know where \302\240 come from
18:51  poisonbit: # version='2k4-0'; echo "${version//-/_}"
18:51  evalbot: poisonbit: 2k4_0
18:51  paissad: but it does break my script
18:51  Tekk_: how do I check if a command has no output?
18:51  trash: Tekk_: Why?
18:51  trash: What command?
18:52  Tekk_: trash: well I'm using dwm, which you can really only modify by changing the source
18:52  paissad: poisonbit,  i use to use tr, but what's the reason why i get that weird character ?
18:52  paissad: trash, what do you mean by PE ?
18:52  Tekk_: so I have a file set in a while loop that right now will start dwm every second, which then shuts down cuz there's already a wm working
18:52  trash: paissad: What poisonbit said.
18:53  Tekk_: so right now I'm trying ps aux | grep [d]wm, but I need to know how to check if there's no output(IE restart dwm)
18:53  trash: Tekk_: while ! pgrep; do dwm; dwm; done
18:53  trash: pgrep dwm*
18:54  Tekk_: thanks
18:54  paissad: do you know why i got that weird char, so that i try to avoid such troubles in the future ?
18:54  poisonbit: which weird char?
18:54 --- kermit is now known as kermit__
18:55  poisonbit: something in  2k4-0 ? how should it look ?
18:55  paissad: poisonbit, \302\240
18:55  Tekk_: trash: that's spitting out pgrep: unexpected operator
18:56  trash: Tekk_: What's your exact code?
18:56  Tekk_: line was if [ ! pgrep dwm ]; then
18:56  trash: Where did I say if or even [?
18:56  Tekk_: you don't need the [?
18:56  Tekk_: and the if is executed in a loop already runnign
18:56  trash: Not at all.
18:56  trash: !ifgrep
18:56  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
18:57  paissad: poisonbit, after the use of sed or tr, i get "aaa " instead of  "aaa"  and that "space" is actually \302\240 (that's what i see when i user set -x)
18:57  Tekk_: thanks
18:58  poisonbit: paissad, ouf, no idea unless you're touching $IFS
18:58  paissad: no i did not !
18:58  paissad: thanks anyway
18:58  trash: paissad: Show us a real reproduceable test case.
18:58  trash: (and a minimal one)
19:01  paissad: trash, http://dpaste.com/278096/
19:01  paissad: trash, the 1st echo is ok
19:02  paissad: but the 2nd one shows the contents of $version and \302\240
19:02  trash: ;Looks fine here.
19:02  poisonbit: in my term shows equal both echos
19:03 --- kermit__ is now known as mavs
19:03  poisonbit: paissad, it seems a terminal/encoding issue ?
19:03  paissad: poisonbit, that's that i think ^^
19:04 --- mavs is now known as kermit
19:11  Sereph: http://pastie.org/private/pwxildzkauqgn7qif2q this is causing the error to print even though the directory copyedTorrents is empty, what have I done wrong?
19:20  edoreld: How would I go about renaming a bunch of lines inside a text file? The goal is to alter the same number in several lines (foo000bar, foo000bar, etc) so they are presented sequentially (foo000bar, foo001bar, etc). Thanks.
19:32  catsup: edoceo: i=0; while read line; do s=$(printf %.3d $i); echo ${line/foo000bar/foo${s}bar}; let i++; done
19:57 --- Muzer is now known as MuzerAway
19:59  edoreld: How would I go about renaming a bunch of lines inside a text file? The goal is to alter the same number in several lines (foo000bar, foo000bar, etc) so they are presented sequentially (foo000bar, foo001bar, etc). Thanks. (Got disconnected before and missed any possible answers :/)
20:00  davidmogar: hello. How can I get the content of a file except the first 4 lines?
20:03  poisonbit: davidmogar, you can hack on the faq1 of the /topic FAQ to make a pure bash implementation, or use tail or head   ( tail -n -4 file)
20:06  go|dfish: edoreld: this might be good enough for you, perl -pe 's/(\d+)/sprintf "%03d", $i++ + $1/e' file
20:06  davidmogar: poisonbit: tail -n -4 file shows the last 4 lines
20:07  poisonbit: tail -n +4 then
20:07  davidmogar: vale, ya
20:07  davidmogar: no
20:07  poisonbit: or bash builtins
20:07  davidmogar: aunque igual si
20:07  poisonbit: # printf '%s\n' 1 2 3 4 5 > file; count=0; while read -r line; do ((count > 3)) && echo "$line"; ((count++)) ; done < file
20:07  evalbot: poisonbit: 5
20:08  edoreld: @go|dfish thanks
20:08  itr8r: also: sed '1,4d'
20:14  wald0: I need to create a function that gets the result of the previous command, for example:  foo(){ echo "result is $?" ; } ;  true ; foo ; false ; foo
20:14  wald0: mmh, it simply worked
20:14  wald0: nm
20:19  wald0: the command "false" returns an exit code "1", how i can generate an exit code for example "2" ?
20:24  falconindy: wald0: you can just 'return 2' in a function
20:26  Sereph: http://paste.org/pastebin/view/25137 this is causing it to error saying abandoned files even though the directory copyedTorrents is empty, what did I do wrong?
20:30  falconindy: Sereph: line 28 doesn't do what you want it to
20:31  Sereph: falconindy: what can i do to fix that?
20:31  falconindy: Sereph: assuming that your goal is to pass the result of the glob expansion to filesExist, get rid of the [ ]
20:31  Sereph: wald0: return 2
20:32  Sereph: http://paste.org/pastebin/view/25137 like this?
20:33  falconindy: that would be the same paste
20:33  Sereph: i changed it
20:33  falconindy: looks the same to me
20:33  Sereph: i removed the []
20:33  Sereph: on line 28
20:33  falconindy: does it work?
20:33  Sereph: different error
20:33  Sereph: rsync: link_stat "/home/tyler/Downloads/Resident Evil Afterlife.2010.R5.XviD.AVI.49296.torrent" failed: No such file or directory (2)
20:33  Sereph: rsync error: some files/attrs were not transferred (see previous errors) (code 23) at main.c(1060) [sender=3.0.7]
20:34  Sereph: and it seems to have removed them how nice
20:35  Sereph: no wait it moved them to copyedTorrents like i wanted
20:35  Sereph: now the question is why did it mess up
20:36  Sereph: falconindy: do you see anything wrong the first function
20:36  falconindy: rsync would know better than i would
20:38  falconindy: your filesExist could be a oneliner
20:38  falconindy: as could cleanup
20:39  Sereph: syncfiles shouldnt be moving it if rsync reports an error code..
20:39  Sereph: right?
20:39  falconindy: depends on the exit status of rsync
20:39  Sereph: isnt that (2) the status
20:40  falconindy: if that's what the manual says
20:41  Sereph: ok now its syncing them but not running cleanup
20:42  Sereph: can bash ask for input
20:42  falconindy: help read
21:10  {aaron}: hi guys, i'm having trouble getting an env variable set for an SSH command.  i know that they are not transferred over the connection, so i am trying to explicitly set one like:
21:10  {aaron}: ssh user@host 'FOO=BAR echo $FOO'
21:11  {aaron}: i've also played with `env' to no luck
21:11  {aaron}: i can echo existing vars for the remote user...i'm wondering if setting env is restricted, maybe restricted shell or something
21:14  poisonbit: ssh infinity 'FOO=BAR; echo $FOO'
21:15  poisonbit: just the ';' did it
21:15  poisonbit: ^^ {aaron}
21:16  {aaron}: ok i'll give it a shot, thanks
21:16  zumbi_: hi - how should i read/parse a file like fstab with a shell script? (skipping comments (#) and read a line and parse it)
21:16  poisonbit: as well as without ssh, the same
21:16  poisonbit: zumbi_, see faq1 in /topic FAQ
21:18  {aaron}: interesting... i think i've seen instructions that say to prepend vars (without ;). i usually explicitly export them myself
21:21  go|dfish: you can do that, but expansion happens before assignment
21:21  go|dfish: which is why FOO is empty in your case
21:23  {aaron}: ahh
21:23  valajbeg: what does "export" do by default, i can't understand the definition in bash reference?
21:23  valajbeg: does it just set  following $variable?
21:23  valajbeg: or something more than just that
21:23  valajbeg: ?
21:24  poisonbit: "help export"  makes a more acurate description that i can make
21:24  valajbeg: ok thnx
21:25  valajbeg: what is the different between exported variables and environment variables?
21:25  valajbeg: *global environment?
21:27  poisonbit: "NAMEs are marked for automatic export to the environment of subsequently executed commands."
21:27  poisonbit: your shell can have some environment variables at start, you can export more for your childs
21:28  valajbeg: childs = programs that i start from shell?
21:28  poisonbit: yup
21:28  valajbeg: ok
21:28  valajbeg: thank you
21:28  valajbeg: poisonbit,
21:28  dmarkey: grep nameserver /etc/resolv.conf | read nameserver ## should this work?
21:28  poisonbit: valajbeg,  n.p. i'm not very good at explaining :)
21:29  poisonbit: nameserver="$(grep nameserver /etc/resolv.conf)"
21:29  poisonbit: dmarkey, but there can be multiple nameservers, why don't use a list ?
21:29  dmarkey: poisonbit: its just an example, i wonder why "| read (variable) " doesnt work
21:30  dmarkey: its it because its executed in a subshell?
21:30  go|dfish: yes
21:30  poisonbit: | while read...
21:30  poisonbit: ?
21:34  zumbi_: poisonbit: thanks, faq#1 is very helpful, but how to avoid comment (#) lines, should i detect it within my script?
21:36  poisonbit: [[ "$line" =~ ^# ]] && continue
21:36  geirha: [[ $line = \#* ]] && continue
21:38  poisonbit: # line="#fooo"; [[ $line =~ ^# ]] && echo MATCH
21:38  evalbot: poisonbit: MATCH
21:38  poisonbit: geirha, is wrong ?
21:38  catsup: probably for comments you want line=${line/#*/}; [ -z "$line" ]
21:39  zumbi_: # line="foo #bar"; [[ $line =~ ^# ]] && echo MATCH
21:39  evalbot: zumbi_: no output
21:39  catsup: although, then what about escaped #'s
21:39  catsup: better use bison :p
21:42  zumbi_: poisonbit: anyway, thanks, i think that will do :)
21:44  poisonbit: inline comments are difficult to difference from # chars in code
21:46  poisonbit: an line comments are difficult to difference from HEREDOCS
21:53  geirha: poisonbit: Not wrong, I just prefer globs over regexes.
21:54  poisonbit: ah :)  as I use to fail, asked just in case
22:26  knaveofclubs: I just looked at man head and there are options like -n and -b but still I can't find one that matches 'head -9'.
22:27  knaveofclubs: What's 'head -9'? Number of lines from the beginning?
22:28  knaveofclubs: It's the number of lines, but I can't see one of the options in the man-page to match..
22:29  taylanub: probably a non-standard feature
22:29  taylanub: GNU coreutils? same here
22:29  knaveofclubs: I would have to use something like '-c <number of lines>'
22:30  knaveofclubs: Yeah
22:30  knaveofclubs: But it's just there without the '-c'
22:30  taylanub: stands for -n
22:30  taylanub: i.e. -X = -n X
22:30  taylanub: really not in the manpage apparently
22:30  knaveofclubs: Oops, meant -n
22:30  taylanub: yeah
22:31  poisonbit: http://www.openbsd.org/cgi-bin/man.cgi?query=head&apropos=0&sektion=0&manpath=OpenBSD+Current&arch=i386&format=html
22:31  poisonbit: -count | -n count
22:33  poisonbit: openbsd man pages use to have very good quality, but nowdays that does not count too much in internet meritocracy. Tha worlz is turning lunix x86 or amd64 + adobe flash,  slowly
22:33 --- MuzerAway is now known as Muzer
22:34 --- cuba33ci_ is now known as cuba33ci
22:34 --- y3llow_ is now known as y3llow
22:37 --- Muzer is now known as MuzerAway
22:50  xiong: Is there any way in which I can alter file globbing or introduce new syntax to it?
22:51  jsquared: Is there a way using builtins to say "rename files a.foo, b.foo., c.foo to a.foo.bar, b.foo.bar, c.foo.bar respectively"?
22:51  ferret: xiong: yes; it requires changing bash
22:51  ferret: luckily you don't need to, though
22:52  xiong: ferret, I don't know how far I'm prepared to go with this but I feel a strong need. What's the straightforward solution?
22:52  ferret: jsquared: for file in *.foo; do mv "$file" "$file.bar"; done
22:52  ferret: mv isn't a builtin though
22:53  xiong: jsquared, Not sure how strictly you intend "builtin". There's always the rename command.
22:53  ferret: if you really want to do it with just builtins then it is impossible unless you are sure none of the files contain NUL bytes
22:53  ferret: (actually even that is a lie, it's just a bit tricky)
22:54  ferret: xiong: there isn't one
22:54  ferret: xiong: what you need to do is state the actual problem, and then likely it turns out that bash can already do it without any mucking about
22:54  xiong: Well, ferret, okay. Tell me what you were thinking of, when you said I don't need to do this.
22:55  ferret: well, either extglob or one of the similar options can do it, or what you want to do is stupid
22:55  ferret: one of those is sure to be the case
22:55  xiong: I've worked at this from a few different angles. If I'm willing to do enough typing, I can get the desired effect without writing any new code, I agree.
22:56  xiong: The actual problem is integrating 'tracker' with the shell. It's a nice backend but has almost nothing in the way of actual usability, either CLI or GUI.
22:57  ferret: no idea what that is
22:57  xiong: One moment, I'll link.
22:57  ferret: Couldn't you just say what it is?
22:58  xiong: https://wiki.ubuntu.com/Tracker
22:59  xiong: Sure. But I believe in linking. It's obnoxiously difficult to search for, though, because the name is too common. \
22:59  xiong: Basically, it's a metadata database.
23:00  xiong: It's one of the very few solutions I've seen for applying user tags to a file. See stuff like trackerd, tracker-tag, etc.
23:01  xiong: So, for example, in theory, one could write, oh, $ somecommand "$(tracker-tag -s mytag)" -- but this won't actually work, because tracker-tag outputs messy. That can be fixed, of course.
23:03  xiong: ferret, It's a matter of opinion, not fact; but I say that anything like "$(tracker-tag -s mytag)" is a knucklebuster if I intend to do it constantly. I'm looking to improve the syntax to #mytag -- optimally.
23:04  xiong: I'll tolerate a private solution but of course, it would be nice if it could be made public without too much disruption, for those willing to get into it.
23:06  xiong: So, the ideal solution, in my mind, is to extend file globbing to expand #mytag to files tagged with mytag.
23:07  xiong: Obviously, this causes problems with files that have leading #. I don't see a way around that, except to not name files that way.
23:11  xiong: ferret, Did I make sense? Am I overlooking the obvious?
23:11  wdp: hey, i want to add zeros to a number - numbers are from 1 to 99 - if its 4 i want 04, how to do that?
23:12  wdp: or better: how can i see the length of an int or string? :)
23:15  Bushmills: # printf '%02d' 2
23:15  evalbot: Bushmills: 02
23:15  wdp: ty
23:16  Bushmills: # var="foobar"; echo ${#foobar}
23:16  evalbot: Bushmills: 0
23:16  Bushmills: ehm
23:16  wdp: heh
23:16  Bushmills: # var="foobar"; echo ${var}
23:16  evalbot: Bushmills: foobar
23:16  Bushmills: # var="foobar"; echo ${#var}
23:16  evalbot: Bushmills: 6
23:16  Bushmills: finally
23:18  bpo: how can I detach a process from a tty? I don't just want nohup, and disown doesn't seem to do what I want. I'd like the output of 'ps -a' to reflect no controlling tty.
23:18  bpo: https://gist.github.com/709210
23:24  qubit: is there a way to make the bash history file 'live'? As in you type a command and its instantly in the history file? I want to have syslog-ng monitor the history file and log to our central server every command that gets run as its run (auditing purposes)
23:35 --- qubit_ is now known as qubit
23:36  replay: qubit, might help http://www.theillien.com/Sys_Admin_v12/html/v15/i04/a9.htm
23:38  qubit: replay: ya, but none of that alleviates the problem that the history file only gets written to when the shell exits
23:38  qubit: I'm thinking i'll just create a debug trap and have the trap call `logger`
23:43  replay: qubit, logging every command is an overkill don't you think?
23:44  qubit: replay: no, this is only going to be for the root account, which doesnt get used much
23:45  qubit: besides, our syslog server takes in about 2k messages a second, whats 10/s more? :-)
23:45  replay: qubit, w/e you have set up, won't a root user be able to remove it?
23:46  qubit: replay: ahh, see, with recording every command as it happens, i'll be able to capture the command that removes it
23:48  replay: qubit, don't trust your root users?
23:48  qubit: replay: i dont trust them to not make mistakes
23:49  replay: qubit, won't it be easier to give them 'some' root privileges with sudo?
23:49  qubit: replay: everyone already has sudo access. but sometimes people flip over to root when they have to do a lot of stuff
23:50  manhunter: val="hihello" ;echo "This is "${hihello}"" ,is this correct? or this is better,echo "This is ${val}" ,why is " " used? ,isn't enough ? echo "This is $val"
23:50  Knirch: !${}
23:50  greybot: Curly-braces in parameter expansions are used when the parameter name is ambiguous: "${foo}bar", "${foo[1]}". They are not necessary for normal PEs (eg. "$foo"). They are no replacement for quoting. echo ${line} is BROKEN. (use echo "$line" or "${line}")
23:51  qubit: and if your goal is to print out the quotes around the var, you need to escape them '\"'
23:51  replay: qubit, if they make a mistake, it'll become apparent, even if you logged it the damage will already be done.
23:51  qubit: (when double quotes are used within double quotes)
23:51  qubit: replay: ah, but i'll be able to find who made the mistake and when
23:51  manhunter: qubit: ok,but is this correct? echo "This is "${val}""
23:52  qubit: no
23:52  Knirch: manhunter: no
23:52  manhunter: qubit: why?
23:52  qubit: I just told you
23:52  Knirch: it makes no sense
23:52  qubit: and if your goal is to print out the quotes around the var, you need to escape them '\"'
23:52  manhunter: Knirch: why?
23:52  manhunter: qubit: my goal is not printing double quote
23:52  qubit: then dont put them in there
23:52  Knirch: "quoted string"$unqoutedvariable"<nothing here, but it's quoted>"
23:53  manhunter: qubit: so you are suggesting this? echo "This is ${val}"
23:53  qubit: manhunter: yes
23:53  Knirch: manhunter: echo "this is a $var"
23:53  qubit: or that
23:53  Knirch: !${} > manhunter
23:53  greybot: manhunter: Curly-braces in parameter expansions are used when the parameter name is ambiguous: "${foo}bar", "${foo[1]}". They are not necessary for normal PEs (eg. "$foo"). They are no replacement for quoting. echo ${line} is BROKEN. (use echo "$line" or "${line}")
23:54  manhunter: qubit: why is it broken ? echo ${line}
23:54  qubit: manhunter: I just said thats fine
23:54  qubit: (the earlier one, not that)
23:54  manhunter: qubit:  ${line} is BROKEN. (use echo "$line" or "${line}")
23:55  qubit: yes
23:55  manhunter: qubit: greybot says this is boken
23:55  qubit: `echo "$line"` and `echo "${line}"` are both perfectly valid
23:56  manhunter: qubit: are those similar? echo "${line}" and echo "Result: ${line}" ,
23:56  qubit: manhunter: those are both perfectly valid as well
23:56  manhunter: both are encapsulated with double quote
23:57  qubit: Knirch was saying that the curly braces are un-needed, which they are, but they dont hurt anything
23:57  manhunter: qubit: when do we need {} ? when is it ambiguous? any example?
23:57  Knirch: !${} > manhunter
23:57  greybot: manhunter: Curly-braces in parameter expansions are used when the parameter name is ambiguous: "${foo}bar", "${foo[1]}". They are not necessary for normal PEs (eg. "$foo"). They are no replacement for quoting. echo ${line} is BROKEN. (use echo "$line" or "${line}")
23:57  Knirch: has the example right there
23:57  qubit: think of `FOO="asdf" echo "$foobar"` vs `FOO="asdf" echo "${foo}bar"
23:59  qubit: I personally throw the curly braces on everything. makes it easier to read and prevents accidents
23:59  manhunter: how is ${foo} assigned to bar?
23:59  Knirch: I tend to remove them, people not used to bash seems to think they offer protection
23:59  manhunter: echo "${foo}bar" prints bar
--- Log closed Mon Nov 22 00:00:06 2010
