--- Log opened Tue Nov 16 00:00:06 2010
--- Day changed Tue Nov 16 2010
00:00  ksk: thanks :)
00:00  ksk: my script works. just wanted to know if there are "better" ways to do it. thanks for the related faq
00:01  nDuff: *nod*. Generally speaking, read is considered the Right Thing.
00:02  ksk: its a minecraft wrapper btw ,)
00:15  Tunix: On the channels that you must be invited to, how do you obtain an invitation?
00:16  erUSUL: Tunix: you have to get someoen from the chan that can ( an op probably ) to invite you
00:18 --- mar77i_ is now known as mar77i
--- Log closed Tue Nov 16 00:34:56 2010
--- Log opened Tue Nov 16 00:35:14 2010
00:35 --- Users 543 nicks [0 ops, 0 halfops, 0 voices, 543 normal]
00:36 --- Channel #bash was synced in 86 seconds
00:49  pozican: Can you rm files under a mount point?
00:50  pozican: without umouting
00:50  nDuff: pozican, that's a question about your OS, not about the bash shell
00:50  pozican: fair enough.
00:50  nDuff: pozican, that said, if your OS is linux, yes -- use a bind mount to get access. And next time direct such questions to ##linux
00:51  cthuluh: hmmm
00:52  nDuff: ie. if you want to delete /var/spool/* on the root filesystem (as opposed to the filesystem mounted on /var), mount -o bind / /mnt && rm -rf /mnt/var/spool
00:55 * cthuluh wonders how this would be useful
00:57  pozican: well, some stupid workflow at my company ends up with trash files under a mount point
00:58  pozican: some kid wrote a script that didn't check to see if a mount actually umount'ed before rm -rf'ing
00:58  pozican: so I'm trying to find all the ways he could have prevented
00:58  pozican: I'm up to 3-4
00:58  pozican: I mean bash supports return codes, so it should have been piss easy
00:58  pozican: instead of deleting 35T
01:02 --- jzacsh_ is now known as jzacsh
01:08  FruitBasket: Using alt-arrow is defined in inputrc to word advance/backward. In the console, however, it changes the active tty.. what should I look for to fix that?
01:10  cthuluh: sounds like a linux console "problem", maybe should you ask in ##linux?
01:11  FruitBasket: sigh.. keymaps i386/include/linux-keys-bare.inc defines it.
01:12  pozican: you can remap it with some binaries somewhere depending on your distro IIRC
01:12  FruitBasket: ... mayb enot.
01:12  FruitBasket: yeah. "alt kycode 105" -- Decr_Console.
01:14 * FruitBasket should really go through those files sometime and see what he can do :-)
01:21  cthuluh: FruitBasket: you should be able to change them, loading a custom keymap with loadkeys
01:21  FruitBasket: bleh.. custom keymap..
01:29  cthuluh: works pretty good here
01:39  pozican: I need to do a chown on every directory named .svn under a specific directory recursively - Is there a slick way to do this?
01:42  cthuluh: !find
01:42  pozican: I guess I just need to find all the directories under the current directory
01:42  greybot: http://mywiki.wooledge.org/UsingFind
01:42  pozican: ha
01:42  likewhoa: pozican: find /src -type d -name .svn -exec chown 600 {} \;
01:43  likewhoa: ugh i read chmod.
01:43  pozican: no worries
01:43  pozican: I know how exec works  :D
01:43  k\-: \*.svn ??
01:43  pozican: I'm unsure why I've always found find so complicated
01:43  likewhoa: pozican: you was shy?
01:44 * k\- is confused about the for command
01:44  pozican: I think I'm just scurred
01:44  likewhoa: same thing
01:44  k\-: s/command/loop/
01:44  pozican: k\-: Do you need help with the for command? THAT i understand!
01:44  pozican: sometimes I use "help for" to assist with the syntax, but I"m over that now
01:45  k\-: well it's the "for NAME ; do COMMANDS ; done" instead of "for NAME < in WORDS > ; do COMMANDS ; done "
01:45  cthuluh: k\-: it's the same as    for name in "$@"; ...
01:46  k\-: cthuluh do you have an example for _for_ without <in WORDS> ?
01:47  cthuluh: 4# set -- a b c; for arg; do printf '[%s]' "$arg"; done
01:47  shbot: cthuluh: [a][b][c]
01:47  k\-: besides : find /usr/c/ -type f -iname '*.c' -exec bash -c 'for cfiles ; do cp $cfiles /tmp/backup ; done' {} _ +
01:47  cthuluh: hmmmm
01:48  cthuluh: up ; done' _ {} +
01:48  cthuluh: rather
01:48  cthuluh: and quote "$cfiles"
01:48  k\-: *facepalm..
01:48  k\-: *gotit ;-)
01:49  cthuluh: why do you use -exec bash -c .... _ {} +  ?
01:49  cthuluh: oh right
01:49  k\-: because of find . -type f -exec cp {} /tmp/{}.bk
01:50  k\-: and other reasons that pgas, twk, yitz, greybot etc have mentioned in the past...
01:50  k\-: s/twk/twkm/
01:51 --- tharkun is now known as tharkun__
01:51  k\-: !find > k\-
01:51  greybot: k\-: http://mywiki.wooledge.org/UsingFind
01:53  k\-: hmm, the example of prune is slightly different from the man page...
01:59  quotemstr: Is there a command like history-search-forward that uses a regular expression instead of a substring?
02:08  CIDR: I have multiple internet connections that I use iproute2 for multi-wan/round-robin.  The problem is the connections aren't all that reliable and go up and down.  I'd like to write a script to ping say google/yahoo, determine weather the router is up or not, then adjust the default route according.  I've tried a few starts on it, but I'm not getting anywhere.  Any suggestions?
02:09  Bushmills: ping -c 1 hostname && echo ok
02:11  CIDR: Yeah, I've gotten the ping logic down.
02:11  CIDR: So if eth1=ok then , but my problem is putting the oks together in a useable fashino
02:12  CIDR: ip route add default nexthop via x.x.x.x dev eth1 nexthop via x.x.x.x.x dev eth2 nexthop via x.x.x.x eth3 nexthop via x.x.x.x eth4
02:12  Bushmills: factor your script.  design top down, implement bottom up.
02:12  CIDR: Now when eth2 and 3 are down, how does it know to just use 1 and 4?
02:13  CIDR: if I did simple if logic I'd have a TON of statements for every possibility of an itnerface being up and down, and that doesn't seem the right way to do it
02:13  Bushmills: the "ip route add" part is pretty "bottomÂ§
02:14  CIDR: Yes, that is the end result.  MY issue is once I have wether or not a interface is up, I'm not sure how to transform that into a route statement, except basic if statements
02:14  Bushmills: well, that's what designing programs - not coding - is about
02:15  Bushmills: work in the logic until it is simple enough to implement it
02:15  Bushmills: on it
02:15  cthuluh: hell, isn't there something already written?
02:15  CIDR: Well the way I can do it is SIMPLE, but a huge pain, as I have to come up with the possibility of each ip up/down/etc...
02:16  Bushmills: i'd not call that "simple" but "tedious"
02:16  CIDR: Exacltly
02:16  CIDR: I'm doing things like this if [[ $CLS1 -eq 0 || $CLS2 -eq 0 ]]; then
02:16  CIDR: except there's be 4 of those statements, and one for each possibility
02:17  Bushmills: a state machine may be a way to go
02:17  CIDR: hrmmm
02:18  Bushmills: or, when connection fails, run through the list of interfaces, in order of most to least preferable one, and pick the first one which replies.
02:18  Bushmills: keep one handy for immediately switching to when connection fails
02:19 --- tory is now known as Tunix
02:19  CIDR: sadlty the links are pretty unpredictable
02:20 --- Tunix is now known as Tunix2
02:20  Bushmills: that's what you're testing. you can't improve the connections by scripting
02:21  Bushmills: or look at some routing protocols. they might do that automatically already
02:22  CIDR: Bushmills: fair enoug
02:22  CIDR: I need to probably do something with some sort of logic, like for * that are up, do this
02:23  CIDR: instead of for is this is up, if this is up, if this is up, and this id down so this
02:23  Bushmills: i think you'd be looking at a path vector protocol
02:23  CIDR: I don't think any of the stuff is going to support it
02:24  CIDR: the connections are cellular, dialup, and satellite
02:25  Bushmills: or a link state protocol.  not sure. i'm no expert in the field of routing protocos
--- Log closed Tue Nov 16 02:32:51 2010
--- Log opened Tue Nov 16 02:33:10 2010
02:33 --- Users 520 nicks [0 ops, 0 halfops, 0 voices, 520 normal]
02:34 --- Channel #bash was synced in 86 seconds
02:41  Ademan: is there an alternative to logrotate that's useful from the command line? (no config) I just want to specify like rotatelogs -n 10 'foobar$(number).log' or something like that
02:41  BuenGenio: hellooo
02:42  BuenGenio: Q: I am passing a file name to a bash script. how do I strip the path from $1 and just leave the filename?
02:43  crimeboy: basename $1
02:43  nDuff: !basename > BuenGenio
02:43  greybot: BuenGenio: basename(1) can strip the directory and extension from a path. (a/b/c.d -> c.d or c). Or you can use a parameter expansion: "${path##*/}" or "${path%.*}"
02:44  BuenGenio: oh, that's easy
02:44  BuenGenio: almost like PHP ;-)
02:44 * nDuff shudders
02:44  BuenGenio: I was expecting something like ${x/\/*\//}
03:01  getxsick: http://paste.pocoo.org/show/291835/ - what is wrong
03:01  getxsick: ?
03:04  go|dfish: getxsick: should only be 1 = sign
03:06  getxsick: go|dfish: oh, right
03:07  getxsick: and i need to check if $1 is even defined
03:21  tsolox: why is 'nice' has the range -20 to 19 value. But doing 'ps -l' shows the PRI column as 80 ?
03:36  seanjohn: how do you grab a random line from a file using a bash script and set that line as a variable?
03:37  seanjohn: a variable in the bash script of course.
03:38  go|dfish: !faq random
03:38  greybot: http://mywiki.wooledge.org/BashFAQ/026 -- How can I randomize (shuffle) the order of lines in a file?  (Or select a random line from a file, or select a random file from a directory.)
04:19  seanjohn: If I have a file with alternating lines of remote ip: a.n.i.p and local ip: a.n.i.p how do i sed the last remote ip in the file. Like, if they were in this order: local ip: 127.0.0.1 remote ip: 127.0.0.1 local ip: 27.83.22.37 remote ip: 81.84.73.94, how would I grab 81.84.73.94?
04:19  Kerrick: Is there any to force the input to a specific command to not undergo shell expansion?
04:20  seanjohn: Kerrick, parse it?
04:20  seanjohn: \
04:21  seanjohn: grep it from a file with command < file
04:22  Riviera: seanjohn: so it might either be the last or the penultimate line?
04:22  Riviera: Kerrick: what do you mean?
04:22  seanjohn: Riviera, it will always be the last one
04:22  seanjohn: that will make it easier
04:22  Riviera: seanjohn: tail -n 1 file
04:23  seanjohn: yeah, Riviera, but Im trying to make the ip a variable
04:23  Riviera: seanjohn: var=$(tail -n 1 file)
04:23  Riviera: seanjohn: or is the "remote ip: " string a part of the line?
04:23  seanjohn: if I do that it will put 'remote ip=81.84.73.94' NOT '81.84.73.94'
04:23  Riviera: ah.
04:23  clyphox: is there a space inbetween? etc?
04:24  Kerrick: Riviera, I do not want arguments like * to be expanded. The command in question is a script that is currently  a one-liner (plus a shebang): echo $* | bc
04:24  seanjohn: exactly how I wrote remote ip: a.n.i.p
04:24  seanjohn: thats the whole line
04:24  Kerrick: I want to be able to type script 4 * 5 and have it pipe "4 * 5" to bc.
04:24  Riviera: seanjohn: var=$(sed '$!d; s/.*=//' file)  or  IFS== read -r _ var < <(tail -n 1 file)  (both untested)
04:25  seanjohn: are youn trying to make $!d; $!d: ?
04:25  Riviera: seanjohn: well, you wrote both, "remote ip: " and "remote ip="
04:25 --- cookiemon5ter is now known as Vader
04:25  seanjohn: the second was a typo
04:25  seanjohn: 'remote ip:' is the first part to be truncated
04:26  Riviera: seanjohn: var=$(sed '$!d; s/.*: //' file)
04:26  seanjohn: thank you
04:26  Riviera: Kerrick: I think you can't in bash.
04:26  cthuluh: Kerrick: you'll need to type    script 4 '*' 5    anyway
04:27  Kerrick: OK, thanks
04:27  seanjohn: why cant sed use emacs regex, lol
04:27  clyphox: whats emacs?
04:27  seanjohn: basically, regular unix regex
04:27  crimeboy: have someway to know when the distro was installed?
04:27  cthuluh: Kerrick: but the exact syntax would be:   echo "$@" | bc
04:27  Kerrick: Because extended regexes are the best, that's why.
04:27 * hashashin nas
04:28  cthuluh: Kerrick: or bc <<< "$@"
04:28  Riviera: cthuluh: rather "$*"
04:28  crimeboy: some file file or anything like that
04:28  crimeboy: file date*
04:28  cthuluh: Riviera: or that, I don't think it matters :P
04:28  Kerrick: What is the difference between $* and $@?
04:29  cthuluh: !$@
04:29  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
04:29  Kerrick: OK, thanks
04:29  Kerrick: !IFS
04:29  greybot: Internal Field Separator (or Input Field Separator), used to break things into words. See http://mywiki.wooledge.org/IFS and http://mywiki.wooledge.org/BashFAQ/001 and http://bash-hackers.org/wiki/doku.php/syntax/words
04:29  Riviera: cthuluh: Odd.
04:29  Riviera: cthuluh: you are right :)
04:30  cthuluh: Kerrick: feel free to /msg greybot foobar
04:30  seanjohn: i forgot the order of arguments as variables, do they start with 0 or 1?
04:30  seanjohn: ${1} ${2} ...
04:30  Riviera: cthuluh: I expected <<< "$@" to potentially cause trouble, but I was wrong :)
04:30  cthuluh: 1
04:30  Riviera: cthuluh: strange, why is this so.
04:31  Kerrick: Isn't $0 the script, including path used to invoke it?
04:31  cthuluh: Kerrick: $0 is _supposed_ to be the executable name / script name
04:31  Kerrick: Err, apparently it's the script with the complete path.
04:32  Kerrick: _supposed_ to?
04:32  tmr: !faq location > Kerrick
04:32  greybot: Kerrick: http://mywiki.wooledge.org/BashFAQ/028 -- How do I determine the location of my script?  I want to read some config files from the same place.
04:34  cthuluh: Riviera: the manpage doesn't say much about it, but /msg greybot <<< is quite clear and shows the real behaviour
04:35  Kerrick: 43 lines to determine, simplistically, the directory the script is in.
04:35  Kerrick: wow
04:35  Riviera: cthuluh: mh, I don't see how this clarifies it :)
04:36  cthuluh: Riviera: "$@" is a _word_ 8)
04:37  Riviera: cthuluh: ah
04:37  CIDR: http://pastie.org/1301565
04:37  CIDR: ermm
04:37  CIDR: I'm trying to simplify a script for some routing changes I need it to make, anyone have any suggestions? http://pastie.org/1301565 ?
04:38  Riviera: cthuluh: not that "word" enlightens me here,
04:38  Riviera: cthuluh: from the manpage:
04:38  Riviera: cthuluh: >word  and   <<<word, both from the chapter "Redirection";
04:39  cthuluh: see the DEFINITIONS section
04:39  Riviera: cthuluh: well, what I mean
04:39  Riviera: cthuluh: ">" also goes with "word"
04:39  Riviera: cthuluh: but has different behaviour
04:39  Riviera: cthuluh: so Definitions won't be much helpful
04:39  Riviera: cthuluh: ah.
04:40  Riviera: cthuluh: I just found the relevant part in the manpage: "No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is  performed  on  word. [..]" (Section "Here Documents")
04:40  cthuluh: I guess "$@" is a corner case
04:40  Riviera: cthuluh: here documents are the corner case
04:40  Riviera: cthuluh: they're the exception
04:47 --- redrocket is now known as red|rocket
04:48 --- Natch is now known as Natch|
04:48  Riviera: cthuluh: I am too stupid to read. :)
04:49 --- Vader is now known as Starkiller
04:51  cthuluh: Riviera: and I understand faster than I read, see the crap I can say! :P
04:51  cthuluh: this has nothing to do with the 'word' definition
04:52  Riviera: :)
04:56 --- rbronosky is now known as richardbronosky
05:05 --- Starkiller is now known as cookiemon5ter
05:18  SpinachHead1: Hi, does anyone know offhand if something like conky is reading from a top bash script ?  I need to do a system monitor for the desktop and thought using top and sending it to a file would be the best way to interface with the desktop app
06:00  CIDR: I'm trying to simplify a script for some routing changes I need it to make, anyone have any suggestions? http://pastie.org/1301565 ?
06:02  cthuluh: CIDR: ask yourself if there isn't a daemon / kernel support for clean multirouting provided by your OS
06:02  CIDR: cthuluh: sadly not really
06:02  CIDR: Only if the failure meant the interface would go down, but if the thing just quits sending/receiving traffic it just assumes it's up
06:13  chilicuil: hi there, I wonder how can I use 2 or more parameters with 'getopts', I know I can pass the first parameter with '$OPTARG', but what if I have an option who needs 2 of them?
06:17  SiegeX: quote them
06:17  SiegeX: foo -q "one two"
--- Log closed Tue Nov 16 06:25:37 2010
--- Log opened Tue Nov 16 06:25:57 2010
06:25 --- Users 498 nicks [0 ops, 0 halfops, 0 voices, 498 normal]
06:27 --- Channel #bash was synced in 86 seconds
--- Log closed Tue Nov 16 06:33:45 2010
--- Log opened Tue Nov 16 06:34:09 2010
06:34 --- Users 499 nicks [0 ops, 0 halfops, 0 voices, 499 normal]
06:35 --- Channel #bash was synced in 85 seconds
06:43  seanjohn: r=$((RANDOM % n + 1))
06:43  seanjohn: does this chat have an eval function?
06:43  seanjohn: channel*
06:43  yitz_: # r=$((RANDOM % n + 1)) ; echo $r
06:44  evalbot: yitz_: bash: RANDOM % n + 1: division by 0 (error token is "+ 1")
06:44  seanjohn: is the # necessary?
06:44  yitz_: Yes
07:05  kaushal: hi
07:05  The-Compiler: hi
07:07  seanjohn: is any access other than root needed for /etc/sysconfig?
07:07  seanjohn: 750?
07:08  seanjohn: hello
07:08  mattcen: That's a Redhat-ism isn't? (Also, be patient; most people in this channel are idle most of the time)
07:08  seanjohn: sorry wrong channel
07:08  mattcen: Ah
07:14  seanjohn: This is what I was told to use, if every last line in one file said 'remote ip: a.n.i.p'  remote=$(sed '$!d; s/.*: //' /var/log/tunnel)  to catch only the ip as the variable remote. This is my my fault as the line REALLY says "remote ip address a.n.i.p". What would the correct syntax be?
07:16  seanjohn: remote=$(sed '$!d; addresss/ //' /var/log/tunnel) ?
07:17  Mike1: good Morning!
07:17  geirha: remote=$(awk 'END{print $NF}' /var/log/tunnel)
07:18  seanjohn: thanks for the reply geirha. Will that fetch only the ip address?
07:19  geirha: It will fetch the last field of the last line
07:19  Mike1: http://fpaste.org/an9I/ which subshell-workaround would be best in this case? And are the { } correct and necessary? Somehow http://mywiki.wooledge.org/BashFAQ/024 focuses only on loops =(
07:21  Mike1: can I just repace the last | with a > ?
07:21  Mike1: *replace
07:21  geirha: No.  cmd | cmd    cmd > file
07:22  apetrescu: Does anyone have a quick little idiom for checking if a file already ends in a newline?
07:23  Mike1: geirha: but here http://mywiki.wooledge.org/ProcessSubstitution itâs used for stuff like diff <(sort list1) <(sort list2)
07:23  geirha: Mike1: Something like this perhaps   while IFS=, read -r _ _ _ _ _ _ _ _ _ _ _ _ climb_raw _; do ...; done < <(while sleep 0.1; do echo "?POLL;"; done | ncat ...)
07:25  Mike1: geirha: why the do ...; done?
07:25  geirha: apetrescu: if [[ $(tail -c 1 file) = $'\n' ]]; then
07:26  geirha: Mike1: Well, couldn't be bothered to write everything. Replace ... with another read to strip out the climb.
07:26  geirha: e.g.  IFS=: read -r _ climb _ <<< "$climb_raw"
07:27  Mike1: and all that to work around the damn subshell thing?
07:27 * Mike1 is tired and frustrated -_-
07:29  geirha: Only the part in <() is run in a subshell with that code.
07:31  geirha: apetrescu: Err, actually, that one won't work since the $() strips off trailing newlines
07:31  apetrescu: geirha, right :(
07:33  geirha: if read < <(tail -c 1 file); then echo "Ends with newline"; done
07:34  geirha: # printf "test\n" > file; if read < <(tail -c 1 file); then echo "Ends with newline"; fi
07:34  evalbot: geirha: Ends with newline
07:34  geirha: # printf "test" > file; if read < <(tail -c 1 file); then echo "Ends with newline"; fi
07:34  evalbot: geirha: no output
07:37  geirha: tail -c 1 file | read   would work too
--- Log closed Tue Nov 16 08:42:24 2010
--- Log opened Tue Nov 16 08:44:12 2010
08:44 --- Users 494 nicks [0 ops, 0 halfops, 0 voices, 494 normal]
08:48 --- Channel #bash was synced in 280 seconds
09:00  devurandom: Hello!
09:02  devurandom: I have a problem with iterating through PATH. I do IFS=':' ; for f in 'a:b:c' ; do echo $f ; done, but I will only get one line of output instead of three. Additionally the output is "a b c"; the colons have been replaced with spaces.
09:02  devurandom: Can someone explain to me why that happens, and how to do it correctly?
09:04  devurandom: Oh, and I tried IFS=$':', too, because I read that somewhere. It had the same effect, though. What is the difference between =$':' and =':' ?
09:08  lhunath: $'' expands escape sequences like \n into newlines
09:09  lhunath: IFS is only used when wordsplitting.  no wordsplitting happens on 'a:b:c'
09:09  lhunath: in fact; wordsplitting should *always* be avoided at all cost.
09:09  SiegeX: # while read -d: line; do echo "-->$line<---"; done <<<"a:b:c:"
09:09  evalbot: SiegeX: -->a<---
09:09  evalbot: SiegeX: -->b<---
09:09  evalbot: SiegeX: -->c<---
09:09  lhunath: why are you trying to iterate PATH anyway?
09:10  devurandom: lhunath: But wordsplitting happens on for f in $PATH ; ... ?
09:10  devurandom: But not in for f in a:b:c ; ... ?
09:10  lhunath: wordsplitting happens on unquoted expansions, yes.
09:10  bruenig: # IFS=$'\n' ; for x in a:b:c; do echo $x; done
09:10  evalbot: bruenig: a:b:c
09:10  bruenig: boo
09:10  bruenig: # IFS=':' ; for x in a:b:c; do echo $x; done
09:10  evalbot: bruenig: a b c
09:11  lhunath: bruenig: you're word-splitting the wrong thing ;-)
09:11  bruenig: I am rusty
09:11  lhunath: $x
09:11  lhunath: quotes!
09:11  bruenig: # IFS=':' ; array=( a:b:c ); for x in "${array[@]}"; do echo $x; done
09:11  evalbot: bruenig: a b c
09:11  bruenig: :/
09:11  devurandom: lhunath: I want to create a list of paths, just like PATH, and do something to it later.
09:12  bruenig: # IFS=':' ; array=( a:b:c ); for x in "${array[@]}"; do echo "$x"; done
09:12  evalbot: bruenig: a:b:c
09:12  lhunath: bruenig: no wordsplitting happens on a:b:c
09:12  bruenig: D:
09:12  bruenig: but I changed the IFS!
09:12  lhunath: devurandom: paths=( /path1 /path2 /path3 )
09:12  lhunath: bruenig: string=a:b:c; array=( $string )
09:12  bruenig: # IFS=':' ; array=("a:b:c"); for x in "${array[@]}"; do echo "$x"; done
09:12  evalbot: bruenig: a:b:c
09:12  lhunath: but wordsplitting is evil.
09:13  bruenig: this is some boshit
09:13  devurandom: # x=a:b:c ; IFS=: ; for f in $x ; do echo $x ; done
09:13  evalbot: devurandom: a b c
09:13  evalbot: devurandom: a b c
09:13  evalbot: devurandom: a b c
09:13  lhunath: devurandom: echo "$f"
09:13  lhunath: but seriously; I'm talking to a wall here.
09:13  lhunath: stop wordsplitting!
09:13  devurandom: Oh, yes, but at least the idea is right.
09:13  devurandom: Why is this evil?
09:14  bruenig: # IFS=':' ; array=($(echo a:b:c)); for x in "${array[@]}"; do echo "$x"; done
09:14  evalbot: bruenig: a
09:14  evalbot: bruenig: b
09:14  evalbot: bruenig: c
09:14  bruenig: ha!
09:14  bruenig: hack ftw
09:14  lhunath: because you're changing the way bash behaves within the entire for loop AND you're ALSO pathname expanding the result.
09:14  devurandom: pathname-expanding means what?
09:15  bruenig: # IFS=':' ; for x in $(echo a:b:c); do echo "$x"; done
09:15  evalbot: bruenig: a
09:15  evalbot: bruenig: b
09:15  evalbot: bruenig: c
09:16  bruenig: optimal solution amirite
09:16  lhunath: # mkdir 'foo?' 'foo!'; firstfoo='foo?'; echo $firstfoo
09:16  evalbot: lhunath: foo! foo?
09:16  lhunath: that is pathname expansion.
09:17  lhunath: firstfoo being 'foo?' expands to 'foo!' 'foo?'.
09:17  bruenig: blew my mind
09:17  devurandom: echo "$firstfoo" works though.
09:18  devurandom: But I agree this is ugly.
09:18  lhunath: yes, because it disables wordsplitting
09:21  lhunath: anyway; SiegeX showed you a good alternative
09:21  lhunath: while read -d: path; do echo "$path"; done <<< "$PATH:"
09:21  lhunath: I still can't fathom why you think it's a good idea to iterate PATH.
09:22  lhunath: if you're trying to iterate a custom variable; learn what arrays are.
09:22  lhunath: !arrays
09:22  lhunath: meh; greybot's asleep again.
09:23  lhunath: mywiki.wooledge.org/BashSheet#Arrays
09:30  geirha: You could also do   IFS=: read -r -d '' -a paths <<< "$PATH:"   to put it in an array. Though it'll add an extra element containing only a newline at the end.
09:31  geirha: (which should be ignored of course)
09:42  Vide: hi, I have some problems with here docs, command expansion and variables substitution
09:42  Vide: here is my PoC http://pastebin.com/MVupuXsy
09:42  Vide: the first heredoc is what I'm doing and the second is what I'd like to get as output
09:43  Vide: I understand why it doesn't work but I don't get how to fix it
09:43  Vide: is this possible?
09:43  geirha: !template
09:43  geirha: Err, no greybot
09:44  Vide: it's just a PoC, I don't need other solutions based for example on sed
09:44  geirha: Vide: http://mywiki.wooledge.org/TemplateFiles
09:48  Vide: geirha: but the sh in pipe doesn't know about my variable in the template
09:48  Vide: ah ok sorry
09:48  Vide: export VAR
09:48  Vide: it solved
09:49  Vide: thanks!
09:49  Vide: i looked through greg's wiki but I didn't find this great example
09:49  Vide: thx for pointing it out
10:15  mseidl: how do i do a for i in (seq 0 $var) ?
10:16  geirha: for ((i=0; i <= var; i++)); do
10:16  mseidl: ok
10:16  geirha: seq is a non-standard command. Don't use it.
10:17  mseidl: ok
10:17  mseidl: why the (())?
10:17  geirha: I guess you actually want i < var
10:17  mseidl: now i do yes
10:18  geirha: help '(('
10:18  geirha: help 'for (('
10:19  mseidl: if im doing the cat >> over ssh can i put a statement in front of that?  to check to see ifa  directory exists?
10:20  auscompgeek: # help '(('
10:20  evalbot: auscompgeek: (( ... )): (( expression ))
10:20  evalbot: auscompgeek:     The EXPRESSION is evaluated according to the rules for arithmetic
10:20  evalbot: auscompgeek:     evaluation.  Equivalent to "let EXPRESSION".
10:20  auscompgeek: meh
10:20  auscompgeek: that is interesting though
10:21  geirha: mseidl: I don't know what you mean by ''the cat >> over ssh''
10:22  mseidl: cat file >> ssh server1 cat >> file2remotemachien
10:22  mseidl: err
10:22  mseidl: |
10:22  mseidl: cat file |
10:22  mseidl: i ended up with something like this after takling to someone last night ssh ${sshuser}@${ipstart}$(expr $ipend + $i) <<< "if [ ! -d ~/.ssh ]; then mkdir /root/.ssh; fi; $(printf 'cat >> %q', ${authkey}) < ${pubkey}";
10:22  geirha: that'll read and write to local files
10:23  mseidl: i know i need to change the {}
10:23  geirha: expr..! stop reading the guides at tldp.org. They're crap.
10:24  mseidl: haha. ok
10:24  geirha: Don't use expr in a bash script
10:24  mseidl: is there a betterone_
10:24  geirha: # echo $((2*3+1))
10:24  evalbot: geirha: 7
10:25  mseidl: i mean better documentation
10:25  mseidl: that too
10:25  geirha: Yes, see /topic
10:26  mseidl: ah, ok, rhNKA
10:26  mseidl: thanks
10:26  geirha: ssh user@host 'mkdir -p .ssh && cat >> .ssh/authorized_keys' < "$public_key_file"
10:27  mseidl: does -p make the dir if it doesnt exist?
10:27  geirha: Yes, and if it already exists, it'll just return true.
10:30  karthee: geirha: shouldnt it be authorized_keys2 ??
10:30  mseidl: are ' and " interchangable?
10:31  geirha: mseidl: They are not.
10:31  geirha: karthee: Dunno, works for me without the 2.
10:32  karthee: ya .. but its adviced to use 2 since SSH2 ..
10:32  geirha: mseidl: Everything inside '' quotes are taken literally. In "", expansions occur, but it prevents wordsplitting and globbing
10:33  geirha: karthee: Ah, I should start using that then. :)
10:36  geirha: mseidl: http://mywiki.wooledge.org/Quotes
10:36  mseidl: ssh "$sshuser"@"$ipstart"$(expr $ipend + $i) 'mkdir -p /root/.ssh &&  cat >> .ssh/authorized_keys' < "$pubkey"
10:36  _bugz_: is http://www.commandlinefu.com/ down, hacked or dead for good?
10:36  geirha: mseidl: Knowing quotes is the most important thing in shell scripting.
10:36  geirha: mseidl: That's good, apart from the expr
10:37  mseidl: its complaining about a } at the on the line of the closing } on the function
10:38  geirha: ssh "$sshuser@$ipstart$((ipend+i))" 'mkdir -p ~/.ssh && cat ~/.ssh_authorized_keys2' < "$pubkey"
10:38  geirha: } must be preceded by a ; or a newline
10:39  mseidl: i have { forloop ; do \n ssh command ; done ; }
10:40  geirha: Probably missing a closing quote or parenthesis or something somewhere inside that function then
10:41  mseidl: oh wait, i see something, i had quotes around each variable, and you have only variable around the whole host/ip thing
10:41  joshcheek: Hi, I have a simple command. Works in the shell, not in the script. I copy the generated args, and paste them back into the script, and it works. http://pastie.org/1302084
10:41  geirha: "$sshuser"@"$ipstart"  and   "$sshuser@$ipstart"  will expand to the exact same strings
10:42  mseidl: ok
10:42  mseidl: im probably missing something stupid http://codepad.org/DLFGfoNk
10:43  geirha: joshcheek: quotes inhibit glob expansion
10:44  geirha: mseidl: nopassword() {
10:45  mseidl: ha.  i got an error with that too, but i will put it back
10:45  joshcheek: geirha: Thank you, I removed the quotes and it works.
10:46  geirha: joshcheek: The expansions should still be quoted
10:46  geirha: joshcheek: There are a lot of bad practices in that little script of yours.
10:47  geirha: Having more than two words in the she-bang is not defined
10:47  joshcheek: geirha: I have done "$DIRECTORY"/*_test.rb and this works. Is this what you were suggesting?
10:47  geirha: Always check the return value of cd
10:47  geirha: don't use ``, use $()
10:47  geirha: Or rather "$()"
10:47  geirha: joshcheek: Yes
10:48  geirha: joshcheek: Please see http://mywiki.wooledge.org/BashFAQ/028
10:50  mseidl: does a ;; in a case statemtn have to be on the same line?
10:50  geirha: And variable names you set should be lowercase (except for environment variables)
10:50  geirha: mseidl: No
10:50  mseidl: when i call the function i call it nopassword()?
10:52  geirha: mseidl: No, you use it as any other command. nopassword arg1 arg2 ...  you only use the () for the definition
10:54  mseidl: does function order matter?  can i call a funtion declared later on in the script?
10:55  mseidl: i have a case and it says command not found
10:55  geirha: Yes, as long as it is declared when the function is actually called
10:56  geirha: # foo() { bar; }; bar() { echo "I am bar"; }; foo
10:56  evalbot: geirha: I am bar
10:58  geirha: mseidl: Oh btw, forgot about this one:   man ssh-copy-id
11:00  mseidl: hmmmm.  i have case "$i" in \n nopassword)  \n nopassword \n ;;
11:00  geirha: ... and?
11:01  mseidl: it says nopassword not found
11:01  mseidl: command not found
11:02  geirha: So make sure you declare the function before that code is executed.
11:02  joshcheek: geirha: Thank you. I think the objections raised in the article are intended for more publicly used scripts. This is just intended to be a small helper to automate some things I would otherwise do by hand, while developing a library I am working on. So I feel comfortable assuming it will always have bash and never be symlinked; placing it in a hard coded location is definitely not right for my script. I appreciate your help and the article.
11:04  geirha: joshcheek: I'd cd to the right place in an interactive shell, then run the script and have the script operate on the current dir.
11:04  Quanta: hi, i have a problem with my awk command: awk '\'' /: pb0416096fz0000.tps / {printf "0\n",$4}'\'' /home_local/gpssite/prt/pb04/prt_GPS_2010_317'
11:04  mseidl: ooooooh, ok, that makes sense
11:04  geirha: Quanta: You can't embed ' inside '' quotes
11:05  Quanta: awk sould search for the string pb0416096fz0000.tps in file home_local/gpssite/prt/pb04/prt_GPS_2010_317 and return the 5th element in that line
11:05  geirha: awk '/:pb0416096fz0000.tps / {print $4}' /home_local/gpssite/prt/pb04/prt_GPS_2010_317
11:05  mseidl: geirha: thanks a bunch for your help... you guys are a lot nicer than the java guys, haha
11:05  geirha: And don't forgot the cover sheet on that tps-report!
11:06  Quanta: thanks
11:10 --- mingdao_ is now known as mingdao
11:14  Quanta: i test it and i get no match, althought i know the text i search is there.....
11:15  Quanta: (in that file, i test it with cat and grep)
11:18  Quanta: ok, found the problem
11:19  geirha: I see I omitted a space after the :   probably that
11:47  remoteCTRL1: hi guys! can somebody please translate the following into a shell script? thanks in advsnce:
11:48  remoteCTRL1: while (true) { touch bla.txt && sleep a second}
11:48  twkm: because you aren't yet a rocket scientist?
11:48  remoteCTRL1: twkm: exactly;)
11:49  remoteCTRL1: twkm: are you one?
11:51  twkm: i play one on tv.
11:52  remoteCTRL1: ok i guess i took the fast course in rocket science...
11:52  frey_: hi all. how can i find all the files which filename starting with ROOT or TREE... i tried ls -al ^[ROOT\|TREE]* but it's not working
11:53  twkm: remoteCTRL1: ''man touch sleep ; help while''
11:53  twkm: frey_: is ROOT* TREE* not sufficient?
11:54  remoteCTRL1: twkm: i thank you dude, but i was meanwhile able to google the syntax, i just thought it'd be an easy enuff question to get an answer here... obviously i was wrong :D
11:55  frey_: twkm: yes, ROOT* or TREE*
11:55  twkm: remoteCTRL1: it is.  i don't.  i prefer people to learn to fish.
11:55  frey_: twkm: i tried list=`ls -la [ROOT\|TREE]* | cut -d/ -f2` but i still get error
11:55  twkm: frey_: well, then you have it.
11:55  twkm: globs are not fucking regexes.
11:56  twkm: (not even bad/wrong regexes)
11:56  twkm: why are you cutting ls' output?
11:56  geirha: list=(ROOT* TREE*)
11:57  remoteCTRL1: twkm: well sometimes you just want to eat the fish whithout having to beed it first... but thanks for smartassing me arround anyways...
11:57  strull: what an idiot
11:58  twkm: frey_: well?
12:00  frey_: twkm: sorry, my fault... i'm cutting because tmp directory... list=`ls -la tmp/[ROOT\|TREE]* | cut -d/ -f2`
12:00  lhunath: !ls
12:01  twkm: foolish.
12:01  geirha: No greybot today :(
12:01  lhunath: frey_: don't use ls to enumerate files.
12:01  twkm: *never* use ls' output to form a list of files.  see geirha's response.
12:01  lhunath: that's not what it's for
12:01  frey_: so what to use?
12:01  frey_: find?
12:01  twkm: [repeat:] see geirha's response.
12:01  geirha: list=(tmp/{ROOT,TREE}*)
12:01  twkm: (initial response)
12:02  twkm: w/o tmp/ you might use: cd tmp && list=(ROOT* TREE*) ; cd -
12:02 --- MuzerAway is now known as Muzer
12:02  twkm: i might use nullglob too.
12:03  alek{xmb}{bottz}: and ownglob
12:03  Cyber_Beast: I want to learn how to automate the tasks in unix system environment.. from where should I start... Please advise experts.
12:03  geirha: Cyber_Beast: /topic
12:04  Cyber_Beast: geirha: about cron jobs may be
12:04  frey_: when i use list=(tmp/{ROOT,TREE}*) i get only ROOT file... not TREE*
12:04  geirha: Cyber_Beast: Then ''man cron''
12:04  alek{xmb}{bottz}: the advise is
12:04  alek{xmb}{bottz}: on your schell
12:04  alek{xmb}{bottz}: where u enter kommands
12:04  alek{xmb}{bottz}: so u're here on the right path
12:04  alek{xmb}{bottz}: to automate u write kommands in a file and basch the file afterwards
12:04  alek{xmb}{bottz}: just as u write them on your schell
12:04  alek{xmb}{bottz}: u write em to the file
12:04  alek{xmb}{bottz}: gg
12:04  twkm: frey_: you probably failed to expand list properly.
12:04  alek{xmb}{bottz}: ' # man bash'
12:05  twkm: sheesh, is xmb lagged or just spewing more these days.
12:05  geirha: frey_: "${list[@]}"
12:05  Cyber_Beast: geirha: I meant the "tutorial".
12:05  alek{xmb}{bottz}: says 66er lag here
12:05  frey_: ${list[@]} works:) thanks a lot
12:06  geirha: frey_: Not ${list[@]}, but "${list[@]}"
12:06  brabo: Cyber_Beast: just read the topic
12:06  frey_: btw. why using 'ls' is a bad idea?
12:07  twkm: ls doesn't do anything useful as you've used it, it is the shell expanding the glob that does so.
12:07  geirha: frey_: http://mywiki.wooledge.org/ParsingLs
12:08  frey_: but i need only filename without path... how use cut on list array, please?
12:08  geirha: frey_: "${list[@]#tmp/}"
12:09  geirha: Or use cd like twkm suggested
12:09  frey_: thank you a lot
12:10  twkm: and you probably want nullglob.
12:14  alek{xmb}{bottz}: tw got redundant code to separate { .. , ..} or arr=( *elems* ) with , instead of whitespace
12:14  alek{xmb}{bottz}: ?
12:30  iceroot: if [ $swraid = 'false' ]; then  is it the common way to check false/true? or is there another common way to check if a var is true/false (assigned with var=true/false as a string)
12:32  erUSUL: that looks ok for string comparision. if it is bash you can use [[ ]]
12:35  geirha: s/can/should/
12:36  geirha: I prefer to use 1 (true) and 0 or null (false).  if ((some_var)); then "it's true"; else "it's false"; fi
--- Log closed Tue Nov 16 12:42:13 2010
--- Log opened Tue Nov 16 12:42:44 2010
12:42 --- Users 528 nicks [0 ops, 0 halfops, 0 voices, 528 normal]
12:44 --- Channel #bash was synced in 84 seconds
12:59 --- Muzer is now known as MuzerAway
13:00  lyhana8: hi, I want to valid file differences line by line, without any grouping, how could I do that?
13:01  lyhana8: I tried kompare/kdiff3 but don't find the right setting
13:04  Naib: lyhana8. diff ?
13:05  lyhana8: Naib: diff seem to group contiguous differences
13:07  geirha: lyhana8: comm(1)
13:08  geirha: lyhana8: http://mywiki.wooledge.org/BashFAQ/036
13:10  cH40z-Lord: is there any nifty way to get the last $x param :) ? for example $20 if I pass 20 params
13:17  geirha: cH40z-Lord: "${@:$#}"
13:17  geirha: See Parameter Expansion in bash's manpage
13:18  cH40z-Lord: thanks :)
13:19  herdingcat: hi, could I use bash to write a loop like C?
13:20  mr_daniel: Many commands produce a lot of output, for example 'svn update' when a lot files have been edited since last update. I usually use 'svn update > outfile' to redirect to output to a file and inspect it later. But 'svn update' also waits for user input, so I guess a simple redirect with > is not enough
13:20  mr_daniel: How can I copy instead of redirecting the stdout to a external file?
13:20  sn18: herdingcat: what loop?
13:21  herdingcat: for (i=0;i<6;i++)
13:21  herdingcat: sn18, like that
13:21  sn18: !cfor > herdingcat
13:21  mr_daniel: so I want the output to appear on the console AND to be redirected to an external file. Is this possible? Will this fix the problem with input from stdin 'svn update' maybe is waiting for?
13:22  Mike1: mr_daniel: I think tee can do that
13:22  herdingcat: sn18, nothing showed
13:23  sn18: herdingcat: for ((i=0 ; i<6 ; i++)) ; do ... ; done
13:23  lyhana8: I want to commit only the line with a green outline (as I changed my gettext key to something more genering, see right).
13:23  lyhana8: geirha: I don't see how comm can help me
13:24  herdingcat: sn18, ?
13:25  Mike1: sn18: http://tldp.org/LDP/abs/html/loops1.html look for C-Style Loop
13:25  sn18: Mike1: ?
13:26  tmr: !abs > Mike1
13:26  tmr: Meh..
13:27  sn18: tmr: bot is absent
13:28  Mike1: herdingcat I mean
13:32  geirha: lyhana8: Then show some sample code and wanted output
13:32  geirha: Mike1: ABS is crap. Wipe it from your memory.
13:37  Mike1: geirha: okay *starting delete process*
13:38  lyhana8: geirha: oh sorry I forgot to paste the screenshot: http://img405.imageshack.us/img405/4893/2010poedithowtocommitli.png
13:39  geirha: lyhana8: Oh, po files. There are lots of tools for handling those
13:40  geirha: lyhana8: You want msgcomm(1) or msgmerge(1) I think ... See also the other msg* commands
13:40  lyhana8: ok, I'll look
13:41  heisenberg_: Hi
13:46  knob: Hello
13:46  knob: Is there a rm -rf   "undo" command?
13:46  knob: for when one... fsck up?
13:46  lhunath: restore the files from your backup.
13:47  knob: I have a backup of the database...
13:47  knob: Not of the directory
13:47  knob: any... "undo"  or something like that in bash?
13:47  lhunath: not that it has anything to do with bash, at all.
13:47  lhunath: but no.
13:47  knob: =\  dang...
13:47  knob: lord
13:47  knob: thanks man
13:49  lhunath: zfs snapshot++
13:51  knob: that snapshot would be for... future backups?
13:51  geirha: You might be able to get _some_ files back, but with great difficulty and don't get your hopes up.
13:52  knob: I did have a 2-3 week old copy of the directory... and it seems to have the site up and running
13:52  knob: my great fsck up was      rm -rf forums OEM/       that space shouldn't have been there.. should have been   forumsOEM/  != forums OEM/
13:53  mseidl: quick Q how do i execute a function into an ssh command? ssh "$sshuser@$ipstart$((ipend+i))" 'functionfoobar; $curls && $setup $key[3]'  ?
13:53  lhunath: hourly zfs snapshots mean those worries are a thing of the past.
13:53 --- matjas_ is now known as matjas
13:54  knob: I'm reading up on it
13:54  lhunath: mseidl: don't put commands into variables.
13:54  knob: reading this : http://docs.huihoo.com/opensolaris/solaris-zfs-administration-guide/html/ch06.html
13:54  lhunath: mseidl: and your other shell doesn't have functionfoobar defined.
13:54  lhunath: knob: unfortunately; zfs isn't commonly available outside solaris or freebsd.
13:56  lhunath: mseidl: good thing I already showed you how to properly run commands remotely so you don't have to do what you're doing now.
13:56  lhunath: in reference to your attempts at expanding local variables remotely.
13:58  mseidl: the commands are really long i just thought it would help for readability and reusability
14:01  lhunath: don't inject variables into code.
14:09  avinashhm: hi ,is it possible to use 'ls' with someoption, so that it lists all contents of the directory using fullpath ..so i should get full path of the contents inside a directory .. any way ???
14:11  geirha: printf '%s\n' "$PWD"/*
14:15  avinashhm: geirha, this is helpful .. i ll use this with my shell script
14:16  geirha: If you mean to iterate the files, just use the glob of course.
14:17  avinashhm: geirha, how to use it .. ???
14:17  geirha: for file in "$PWD"/*; do echo "Do something with $file"; done
14:17 --- alek{xmb}{bottz} is now known as bouncsz
14:18 --- bouncsz is now known as bounercsz
14:19  avinashhm: i have a list of directiories in a file ... i want to list the files in those directories .. [not recursive ..].only those in that directory ..
14:19  avinashhm: i am now try cd dir1 ; printf '%s\n' "$PWD"/* >> allfiles.txt
14:19  avinashhm: so on for all the dirs in the file.
14:20  geirha: For what purpose?
14:21  avinashhm: i am trying to build cscope for a linux kernel project .. if i do cscope -R, i am getting multiple definitions for x86, arm ...so i am listing those dirs where my .o's have been built and getting files in those dirs and redirecting to cscope.files
14:21  bounercsz: >>allfiles e *
14:24  bounercsz: bouncsz
14:26  Jef91: I am looking to write a loop that goes through all sub directories of my current directory and performs a chmod +x on all the files called "installer" how would I do that?
14:27  koala_man: find dir -name installer -exec chmod +x {} +
14:28  Jef91: thanks koala_man
14:30  avinashhm: hi,  am trying to write a simple shell script to cd into a dirctory and list its contents .. cd is failing from shell script, where as doing it manually is working .. can some one help .. script and contents @ http://paste.ubuntu.com/532996/
14:31  koala_man: !faq change dir > avinashhm
14:31  greybot: avinashhm: http://mywiki.wooledge.org/BashFAQ/060 -- I'm trying to write a script that will change directory (or set a variable), but after the script finishes, I'm back where I started (or my variable isn't set)!
14:33  Naib: avinashhm. if you are just after listing
14:33  Naib: dirlist() { f=("$@"/*);echo "${f[@]}"; }; dirlist /tmp
14:36  Riviera: Naib: "$@"/* is a bit odd imho
14:37  Naib: true, you get what I mean, doing electronics atm so couldn't remember
14:37  Riviera: yes, electronics' bad for the mind :)
14:39  avinashhm: koala_man, Naib .. .thanks guys i realised the mistake.. changed the script and got it working .. thanks again ...
14:40 --- Tobias| is now known as Tobias
14:41 --- Tobias is now known as Guest6159
14:46 --- fipar_ is now known as fipar
14:48 --- Guest6159 is now known as Tobias|
14:51  Jef91: how do I do a loop for each folder in my current directory?
14:52  koala_man: for f in */
14:53  Jef91: so like
14:53  Jef91: for f in */ echo $f
14:54  koala_man: for f in */; do echo "$f"; done
14:55  Jef91: is there a way I can strip the "/" off the end of $f?
14:55  tempmj: can someone give me a suggestion for a script i'm working on?  i'm trying to interactively run another program.  i need to pass it o then 8 then $1 then x then x.  any suggestions?
14:58  tempmj: Jef91, i just cought the tail end of your conversation, but you may check out http://tldp.org/LDP/abs/html/string-manipulation.html
14:58  Jef91: thanks guys
14:59  koala_man: tempmj: you can either just echo it if the app is willing, or you can script it with expect
14:59  lhunath: !pe > Jef91
14:59  greybot: Jef91: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
14:59  lhunath: !abs
14:59  greybot: The infamous "Advanced" Bash Scripting Guide should be avoided unless you know how to filter out the junk. It will teach you to write bugs, not scripts. In that light, the BashGuide was written: http://mywiki.wooledge.org/BashGuide
14:59  tempmj: so do command then echo o then echo 8 and so forth?
14:59  lhunath: tempmj: ^
15:00  koala_man: tempmj: { echo o; echo 8; ...; } | something
15:01  tempmj: ah... i'll give it a try.
15:01  lhunath: "do command then echo o then echo 8"   command; echo o; echo 8
15:06  anon33_: i find myself executing commands appended with &! often... is there another solution that allows for just one-off commands in an effective shell with autocompletion?
15:06  tempmj: lhunath, i did this: do run_explore then echo o then echo 8 > test and it responded with ./tempmj2: line 1: syntax error near unexpected token `do'
15:06  tempmj: ./tempmj2: line 1: `do run_explore then echo o then echo 8 > test'
15:07  geirha: tempmj: That's english, not bash code.
15:08  tempmj: didn't know if it was quasi do while loop
15:08  tempmj: sorry
15:08  geirha: In bash you run:  { run_explore; echo o; echo 8; } > test
15:08  Riviera: anon33_: &! is a zsh feature, isn't it
15:08  tempmj: :P now i feel dumb
15:08  anon33_: Riviera: umm..i think so..i feel dumb too
15:10  paxl: Problem and attempt of solution : I'm trying to redirect the output of multiples programs to a file... but I'd like to prepend each line with the name of the program that has generated it as with the stream ( so if it's a stdout or stderr and so on ).. Should I use fifo's or stream redirection... I'm kinda lost on how to do that :(
15:11  koala_man: how about just  lulz | sed 's/^/lulz: /' >> file
15:12  lhunath: tempmj: to fix that feeling; stop reading the abs and read through the guide in the topic.
15:12  paxl: koala_man, good solution easy enough ... i"m going to try it out :D
15:17  paissad: my shebang is /bin/bash, .. my shell is bash, i would like to know which of these 2 versions is the most correct
15:17  paissad: [ $var = 1 ] || echo "var is not 1"
15:17  paissad: [[ $var = 1 ]] || echo "var is not 1"
15:17  paissad: actually, i wonder about the use of one or 2 '['
15:17  paissad: thanks in advance
15:19  paissad: when i run the script in my computer, i have no problem, but some users reported me this error
15:19  paissad: [: = : unary operator ***
15:20  koala_man: ![[ > paissad
15:20  greybot: paissad: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
15:21 --- MuzerAway is now known as Muzer
15:21  paissad: oknowton, thanks
15:22 --- Muzer is now known as MuzerAway
15:22 --- MuzerAway is now known as Muzer
15:23  skered: paissad: Looks like a quoting issue when $var is an empty value
15:23  geirha: [ $var = 1 ]  becomes [ = 1 ] when var is empty
15:23 --- Muzer is now known as MuzerAway
15:23  geirha: # [ = 1Â ]
15:23  evalbot: geirha: bash: [: missing `]'
15:24  paissad: yeah, maybe
15:24  geirha: sh# [ = 1Â ]
15:24  shbot: geirha: [: 1: missing ]
15:24  mr_daniel: I have a small program called a.out, which reads an user input and prints out some messages on stdout. In the real case the printed messages are very long; a.out is just an example, it looks like this: http://pastebin.com/Ci4BUNWY
15:25  geirha: # [ = 1 ]
15:25  evalbot: geirha: bash: [: =: unary operator expected
15:25  mr_daniel: my first idea was to use tee like so to simultaniously write stdout to file and to a console:  ./a.out | tee outfile
15:25  geirha: There, had one of those damn utf-8 spaces in the first one
15:25  mr_daniel: but the problem is that tee is *not* printing the first long text on the console, but is waiting until I first enter the input
15:27  koala_man: fflush stdout
15:27  mr_daniel: it seems like tee is 'blocking' or 'waiting' for my input and is *not* printing any output to stdout in this time
15:27 --- MuzerAway is now known as Muzer
15:27  koala_man: libc will tend to buffer stdout when output is not a terminal
15:28  mr_daniel: this solved the issue, thanks koala_man
15:29  mr_daniel: I hope that 'svn update' also uses 'fflush(stdout)' to flush the buffer...
15:29  koala_man: doubt it
15:29  koala_man: you can use 'unbuffer' from expect if svn itself doesn't have a switch for it
15:30  geirha: GNU coreutils also have a command to unbuffer
15:30  Synthead: I'm doing some text manipulation, and I basically created a huuuuuuuge line that is more or less like output="$variable1$([[ $stuff ]] && printf $variable2)$([[ $morestuff ]] && printf $variable3)" etc etc.  It's huge and ugly.  Is there a cleaner way I can be writing this in my script while avoiding multiple declarations of $output?
15:30  geirha: http://mywiki.wooledge.org/BashFAQ/009
15:30  geirha: stdbuf
15:33 --- Muzer is now known as MuzerAway
--- Log opened Tue Nov 16 15:52:48 2010
15:52 --- Users 544 nicks [0 ops, 0 halfops, 0 voices, 544 normal]
15:53  erUSUL: i think that is becouse tilde expansion is done before parameter expansion
15:54 --- Channel #bash was synced in 85 seconds
15:54  voxio: put it in a variable first then
15:54  Vide: voxio: eval  echo ~"$1" doesn't work?
15:56  voxio: if i stick eval before the line
15:56  voxio: i still get the rrorr
15:56  voxio: ./setup: line 385: ~user/.bashrc: No such file or directory
15:56  voxio: i'll put it in a variable first :)
15:57  Vide: how does line 385 look like?
15:57  Vide: just out of curiosity
15:58  voxio: bah same error :>
15:58  voxio: echo "export PATH='$config_installdir/bin'" >> ~$1/.bashrc
15:58  skered: ls ~user/.bashrc
15:59  geirha: You can't use variables with tilde expansion
15:59  voxio: # ls ~user/.bashrc
15:59  voxio: /home/user/.bashrc
15:59  evalbot: voxio: ls: cannot access ~user/.bashrc: No such file or directory
15:59  geirha: tilde expansion happens before parameter expansion
15:59  voxio: even if it doesn't exist echo >> should create it
15:59  voxio: geirha: is there anyway around that?
15:59  voxio: i could grab the home directory from /etc/passwd
16:00  geirha: Yes, or use getent if available
16:00  voxio: is getenv quite widely adopted amongst linux distros?
16:00  voxio: ent
16:01  voxio: or am I safer with /etc/passwd
16:01  geirha: voxio: It's part of glibc
16:01  geirha: So any GNU/linux system will have it
16:01  voxio: THANKS geirha  :)
16:01  voxio: -caps
16:02  geirha: IFS=: read -r _ _ _ _ _ home _ < <(getent passwd "$username")
16:02  Vide: voxio: echo foobar >>  $(eval echo ~"$1"/.bashrc)
16:02  Vide: should work
16:03  geirha: Why are you editing other users' files anyway?
16:03  voxio: Vide: that works fine
16:03  voxio: thanks
16:04  voxio: well its an installer, it creates a user if it doesn't already exist with a specific home directory. If the user already exists it doesn't try to change the home directory
16:04 * lhunath hits Vide with a quotes and a sense for code injection.
16:04  lhunath: if you're gonna use eval; at least learn to not be an idiot in doing so.
16:04  voxio: but there is an option to set path
16:05  Vide: lhunath: eval is evil I know but how would you solve this problem (without changing approach, I mean)
16:06  geirha: voxio: Just use a skel dir
16:06  lhunath: h=$(eval "$(printf 'printf %s ~%q' "$1")")
16:06  lhunath: Vide: if you're gonna use eval; always printf your to-eval code and use %q wherever you inject variable data
16:07  gwz: hey, I was unable to find a manual for at on my machine, any online link
16:07  Vide: lhunath: thx for the advice :)
16:07  lhunath: eval "$(printf 'h=~%q' "$1")"
16:07 --- Mike1_ is now known as Mike1
16:07  lhunath: is simpler
16:08  geirha: voxio: Also, "with a specific homedir" sounds like you already know the homedir.
16:08  lhunath: voxio should probably run his script like ./script ~foo instead of ./script foo
16:08  lhunath: and get rid of this stupid problem.
16:09  erUSUL: gwz: depends on your machine OS. many free OS has man pages online. google may be of help
16:09  lhunath: gwz: google for 'man at'
16:09  karthee: awk
16:10  karthee: ops sorry ..
16:10  Vide: lhunath: with eval "$(printf 'h=~%q' "$1")" the first time $h has value  ~username
16:10  Vide: if i run it a second time, then $h is /home/username
16:10  Vide: i don't get it
16:11  lhunath: Vide: not with me.  with me it works from the first time; even on a fresh shell.
16:11  Vide: mmm, strange
16:11  Vide: i tried with another var name and it's the same
16:11  lhunath: # u=root; eval "$(printf 'h=~%q' "$u")"; echo "$h -- $HOME"
16:12  evalbot: lhunath: /root -- /root
16:14  Vide: lhunath: it "fails" only with usernames with dot inside (i'm using active directory and I have dots in the usernames)
16:14  Vide: with local users (no dots) everything ok
16:16  lhunath: are those local users?  bash's tilde expansion probably only looks at the shadow file or so.  Don't know how exactly it works.
16:17  lhunath: if you're using active directory; then why don't you ask active directory for your user's metadata instead of raping bash into caughing it up?
16:17 --- ricky_ is now known as ricky
16:18  Vide: lhunath: I'm not the one who asked :) i just gave a (not completely right)  solution
16:19  Vide: i was trying your solution to learn new things
16:20  Vide: anyway tilde expansion works as expected given that the user backend you are using gives the right info
16:20  Vide: I mean, I have no problem with tilde expansion in my workstation
--- Log closed Wed Nov 17 11:21:13 2010
