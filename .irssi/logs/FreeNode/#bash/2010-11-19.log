--- Log opened Fri Nov 19 09:59:40 2010
--- Log closed Fri Nov 19 10:04:41 2010
--- Log opened Fri Nov 19 10:04:51 2010
10:04 --- Users 535 nicks [0 ops, 0 halfops, 0 voices, 535 normal]
10:06 --- Channel #bash was synced in 87 seconds
10:07  mseidl: question i have an oracle xe db with a maxed out tablespace but as i delete stuff out of my application, the tablespace is not reducing, its still staying maxed out at 4gb, is there a way i can shrink it or make it drop whatever?
10:07  mseidl: oops, wrong channel, haha
--- Log closed Fri Nov 19 12:14:04 2010
--- Log opened Fri Nov 19 12:14:26 2010
12:14 --- Users 536 nicks [0 ops, 0 halfops, 0 voices, 536 normal]
12:14 --- Server: [card.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
12:14  Bushmills: Naib: you have me targetted today :P
12:14  Naib: :( <TAB>fail
12:15  Bushmills: <Naib> fail :D
12:15  Naib: pfft
12:15 --- Channel #bash was synced in 85 seconds
12:15  Bushmills: it's always the computer, never the user
12:17  Bruce_Wayne: sente: how can u give a criteria that when i prompt to  enter the character... my  terminal will allow to enter only 1 alphabet? It 's not essential but i want to learn some advance
12:18  Bruce_Wayne: or i don't know  may that possible or not
12:19  erUSUL: Bruce_Wayne: « help read » in your terminal
12:19  Bushmills: Bruce_Wayne: show the bash code you have written as far
12:22  Bruce_Wayne: Bushmills: Give me few mins...
12:28 --- Sky[XX] is now known as Sky[X]
13:05  c0nsumer_: hello! i have an folder with php scripts and folders, (wordpress) i need replace all tha be "http://sites/web-wp" "http://webserver/webwp" recursive, how can i make this?
13:06  geirha: !faq replace > c0nsumer_
13:06  greybot: c0nsumer_: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
13:16 * hashashin nas
--- Log closed Fri Nov 19 13:42:33 2010
--- Log opened Fri Nov 19 13:42:51 2010
13:42 --- Users 537 nicks [0 ops, 0 halfops, 0 voices, 537 normal]
13:44 --- Channel #bash was synced in 90 seconds
--- Log closed Fri Nov 19 13:47:54 2010
--- Log opened Fri Nov 19 13:48:26 2010
13:48 --- Users 538 nicks [0 ops, 0 halfops, 0 voices, 538 normal]
13:48 --- Server: [bartol.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
13:49 --- Channel #bash was synced in 85 seconds
14:19  sas: hi
14:21  sas: how can i see every third char. of a string?
14:21  lhunath: use a loop.
14:21  lhunath: or ask a better question.
14:22  sultan2: 541 people !
14:22  sultan2: wow
14:23  sultan2: I just found about .bash_profile <http://homepages.ihug.co.nz/~trmusson/programs.html#misc> how do I restart bash? (without logging out)
14:24  sas: i have a srting which is in a variable. it looks like this sh1wq2er4jkk .... i want to print from this 124k
14:26  sas: any ideas on this?
14:27  koala_man: sed -e 's/..\(.\)/\1/g'
14:32  sas: koala_man: thanks a lot - i always thought that \1,\2,... referred to the last matched \(\)
14:32  koala_man: it does
14:33  sas: then it shold have shown kkk
14:34  koala_man: ..\(.\) matches sh1 , so just show the 1. repeat for all further matches in the string
14:35  geirha: # sed 's/..\(.\)/\1/g' <<< abcdefghi
14:35  evalbot: geirha: cfi
14:37  sas: hmmmm it will take time to sink it in
14:41  lhunath: for sh1wq2er4jkk the first run of s/..\(.\)/\1/g looks for ..\(.\), finds 'sh1', replaces with \1, which is 1.  The second run continues where the first left off, that is AFTER 'sh1' found by the first run.  Looks for ..\(.\), finds 'wq2', replaces with \1, which is 2.  And so on.
14:43  sas: lhunath: THANKS got it
15:28  massimo_: Hi. [[ $foo == "foo" ]]  is a better syntax than using the test variant  [ $foo -eq "foo" ]  ? Is that true? Is that also true for ksh?
15:29  geirha:  [ $foo -eq "foo" ] is an error
15:29 --- massimo_ is now known as massimo
15:29  geirha: # foo=foo; [ $foo -eq "foo" ]
15:29  evalbot: geirha: bash: [: foo: integer expression expected
15:29  geirha: !tests
15:29  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
15:30 --- jzacsh is now known as jzacsh_
15:30  geirha: For ksh, ask #ksh
15:33  massimo: geirha: Thank. I meant  [ $foo = "foo" ] .  [ ] does invoke test, does [[ ]] also invoke test? Beside safeness is that also a matter of performance to call [[ ]] ?
15:33  geirha: ![[
15:33  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
15:34  geirha: [[ can do everything [/test can, and then some.
15:34  lhunath: massimo: neither invoke test.  [ is a bash builtin, [[ is a bash keyword
15:35  lhunath: [[ is a matter of safety, features, and consistency.
15:36  lhunath: [ is useful if you want to look like you're writing a portable script even if you're really not; and in the process, enjoy shooting yourself in the foot.
15:36  massimo: lhunath: Ok, but [ being a bash builtin behaves the same as test does? No test call is forked.
15:37  lhunath: test is also a bash builtin
15:37  lhunath: but yes, they behave the same (other than the fact that [ requires a trailing ])
15:37  massimo: Nice. ksh people say they invented the [[
15:38  lhunath: I'm sure they invented a lot more than that.
15:40  massimo: lhunath: I need to programm ksh scripts while I'm more used to Bash. Can I say ksh can do most of the things bash can do? So as for the if [[ $foo == "foo ]] ; then echo "true" ; fi I see no difference.
15:40  lhunath: I would rather say bash can do most of the things ksh can do.
15:41  lhunath: ksh can likely do all of the things bash can do.
15:41  massimo: Fine, then I'm safe to program bash style..
15:41  nDuff: massimo, we didn't say the syntax was the same :)
15:41  lhunath: I'm no authority on the subject, though.
15:42  lhunath: bug pgas about it, he looks like he knows what he's talking about when he talks ksh.
15:43  nDuff: massimo, ...by the way, you've heard the story about David Korn at the USENIX Windows NT conference, right?
15:43  massimo: When comparing strings, why is it better to write  [[ "$foo" == "moo" ]]  than  [[ $foo == "moo" ]]  ?
15:43  lhunath: it makes no difference.
15:43  massimo: nDuff: No.
15:44  The-Compiler: massimo: because "" doesn't stand for strings in bash, but for "don't split words". Inside [[ it doesn't make any difference though.
15:44  The-Compiler: !quotes > massimo
15:44  greybot: massimo: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
15:44  lhunath: [[ moo == $foo ]] and [[ moo == "$moo" ]] ARE different, though.
15:44  lhunath: sigh.
15:44  lhunath: [[ moo == $foo ]] and [[ moo == "$foo" ]] ARE different, though.
15:44  The-Compiler: lhunath: how so?
15:45  lhunath: if the right-hand side is quoted, the = does a string comparison.  if not, the = does a glob pattern match.
15:45  The-Compiler: lhunath: using a variable, it still doesn't make any difference, does it?
15:45  lhunath: # foo=ab*; [[ abc = $foo ]]; echo $?; [[ abc = "$foo" ]]; echo $?
15:45  evalbot: lhunath: 0
15:45  evalbot: lhunath: 1
15:46  nDuff: massimo, ...I'm having some trouble finding the original telling (which David Korn confirmed as true) anywhere without ads, so I'm pastebinning it: https://gist.github.com/raw/706596/e7ea3c0ed19e68f5b273ed1ba49c94e08e2ebc16/gistfile1.txt
15:46  lhunath: the latter fails because the string abc is not the same as the string ab*
15:46  lhunath: the former uses ab* as a glob pattern and abc matches it.
15:47  lhunath: so always put your variables on the left and your constants on the right, unless you're gonna quote both parts.
15:52 --- massimo_ is now known as massimo
15:56 --- qorep_ is now known as qorep
15:57 --- qorep is now known as Guest534
16:00  Jak2000: hi all, i have a file named respsql with the next line: mysqldump --opt embarques > /backup/mysql/07embarques19Nov2010.sql -uroot -p!*kaan@& if execute the file respsql say me access deneied, but if remove the password of the line: mysqldump --opt embarques > /backup/mysql/07embarques19Nov2010.sql -uroot -p and execute again the file respsql and type the password:  !*kaan@&   work, why? any
16:00  Jak2000: advice? thx
16:00 --- Guest534 is now known as qorep
16:01  koala_man: Jak2000: single quote the password
16:02  koala_man: # echo -uroot -p!*kaan@&
16:02  evalbot: koala_man: -uroot -p!*kaan@
16:02  evalbot: koala_man: [1] 230
16:02  evalbot: koala_man: [1]+  Done                    echo -uroot -p!*kaan@
16:03  koala_man: # echo -uroot -p'!*kaan@&'
16:03  evalbot: koala_man: -uroot -p!*kaan@&
16:05  lhunath: !quotewhen > Jak2000
16:05  greybot: Jak2000: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
16:23  basyirstar1: can anyone help me with this http://pastebin.com/gm2H3nbR
16:24  nDuff: !questions > basyirstar1
16:24  greybot: basyirstar1: Ask questions. Don't just paste 200 lines of code on a web page and say "HERE MY KODE <URL> WHATZ RONG". Describe the problem, clearly and concisely. If necessary, give the SMALLEST sample code that demonstrates the problem.
16:25  basyirstar1: whe i'm trying to compile the game name excalibur it produce those result...
16:25  nDuff: basyirstar1, that isn't an error or a result
16:25  greycat: Compiling stuff is not a bash question.
16:26  grosboulet: Hello
16:26  basyirstar1: but compile is not working
16:26  grosboulet: How can I encode binary file into base64 ?
16:26  nDuff: basyirstar1, ...but you haven't pastebinned anything which would describe why the compile is not working.
16:26  lhunath: Fixing your compile stuff is not a bash question either.
16:26  greycat: If you are having trouble compiling something, you contact the support group for that thing.  Not us.
16:26  nDuff: grosboulet, base64 <your_binary_file
16:27 * greycat blinks
16:27 * greycat reads a few man pages
16:27  basyirstar1: nDuff, this in my directory http://pastebin.com/vBzbuXHU
16:28  basyirstar1: nDuff, can you guide me?
16:28  greycat: nDuff: and how would you do it on something that isn't GNU coreutils 6.x or whatever the first version is that has that tool?
16:28  grosboulet: thanks nDuff
16:28  geirha: openssl base64 < file
16:28  nDuff: !nabq > basyirstar1
16:28  greybot: basyirstar1: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
16:30  grosboulet: nabq ? what's it mean ?
16:30  nDuff: grosboulet, see greybot's response
16:30  basyirstar1: greybot, umm ... channel, but i have search it over the internet but it didn't working... or confusing me...
16:31  greycat: basyirstar1: FIND THE CHANNEL THAT SUPPORTS THIS GAME.  THEN GO THERE.
16:31  basyirstar1: greybot, ok...
16:31  grosboulet: greycat and greybot... well, i'm confusing
16:31  basyirstar1: greybot, fine
16:33 --- MuzerAway is now known as Muzer
16:33  nDuff: greycat, ...I presume this platform also doesn't have uuencode -m?
16:34  greycat: nDuff: Just asking in general.  (Yes, I can come up with a platform that has neither GNU coreutils nor uuencode -m....)
16:34  geirha: openssl?
16:34 * nDuff would probably fall back to Python; a platform with Python is one he has no interest in working on. :P
16:34  greycat: The openssl base64 answer is probably the best one for that.
16:34  nDuff: ahh, good call
16:35  greycat: For the record, OpenBSD has uuencode -m but not base64 as a standalone tool.
16:35  greycat: HP-UX 10.20 has neither, of course.
16:35  geirha: I wonder why they didn't add base32 while they were at it
16:46  Orbixx: I'm running a bash script that is calling 'rm' (with direct path), however I'm trying to delete a bunch of files (specifically /root/sql-backups/*.bak.gz) however when I call the script, it specifically says the files cannot be found (not one match is made with the wildcard), but if I call the same command on a bash shell, it works without a hitch.
16:47  greycat: Make sure you didn't use set -f
16:47  Orbixx: No switches have been set.
16:47  greycat: Make sure you didn't quote the glob.
16:47  nDuff: Orbixx, echo $-
16:47  Riviera: !set-x
16:47  greybot: Setting the -x option on bash enables a debugging mode that makes bash output the command name and arguments that it will run (after all parsing and expansion has been applied). Set it by starting a script with ''bash -x ./myscript'' or putting ''set -x'' before the code you want to debug. ''set +x'' turns this behaviour off.
16:47  Orbixx: nDuff: 'hB'
16:48  nDuff: Orbixx, ...can you paste a minimal reproducer?
16:49  greycat: I'm betting it's something like foo=glob; rm "$foo"
16:49 * nDuff is guessing as much
16:49  Orbixx: nDuff: It is pretty much 'rm /path/to/dir/*.bak.gz'
16:49  greycat: !exact
16:49  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
16:49  greycat: "pretty much" doesn't help us
16:49  nDuff: Orbixx, ...if you can put that one line into a script, and that script reproduces the bug, then and only then is that an adequate explanation.
16:49  Orbixx: Of course.
16:49  Orbixx: Yes, I understand.
16:49  Orbixx: I'll do it now.
16:52  Orbixx: nDuff: greycat: http://pastebin.com/kV9F7BRL
16:52  Orbixx: oh, forgot one thing
16:52  Orbixx: d'oh
16:52  nDuff: Orbixx, the quotes
16:52  greycat: You quoted the glob.
16:53  nDuff: Orbixx, you're explicitly telling the shell NOT to expand the glob
16:53  greycat: 10:47  greycat> Make sure you didn't quote the glob.
16:53  Orbixx: I need to brush up on my bash D:
16:54  Orbixx: Singles quotes?
16:54 * Orbixx isn't sure
16:54  lhunath: !quotewhen
16:54  greybot: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
16:54  lhunath: !args > Orbixx
16:54  greybot: Orbixx: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
16:55  greycat: *Either* kind of quotes will prevent the glob from being expanded.
16:55  lhunath: if you want a * to expand, it needs to be syntactical.
16:55  Orbixx: Ah I see.
16:55  lhunath: the job of quotes is to turn what is inside them into literal characters.
16:56  lhunath: if you quote a star, it will no longer be syntactical.  if you don't want that, don't do it.
16:56  Orbixx: Got it.
16:56  Orbixx: Many thanks all.
16:56  Orbixx: rm "${PATH}"/*.bak.gz
16:57  lhunath: !varcap
16:57  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
16:57  Orbixx: Works for me. :>
16:57  greycat: I doubt you want to use $PATH here.
16:57  jophish: Howdy all!
16:57  jophish: Who likes a challenge
16:57  lhunath: that's probably the most awesome example of varcap fail.
16:57  jophish: Who would really like to help someone out?
16:57  Orbixx: Well, was just using as an example.
16:57  greycat: !ask
16:57  greybot: You need not ask permission to ask a question. Just ask and be patient. http://mywiki.wooledge.org/NetEtiquette
16:57  Orbixx: Good call, though.
16:58  jophish: greycat: I'm just trying to drum up some excitement :)
16:58  greycat: It's hard to get excited about the 7134th iteration of !faq 1
16:58  nDuff: jophish, we're a bunch of jaded grouches who distrust people who try to drum up excitement.
16:58  nDuff: well, I am, anyhow.
16:59  Orbixx: In before anti-climax.
16:59  Riviera: Of course. It's soon to be christmas!
16:59  Riviera: Presents, joy! <3
16:59  greycat: Christmas == "What did you get me?!" == ! joy
16:59  jophish: nDuff: this is to do with Star Wars though
16:59  jophish: anyway. I have a file like this: http://pastebin.com/eauMEzm1
17:00 * nDuff has spent the last several years setting low expectations, and thus does not share greycat's problem.
17:00  Orbixx: Oh whilst I'm here (I know it's not strictly relevant to the channel), but how do I get echo not to
17:00  Orbixx: You know, in fact I'll just RTFM like I should.
17:00  greycat: Orbixx: printf or echo -n
17:00  jophish: What would be great, would be to extract all the vader quotes
17:00  greycat: jophish: grep VADER:
17:00  Orbixx: Good guess though.
17:00  jophish: Into a format, where every quote is not split by line breaks, and is separated from all of the other quotes by two newlines
17:01  jophish: greycat: some of the quotes have newlines in the middle of them
17:01  greycat: Ah.  I didn't read that far down.
17:01  jophish: so, ideally, I want to replace all the single newlines with spaces
17:01  jophish: and then grep through
17:01  jophish: and remove the VADER: tag
17:02  nDuff: wish you'd finished the question before I started writing code
17:02  greycat: I'd keep it in its current form, and just set up a !faq 1 loop that reads line by line, setting a flag variable and copying the contents into a buffer whenever it finds VADER: and then unsetting the flag when it finds a blank line.
17:03  jophish: !faq 1
17:03  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
17:03  greycat: Also, um, pasting the *entire* file was probably a bit overkill.
17:03  jophish: well, cat darth | pastebinit
17:04  lhunath: pastebinit < darth
17:04  greycat: head -400 darth | pastebinit
17:04  jophish: I'm jsut waiting for someone to say "You have much to learn, my young apprentice"
17:05  greycat: I'm sure we can find a place to throw in a "I find your lack of quotes disturbing."
17:05  jophish: :D
17:06  jophish: I'm going to construct this loop now
17:06  jophish: For other movies, I had written this in C. I think that bash is probably a better suited to thsi
17:09  skered: ![
17:09  greybot: [ is NOT part of the `if' syntax. It's a normal, ordinary COMMAND. The `if' just checks its exit status. See `help test', http://mywiki.wooledge.org/BashGuide/TestsAndConditionals , and http://partmaps.org/era/unix/award-example-backticks.html
--- Log closed Fri Nov 19 19:02:21 2010
--- Log opened Fri Nov 19 19:02:48 2010
19:02 --- Users 549 nicks [0 ops, 0 halfops, 0 voices, 549 normal]
19:06 --- Channel #bash was synced in 214 seconds
19:07  greycat: You'd need a loop.
19:08  ss0: greybot:  thanks. It's too bad you can't just jam it in there and have bash iterate over it with no further input.
19:08  greycat: Bash is not a high-level language.
19:09  ss0: greybot:  But it is a very fun one! thanks
19:10  ss0: greycat:  sigh itchy tab finger.
--- Log closed Fri Nov 19 19:35:50 2010
--- Log opened Fri Nov 19 19:36:50 2010
19:36 --- Users 545 nicks [0 ops, 0 halfops, 0 voices, 545 normal]
19:41  Riviera: Good to have a superhero on our side.
19:42 --- Channel #bash was synced in 408 seconds
19:59  mehwork: if i have s="/home/storage/foo.com/uploads" how can i get the substr of just '/home/storage/foo.com/'. Eg take out the 'uploads'?
19:59  go|dfish: !pedirname
19:59  go|dfish: or not.
20:00  go|dfish: # s=/home/storage/foo.com/uploads; echo ${s%/*}/
20:00  evalbot: go|dfish: /home/storage/foo.com/
20:08  redmorning: !pe
20:08  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
20:13  realubot: How do I create a do { } while loop in bash? I mean a while loop where the first runalways will be executed?
20:14  greycat: The easiest way is to use while true; do ...; foo && break; done
20:14  realubot: greycat: Isn't there any real do while loop as in PHP?
20:14  greycat: nope
20:14  jShaf: I am figuring out how to get a listing of not just directories but the files in those directories as well so the listing would look like this:
20:14  jShaf: dirA/foo.txt
20:14  jShaf: dirA/boo.txt
20:14  jShaf: dirB/bar.txt
20:14  greycat: !find > jShaf
20:14  greybot: jShaf: http://mywiki.wooledge.org/UsingFind
20:15  realubot: Ok, thansk. Then I will get along with break.
20:17  jShaf: greycat: sweet, thanks and how would you not include the ./ in those listings?
20:17  jShaf: ./ shows in beginning for each
20:19  rhizmoe: in ^r history-searching, can i search a pattern?
20:20  rhizmoe: like "vi...something_that_is_probably_an_unknown_path...filename"
20:20  rhizmoe: that middle part is just a placeholder, natch.
20:26  maek: can someone explain what this is doing please?  config=${CONFIG-/etc/foo.conf}  ? config = /etc/foo.conf unless CONFIG=bar.conf  is set ?
20:27  nDuff: !pe > maek
20:27  greybot: maek: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
20:28  nDuff: maek, that said, I wonder if it's intended to be :- rather than -
20:29  nDuff: # echo ${var:-default_value}; var=foo; echo ${var:-default_value}
20:29  evalbot: nDuff: default_value
20:29  evalbot: nDuff: foo
--- Log closed Fri Nov 19 20:37:13 2010
--- Log opened Fri Nov 19 20:42:40 2010
20:42 --- Users 550 nicks [0 ops, 0 halfops, 0 voices, 550 normal]
20:43 --- Channel #bash was synced in 85 seconds
20:46  rustymyers: Question: should I read Bash Cookbook first or classic shell scripting first?
20:46  greycat: No.
20:46  rustymyers: both are the O'Reilly books
20:46  nDuff: rustymyers, see the guide in the topic
20:46  greycat: I haven't read either one, but it's a fair bet they both suck.
20:46  rustymyers: I do see the link to the guide in the topic, yes
20:46  rustymyers: hehe
20:47  greycat: I'd be happy to be proven wrong -- for there to be a SINGLE decent bash book in the entire world -- but I'm not holding my breath.
20:47  rustymyers: Hows the guide in the topic compare to the ABS guide?
20:47  greycat: !abs
20:47  greybot: The infamous "Advanced" Bash Scripting Guide should be avoided unless you know how to filter out the junk. It will teach you to write bugs, not scripts. In that light, the BashGuide was written: http://mywiki.wooledge.org/BashGuide
20:47  nDuff: rustymyers, ...that's what we endorse in terms of documentation. Sturgeon's Law very, very much applies on the topic.
20:48  rustymyers: I see, I don't suppose its in print anywhere?
20:49  greycat: !pdfguide
20:49  greybot: PDF version of the BashGuide: http://stuff.lhunath.com/BashGuide.pdf or print http://mywiki.wooledge.org/FullBashGuide (to paper or PDF) for the latest version.
20:49  greycat: wget tells me lhunath last updated that in October, so it's not as out of date as it normally is....
20:50  rustymyers: great, thanks greycat!
20:51  rustymyers: ...and everyone else ;-)
20:51  greycat: lhunath wrote the majority of the BashGuide, so he deserves most of the credit
20:54  alesan: hi
20:54  rustymyers: much appreciated lhunath
20:54  alesan: how can I write an hex value to a given address in memory from a POSIX sh prompt? In Linux...
20:55  greycat: You can only write to your own process's memory space.
20:55  greycat: There is no POKE in unix.
20:55  alesan: no, I can write to physical memory using /dev/mem
20:55  greycat: Have fun, then.
20:56  alesan: read is easy with dd
20:56  alesan: greycat, why did you say "You can only write to your own process's memory space." ?
20:56  greycat: Because normally you are not ROOT and EVIL.
20:56  greycat: But apparently I don't have enough people on /ignore.
20:58  alesan: I am on an embedded system with limited "programs" installed and there is a faulty driver. By writing a specific value to 0x40002000 I can reset the RAS and see if it works
20:58 --- erage is now known as erage_m
20:58  alesan: but, evidently I'm EVIL
20:59  greycat: I tend to assume everyone here is on an actual operating system, not a single board computer.
20:59  greycat: And for purposes of this discussion, let's say that MS-DOS doesn't count as an OS.
21:00  rustymyers: alesan: I think he meant ROOT is EVIL
21:00  greycat: That said, if you need to POKE values into raw memory locations of your single-board computer and its embedded controller firmware whatever, then write something in C using lseek(), or fudge it with dd skip=.
21:00  greycat: rustymyers: POKEing raw data into random locations in memory would be substantially evil on a running multiuser OS.
21:01  rustymyers: greycat: you know thats right!
21:01  alesan: greycat, of course I have that, but in this particular condition, I reproduced the problem (with only happens every so often) and I realized I do not have such little program loaded
21:02  alesan: so I was wondering if using a POSIX shell I could have done that
21:02  greycat:                 fudge it with dd skip=.
21:02  alesan: s/with/wich
21:02  alesan: yes but what about the input, how can I provide some "hex" values as input
21:02  greycat: *plonok*
21:02  greycat: *plonk*
21:02  mehwork: how do you echo "foo\n" ?
21:03 --- erage_m is now known as erage
21:03  greycat: You want two newlines?  printf 'foo\n\n'
21:03  mehwork: without printing the newline , do i have to echo -e?
21:03  mehwork: yeah
21:03  mehwork: thanks
21:04  mehwork: do expansions work the same with printf as they do with echo?
21:04  alesan: to everybody: do you have any idea why my question caused such an outrage?
21:04  greycat: !printf
21:04  greybot: The printf command: http://bash-hackers.org/wiki/doku.php/commands/builtin/printf
21:04  rustymyers: OMG alesan, what do you have to gain from that question?
21:05  geirha: echo doesn't expand anything. Bash does.
21:05 * rustymyers should never answer a question with a question
21:05  greycat: geirha: that's splitting hairs when he obviously means bash's echo -e
21:05  alesan: rustymyers, well do you know how to feed binary data to dd?
21:06  geirha: Ah, didn't read enough context
21:06  geirha: alesan: Either with if= or send it to it's stdin
--- Log closed Fri Nov 19 21:12:58 2010
--- Log opened Fri Nov 19 21:14:22 2010
21:14 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
21:14  greycat: mac-: You could write a script which does both commands, and then run that script.
21:14  greycat: mac-: but it still won't affect your FTP client.
21:14  greycat: Children can't touch their parent's environment.
21:14  alesan: geirha, you think that should work?
21:14  mac-: it should affect only shell variable
21:14  greycat: (Unless you're alesan on his embedded board where he fucks with random memory locations.)
21:14  geirha: alesan: You think it didn't?
21:14  mac-: greycat: but if I will write separate script, ftp will execute it on a child shell anyway
21:14  alesan: geirha, thanks
21:14  greycat: Right.  You cannot change the environment of a running /usr/bin/ftp process.
21:17  mac-: heh
21:17  greycat: You'd have to launch a new one.
21:17  geirha: alesan: Would be easier with a more suitable language
21:17  mac-: I have to close ftp session, export new value of variable and open ftp session again
21:17  nDuff: well, you could attach with a debugger and force it to call setenv() if you felt evil :P
21:17  alesan: geirha, I have already written a read and write utility in C
21:17  greycat: What environment variables does your FTP client actually use?  Other than, say, ftp_proxy....
21:17  alesan: I just do not have it in this instance and the problem I am trying to fix is not easy to reproduce
21:17  mac-: my own variable, I need to change value of some control variable when script executing
21:17  greycat: Move it to a config file instead?
21:17  mac-: config file ?
21:17  Huskypaw: How to compute 2^2 with bash?
21:17  greycat: So that your script can read it in each time....
21:17  greycat: # echo $((2**4))
21:17  evalbot: greycat: 16
21:17  greycat: Assuming you mean exponentiation and not XOR.
21:17  Huskypaw: Thanks greycat!
21:18 --- erage is now known as erage_
21:19 --- Channel #bash was synced in 346 seconds
21:22  eportel6607: Guys shouldn't this work?  mv /media/temp //media/$(date +%Y%m%d)
21:23  greycat: If you have appropriate permissions, etc.
21:23  eportel6607: I just want to rename a directory to the date?
21:23  greycat: Do you have write permission on /media itself?
21:23  eportel6607: hmmm  greycat
21:23  geirha: Or are you trying to do this with a cronjob?
21:23  greycat: Is /media/temp a regular dir, or a mount point?
21:23  eportel6607: damn...let me check
21:24  eportel6607: greycat: /media is a mount point but the folder is inside that mout point directory
21:24  greycat: That should be OK, then.
21:25  greycat: Make sure it's mounted read-write.
21:26  eportel6607: greycat: it's looking at the date string as a command and it's indicated command not found
21:26  eportel6607: greycat: ok I'll check that also
21:30  geirha: !faq cron
21:30  greybot: http://mywiki.wooledge.org/BashFAQ/043 -- Why does my crontab job fail?  0 0 * * * some command > /var/log/mylog.`date +%Y%m%d`
21:31  mjrosenb: is there any way of telling if the code currently being executed is a result of being invoked under bash or being sourced?
21:31  greycat: why does it matter?
21:31  mjrosenb: greycat: if it is being sourced, i just want to define a bunch of functions
21:32  mjrosenb: if it is being executed, i want to run said functions
21:32  eportel6607: greycat: the exact line in the script is mv /media/mybook/temp /media/mybook/$(date+%Y%m%d)   The error is $(date+%Y%m%d) command not found and "mv: media/mybook/temp/ media/mybook/temp are the same file"   WHAT?
21:32  geirha: man bash  search for BASH_SOURCE
21:32 * mjrosenb suspects that there is a better word than "being executed"
21:33  krzie: just make the stuff you source only things being defined
21:33  greycat: Have you tried "return 2>/dev/null" yet?  "return" only works when you're sourced.  You could define the functions, then return 2>/dev/null, then execute them.
21:33  greycat: eportel6607: You lost the SPACE between date and its argument.
21:34  mjrosenb: geirha: was that for me?
21:34  eportel6607: greycat: so "$(date +%Y%m%d)?  Sorry man....I've been working on this waaay too long. :)
21:35  greycat: Or not long enough.
21:35  eportel6607: or %Y %m %d
21:35  greycat: Yes, you must include whitespace between a command and its argument list.
21:35  greycat: If you want spaces between the year, month and day, then you will have to quote that bit.
21:35  kbukhari: hello
21:35  eportel6607: greycat: ahhhh
21:36  eportel6607: your good.  i'll try that
21:36  kbukhari: i want to search something in 100 files and delete that linke which containg search word
21:36  greycat: !faq replace > kbukhari
21:36  greybot: kbukhari: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
21:37  kbukhari: grep -r -i SOMTHING show me
21:37  geirha: mjrosenb: Yes, though greycat's suggestion sounds better
21:37  greycat: you'll have to start by throwing away grep -r
21:37  kbukhari: "grep -r -i SOMTHING ./ "
21:38  kbukhari: show me the reselts
21:38  mjrosenb: greycat: oh hey, i didn't even see that.  that sounds like it'll work
21:38  kbukhari: now i want to remove them all
21:38  greycat: Yes, got that.  Now stop doing that, and read the bot's answer.
21:38  kbukhari: from every fles
21:38  mjrosenb: kbukhari: *results
21:38  greycat: Of all the things to correct, his spelling isn't on top of the list.
21:41  kbukhari: mjrosenb, it show me the lines contain that word
21:41  kbukhari: i want to remove that fail
21:41  greycat: !faq replace > kbukhari
21:41  greybot: kbukhari: http://mywiki.wooledge.org/BashFAQ/021 -- How can I replace a string with another string in all files?
21:41  greycat: You want to remove the linke, or the fail?
21:41  greycat: Make up your mind.
21:42  kbukhari: files
21:42  kbukhari: sorry links
21:42  greycat: *sigh*
21:43  kbukhari: my website is infected with a script
21:43  greycat: SKADNKJASKJDHKLJASHDKJL
21:43  greycat: FUCKING PHP IDIOTS!
21:43  kbukhari: and it infected almost all files
21:43  lhunath: restore it from backup.
21:43 * hashashin nas
21:43  greycat: FUCK FUCK FUCK FUCK ....
21:43  kbukhari: i am not php guy
21:43  greycat: I honestly, truly thought he meant "lines" the first time.
21:43  lhunath: calm blue ocean.
21:44  lhunath: heh.
21:44  kbukhari: cript it writen in one line
21:44  greycat: I *will not* help you remove weird fucking regexes from *.php files.  Go to ##php.
21:45  lhunath: if your server is compromised; restore it from backup.
21:45  kbukhari: it can be done in bash
21:45  kbukhari: and if you dont want to help then shut your fucking ass greycat
21:45  greycat: @400000004ce4347c269e15e4 <c0nsumer_> hello! i need from help with this "http://pastebin.com/pfyHmUzP" all pages *.php on my website are infected with this.. how can i remove using sed, i don't know how use scape to remove this, some one can help me?
21:46  greycat: I sent HIM to ##php also.
21:46  greycat: Don't know if he ever got there.
21:46  greycat: People tend not to listen to us.
21:46  xenyl: haha
21:47  xenyl: php does put some buttery fodder in the ears
21:47  greycat: That c0nsumer guy, as I recall, couldn't even manage to tell us whether the expression he wanted to remove was on a separate line or not.
21:48  greycat: At which point most of us gave up.
21:48  ss0: greycat:  I didn't know you had to deal with that sort of thing; I can see now why you can be short on patience.
21:48  greycat: Welcome to #bash.
21:49  Goosey: Hello, I am trying to pipe each line from a "find . -name "blah"" command into chown, but I don't know how to split it. xargs seems to dump all the lines of found files into one execution of chown command. Actually I am piping into echo to test. The closest I have found is a wikipedia page talking about pipemilling.
21:49  ss0: greycat:  btw thanks for all the help you have helped me numerous times and I really appreciate it.
21:49  greycat: !find > Goosey
21:49  greybot: Goosey: http://mywiki.wooledge.org/UsingFind
21:49  greycat: Goosey: you want to use -exec, not a pipe
21:49  kbukhari: he need to learn FUCKIN manars
21:49  xenyl: speaking of php i was thinking of replacing wordpress with a plain bash script for uploading static web pages :)
21:49  geirha: Maybe, just maybe, he'll do backups next time.
21:50  Goosey: ah, thanks greycat. Is there a way to do it with a pipe as well? It seems like a more generalized pattern that might be useful outside of find
21:50  greycat: Or he could read the page that was given to him (twice) and construct a find | perl -pi -e solution.
21:50  ss0: kbukhari:  I really don't care about your opinion. I have never seen you help anyone or ask anything except questions that can be solved by google in less thna 3 seconds.
21:50  greycat: Goosey: the UsingFind page is full of tips
21:51  Goosey: Cool, I will read it first. Thanks
22:00 --- rbronosky is now known as richardbronosky
22:06  Goosey: Thanks greycat. :) i've constructed my command.
--- Log closed Fri Nov 19 22:14:07 2010
--- Log opened Fri Nov 19 22:14:31 2010
22:14 --- Users 553 nicks [0 ops, 0 halfops, 0 voices, 553 normal]
22:15 --- Channel #bash was synced in 79 seconds
22:25  bnovc: I have a script where I do last_revision=$(git describe --abbrev=0 origin/$branch) ... this works fine, but if I add " | grep $branch-" (or pipe grep anything) the script silently exits out
22:25  greycat: !exact
22:25  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
22:25  bnovc: that is exact :\
22:25  greycat: No, show the line as is.  Not "I have this" "I added that".
22:26  bnovc: last_revision=$(git describe --abbrev=0 origin/$branch | grep foo)
22:26  greycat: Do you have 'set -e' in the script?
22:26  bnovc: yes
22:26  bnovc: but what's the error??
22:26  greycat: Then the grep is not finding a match, which causes it to return non-zero, which causes bash to exit.
22:27  bnovc: ah... I guess that makes sense
22:27  bnovc: should I just unset "set -e" for that section?
22:27  sneakers: Hi, I have a little bash snippet I wrote for renaming all files in a directory to a number that increases by 1 integer for each file (while keeping the file extension the same).  Can anyone help me find out what I did wrong?  Thanks.  http://fpaste.org/TBtf/
22:28  greycat: sneakers: you do not have a loop, so having a counter variable is ... not very counting.
22:28  bnovc: I guess I was thinking that 'set -e' only applied to main commands and not stuff in subcommands
22:28  bnovc: (or at least thats the behavior I wanted)
22:28  greycat: !faq set -e
22:28  greybot: http://mywiki.wooledge.org/BashFAQ/105 -- Why doesn't set -e (set -o errexit) do what I expected?
22:28  bnovc: greycat: thanks
22:29  greycat: If you insist on keeping the set -e, you could do something ugly like    x=$(foo | bar; true)
22:29  erUSUL: sneakers: well where do you increase your counter? find can not do that for you. you have to use a loop construct.
22:29  erUSUL: sneakers: while; or for.
22:29  sneakers: greycat, erUSUL, like an if/then look?  or a do/while loop?
22:29  greycat: sneakers: Your code also has find, which is recursive.  This means we need a much better definition of what you are trying to do.
22:30  greycat: (and "if" is not a loop.  while and for are loops.)
22:30  sneakers: greycat, I want to run a script and have all the files named as follows:  01.dm_68 02.dm_68 03.dm_68 etc
22:31  greycat: sneakers: And how does the recursion play into this?
22:31  greycat: You want dir1/01 dir1/02 dir1/03  dir2/01 dir2/02  ?
22:31  sneakers: greycat the recursion is probably crap that needs to be removed
22:31  greycat: Or do you want dir1/01 dir1/02 dir1/03  dir2/04 dir2/05  ?
22:32  sneakers: greycat, no.  there are no subdirectories.  all files are in that one directory.  I want:   ~/.q3a/q3ut4/demos/01.dm_68 ~/.q3a/q3ut4/demos/02.dm_68 ~/.q3a/q3ut4/demos/03.dm_68
22:33  greycat: cd ~/.q3a/q3ut4 || exit 1; i=1; for f in *; do printf -v x %02d $i; echo mv "$f" "$x.${f##*.}"; ((i++)); done
22:34  greycat: (could also merge the printf and the i++)
22:34  sneakers: can I put each one on a new line?
22:34  sneakers: the line ends after each semicolon yes?
22:34  greycat: yes
22:35  greycat: we write things compactly for IRC, but in a real script, you'd use newlines
22:35  sneakers: greycat, like this?  http://fpaste.org/zvjN/
22:35  trash: identation is missing.
22:35  trash: inden*
22:36  greycat: You can remove ; at the end of a line.
22:37  sneakers: trash like this?  http://fpaste.org/aGnR/
22:37  greycat: better, yes
22:38  greycat: and put   #!/usr/bin/env bash   at the top of it
22:38  greycat: or #!/bin/bash or whatever, if you prefer that way
22:43  sneakers: greycat, for some reason it didn't work
22:43  sneakers: the file name stayed the same
22:44  greycat: It should have written a bunch of mv commands to stdout.
22:44  greycat: If they look sane, then remove the 'echo'.
22:45  ss0: greycat:  I suppose expect is not covered under the mandate of this channel?
22:45  greycat: correct
22:45  sneakers: greycat, http://fpaste.org/ARSe/
22:45  greycat: It's written in Tcl, so we hope #tcl supports it.
22:45  ss0: greycat: Thanks! I will poke around over there at some point.
22:46  greycat: 16:44  greycat> If they look sane, then remove the 'echo'.
22:46  sneakers: greybot, Do you see the problem>?
22:46  greycat: Did you remove the echo yet?
22:47  sneakers: greycat, Oh. I see.  Works now.
22:47  greycat: I like to be VERY sure something irreversible like an rm or a mv is going to work before I actually do it.
22:48  jco: hello, does anyone knows how to redirect stdout to stdout and a file from inside a script? I'd like to achieve something like tee(1) but from inside the script
22:48  greycat: jco: exec > >(tee file)     # but there may be synchronization issues
22:48  greycat: especially after you change the question to something even harder
22:48  greycat: which should be in about... 90 seconds
22:49  jco: greycat: lol, let me try (although IIRC I already tried that...)
--- Log closed Sat Nov 20 13:48:31 2010
