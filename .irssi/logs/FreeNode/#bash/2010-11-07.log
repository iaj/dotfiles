--- Log opened Sun Nov 07 20:54:15 2010
--- Log closed Sun Nov 07 20:54:15 2010
--- Log opened Sun Nov 07 20:59:39 2010
20:59 --- Users 517 nicks [0 ops, 0 halfops, 0 voices, 517 normal]
21:00  poisonbit: # v1='1'; v2='2'; eval vars_${v1}='foo'; eval vars_${v2}='bazz'; set | grep ^vars_
21:00  evalbot: poisonbit: vars_1=foo
21:00  evalbot: poisonbit: vars_2=bazz
21:00  poisonbit: # v1='1'; v2='2'; eval vars_${v1}='foo'; eval vars_${v2}='bazz'; set | grep ^vars_ | sed "s/vars_.*=//"
21:00  evalbot: poisonbit: foo
21:00  evalbot: poisonbit: bazz
21:00  poisonbit: # v1='1'; v2='2'; eval vars_${v1}='foo'; eval vars_${v2}='bazz'; set | grep ^vars_ | sed "s/=.*//"
21:00  evalbot: poisonbit: vars_1
21:00  evalbot: poisonbit: vars_2
21:00  poisonbit: I mean if the last set |... etc cmds can be done just using bash
21:00  poisonbit: instead of grep, sed, awk, etc
21:01 --- Channel #bash was synced in 98 seconds
21:04  hatten: my memory is blank, how do I achieve "cut -c 1 $time", ie let cut cut a variable, not a file. Or is "echo $time|cut -c 1" the only way?
21:04  poisonbit: # var=ble; cut -c 1 <<< $var
21:04  evalbot: poisonbit: b
21:04  twkm: cut is a filter.  consider using parameter expansion instead.
21:05  hatten: thx@poisonbit
21:05  poisonbit: # var=ble; echo ${var:0:1}
21:05  evalbot: poisonbit: b
21:13  StevenX: !find
21:13  greybot: http://mywiki.wooledge.org/UsingFind
21:17  [bottzman]{xmb}: the sky is high, the cloud is low
21:20  Noble: I have the following command: find .
21:20  Noble: err
21:21  Noble: find . -mtime +2 ! -type d -exec mv {} old/ \;
21:21  Noble: I want it to move all files, but not directories older than two days into the old/
21:22  taylanub: your line won't move _any_ directory
21:24  Noble: Ok
21:24  Noble: But it still recurses into dirs, and moves files into the old/ dir. I want it to move whole folders without touching the folder structure inside.
21:25  taylanub: -depth
21:25  Noble: depth should be 1 or 0? Can I also blacklist folders?
21:26  taylanub:  ! -name   for blacklist. or if your version supports it, -regex
21:26  taylanub: oh, it's not -depth
21:27 * taylanub RTFMs
21:27  [bottzman]{xmb}: nada
21:27  taylanub: -maxdepth
21:27 --- [bottzman]{xmb} is now known as {xmb}{bottz}{man
21:28  Noble: taylanub: I see. is 0=unlimited and 1=fist?
21:28 * taylanub experiments
21:28 --- {xmb}{bottz}{man is now known as {xmb}{bottz}man
21:28  erUSUL: !prune
21:28  greybot: see http://mywiki.wooledge.org/UsingFind or example: find . -name .svn -prune -o \( ... what you really wanted ... \) -print
21:28  taylanub: 0 means only what you typed on the command line
21:30  Noble: taylanub: So maxdept is unset by default?
21:30  taylanub: Noble: it's infinite by default
21:30  taylanub: erUSUL: manpage says -prune is always true.  sure that -prune -o works?
21:31  Noble: taylanub: Right, ty
21:35  alexander_: hey guys
21:35  alexander_: I need to count the number of lines in a file but I need only an integer
21:36  twkm: use wc.
21:36  alexander_: wc -l gives me this output:
21:36  alexander_: 2992 examplefile.txt
21:36  alexander_: but I only need the integer
21:36  twkm: it won't if you don't name a file.
21:37  alexander_: and how is that supposed to work?
21:37  twkm: as ''man wc'' says it will work.
21:38  alexander_: I've got 12 .xml files in a folder and I want to read the linecount of one of the files
21:38  alexander_: wc -l
21:38  alexander_: without any filename wont work
21:38  twkm: have you considered faq #1?
21:38  poisonbit: grep -c ^.*$ "$file"   # another approach
21:39  taylanub: wc -l < file
21:40  alexander_: thanks poisonbit grep works
21:40  poisonbit: but the twkm and taylanub tips are just better
21:40  poisonbit: ^^ alexander
21:40  poisonbit: ^^ alexander_
21:41  twkm: poisonbit: why anchor the match?
21:42  alexander_: poisonbit, the problem with wc -l is that I'll get more than the integer ^^^
21:42  poisonbit: well grep -c ^ file, or grep -c $ file, also works
21:42  taylanub: alexander_: run  "wc -l < some_file"
21:42  {xmb}{bottz}man: hey alex got fukbuk ?
21:43  alexander_: taylanub, thanks
21:43  dagni: ! [[
21:43  yitz_: ![[
21:43  greybot: [[ is a bash keyword similar to (but more powerful than) the [ command. See <http://mywiki.wooledge.org/BashFAQ/031> and <http://mywiki.wooledge.org/BashGuide/TestsAndConditionals>. Unless you're writing for POSIX sh, we recommend [[.
21:44  dagni: ty
21:49  alexander_: is anyone familiar with imagemagick?
21:50  yitz_: A bit
21:50  alexander_: yits I've got a problem with the convert -crop syntax
21:51  alexander_: yitz_, convert -crop $w*$h+$x+$y example.dds example.png
21:51  twkm: perhaps folks in ##imagemagick
21:52  alexander_: noone there I am afraid
21:52  alexander_: tried yesterday and today several times
21:52  twkm: two #'s, not one.  27 clients are joined to it.  patience might be useful.
21:53  alexander_: twkm, yeah 27 and noone answered
21:53  twkm: *tears*
21:53  alexander_: thanks....
21:54  yitz_: alexander_: Change * to x
21:55  yitz_: http://www.imagemagick.org/script/command-line-processing.php#geometry
21:58  alexander_: yitz_ mayn thanks
--- Log closed Sun Nov 07 22:07:47 2010
--- Log opened Sun Nov 07 22:08:17 2010
22:08 --- Users 512 nicks [0 ops, 0 halfops, 0 voices, 512 normal]
22:09 --- Channel #bash was synced in 100 seconds
--- Log closed Sun Nov 07 22:19:30 2010
--- Log opened Sun Nov 07 22:29:52 2010
22:29 --- Users 515 nicks [0 ops, 0 halfops, 0 voices, 515 normal]
22:31 --- Channel #bash was synced in 101 seconds
22:38  lex_: hey guys
--- Log closed Sun Nov 07 22:58:20 2010
--- Log opened Sun Nov 07 23:03:51 2010
23:03 --- Users 509 nicks [0 ops, 0 halfops, 0 voices, 509 normal]
23:05 --- Channel #bash was synced in 101 seconds
23:09  metalfan___: poisonbit, take a look at python regex.
23:12  poisonbit: metalfan___, is there something like   perldoc perlre  in py  ?
23:13  poisonbit: some command to read about them
23:13  metalfan___: http://docs.python.org/dev/howto/regex.html
23:14  metalfan___: its of course different than bash and you need more time at first
23:14  poisonbit: thanks :)
23:14  metalfan___: but python itself is more solid than bash's little quirks
23:15  poisonbit: indeed, but depending on the coder, you may see python coded "like bash"; or you may find bash coded pedanticaly solid
23:16  poisonbit: always that you don't change the py version :)
23:35  skydrome: hey all, im looking to a command that will check to see if another user owns a directory how would i do this? im thinking using ls somehow
23:36  skydrome: if [[ $(ls blah $dir | blah) == "$some_user" ]]; then do something
23:36  skydrome: im not sure how to go about that
23:37  gniourf_gniourf: skydrome, stat DIR -c %U
23:37  gniourf_gniourf: skydrome, man stat for more details
23:37  skydrome: ah stat!, thank you
23:39  geirha: A portable way would be  [[ $(find "$dir" -prune -user "$UID") ]]
23:40  geirha: Oh forgot about -O
23:40  gniourf_gniourf: oO
23:40  tokam1: I googled how to check if a directory exists, and I found this code, can you explain me this please?
23:40  tokam1: if &#91; -d $check &#93;; then
23:40  geirha: if [[ -O $dir ]]; then echo "dir is owned by me"; fi
23:40  tokam1: whats -d -O :D
23:41  geirha: tokam1: help test
23:41  tokam1: where do these commands come from, I think -d looks like a param
23:41  gniourf_gniourf: tokam1, it's a test to check wether it's a directory or not
23:41  geirha: tokam1: -d is a parameter to the commands test, [ and [[
23:42  geirha: *operator
23:42  geirha: option ... not sure what best to call it.
23:42  gniourf_gniourf: option ?
23:42  gniourf_gniourf: for test and [ I'd say it's an option
23:42  tokam1: but what's the command?
23:43  geirha: tokam1: [
23:43  tokam1: never saw this, thought it belongs to the if else syntax =)
23:43  geirha: # type -a [
23:43  evalbot: geirha: [ is a shell builtin
23:43  geirha: tokam1: No, if only runs a command and checks the return value of that command.
23:43  tokam1: [ test ] :) thx
23:43  gniourf_gniourf: # mydir="."; if [[ -d "$mydir" ]]; then echo "it's a dir"; else echo "it's not a dir"; fi
23:43  evalbot: gniourf_gniourf: it's a dir
23:44  tokam1: why did you use [[ in your examples instead of [
23:44  gniourf_gniourf: # mydir="non existent directory"; if [[ -d "$mydir" ]]; then echo "it's a dir"; else echo "it's not a dir"; fi
23:44  evalbot: gniourf_gniourf: it's not a dir
23:44  geirha: !tests
23:44  greybot: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
23:44  geirha: !faq [[
23:44  greybot: http://mywiki.wooledge.org/BashFAQ/031 -- What is the difference between test, [ and [[ ?
23:45  gniourf_gniourf: # touch hello; mydir="hello"; if [[ -d "$mydir" ]]; then echo "it's a dir"; else echo "it's not a dir"; fi
23:45  evalbot: gniourf_gniourf: it's not a dir
23:47  tokam1: if [[!-d $1]] works?
23:48  tokam1: if $1 is not a directory
23:48  geirha: tokam1: No
23:48  geirha: [[ is a command. You separate commands and its arguments with whitespace.
23:48  tokam1: 	if [[ !-d $1 ]] ?
23:48  geirha: [[ ! -d $1 ]]
23:49  tokam1: yes of course, thx =)
23:49  geirha: Which will return true if "$1" does not exist or if it exists but is not a directory.
--- Log closed Sun Nov 07 23:58:45 2010
--- Log opened Sun Nov 07 23:59:06 2010
23:59 --- Users 502 nicks [0 ops, 0 halfops, 0 voices, 502 normal]
23:59  geirha: and/or see the REDIRECTION section of the man-page.
23:59  gniourf_gniourf: tokam1, it's e.g., like this: 4>&8
--- Log closed Mon Nov 08 00:00:03 2010
