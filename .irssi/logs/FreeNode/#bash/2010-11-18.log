--- Log opened Thu Nov 18 08:46:38 2010
--- Log closed Thu Nov 18 08:51:39 2010
--- Log opened Thu Nov 18 08:52:01 2010
08:52 --- Users 527 nicks [0 ops, 0 halfops, 0 voices, 527 normal]
08:53 --- Channel #bash was synced in 85 seconds
09:09  lhunath: fluter: cthuluh showed you.
09:09  lhunath: you pass the array's values.
09:18  SiegeX: what's the command to see defined functions?
09:19  koala_man: set
09:20  SiegeX: thanks. I always forget that it does that with no args.
09:23  Phazorx: bah
09:23  Phazorx: this is too simple to mess up
09:23  Phazorx:  cat test.file | tar cf - > test.tar
09:23  Phazorx: what did i do wrong here?
09:25  koala_man: Phazorx: you specified the output file, stdout, but not the files to archive
09:25  Phazorx: koala_man: hmm... the idea was to tar whatever comes from stdout into a file
09:28  Phazorx: err... stdin not stdout
09:28  Symbi0nt: how to read what user and group has another file?
09:28  Phazorx: but this is such a basic idea to fail... i need to wake up\
09:28  Symbi0nt: so that I could chown files corectly when executing a script as root
09:28  lhunath: Phazorx: tarring stdin makes no sense.
09:29  lhunath: maybe you mean to compress it?
09:29  Phazorx: lhunath: i mean the data coming from pipe
09:29  lhunath: obviously.
09:29  lhunath: still makes no sense.
09:29  Phazorx: cat | tar > output.tar is what i want
09:29  lhunath: still makes no sense.
09:29  lhunath: tar archives files.  if you have no files; what are you tarring?
09:30  Symbi0nt: why not cat > output.txt
09:30  Phazorx: obviously i want to add -z there but that is besides the point
09:30  lhunath: no, it's not.
09:30  lhunath: you are confused as to what tar is.
09:30  lhunath: if you want to compress stdin, then send it to gzip
09:31  Phazorx: ahh... i tihnk i have logic issue here
09:31  Phazorx: right
09:31  Phazorx: thanks for making my head work :)
09:31  lhunath: consider this:  What would you like the resulting tar archive to look like once stdin is "tarred"?
09:31  lhunath: tar archives contain filenames.  there would be no way to represent "stdin"
09:32  Phazorx: lhunath: yeah i got the point, if i want to compress single file - tar has no purpose
09:32  lhunath: indeed.  file, or in your case, stream
09:32  Phazorx: should bzip it like normal people
09:32  Phazorx: yeah stream to file is as simple as "> file"
09:33  Phazorx: definatelly to early in the morning
09:34  Phazorx: this actually brings up another issue
09:35  Phazorx: what i has as a stream is output from db dumping utility
09:35  Phazorx: what would be a good compression method, optimized for speed to minimize working time?
09:36  Symbi0nt: normally (i think) nobody needs tar really. every archiver out there except gzip (which is like 20 years old) can do everything tar is needed for
09:36  Phazorx: Symbi0nt: agreed... but it's legacy overhead :)
09:37  Symbi0nt: hmm we are in #bash. what is the "exit" name in bash files?
09:37  Symbi0nt: is it exit, quit or die?
09:37  Symbi0nt: or something else
09:38  Phazorx: as in returning exit code you mean?
09:38  Symbi0nt: no just leaving the script when a parameter is not there
09:39  Symbi0nt: if [..] exit; fi ...
09:39  Phazorx: exit should work fine?
09:41  Symbi0nt: thanks
10:11  Bruce_Wayne: I am a student and enthusiastic about unix bash. I want to learn more about cron jobs. Can anyone please provide a advanced tutorial of it. I have learned so far to set a crontab for a specific user, modify, remove etc. Please advise experts.
10:12  koala_man: man 5 crontab
10:15  fluter: hi, is there a good way to convert the first char of a word to uppercase?
10:15  fluter: e.g.  result ->  Result
10:15  fluter: in bash of coz
10:16  fluter: !capitalize
10:17  fluter: !capital
10:17  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
10:17  koala_man: gnu sed can do sed 's/./\u&/' , otherwise I guess you'd have to split it and run tr on the first char
10:17  koala_man: or awk
10:17  fluter: !tr
10:18  fluter: !faq tr
10:18  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
10:18  koala_man: !faq upper
10:18  greybot: http://mywiki.wooledge.org/BashFAQ/030 -- How can I rename all my *.foo files to *.bar, or convert spaces to underscores, or convert upper-case file names to lower case?
10:19  admin0: i have a file with list of identical lines .. like AA BB CC DD EE FF BB AA CC  .. and somtimes in between  AA B CC  .. how do I grep only that one which does not appear in both
10:19  admin0: like grep B or without the identical one
10:21  koala_man: admin0: grep -v '^\(.*\)\1$'
10:22  admin0: i did cat filename | grep -v '^\(.*\)\1$'  .. don't see much difference
10:23  koala_man: # printf "%s\n" "testtest" "AA" "B" "foobar" | grep -v '^\(.*\)\1$'
10:23  evalbot: koala_man: B
10:23  evalbot: koala_man: foobar
10:26  koala_man: admin0: that prints all lines that aren't on the form AA, where A is some sequence of characters
10:27  lhunath: !cat
10:27  greybot: cat(1) is used to concatenate multiple files together. It should NOT be used to feed file data to processes. There are far better ways to achieve this. The application might take a file as argument (eg. grep ^foo file); or you might want to use file redirection (eg. read line < file).
10:28  admin0: i think i did not gave a clear picture .. please take a look at this paste: http://bash.pastebin.com/ybFCMRxU  ..
10:28  admin0: http://bash.pastebin.com/ybFCMRxU
10:28  admin0: In that paste, i want to grep line 5 C only because there is no identical C lien above or below
10:29  Bushmills: use sed.   sed -n 5p
10:30  koala_man: admin0: man uniq
10:30  Bushmills: ah. never mind
10:30  admin0: koala_man, uniq will give me 1 line of each AA BB  ..
10:30  admin0: i want just the one that appears in just 1 line only
10:30  koala_man: lies
10:31  admin0: and discard that appears in 2 lines
10:31  koala_man: try "man uniq" instead of just "uniq"
10:34  Bruce_Wayne: !crontab
10:54  el_seano: Hey guys, quick question:  I'm using xargs to get input from a command that can only take one target at a time, but I want to grep something specifically from each output.  Is there a way I can xargs -n 1 some-command | grep some-string?
10:55  geirha: Yes, by not using xargs.
10:55  el_seano: sounds good. What should I use?
10:55  geirha: A loop
10:55  geirha: !faq 1
10:55  greybot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
10:58  el_seano: thanks for link, I'll try and rethink this.
11:12  metapeter: Hi all.
11:12  metapeter: how to get the http body response in shell?
11:12  karthee: metapeter:   wget
11:12  metapeter: Or: I want to get the response of a webservice as plaintext.
11:13  metapeter: ooh...
11:13  karthee: metapeter:   wget  -O -  -q  http://www.google.com
11:13  metapeter: karthee, thanks..
11:15  metapeter: I never think of the obious :-)
11:16  metapeter: ll
11:16  Bushmills: curl url
11:40  See093: How could you stop three processes of your choice using a basic linux command ?
11:42  n1x0n: kill ?
11:42  See093: ok
11:45  geirha: !pm
11:45  greybot: http://mywiki.wooledge.org/ProcessManagement
11:51  See093: a linux command to show what platform your using ?
11:52  n1x0n: uname -a should give you some details
11:53  See093: ok
11:53 * hashashin nas
11:58 --- mingdao_ is now known as mingdao
11:59  D4T: hi all, how can I use grep to match everything up until some whitespace?
12:00  geirha: [^ ]*
12:00  geirha: [^[:blank:]]*
12:01 * geirha waits for the question to change
12:03 * lhunath anticipates the change: read word _
12:05  D4T: lol
12:05  D4T: ok, im trying to grab the username from the output of who
12:06  D4T: your suggestion was essentially the same as what I was trying but it of course matches the whole line I guess?
12:10  See093: i have copyed files to a backup folder and now i need to compress them using gzip and i also neet to name the gzip file "compfiles".
12:11  Bruce_Wayne: D4T:  how about `who | awk '{print $1}'`
12:13  See093: im new to bash scripting
12:14 * hashashin re
12:19  D4T: Bruce_Wayne: This works for me: who | awk 'NR>1{exit};1' | awk '{print $1}' but I'm guessing there is a more elegant way?
12:20  lenswipe: hey guys
12:20  lenswipe: anyone in here?
12:22  Bruce_Wayne: D4T: Not sure further. I was using `who | awk '{print $1}' | uniq`
12:22  D4T: oh ok
12:22  D4T: Thank you :D
12:23  lenswipe: i fixed it guys
12:27  strull: lucky you
12:30  geirha: D4T: read -a users < <(who -q); echo "${#users[@]} users logged in"
12:30  D4T: geirha: I think Bruce_Wayne's way is easier for me ;)
12:30  D4T: ty anyway
12:30  D4T: :)
12:31  lhunath: uh.  no.
12:31  lhunath: D4T: would appending | cat | tac | tac make Bruce_Wayne's way even easier?
12:32  D4T: well, it would certainly make it easier for me to understand! I appreciate its possibly not the most efficient
12:33  lhunath: who -q gives you what Bruce_Wayne gives you.  geirha's example just puts it to use.
12:33  lhunath: !arrays > D4T
12:33  greybot: D4T: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
12:34  lhunath: molding a command's output is always a bad idea if you can ask the command for the right output directly.
12:35  D4T: lhunath: oh for sure. At the moment geirha's example doesn't give me the same output however.
12:35  D4T: for the record ;)
12:38  See093: how to call the copy command using a linux command line menu ? the files i want to copy have been allocated in a source .sh file just need to link the command and call it in a command line menu
12:39  koala_man: do you already have the menu?
12:40  lhunath: D4T: ah; you want each user to be counted only once?  got bash4?
12:40  D4T: in using OS X 10.6 so no bash 3 :/
12:40  See093: yes i have a menu. i posted my basic menu script here http://code.activestate.com/recipes/577437-basic-linux-menu/?in=user-4169413
12:41  lhunath: D4T: really; an OS X without macports?  ok
12:41  geirha: !tests > See093
12:41  greybot: See093: In bash; consistently use [[ .. ]] to test strings or files and (( .. )) to test numbers or arithmetics. Do *NOT* use [ .. ] in bash, *only* in sh. See http://mywiki.wooledge.org/BashSheet#Tests
12:42  D4T: lhunath: I have MacPorts but the machine this script will run on will not.. its going to be deployed on client machines in a school
12:42  geirha: See093: And you need whitespace between arguments
12:42  See093: ok thnks for the help still kinda new to bash scripting
12:43  geirha: !wordsplitting > See093
12:43  koala_man: See093: and this doesn't copy your file when you select 3, and type in source and destination?
12:43  greybot: See093: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
12:43  lhunath: D4T: to "uniquify" an array in bash; you'd do something like: IFS=$'\n' read -r -d '' -a users <<< "$(printf '%s\n' "${users[@]}" | sort -u)"
12:43  lhunath: D4T: but awk can probably do better.
12:47  D4T: lhunath: i see, thanks for the advice :)
12:47  geirha: read -r -a users < <(who -q | awk '{for (i=1;i<=NF;i++) if (!a[$i]++) printf "%s ", $i; exit}')
--- Log closed Thu Nov 18 12:48:02 2010
--- Log opened Thu Nov 18 12:49:25 2010
12:49 --- Users 539 nicks [0 ops, 0 halfops, 0 voices, 539 normal]
12:50 --- Channel #bash was synced in 113 seconds
12:55  See093: does modifydns show if the dns is working ?
12:59  geirha: !nabq
12:59  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
13:26  b1nd3r: Hi. How can I send an output to stdout and to a file without using tee ??
13:30  Naib: why can't you use tee? thats what it is meant for
13:31  lhunath: b1nd3r: you can send a stream to only one location.
13:32  lhunath: if you want two locations to receive the bytes, make a copy of the stream.  tee does that.
13:32  lhunath: obviously you could do it yourself as well, without tee, but that would be stupid.
13:32  lhunath: !homework
13:32  greybot: "I have to count the lines in a file. But I'm not allowed to use wc. And I'm not allowed to use grep. And I have to type it in using a teletype. With no paper in it. In the dark. Left-handed."
13:33  avinashhm: hi all , i have 10 files .. I wan't to redirect them to 1 file .. I know cat * > scripts .. but i would like both file name and itscontents redirecting into scripts .. any idea how to do it
13:33  lhunath: a loop.
13:35  lhunath: for file in *; do echo "Here starteth thyne file nameth $1"; cat "$1"; done > scripts
13:35  lhunath: err
13:35  lapsusbrutus: I have a long list of email addresses..  One on each line in textfile.  I would like to get all addresses on a long continous line with ';' to separate the addresses.  Is there a fast way of doing this?  tr command maybe?
13:35  lhunath: $file instead of $1 of course
13:37  Naib: lapsusbrutus. sed and replacing \n with ;
13:37  lhunath: tr '\n' ';' < list
13:37  tktiddle: Whats the regular expression to match one or two digits using sed?
13:37  Naib: or that :D
13:37  avinashhm: lhunath,  .. let me try ...
13:37  lapsusbrutus: niice!  Thanks to you both! :D
13:38  Riviera: tktiddle: [[:digit:]]\{1,2\}, also there are #regex and ##sed
13:38  avinashhm: lhunath, this worked .. thanks buddy :) ..
13:39  lhunath: !loops > avinashhm
13:39  greybot: avinashhm: Loops repeatedly execute a block of code. See http://mywiki.wooledge.org/BashSheet#Loops
13:40  avinashhm: lhunath, thanks again man .. ll learn this .. this ll be very handy for me
13:40  tktiddle: thanks
13:44  Eiler: how can i make an alias or a function, so i can write: akill <processname> and then it kills that process? it has to find out the pid or something?
13:54  sente: Eiler: pkill?
14:00  See093: how i do this ? http://pastebin.ca/1995423
14:01  b1nd3r: lhunath, okay, I thought that it was possible, I could swear I saw it somewhere, but I must be mistaken. Thanks
14:08  lhunath: See093: ...
14:08  See093: yep
14:08  lhunath: See093: do you know what IRC is?
14:08  See093: yes
14:08  See093: why ?
14:08  lhunath: write your question in the channel.
14:08  lhunath: !nopaste
14:08  greybot: Please don't waste our time by making us go to a pastebin just for a five-line snippet. Paste it in the channel. If you have a larger script that's showing problems, trim it down to the bare minimum size that still shows the problem. You'll probably fix it yourself once you do that.
14:09  See093: ok
14:09  lhunath: a sentence question in a friggin pastebin.
14:09  See093: understood
14:11  nDuff: ...what _was_ the question, anyhow?
14:11 * nDuff doesn't much follow pastebin links without introduction/description
14:12  Symbi0nt: how can I rename all *.log files to *.1.log?
14:12  trash: !faq rename
14:12  greybot: http://mywiki.wooledge.org/BashFAQ/030 -- How can I rename all my *.foo files to *.bar, or convert spaces to underscores, or convert upper-case file names to lower case?
14:14  nDuff: Symbi0nt, ...that said, typically, log rotation is done with a tool that has that functionality built in (like, say, logrotate)
14:15  Symbi0nt: nDuff: my dedicated server does not seem to have that. So I thought I could do the quick route and rename it all at once and gzip all
14:16  nDuff: Symbi0nt, you'll also need to make sure your applications switch to writing to the new files rather than keeping the old descriptors open
14:16  nDuff: Symbi0nt, ...that's typically done via a signal.
14:16  nDuff: Symbi0nt, ...that said, I'm surprised you can't install logrotate via your local package manager.
14:22  karthee: Symbi0nt: which application ?? which language ?
14:48  Symbi0nt: bash
14:48  Symbi0nt: I found the one log i am intereseted in .. so I need no help anymore ... keep coding :->
14:49 --- massimo_ is now known as massimo
14:55 --- pragma_ is now known as Guest76737
14:58  clyphox: non bash related but does anyone here know how to display non-ascii characters in a terminal?
14:59  clyphox: I'm running urxvt but cant seem to see correct filenames on icelandic files for example
14:59  clyphox: wish i wasnt english lol
15:01  Riviera: The encoding of the characters in the filename needs to be the same encoding the terminal expects characters to be encoded. If they are not, you need to convert them, for example with a tool like recode or iconv. The trick is at least to know the encoding the filenames are encoded with, because this is usually nowhere stored.
15:02  clyphox: ye i've no idea
15:02  clyphox: before that i just want to see a non-ascii char first
15:03  clyphox: just rending characters as ? for moment
15:03  clyphox: maybe i need a unicode font... more reading
15:04  clyphox: nm that, using same font in gtk and its working...
15:05  koala_man: clyphox: set LC_CTYPE correctly, and ls should show them
15:08  clyphox: intresting, its not set
15:09  clyphox: well i found ls -NQ lol  : 04. Untitled (Nj\303\263snav\303\251lin).mp3
15:24  biganon: Excuse me, I can't seem to use the token \$ in my PS1 var
15:24  biganon: it returns $ for both users and root-user
15:35  Dynetrekk: how can I remove all leading tab/space from all lines in a file / stdout?
15:36  koala_man: sed -e 's/^[[:space:]]*//'
15:36 --- jzacsh is now known as jzacsh_
15:37  erUSUL:  sed -e 's/^[[:blank:]]\*//' -e 's/[[:blank:]]\*$//'
15:37  Dynetrekk: what is the difference between :blank: and :space: ?
15:38  Dynetrekk: and is it a coincidence that sed commands look like vim searc/replace?
15:38  Riviera: The latter additionally includes vertical whitespace.
15:38  clyphox: vertical whitespace?
15:38  Riviera: Dynetrekk: No, not at all.
15:38  clyphox: now i've heard it all
15:39  Dynetrekk: Riviera: are they identical_
15:39  Dynetrekk: ?
15:39  clyphox: is it like vertical tab?
15:39  Synthead: is there a way I can see how large a varible would be if I wrote it to disk, "echo $a > file" style?
15:40  Riviera: Dynetrekk: no, not identical :)
15:40  Synthead: I don't want to actually write it to disk
15:40  Dynetrekk: Riviera: but similar?
15:40  Riviera: Dynetrekk: :)
15:40  koala_man: Synthead: echo $a | wc -c
15:40  Riviera: Dynetrekk: http://en.wikipedia.org/wiki/Sed#History
15:40  Synthead: koala_man: would that give me KB?
15:41  koala_man: Synthead: it would give you bytes
15:41  Synthead: oooh :)
15:42  Riviera: Synthead: usually what you want is to have the variable double-quoted: echo "$a" instead of echo $a, because otherwise word-splitting (reducing whitespace to one space in this case) and globbing would be performed.
15:42  Riviera: Synthead: in these cases, you could see the length of the variable a usually with "${#a}"
15:42  Synthead: right, it was just an example :)
15:42  Riviera: Synthead: that is, in bytes.
15:42  Synthead: right
15:42  Riviera: Synthead: You can then add 1 to that result
15:43  Synthead: I didn't know the character count wa bytes :) makes sense
15:43  Riviera: Synthead: because the trailing newline character echo usually adds is one character long
15:43  iceroot: i have a file with 10 lines, i want to read everyline and use it in a for-loop. what is the common way to do it? for a in $(cat myfile);do echo $a; done  or is there a better way?
15:43  Riviera: iceroot: This is, I believe the first FAQ in the FAQ.
15:43  Synthead: iceroot: cat file | while read line; do echo "$line"; done
15:44  koala_man: Synthead: it isn't. the byte count is bytes, while the character count (-m) is characters
15:44  Riviera: !faq 1 > iceroot
15:44  greybot: iceroot: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
15:44  iceroot: Riviera: Synthead thx
15:52  ChoHag: Can you use more than one expansion on a variable?
15:53  ChoHag: eg. I currently have mac=${1//:/-}; mac=${mac,,}. Can I just do mac=${1<something>} where the something will do both the regex substitution and case modification?
15:54  complete: Strange... i use "find" on a machine and its very fast. When I use it on another machine where i mounted the same directory over sshfs its very slow
15:54  complete: but it does not have to transfer a lot of data to search for filenames... what could go wrong here?
15:55  erUSUL: complete: completely normal. you are accessing it via a lot of new layers in the second case
15:56  complete: erUSUL: yeah, but searching something like 100 directories for a filename...
15:56  erUSUL: complete: sshfs = ssh ( network + encryption ) + fuse ( file system in userspace )
15:58  Naib: and nice and slow
15:59  complete: ok. so its probably better to ssh into the machine and do the search there.
15:59  erUSUL: complete: yes
16:00  ChoHag: Right, complete is (haha) complete. Now it's my turn.
16:00  ChoHag: Two variable expansions without an intermediate variable?
16:02  erUSUL: ChoHag: have you tried mac=${${1//:/-},,} ? dunno if it will work
16:02  erUSUL: ChoHag: have you tried mac="${"${1//:/-}",,}" ? dunno if it will work
16:02  ChoHag: I hadn't, but it's a bad substitution
16:08  seanjohn: is there any way to pgrep base on the time the process was started?
16:08  seanjohn: man pgrep doesnt even have the word 'time' in it.
16:09  biganon: woot, my first line with sed
16:19  saml: how can I read user input and test if it was "y" ?
16:19  saml: ~prompt
16:19  nDuff: saml, run "help read" at your shell
16:25 --- pyoor_ is now known as pyoor
16:33  Bruce_Wayne: How can I delete 1) all leading and trailing spaces & 2) new empty lines from a file?
16:34  erUSUL: Bruce_Wayne: what are "new empty lines"? hoe is it different from an empty line
16:34  Bruce_Wayne: erUSUL: I meant the same
16:34  Bruce_Wayne: empty lines
16:34  yitz_: while read -r line ; do [[ $line ]] && printf "%s\n" $line ; done > new < file ; mv new file
16:35  nDuff: perhaps it includes lines which are made empty after removing whitespace?
16:35  yitz_: Bruce_Wayne: ^^
16:35  schweizer: hi
16:35  nDuff: ..it's overkill, but I typically use something more like the following: sed -r -e 's/^[[:space:]]+//' -e 's/[[:space:]]+$//' | egrep -v '^$'
16:35  lhunath: yitz_: "$line"
16:35  Bruce_Wayne: yitz_: will be back after testing. Thank you.
16:36  lhunath: Bruce_Wayne: ^
16:36  schweizer: my alt-backspace doesnt work anymore! what do i now?
16:36  schweizer: how can i fix this?
16:36  yitz_: nDuff: 'grep .' ?
16:36  schweizer: also: alt-b
16:36  nDuff: yitz_, ...that works too.
16:36  schweizer: strangely, ctrl-p and ctrl-n still work
16:37  schweizer: how can i re-enable my alt-* functionality in the terminal?
16:37  yitz_: schweizer: Try 'reset'?
16:37  clyphox: whats alt-backspace?
16:38  schweizer: yitz_: thx, now i works again
16:38  schweizer: you saved my life
16:38  clyphox: schweizer: ctrl-u btw
16:38  erUSUL: !uniq
16:38  greybot: uniq is a utility for removing or reporting repeated lines. uniq will only work effectively with sorted input (sort | uniq). awk '!s[$0]++' is an order-insensitive alternative.
16:38  schweizer: clyphox: what does that do?
16:39  clyphox: schweizer: ^u clears the whole line, ^w does 1 word at a time like alt-backspace
16:40  schweizer: nice
16:40  clyphox: ^h does 1 character
16:44  jophish_: Howdy fellas!
16:45  jophish_: Let's suppose for a second, that I have a python script. And I want to interface with a binary via stdin/out
16:45  jophish_: In this script, I have a function that takes a string. I'd very much like to send this string to stdin of this binary
16:45  jophish_: and then read the reply back to the script
16:46  jophish_: Would one of you kind people be able to point me in the right direction?
16:47  taylanub: foo=$(echo "$string" | program)
16:48  jophish_: Ah, that's not too tricky
16:48  taylanub: jophish_: ^^^ now you have the output of 'program' (whose stdin was $string) in the variable foo
16:48  jophish_: oh wow
16:48  jophish_: that's cool
16:48  jophish_: it's not perfect for what I'm trying to do though
16:48  jophish_: This program stays open
16:48  taylanub: depending on what you want to do with the output, you could also just pipe it forward:  echo "$string" | program | more_stuff
16:49  jophish_: ok
16:49  taylanub: so what do you exactly want?
16:49  jophish_: so this program starts up and spews a bit of junk to stdout. After that I'm basically a chat program
16:49  jophish_: the user types a line, and then the program outputs a line
16:50  jophish_: so python needs to host the program I suppose
16:50  jophish_: the output needs a bit of formatting, but that shouldn't be a problem
16:51  taylanub: input is taken line-by-line from the user, interactively?
16:51  jophish_: yes
16:51  jophish_: the user types a line, and then retuen twice
16:51  taylanub: while read [-r] line; do ...; done
16:51  taylanub: in the 'do ...' part, you have the user input in $line, and can do whatever you want with it
16:52  jophish_: I'm sorry, but I'm not quite keeping up
16:52  jophish_: As far as I understand it, I would need to keep a handle on this process
16:52  intangir: i have a variable PWD=`pwd` that i set to save a path then ichange path and check the variable and its changed
16:53  yitz_: !capvars > intangir
16:53  yitz_: !varcap > intangir
16:53  greybot: intangir: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
16:53  intangir: oh
16:53  intangir: thx
16:54  taylanub: jophish_: a 'while read' loop is the simplest way to read input line by line and act upon it
16:54  yitz_: !faq 1 > jophish_
16:54  greybot: jophish_: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
16:54  jophish_: This would involve piping the output of the program to the script?
16:54  jophish_: The script also needs to respond the the stdin of the program
16:55  jophish_: so its a two way data transfer
16:55  taylanub: could you tell again what exactly this script does, from beginning to end?
16:55  yitz_: !coproc
16:55  jophish_: ok taylanub
16:55  yitz_: Stupid bot...
16:56  jophish_: I have an interactive program. This program reads a line from the user, and responds with it's own line. I would like to adapt a python script to play the part of the user
16:56  taylanub: ah
16:56  jophish_: so the script would send a line to stdin of the program and then read the response
16:56  taylanub: you'll just pipe the python program to the script
16:57  jophish_: oh, the script is the python part. The program is a flat binary
16:57  taylanub: erm... where's bash in here?
16:57  jophish_: I was hoping that there was a nifty way with some kind of circular pipe
16:57  yitz_: jophish_: So you need a two way communication between two processes?
16:58  jophish_: yitz_: exactly
16:58  yitz_: If you got bash4, check out coprocesses
16:58  yitz_: !faq coproc
16:58  greybot: yitz_: No matches found at http://mywiki.wooledge.org/BashFAQ
16:58  jophish_: yitz_: Ah, I only have 3.2.33
16:58  jophish_: with no hope of upgrading
16:59  yitz_: There's a way to do it with a bunch of redirects...
17:00  taylanub: so you want bash to work as a bridge between two interactive programs. both programs work with stdio, being designed for interactive use
17:00  yitz_: I forget how, though. I've seen the gurus here do it once or twice
17:01  jophish_: well, the binary is designed for interactive use. I'm fairly flexible with what I can do in the python script
17:01  taylanub: then i would design the python script specially for this purpose, and not rely on bash at all
17:01  erUSUL: jophish_: why not use the python expect clone ?
17:02  jophish_: erUSUL: What does that do
17:03  erUSUL: jophish_: http://pexpect.sourceforge.net/pexpect.html http://www.noah.org/wiki/pexpect
17:03  erUSUL: !expect
17:03  greybot: http://expect.nist.gov/ -- a Tcl package for driving interactive terminal-based programs
17:05  jophish_: er
17:05  jophish_: erUSUL: that looks great
17:05  jophish_: Thansk
17:05  erUSUL: yw
17:17  skered: If 'which [' can't find [ and [ foo ]; echo $? prints 0.. you're using the shell's builtin [?
17:18  sPiN-: i am having a problem getting my glob to expand in a find commance when it is contained in a varialble... so.. glob={foo,bar}; find /path/$glob/morepath
17:18  Riviera: sPiN-: that's not a pathname expansion pattern.
17:18  nDuff: skered, use type, not which
17:19  nDuff: # type [
17:19  evalbot: nDuff: [ is a shell builtin
17:19  nDuff: skered, ^^^
17:19  skered: Yep, thanks.
17:21  sPiN-: Riviera: not sure I understand you.. if i write out my find cmd without trying to substitute in the text from a variable it works. Ive tried all kinds of quoting but have not been successful..
17:23  nDuff: sPiN-, {foo,bar} is brace expansion, not glob expansion
17:23  erUSUL: sPiN-: brace expansion {foo,bar} is not the same as parameter expansion "$glob" it is done at different times. and therefore your example wont work
17:24  sPiN-: ohh sorry.. ill read on difference
17:24 --- lynucs is now known as jham
--- Log closed Thu Nov 18 18:39:12 2010
--- Log opened Thu Nov 18 18:44:36 2010
18:44 --- Users 554 nicks [0 ops, 0 halfops, 0 voices, 554 normal]
18:45  grosboulet: ok thanks
18:45 --- Channel #bash was synced in 86 seconds
18:55 --- MuzerAway is now known as Muzer
18:56  grosboulet: array=("here" "not here" "in place of") How can I pass this array to an function ?
18:56  grosboulet: or how can I get it properly ?
18:57  nDuff: # my_function() { printf "%s:" "$@"; }; array=("here" "not here" "in place of"); my_function "${array[@]}"
18:57  evalbot: nDuff: here:not here:in place of:
18:57  nDuff: grosboulet, ^^^
18:57  Eiler: how can i see the write permissions of a file
18:58  nDuff: Eiler, do you mean test whether the file is writable?
18:58  nDuff: Eiler, ...if so, see the output of 'help test' in your shell
18:59  grosboulet: nDuff: so simple, thanks :)
19:01  Eiler: ok
19:03  sPiN-: ok.. so i was try to do some of difference brace expansions on a find command and this seems to work for me... findPath=$(echo /path/{brace,expansion}/morepath); find $findPath -exec yada yada
19:03 * nDuff shudders
19:04  nDuff: sPiN-, find_path=( /path/{brace,expansion}/morepath ); find "${find_path[@]}" -exec yadda yadda
19:05  nDuff: sPiN-, ...the approach you gave in your example behaves badly on paths including whitespace
19:05  sPiN-: excellent. thanks for your help
19:07  sPiN-: ohh and the yada yada is stat --format='%n,%U,%G,%y,%s,%A' {} \; | sort
19:07  nDuff: sPiN-, any reason you're using find -exec ... {} ; rather than find -exec ... {} + ?
19:08  nDuff: sPiN-, ...the latter will result in fewer individual stat invocations, thus better performance
19:09  sPiN-: that would be ignorance :P
19:09  sPiN-: thanks for the tip, just what i am looking for.. there are 10s of of thousands of files
19:12 * nDuff is also paranoid enough to not trust commas or newlines as separators -- what if you have commas in your filenames? -- but then, your problem domain may be more restricted.
19:13  sPiN-: yes i ended up here because of spaces in files names..
19:13  nDuff: '//' is guaranteed not to occur in a filename, and is thus what I'd use to separate the name from the data; for separating records, a null is the safest approach.
19:13  sPiN-: i was doing something dirty with ls and awk
19:13  nDuff: ewww
19:13  nDuff: :)
19:17  grosboulet: Do I need to use a global variable if I want that a function returns a string ?
19:17  yitz_: !cs > grosboulet
19:17  greybot: grosboulet: Command Substitution: The $(foo bar) causes the command 'foo' to be executed with the argument 'bar' and $(..) will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
--- Log closed Fri Nov 19 09:59:40 2010
