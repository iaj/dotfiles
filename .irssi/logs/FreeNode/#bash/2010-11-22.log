--- Log opened Mon Nov 22 00:00:06 2010
--- Day changed Mon Nov 22 2010
00:00  manhunter: yes, curly braces are safer
00:00  Knirch: no
00:00  Knirch: # foo=this_is_foo ; echo "${foo}bar"
00:00  evalbot: Knirch: this_is_foobar
00:00  mac-: I wish to read lines from the file
00:01  Knirch: !faq 1 >mac-
00:01  greybot: mac-: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
00:01  mac-: thx
00:02  manhunter: Knirch: what do you mean by "no" ?
00:02  Knirch: manhunter: that they offer no protection, are safer, or whatever you seem to think
00:02  manhunter: Knirch: foo=this_is_foo;echo "${foo}bar" has no ambiguity
00:03  Knirch: rm ${file} is just as bad as rm $file
00:03  manhunter: echo "${foo}bar" , just concatenation
00:03  manhunter: Knirch: this is better,rm "${file}"
00:03  Knirch: manhunter: not any better than rm "$file"
00:04  manhunter: Knirch: greybot says ,there may be some ambiguity ,if there is ambiguity then rm -rf "${file}" is better to use
00:05  manhunter: can't find actual example of ambiguity though
00:05  SiegeX: !redirection
00:05  greybot: Redirections: http://bash-hackers.org/wiki/doku.php/syntax/redirection http://mywiki.wooledge.org/BashGuide/InputAndOutput#Redirection http://bash-hackers.org/wiki/doku.php/howto/redirection_tutorial
00:15  manhunter: rpm -qa *xine* *lame* works buy why doesn't work? vr=*xine* *lame* ; r=$(rpm -qa "${vr}");echo "${r}"
00:16  manhunter: no output for , echo "${r}"
00:17  qubit: the problem is your vr assignment
00:17  qubit: think about it and you'll see why
00:18  manhunter: qubit: sory, it was vr="*xine *lame*"
00:18  manhunter: but still no result
00:19  qubit: oh, and quote $()
00:19  qubit: quotes quotes quotes. quotes are very important to bash
00:20  manhunter: qubit: what's the problem?
00:20  qubit: somevar="$(somecmd)"
00:21  manhunter: qubit: shit
00:21  manhunter: qubit: still no result :)
00:22  qubit: # A="hi there"; B="$(echo "${A}")"; echo "$B"
00:22  evalbot: qubit: hi there
00:22  manhunter: vr="*xine *lame*" ; res="$(rpm -qa "${vr}")" ; echo "${vr}" , where is the problem?
00:23  qubit: manhunter: well in your last part, youre echoing $vr, not $res...
00:23  manhunter: so?
00:23  qubit: well you want the output of res dont you?
00:23  manhunter: sorry it would be echo "${res}"
00:23  manhunter: qubit: typo
00:24  qubit: also rpm might want "*xine" and "*lame*" in separate args, i dont know
00:24 * hashashin nas
00:24  manhunter: qubit: no, it works manually on terminal,like rpm -qa *xine* *lame* , works on terminal
00:24  qubit: manhunter: yes, on the terminal bash passes them as separate args
00:25  manhunter: vr="*xine *lame*" ; res="$(rpm -qa "${vr}")" ; echo "${res}"
00:25  qubit: manhunter: take the quotes off "${vr}"
00:26  manhunter: qubit: no result
00:26  manhunter: qubit: which distro do you use?
00:26  qubit: gentoo
00:27  manhunter: qubit: any DE? gnome/kde other?
00:27  qubit: nope
00:27  manhunter: qubit: console?
00:27  qubit: ya
00:28  manhunter: processor 2.8GHz ?
00:28  qubit: this is going where and why?
00:28  manhunter: qubit: gentoo takes time to compile packages ,that's why i asked,whatever it's offtopic,can't figure that problem
00:29  manhunter: qubit: does gentoo have some packaging tool like rpm/dpkg ?
00:29  qubit: in your case I'm betting the problem is parameter expansion into multiple args. without access to rpm, I dont know what it wants
00:29  manhunter: qubit: then you could have test with , emerge -qa *xine* *lame*
00:30  manhunter: qubit: i also think it's a problem about quoting
00:30  qubit: no, emerge might accept multiple globs in a single arg, where rpm might not
00:31  qubit: that sort of thing is best left to an array anyway. theres a bashfaq on the question, but I dont know it
00:32  manhunter: qubit: but this works fine, vr=$(rpm -qa *xine* *lame*);echo "${vr}"
00:32  manhunter: qubit: probably the result is lost somewhere
00:33  qubit: !complex
00:33  qubit: bah
00:34  qubit: http://mywiki.wooledge.org/BashFAQ/050
00:34  qubit: that will answer all your questions about what youre trying to do
00:35  qubit: !faq complex
00:35  greybot: http://mywiki.wooledge.org/BashFAQ/050 -- I'm trying to put a command in a variable, but the complex cases always fail!
00:35  qubit: yay, I know how to use bashfaq :-)
00:41  manhunter: qubit: i did not read that bashfaq, i will read later
00:43  manhunter: qubit: but testing that command , i got the result somehow, but i don't know why/how? this is the solution: pkgs="*xine* *lame* *ffmpeg*";res=$(rpm -qa $pkgs);echo "${res}"
00:43  qubit: yes, thats what I said to do earlier, and is explained in that faq entry :-)
00:43  manhunter: qubit: the difference is : res=$(rpm -qa $pkgs); , no double qoutes , no "${pkgs}"
00:44  manhunter: qubit: i did not read the faq , i may read the faq tomorrow
00:45  manhunter: qubit: so double quote is the problem
00:46  manhunter: pkgs="*xine* *lame* *ffmpeg*";res=$(rpm -qa ${pkgs});echo "${res}"
01:07 --- ring2 is now known as ring0
01:25  doublehp: test -f *.html && echo ok ### works ;  test -f "*.html" && echo ok ### does not ; how do i do when files contain a space ?
01:25  geirha: !faq empty > doublehp
01:25  greybot: doublehp: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
01:25  doublehp: i came to ask because the FAQ is unclear
01:26  doublehp: i don't want to use while
01:26  doublehp: and not using quotes seem ... unsecure to me
01:26  geirha: -f takes ONE filename, not many.
01:26  doublehp: i am not going to use a for loop just to be able to add quotes
01:26  doublehp: thus asking about spaces
01:27  geirha: spaces is not an issue
01:27  doublehp: test -f 5 42.html ## simply failes
01:27  geirha: Yes, because you give it two filenames instead of one
01:27  doublehp: so, why does test -f *.html work so well ?
01:27  geirha: It doesn't, it only works if there's one matching file
01:29  geirha: shopt -s nullglob; f=(*.html) n=${#d[@]}; echo "There are $n html-files"
01:45  go|dfish: ok
03:24  sc1ssor: Hey, I'm trying to do  sed \" , but it isn't working :\
03:24  sc1ssor: Any ideas?
03:25  sc1ssor: Ultimately I'm trying to get a string between two "s
03:25  falconindy: sc1ssor: printf "%q" mystring
03:26  sc1ssor: falconindy, nice joke? :p
03:26  sc1ssor: I mean, extract a string from two "s
03:26  sc1ssor: from standard input
03:26  falconindy: that would be different than what you originally asked ;)
03:27  sc1ssor: ;)
03:27  sc1ssor: Any ideas?
03:27  falconindy: sure, is the data from a file? in a variable?
03:27  jsz`: sc1ssor, sed 's/"s\(.*\)"s/\1/' like that?
03:27  sc1ssor: jsz`, I have no clue <_>
03:27  sc1ssor: Does it take a string between two quotations?
03:28  sc1ssor: falconindy, I just said from standard input
03:28  falconindy: right
03:28  falconindy: sed 's/\"//g'
03:29  jsz`: # echo '"sfoo"s bar' | sed 's/"s\(.*\)"s.*$/\1/'
03:29  evalbot: jsz`: foo
03:30  sc1ssor: didn't work on a webpage, hm.
03:30  falconindy: uggh
03:30  falconindy: regex is not for html parsing
03:31  sc1ssor: isn't regex for anything? :p
03:31  falconindy: its for regular expressions. not regular grammars.
03:31  sc1ssor: anyways, your solution 'worked' more than jsz`'s on the input I have
03:32  sc1ssor: still left in mostly everything though <_>
03:32  falconindy: better off grabing the element in question via xpath
03:32  falconindy: or some other form of html/xml parser
03:32  sc1ssor: Why not just search for <img and " ?
03:34  Bruce_Wayne: How can I download given url and all sub-urls of the same site from wget? (example: suppose I've this url... http://www.delorie.com/gnu/docs/wget/wget_toc.html ... how can I download all links forwarded through that page, including that page too? )
03:34  cthuluh: sed ': loop; $!{ N; b loop; }; s/[^"]*"\([^"]*\)"[^"]*/\1/g'
03:34  cthuluh: *shrug*
03:35  jsz`: Bruce_Wayne, with the recursive option
03:35  sc1ssor: cthuluh, that at me?
03:35  sc1ssor: i dont think so =_=
03:36  falconindy: sadly it is
03:36  cthuluh: well, if you like it, take it
03:36  cthuluh: but anyway you shouldn't use regex to parse bla bla
03:36  Bruce_Wayne: jsz`:  I used -drc option.. but many times it fails and gives too many lines saying.. "Decided not to load it.." and finally it downloads only few of links...
03:38  cthuluh: Bruce_Wayne: there's a #wget channel, btw
03:39  Bruce_Wayne: cthuluh: pardon?
03:39  Bruce_Wayne: cthuluh: Ah, okay..
03:46  xelister: cthuluh: ph'nglui mglw'nafh Cthulhu R'lyeh wgah'nagl fhtagn
03:46  sc1ssor: hm.
03:46  sc1ssor: I suck at sed.
03:46  sc1ssor: 8)
03:47  cthuluh: sc1ssor: guess what? you also have a ##sed channel :)
03:47  cthuluh: xelister: may I ask you to repeat? ;)
03:48  jsz`: not a caesar rot..
03:52  xelister: ....
03:52  xelister: <_< http://en.wiktionary.org/wiki/ph%27nglui_mglw%27nafh_Cthulhu_R%27lyeh_wgah%27nagl_fhtagn
03:53  cthuluh: xelister: oh, that ;)
03:53  jsz`: ahahaha
04:08  sec^nd: how can I call a script giving it my command line args in a bash script ?
04:08  sec^nd: would it be $* or $@ ?
04:08  yitz_: !$@ > sec^nd
04:08  greybot: sec^nd: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
04:08  sec^nd: so that if my script is called ./myscript hello test world; the other script would be called like ./other hello test world
--- Log closed Mon Nov 22 11:20:31 2010
--- Log opened Mon Nov 22 11:20:52 2010
11:20 --- Users 508 nicks [0 ops, 0 halfops, 0 voices, 508 normal]
11:22 --- Channel #bash was synced in 79 seconds
11:29  karthee: koala_man: okay got it .. thanks ..
11:34  bash: im trying that regexp
11:34  bash: [[  $STR =~  ^[0-9]{4} ]]   why doesnt this work ?
11:35  bash: should match 2010
11:38  plopix: bash: without a ^ you are right
11:39  karthee: bash: its working fine .. what  s the problem ?
11:40  karthee: STR=2010; [[  $STR =~  ^[0-9]{4} ]]  ; echo $?    ==>   0
11:45  lhunath: !=~ > bash
11:45  greybot: bash: Binary operator, uses the expression on the right hand side as an extended regular expression and returns true if the expression on the left hand side matches the pattern. USE A VARIABLE to hold your regexes: if [[ $var =~ $r ]]; then echo Match; else echo 'No match'; fi
11:45  lhunath: bash: if you're still having trouble; show the actual data.
11:54  bash: the problem is :  ^ should match beginnig of
11:54  bash: yo)u should be able to match a beginning
11:56  bash: does the string:  2010-10-13  begin with four consequential numbers ?
11:56  karthee: what is the problem  ....      STR=2010; [[  $STR =~  ^[0-9]{4} ]]  ; echo $?    ==>   0     ..   STR=a2010; [[  $STR =~  ^[0-9]{4} ]]; echo $? ===> 1
11:56  karthee: bash :yes it begins with four consequential number ..
11:56  karthee:  STR="2010-12-12"; [[  $STR =~  ^[0-9]{4} ]]; echo $?  ==> 0
11:59  bash: ok it works
12:00  bash: my string was STR=' 2010-10-20'
12:00  bash: a space was in there
12:00  karthee: he hee
12:01  tvm: :D
12:01  lhunath: predictable.
12:02  tvm: but amusing.
12:06  plopix: how do I dereference a file name with ls? lets say I have a soft link (a.current) pointing to "a". ls -lL shows "a.current" but I want to see the original file.
12:08  geirha: Why ls?
12:09  krisfremen: plopix: use -l only
12:10  plopix: krisfremen: then I have to pipe and cut
12:10  krisfremen: don't use ls's output for anything
12:10  geirha: other than reading yourself
12:12  plopix: why that? because of $LANG?
12:12  geirha: If readlink(1) is available on your system, use that instead.
12:14  plopix: geirha: I have readlink. thanks
--- Log closed Mon Nov 22 12:38:06 2010
--- Log opened Mon Nov 22 12:38:34 2010
12:38 --- Users 517 nicks [0 ops, 0 halfops, 0 voices, 517 normal]
12:39 --- Channel #bash was synced in 84 seconds
12:46  RenatoSilva: lhunath: http://pastie.org/1317050 -> prints a 256 color table which includes oranges
12:47  lhunath: shudder
12:50  taylanub: eh, i have a better one, printing the numbers for the colors: http://ompldr.org/vNjlsZg
12:54  RenatoSilva: mine does that too, just call colors -n
12:55  taylanub: and does it incredibly uglily :P
12:55  RenatoSilva: unfortunately I only found this table after writing that fuction: http://www.pixelbeat.org/docs/terminal_colours/#256 --> this is easier, just point the mouse over the desired color and it shows the code
12:56  RenatoSilva: taylanub: yeah you need a *very long* terminal for displaying it nice, or you can change the modulus part
12:58  RenatoSilva: taylanub: I tried to extend my terminal in my cube-like desktop so that one edge would touch the other: compiz crashed right before that :D
12:58  taylanub: thanks for the link by the way. i tried and could never find a 256colors reference
12:59 --- Weust`afk is now known as Weust`
13:04 --- Weust` is now known as Weust`afk
13:12 --- taylanub0 is now known as taylanub
13:21 --- Weust`afk is now known as Weust`
13:36  lhunath: who cares; change the colors your terminal uses if you don't like the fully-saturated ones.
13:37  lhunath: http://stuff.lhunath.com/shots/shot.1290429433.png
13:38  Roobarb: is there a better way to determine if a file is older than x minutes, other than using find?
13:38  lhunath: no.  but there is likely a better way to do what you want.
13:39  twkm: given that file age is not maintained?
13:39  Roobarb: well, creation time
13:39  twkm: probably not available.
13:39  Roobarb: I want to remove a given file if it was created more than 10 monies ago
13:40  Roobarb: minutes, even
13:40  pgas: !ctime
13:40  greybot: ctime is NOT creation time! It's (metadata) change time. It's updated whenever a file's ownership, permissions, etc. change. Unix does not store creation time of a file ANYWHERE, at all. There is no way you can possibly know when a file was created, unless you're on a system with nonstandard file system extensions.
13:40  lhunath: Roobarb: have the person that created it delete it.
13:40  lhunath: s/person/program/
13:40  twkm: if you think ctime means creation time you didn't read the documentation (carefully enough).
13:40 * Roobarb didn't say ctime ;)
13:41  pgas: you said creation time
13:41  Roobarb: which isn't the same as ctime, is it?
13:41  lhunath: yawn.
13:42  Roobarb: if creation time isn't stored, I'll have to use ctime
13:42  twkm: just letting you know that of the three times find can match, none of them direct relates to a file's age.
13:42  pgas: which typically doesn't exist on unix
13:42  Roobarb: I get the same ent effect in this case
13:42  pgas: or maybe mtime
13:42  twkm: probably a mistake to use ctime at all.  many people settle for atime, though lately moronic linuxen make that useless so you must use mtime.
13:43  Roobarb: hmm
13:43  twkm: (noatime takes an fs that had useful info and returns it to what was available in msdos)
13:43  kunde: i have problems assembling a pipe. "ping localhost | cut -d' ' -f2,3,4" works, but "ping localhost | cut -d' ' -f2,3,4 | cut -d' ' -f2" doesnt. Why?
13:43  Roobarb: which one of atime/mtime/ctime is displayed by ls?
13:44  twkm: kunde: the first column is gone, but i would expect the original column 3 to be the result.
13:45  geirha: The middle cut is probably just buffering
13:45  lhunath: Roobarb: mtime.  but instead of guessing, why don't you figure out what you WANT before you try to settle for random attempts that appear to maybe work?
13:45  twkm: aye, the result ... eventually.
13:45  geirha: !faq buffer > kunde
13:45  greybot: kunde: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
13:45  kunde: twkm: no. you cant add a second pipe command. the output is always empty. it has something to do with the the character of the ping command, i guess.
13:46  Roobarb: lhunath: well I already said what I wanted
13:46  lhunath: Roobarb: what ls shows is irrelevant to what you need.
13:46  twkm: kunde: i doubt it.
13:46  lhunath: Roobarb: no, you didn't.
13:46  Roobarb: yes, I did
13:46  Roobarb: I want to remove a given file if it was created more than 10 monies ago
13:46  lhunath: you said what you think will give you what you want.
13:46  lhunath: that isn't what you want.
13:46  Roobarb: how do yo know that?
13:47  lhunath: I'm psychic.
13:47  Roobarb: riiiight
13:47  Roobarb: ok, what do you _think_ I want?
13:47  twkm: kunde: i.e., works for me.  if your ping is long running consider limiting the number of packets.
13:47  kunde: twkm: you can add any pipe command to "ping localhost | cut -d' ' -f2,3,4", there will be no output.
13:47  twkm: (e.g., ping -c1 localhost | ...
13:47  twkm: )
13:47  lhunath: Roobarb: explain what the real issue is if you want a real solution.
13:47  Roobarb: I HAVE
13:48  lhunath: I've already given you the most likely accurate solution.
13:48  twkm: no, you have explained what you want to do in trying to solve something.
13:48  geirha: kunde: Because it'll buffer. It waits for a sizable ammount of input before it outputs
13:48  kunde: i'm using bash on ubuntu 10.4
13:48  twkm: bash is not th eissue.
13:48  lhunath: the real issue is likely related to why you think you want to remove a file.
13:48  lhunath: explain that, then.
13:48  kunde: geirha: so whats the solution?
13:48  twkm: $ \ping -c1 localhost | cut -d' ' -f2,3,4 | cut -d' ' -f2
13:48  twkm: (127.0.0.1)
13:49  twkm: see, works find, lasts a long time.
13:49  twkm: err, fine.
13:49  geirha: kunde: See faq 9, it has several
13:49  twkm: if you worry about buffering, stop, give it time, it'll come through.
13:50 --- Weust` is now known as Weust`afk
13:51  kunde: geirha, twkm, actually i#m not interested in 'ping' but 'aseqdump' giving the same problem. so this is not specific to ping. i expect that pipe to work real-time, buffering is unexceptable.
13:52  twkm: kunde: then you are a fool.
13:53  kunde: twkm: why?
13:53  twkm: pipes always buffer, though not a great deal.  but programs almost always buffer when not connected to a terminal.
13:54  twkm: and when connected to a terminal then merely buffer "a little".
13:55  twkm: err, they merely.
13:55  lhunath: if you want line-based parsing; a while-read loop may approximate what you expect better.
13:55  kunde: twkm: anyway. i think the problem has become clear and i'm pretty sure that it must be possible to construct a standard pipe using initially the ping command.
13:55  twkm: so, buffering at every step, which pretty much everyone worried about such things already knows.  but it is unacceptable to your design, which says something about the design.
13:56  kunde: twkm: i'm not in philosophy, more in pragmatic solutions.
13:56  twkm: after you read the faq you may be able to reduce it to acceptable levels of buffering, or at least resolve yourself to their existence.
13:57  kunde: so how can i tweak the set-up to get the desired result?
13:58  twkm: ignore the faq, obviously.
13:59  geirha: Why do you need more pipes anyway? Your example has a useless cut, but I assume that's not the real code.
13:59  kunde: twkm: right now, i dont have access to the faq. unfortunately.
13:59  lhunath: kunde: if you want line-based parsing; a while-read loop may approximate what you expect better.
13:59  twkm: geirha: you know that lies are always clearer!
14:00  kunde: geirha: its only an example to illustrate the problem. actually i want to do the same thing with less common commands (aseqdump etc.)
14:00  twkm: too bad you won't name them all, someone here might be used to them and their options.
14:00  twkm: but fine, please torture yourself by using unbuffer at every step.
14:00  geirha: Then it doesn't sound like buffering is a problem
14:00  twkm: unbuffer ping ... | unbuffer cut ... | unbuffer cut ...
14:01  twkm: (which can transform a MB/s or GB/s pipe into a kb/s one)
14:02  kunde: twkm: 'unbuffer' ... is that a linux command? I'm sitting in front of a windows box, right now.
14:02  kunde: bever heard of 'unbuffer'
14:02  kunde: never
14:02  geirha: Yes, part of the expect package. Probably not installed by default.
14:03  twkm: sorry to hear it.  but kernels seldom have commands so it isn't too surprising.
14:03  geirha: Newer versions of GNU coreutils also has a similar command, stdbuf
14:03  lhunath: !b6
14:03  greybot: When given a choice of solutions, the newbie will always choose the wrong one.
14:03  kunde: twkm: you are veeeeery smart twkm
14:03  twkm: ahh, gnu nih syndrom strikes again.
14:04  kunde: anyway, i guess 'unbuffer' could do the job. thanks.
14:04  twkm: i hope you don't need good performance.
14:04  kunde: i do
14:05  twkm: good luck.
14:06  geirha: The whole reason they're buffering in the first place is for performance :P
14:07  kunde: twkm, geirha, whta are the alternatives?
14:07  geirha: Depends on what you're trying to achieve in the first place
14:08  kunde: ok, the problem still has not become clear
14:08  kunde: i try it again#
14:08  twkm: any chance you won't lie about the commands involved this time?
14:09  kunde: ok, here you are ...
14:11  kunde: i have to look up again, maybe later
14:11  kunde: lets go back to the ping example. its essentially the same question.
14:11  kunde: so ...
14:11  kunde: once more
14:12  geirha: kunde: Tell ping to stop after X packages or X ammount of time. And you will see output.
14:13  kunde: "ping localhost | cut -d' ' -f2,3,4 | cut -d' ' -f2" ...... ping will send a message every second or so. i want every second or so the filtered output. i dont want to stop ping anytime, it should run endlessly (replace ping with aseqdump)
14:14  kunde: every second ping send a new line i want that filtered line
14:14  koala_man: !unbuffer
14:14  geirha: It'll show up eventually, once the buffer is full
14:15  kunde: koala_man. yeah i will check that unbuffer. unfortunately i cant do it now and here.
14:16  koala_man: !learn unbuffer unbuffer from Expect lets you generically disable output buffering in pipes
14:16  greybot: OK, koala_man
14:17  geirha: s,$,See http://mywiki.wooledge.org/BashFAQ/009,
14:17  kunde: koala_man, ok. i'll check it out. thx
14:18  kunde: geirha, thanks a lot. thats exactly the info i needed.
14:18  koala_man: !forget unbuffer
14:18  greybot: OK, koala_man
14:18  koala_man: !faq buffer
14:18  greybot: http://mywiki.wooledge.org/BashFAQ/009 -- What is buffering?  Or, why does my command line produce no output: tail -f logfile | grep 'foo bar' | awk ...
14:18  koala_man: that's much better
14:19  kunde: i see
14:19  kunde: thx
14:20  kunde: what about 'stdbuf'. does the same thing, no?
14:20  geirha: Can be used to achieve the same, yes. But it has a different syntax
14:21  kunde: ok, i think thats it. i will try it back at home. thanks for help to everybody.
14:23  geirha: But of course, turning that |cut|cut to just |cut  would achieve the same.
14:23  RenatoSilva: where to put global aliases?
14:23  geirha: RenatoSilva: ~/.bashrc
14:24  RenatoSilva: /etc/bashrc* or /etc/profile?
14:24  RenatoSilva: geirha: global, not by user
14:24  twkm: aflicting every user sucks.
14:24  RenatoSilva: not here
14:24  RenatoSilva: how to do it
14:24  twkm: ignore the bash documentation.
14:24  RenatoSilva: /etc/bashrc* or /etc/profile?
14:25  geirha: Assuming all users source /etc/bashrc, then /etc/bashrc
14:25  geirha: !dotfiles
14:25  greybot: http://mywiki.wooledge.org/DotFiles or - for a technical explanation - the INVOCATION section of man bash.
14:25  twkm: as an aside, have you removed all other shells as well?
14:26  kunde: geirha: as i said its only an example. i'm going to use this setup with different commands. however, tha fundamental problem is the same (I'm pretty sure :-).
14:40 --- Natch is now known as Natch|
14:51  hp_: How do tell bash to execute a command at startup from the command line? Trying bash echo ok I get: /bin/echo: cannot execute binary file
14:52  koala_man: hp_: bash -c "echo lol" ?
14:53  hp_: koala_man, but bash exits after that
14:53  hp_: I would like it to start, run a command and then stay there.
14:53  hp_: wait, I could do bash -c "echo lol; bash"
14:54  geirha: bash -c 'echo lol; exec bash'
14:54  kunde: how can i filter an output line like  'xxx 123 yyy foo 98 zzz', so i get the two digit number after foo. foo is constant, the number is variable, but always two digit. i'm sure it can be done with sed or awk, but i never got used to these guys.
14:55  kunde: i want the two-digit number after foo
14:56  geirha: sed -n 's/.*foo \([0-9][0-9]\) .*/\1/p'
14:57  pgas: awk '$4=="foo"{print $5}'
14:57  kunde: geirha, i'm glad i asked and did not even think of trying it :-)
14:57  kunde: pgas, ok, i have no clue why that should work. thanks anyway.
14:58  hp_: but then it doesn't work if the command doesn't return immediately, (e.g. tail -f). Isn't there a consistent way to do it?
14:59  koala_man: hp_: uhm. you want it to run in the background?
15:00  koala_man: if you type in "tail -f" manuall, you don't get a prompt until tail is done either, so the behaviour is consistent
15:00  pgas: kunde: why would it fail?
15:01  pgas:  # echo 'xxx 123 yyy foo 98 zzz' | awk '$4=="foo"{print $5}'
15:01  pgas: # echo 'xxx 123 yyy foo 98 zzz' | awk '$4=="foo"{print $5}'
15:01  evalbot: pgas: 98
15:01  hp_: koala_man, that is true. What I want to do is run bash, then have it run a few commands, then give me back the prompt -- as if I had typed those command.
15:02  koala_man: hp_: so much like bash -c 'something; exec bash'
15:04  hp_: koala_man, except if I ^C while in bash -c 'tail -f somefile; exec bash', I lose the prompt.
15:05  hp_: whereas ^C while in bash -c 'echo lol; exec bash' works.
15:06  kunde: kunde: thats not i meant. its just totally cryptic to me, even though i'm a little bit familiar with regex.
15:07  kunde: pgas:thats not i meant. its just totally cryptic to me, even though i'm a little bit familiar with regex.
15:09  kunde: pgas: but nice. so short and elegant, compared to a standard regex
15:09  pgas: kunde: no regex involved
15:10  pgas: $4 means "the 4th column"
15:10  kunde: cool. i can recognize geirhas sed regex, but that awk expression tells me nothing.
15:11  kunde: i see. implicating whitespace as delimiter, right?
15:12  koala_man: kunde: yes. the delimited can be set with -F
15:13  kunde: nice
15:13  tvm: hmm.
15:13  tvm: you can also use cut for this task.
15:13  tvm: cut -d" " -f2
15:13  tvm: second "column: after a space
15:14  pgas: for some value of 'this task'
15:15  tvm: yes.
15:15  kunde: unfortunately i dont have so much time programming anymore. today i realized that bash has also associative arrays. why use python,perl etc. when bash is already there? :)
15:16  lhunath: because bash sucks at most things one would use python,perl etc. for.
15:16  kunde: clear answer
15:17  hp_: koala_man, is there something obvious I'm missing?
15:17  tvm: bash doesn't sucks.
15:17  tvm: it helps me to make money
15:17  tvm: period
15:17  tvm: ;D
15:17  kunde: bye, all the best to everybody
15:18  koala_man: hp_: not really
15:18  koala_man: hp_: maybe you can hack it together with --rcfile or something
15:19  hp_: koala_man: thank you. I'll look into that.
15:21 --- jzacsh is now known as jzacsh_
15:21  lhunath: hp_: bash -c 'trap "exec bash" EXIT; tail -f somefile'
15:25  pgas: That's an interesting solution to this problem
15:27  hp_: lhunath: aha! didn't know about trap, that is cool.
15:37  lhunath: the problem is "I want to execute a bash prompt when my script is done".  the script is done when the bash process exits.  therefore trapping EXIT is the solution.  it's all in the correct formulation of the problem.
15:38  lhunath: the problem has nothing to do with ^C
15:38  koala_man: nice
15:44 --- abstract3d is now known as abstract3d|brb
15:57 * hashashin nas
--- Log closed Mon Nov 22 16:05:28 2010
--- Log opened Mon Nov 22 16:11:24 2010
16:11 --- Users 516 nicks [0 ops, 0 halfops, 0 voices, 516 normal]
16:12 --- Channel #bash was synced in 128 seconds
16:21  lhunath: hashashin: what's the deal with this random /me word spam?
16:22  cHarNe2: is there a bashlog? i get error 127 but i dont know what i the moule is trying to run
16:22  hashashin: Ikarus, say hello in a lazzy mode?
16:23  catsup: # factor 126
16:23  evalbot: catsup: bash: factor: command not found
16:23  catsup: factor is in coreutils
16:23  ksk: cHarNe2: isnt it just a exit code of an bash script? if yes, look it up in there
16:23  twkm: cHarNe2: no.  error 127 usually means the command cannot be found.
16:23  catsup: # echo $PATH
16:23  evalbot: catsup: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
16:24  catsup: # ls /bin/ls
16:24  evalbot: catsup: /bin/ls
16:24  catsup: # ls /usr/bin/factor
16:24  evalbot: catsup: ls: cannot access /usr/bin/factor: No such file or directory
16:24  cHarNe2: twkm: i know, but i dont know what it tryes to run
16:24  catsup: well, duh :\
16:24  geirha: catsup: The bot's filesystem is limited, it doesn't have room for every non-standard command out there.
16:24  catsup: # ls --version|head -1
16:24  evalbot: catsup: ls (GNU coreutils) 6.10
16:24  catsup: geirha: non-standard?  it's in gnu coreutils
16:25  twkm: cHarNe2: bash would say.  set -x may be your friend.
16:25  koala_man: why the hell does coreutils have a tool for factoring numbers?
16:26  geirha: catsup: So?
16:27  geirha: koala_man: And why the hell does util-linux have a tool for converting gregorian dates to discordian dates? :)
16:28  catsup: geirha: well, that's odd :/
16:28  geirha: $ ddate
16:28  geirha: Today is Sweetmorn, the 34th day of The Aftermath in the YOLD 3176
16:29  geirha: bbaffling
16:31  \DSAFEW\: in gentoo, qcheck sys-apps/coreutils
16:32  kaushal: Hi
16:33  \DSAFEW\: oh we're checking the bot... silly me
16:35 --- ring1 is now known as ring0
--- Log closed Mon Nov 22 16:41:52 2010
--- Log opened Mon Nov 22 16:42:12 2010
16:42 --- Users 528 nicks [0 ops, 0 halfops, 0 voices, 528 normal]
16:42  catsup: lol omg
16:42  catsup: i didn't even notice the other flaws
16:42  twkm: it will help if you read the bash manual, focusing on the grammar.
16:42  _ting_: I am sorry
16:42  _ting_: i am newbie
16:42  tvm: hmmm.
16:43  _ting_: I appologize if I make a stupid question
16:43  twkm: or perhaps read the guide.
16:43  paissad: _ting_, basename /home/user/desktop/directory1
16:43 --- Channel #bash was synced in 80 seconds
16:43  _ting_: but i wanna that the full path can be obtained dynamically by pwd
16:45  paissad: _ting_, i think that if you do good combinations of basename, dirname, & pwd at the good time, you will get what you want
16:45  tvm: definitely.
16:45  _ting_: umm
16:45  _ting_: thanks
16:45  _ting_: let see it
16:46  _ting_: I got it: directory=`basename $path`
16:46  _ting_: thank guys
16:47  twkm: that will fail some day.
16:48  tvm: heeh.
16:48  _ting_: ummm.....
16:48  _ting_: jarrr
16:48  catsup: dir=$(basename "$PWD")
16:49  _ting_: thank catsup
16:50  tvm: hrmh.
16:50  tvm: but that isn't obviously dynamic.
16:51  tvm: you want dir=$(basename `pwd`) i guess
16:51  _ting_: well may be I expressed myself badly
16:51  tvm: hmm, maybe it's actually same.
16:51  tvm: yeah, no difference.
16:51  _ting_: may be dynamically was not the best word
16:52  _ting_: I was trying to run just basename pwd
16:52  _ting_: I mean "basename pwd"
16:52  tvm: well, doesn't matters, use one of the above, it will work.
16:52  catsup: you need the quotes
16:52  catsup: PWD is updated dynamically, it's a special var
16:53  catsup: the quotes are necessary in case of spaces
16:54  nDuff: !basename
16:54  greybot: basename(1) can strip the directory and extension from a path. (a/b/c.d -> c.d or c). Or you can use a parameter expansion: "${path##*/}" or "${path%.*}"
16:55  nDuff: # mkdir -p /foo/bar/baz; cd /foo/bar/baz; echo ${PWD##*/}
16:55  evalbot: nDuff: baz
16:55  nDuff: _ting_, ^^^
16:56  nDuff: ...much faster than spawning off a subshell only to run the pwd command.
16:56  paissad: when i run "make oldconfig" ... i just have to hit enter (or hold the enter button) to accept default answers until the end. (no troubles)
16:56  paissad: but i really wonder why i also need to hit enter when i do this
16:56  paissad: make oldconfig | while read; do echo -e '\n'; done
16:56  paissad: i use to use it in many cases and that always worked .. but i cannot figure it out this time
16:56  paissad: any idea ?
16:57  lhunath: you're confusing input and output.
16:57  paissad: grrrrr
16:58  _ting_: guys thank you very much for your help
16:58  _ting_: I have done my script
16:58  _ting_: thanks
16:58  lhunath: paissad: echo -e '\n' is just stupid, by the way.
16:58  _ting_: ;-)
16:59  lhunath: paissad: if you want to output a newline, you want: echo
16:59  lhunath: nothing else.
16:59  lhunath: paissad: while echo; do :; done | make oldconfig
17:03  Synthead: I need to check a directory for files, but I've heard that I shouldn't use "ls" in scripts.  What should I be using instead?
17:03  nDuff: Synthead, shopt -s nullglob; files=( directory/* )
17:03  geirha: !faq empty > Synthead
17:03  greybot: Synthead: http://mywiki.wooledge.org/BashFAQ/004 -- How can I check whether a directory is empty or not?  How do I check for any *.mpg files?
17:04  lhunath: depends on what you want to do.
17:04  twkm: i.e., the glob you would use with ls.
17:04  lhunath: "is 'foo' in my directory?" [[ -e dir/foo ]]
17:05  galaxywatcher: I have a fixed width file of addresses with zip code at character position 149-153 and a separate file of zip codes. I want to output matches. Can I force grep to check for a match at a specific character location only - I don't want false positives. Any suggestions?
17:05  Synthead: is there an explicit reason why I would want to run shopt -u nullglob dotglob after the commands?  what adverse effects would I experience if I left it set?
17:05  lhunath: galaxywatcher: you may want join.
17:06  galaxywatcher: lhunath: as far as I know, join only matches on field position...Not character position
17:06  lhunath: Synthead: stuff you don't think is harmless normally; like unset myarray[0] will break.
17:06  geirha: Synthead: Globs that otherwise would not expand, would expand to the empty string
17:07  lhunath: galaxywatcher: possibly.
17:08  galaxywatcher: lhunath: Another option is to embed a regex using sed substitution into my zip code file and then do a grep -f match so that the regex locks the proper position in...I think I will go that route.
17:08  lhunath: galaxywatcher: you could read in the zip codes of your separate file into a bash array; while read the first, iterate the zip array for each line and see if it exists.  the index of the zip array at which the zip exists is the line in your separate file.
17:09  lhunath: galaxywatcher: blink.
17:09  \DSAFEW\: galaxywatcher, use lhunath's idea, there are a number of possible hangups with the way you're going
17:10  Synthead: very nice, thanks guys
17:11  geirha: awk 'NR==FNR{a[$i]=1;next} substr($0,149,5) in a' file_with_zipcodes other_file
17:12  geirha: err, $i should be $1
17:12  galaxywatcher: geirha: Of course...awk...This looks good. Thank you.
17:16  galaxywatcher: geirha: works like a charm - thanks again.
17:18  geirha: It's the same as what lhunath suggested, only in awk instead of bash.
17:22  galaxywatcher: Yes. I do see the awk array you presented. I believe this is more compact than a bash array. And certainly better than the method I was about to do.
17:26  twkm: compact.  funny.
17:26  galaxywatcher: concise. less funny?
17:27  galaxywatcher: Of course Lhunath's suggestion was more relevant to the channel we are on.
17:30  twkm: the awk loop construct is more compact, and some might say concise (while others would say cryptic).  but the arrays seem equivalent ... a[x] vs a[x] (or at worst ${a[x]}).
17:32 --- ChanServ sets modes [#bash +o twkm]
17:32 --- twkm sets modes [#bash +b-o [derek]!*@*$##fix_your_connection twkm]
17:33  knaveofclubs: tar -cfv myarchive.tar verbosely creates a new tar-archive, right?
17:33  chovy: is there a way to get the path of a symlink easily?
17:34  Josay: read -f ?
17:34  nDuff: chovy, readlink is your friend
17:35  nDuff: knaveofclubs, -f needs to be immediately before the filename
17:35  nDuff: knaveofclubs, ...that's what it specifies, "next argument is filename"
17:35  chovy: nDuff: thanks
17:35  nDuff: knaveofclubs, ...so putting "v" after it means you're creating a file named "v"
--- Log closed Mon Nov 22 17:41:43 2010
--- Log opened Mon Nov 22 17:42:07 2010
17:42 --- Users 530 nicks [0 ops, 0 halfops, 0 voices, 530 normal]
17:42  knaveofclubs: My manual page is kind of cropped..
17:42  nDuff: knaveofclubs, also because tar was initially built to backup to tape, not just files
17:42  knaveofclubs: Something about info documents instead..
17:42 --- ring1 is now known as ring0
17:42  Synthead: snot-poop
17:43  Synthead: dung
17:43  knaveofclubs: info tar is a book.. o0
17:43 --- Channel #bash was synced in 83 seconds
17:43  twkm: knaveofclubs: sorry to hear it.  still, info pages are documentation.
17:44  Synthead: knaveofclubs: whoa, it really is
17:44  Synthead: knaveofclubs: the / key is your friend
17:44  twkm: reading is terrible.
17:45  Synthead: I need to figure out how to upload man pages to my brain
17:46  knaveofclubs: Well okay got the info page. Aside from that, why did they implement the -f option later to also support files? How did it work for only tapes back then? Without -f?
17:47 --- EauLand is now known as Eauland_Mala2
17:48  nDuff: knaveofclubs, without -f, you defaulted to your default tape device
17:49  sysop1: if I create a symoblic link to a shell script and I call that script using the link, how can the script tell the difference?
17:49  yitz_: $0
17:49  sysop1: thanks.
17:49  sysop1: I knew it was something I was just forgetting.
17:50  knaveofclubs: nDuff, oh. So is that still the case?
17:51  chovy:  somedays i just can't program.
17:52  twkm: knaveofclubs: is reading what happens when there is no -f really so hard?
17:53  knaveofclubs: twkm, well it's a whole book with who knows how many pages, not seldomly they got several hundred pages which I have to admit don't think it the case here, but still..
17:54  knaveofclubs: Well I found it.
17:54  twkm: amazing!
17:54  twkm: wtf is wrong with reading a book?
17:54  Azer: reading is hard
17:55  ferret: let's go shopping
17:56  nDuff: knaveofclubs, I'd have to look at POSIX to know what (if anything) is guaranteed, but in modern GNU tar, default is stdout
17:58  twkm: sorry, gnu decided to make the world less certain ... it is actually a ./configure option.
17:58  twkm: tar --show-defaults to find what was done to you.
18:00  twkm: with gnu tar you must use -f to be certain, though i suppose you could inspect the --show-defaults output to determine if -f is needed instead.
18:01  chovy: given an array, how do I index it by int?
18:01  twkm: normally one expects an implementation defined default tape device which you can override with TAPE, and if you want stdout you must explictly ask for it.
18:03  twkm: heh, as for posix, you'll need sus2 or earlier, as tar is gone as of sus3.
18:05 * nDuff hugs pax
18:07  chovy: i have "read targ" where user enters 0,1,2 or 3...now I want to index the array by $targ...not working though with ${links[$targ]}
18:12  Synthead: sausagemongler
18:14  geirha: chovy: how is it not working?
18:15  chovy: echo ${links[2]};
18:15  chovy: that returns nothing.
18:15  chovy: i have links=`find . -type l`;
18:15  chovy: should be an array.
18:15  geirha: There you have it. links is not an array
18:15  chovy: doh
18:15  geirha: !faq 20 > chovy
18:15  greybot: chovy: http://mywiki.wooledge.org/BashFAQ/020 -- How can I find and deal with file names containing newlines, spaces or both?
18:16  geirha: What you're doing there is plain crazy.
18:16  chovy: heh
18:16  chovy: why's taht?
18:16  chovy: i want to let the user select a symlink to use in the next command.
18:16  chovy: i print a list first, then they choose it's index.
18:17  geirha: Then put that list in an array, properly. And it does NOT involve `` or $()
18:17  twkm: what will you do if whitespace is in the name?
18:17  chovy: ok
18:17  chovy: i need to coerce this into an array.
18:18  geirha: See faq 20 and/or faq 6 for that.
18:18  lhunath: !arrays
18:18  geirha: Sorry, faq 20 and faq 5
18:18  greybot: An array maps numbers to strings. Bash 4 also has associative arrays (maps strings to strings). See http://mywiki.wooledge.org/BashSheet#Arrays
18:18  lhunath: or that, including some background info
18:19  chovy: ah
18:19  chovy: ()
18:20  chovy: links=(`find . -type l`);
18:20  lhunath: in a way that doesn't destroy your data.
18:20  lhunath: so not that.
18:20  lhunath: and stop using `
18:20  lhunath: !`
18:20  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
18:20  geirha: chovy: I told you, it does NOT involve `` or $()
18:20  geirha: Unless you want broken code of course
18:23  lhunath: the ideal method of putting filenames from find into an array is on the BashSheet: files=(); while IFS= read -d '' -r file; do files+=("$file"); done < <(find . -name '*.txt' -print0)
18:23  lhunath: it's a little verbose; but it's safe.
18:24  bash: ive got a torrent download directory,  many files conaint illegal chars , spaces etc
18:24  lhunath: (probably also in the FAQs you were referenced.  good idea to read those if you want to understand what goes on here)
18:24  bash: how do i slurp all files in an array
18:24  lhunath: nothing illegal about a char.
18:24  lhunath: files=(*)
18:25  twkm: feh, torrents.
--- Log closed Mon Nov 22 18:31:26 2010
--- Log opened Mon Nov 22 18:31:49 2010
18:31 --- Users 529 nicks [0 ops, 0 halfops, 0 voices, 529 normal]
18:32  geirha: !$@
18:32  greybot: The difference between $@ and $*: Unquoted, none at all: both equal $1 $2 .... With double quotes, "$@" is "$1" "$2" ..., while "$*" is expanded as the single argument "$1c$2c..." (where c is the first character of IFS). You almost always want "$@". The same goes for arrays: "${myarray[@]}"
18:32  chovy: lhunath: how about a simple readlink $files[$targ] command output...do I really need to while/do just to capture a command's output everytime?
18:32  lhunath: quotes.
18:32  lhunath: chovy: no.
18:32  lhunath: you need a while loop if you want to iterate lines.
18:33 --- Channel #bash was synced in 82 seconds
18:33  lhunath: (or something else; in the find case above, chunks separated by NUL bytes)
18:34  chovy: i got the loop done.
18:34  bash: yes yes ofc
18:35  antlong: does something exist that will let you type spaces and convert it to :: in bash? ie:  command file function  would be allowed inplace of command fille::function
18:35  lhunath: if your delimitor wasn't a NUL byte (but, for example, a newline) you could use a single IFS=$'\n' read -a lines, no need for a while loop.
18:35  bash: A=("$@") and   for i in "${A[@]}" ; do
18:35  bash: worked
18:35  bash: great
18:35  lhunath: how about:  for i; do
18:35  geirha: !varcap
18:35  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
18:36  catsup: antlong: like globally?  for every shell command?
18:36  antlong: catsup, im not choosy. ill take w/e works on w/e level
18:36  catsup: so you just want to join some arguments with ::
18:36  geirha: antlong: You could make a wrapper function/script for that command
18:36  antlong: well, i want to be able to use spaces, in place of ::
18:37  antlong: let the conversion from space space to :: happen somewhere else
18:37  nDuff: antlong, only the first two arguments to be converted? Or all of them? By what rules?
18:37  geirha: You'll probably need to hack the bash source code to achieve that.
18:38  antlong: nDuff, basically im using py.test theres classes and functions, if youre calling a specific class then a function inside of it, you have to do  py.test filename.py Class_name::function_name
18:39  ferret: antlong: so you want to type "py.test filename.py Class_name function_name"?
18:39  catsup: spaces_to_doublecolons() { out=$*; echo ${out// /::}; };
18:39  ferret: How can it know where to put the :: ?
18:39  antlong: ferret, anywhere spaces are after the filename
18:39  geirha: myfunc() { py.test "$1" "$2::$3"; }
18:39  catsup: ok, py.test() { command py.test "$1" "$2::$3"; }
18:39  catsup: erm heh no
18:40  catsup: pytest() { py.test "$1" "$2::$3"; }
18:40  geirha: Actually, . is allowed in function names
18:40  twkm: funny.
18:40  catsup: oh, hmm
18:41  catsup: well, glad i learned that :)
18:41  ferret: The function I was making was called ::
18:41  ferret: :P
18:41  catsup: oh i didn't notice you beat me to it geirha
18:41  antlong: i dont think . is allowed in py function names
18:41  antlong: ty though, ill give it a shot
18:42  ferret: Pretty much anything is allowed in a function name
18:42  ferret: It's just a bit more difficult to declare it
18:42  geirha: antlong: Well, bash functions != python functions
18:42  catsup: can you put spaces in a function name?  (if so, how?)
18:42  geirha: No
18:44  geirha: I think you can use any characters than doesn't need to be quoted; i.e. no characters special to bash.
18:46  catsup: # test:_/f() { echo w00t; }; test:_/f
18:46  evalbot: catsup: w00t
18:46  geirha: It didn't complain about ^A(), but I'm unable to run it ^^
18:47  antlong: what the shit, a bot that runs bash commands
18:47  ferret: geirha: \^A
18:47  ferret: you can always run them, but they tend to need some kind of escaping
18:47  ferret: the same occurs for e.g. glob characters
18:49  catsup: bin/sh() { echo oh my; }; bin/sh
18:49  catsup: # bin/sh() { echo oh my; }; bin/sh
18:49  evalbot: catsup: oh my
18:50  catsup: omg
18:50  catsup: # /bin/sh() { echo oh my; }; /bin/sh
18:50  evalbot: catsup: oh my
18:50  catsup: you can even do the weird chars in the first char
18:51  catsup: # command() { echo danger will robinson; }; command ls
18:51  evalbot: catsup: danger will robinson
18:51  ferret: yeah, spaces you can't do
18:51  ferret: ./configure() is a useful function to define :)
18:52  catsup: heh
18:52  catsup: hmm actually yeah
18:52  catsup: no more typing --prefix=/usr/local
18:53 --- Azer_ is now known as Azer
18:57  CaBa: hi
18:57  CaBa: in vi-mode, how can i access the previous last arguments?
18:58  ferret: "$_" maybe
18:59  CaBa: ferret: hm indeed... but i dont seem to be able to iterate them like that
18:59  CaBa: ferret: where is that documented?
19:00  ferret: man bash; /Special Parameters
19:02  CaBa: ferret: well ok, but i am more looking for the meta+. behaviour
19:03  ferret: I suspect it doesn't have that
19:03 --- e-DI0-t is now known as e-DIO-t
19:03  CaBa: oh my... that would be a tough trade-off
19:10  nginr: hi .. i want to construct a  grep command and run it ..  like this  grep -e val1 -e val23 -e  val31 .. -e val54  filename ..  i can construct and store this command in a variable . How would I execute it ? or is there any other way ??
19:12  erUSUL: nginr: use an array? ops=() ; ops+="-e val1" ......; ops+="-e valn"; grep "${ops[@]}"
19:12  geirha: array=("val1" "val2" "val3"); printf '%s\n' "${array[@]}" | grep -f - filename
19:13  geirha: erUSUL: You forgot the parenthesis
19:14  erUSUL: geirha: i stand corrected ...
19:15  nginr: wow .. looks cool ..
19:16  nginr: its a big file and I didnt want to loop or grep again and again for every search string ..
19:16  nginr: Thanks guys ..
19:16  jrm222: Hi, I'm trying to update all symbolic links that point to a certain path (because the top directory name in the path pointed to has been changed).  This is what I have so far:  find -L . -type l -lname "/home/joey*" -exec echo {} +.  This will print all the links.  I can | this to xargs to execute ln for each link found, but that's where I'm a little stuck.  Can anyone suggest a good way to do this.
19:18  erUSUL: nginr: use grep's -f option?
19:21  nginr: erUSUL: yeah .. just did man grep for -f option . Never used it before ..
19:22  nginr: erUSUL: does it take the input from the file mentioned after -f 'filename' ?
19:23  erUSUL: nginr: it takes the patterns from filename; just like the man page says
19:23  Buba: jrm222
19:23  Buba: use for
19:24  nginr: erUSUL: sorry i m bad in english .. patterns in the sense input patters . right ?
19:24  Buba: instead of exec
19:24  nginr: input for grep
19:24  erUSUL: nginr: what you would put in « grep "pattern/regex" filename_to_search »
19:24  nginr: takes input patterns from the file and does grep ?
19:24  nginr: :-D
19:24  nginr: okay thanks ..
19:26  nginr: any special meaning when we put grep -f -  ..  any special meaning for that last - (minus) ??
19:26  ferret: !-
19:26  greybot: Tools generally consider an argument that begins with a - as an option. To pass a filename that begins with a -, prefix it with its path: rm ./-foo
19:27  ferret: grrr
19:27  ferret: - means stdin for most (but not all) utilities
19:27  ferret: so it means that it will read newline separated regular expressions from STDIN
19:27  jrm222: Thanks Buba
19:28  NTU: hey guys!!!!!!!
19:28  nginr: ferret: awesome explanation .. thanks
19:29  NTU: how do I have a "if this then do this else do this" in a section? http://pastebin.com/EdpajtAB
19:29  NTU: like drivers () { if this then ; commands ; do ; done }
19:30  greycat: need a ; before }
19:30  greycat: and it's "if commands; then ..." not " if commands then ;"
19:31  NTU: so its done ; ?
19:31  NTU: look at my pastebin please, thats more what im looking for
19:31  lhunath: I vote for you throwing that code away.
19:31  lhunath: it's so ugly and bugged, it's not worth repairing.
19:32  lhunath: it would help a lot if you understood what arguments are before you start writing bash code.
19:32  lhunath: !args
19:32  greybot: Understanding Arguments and Word Splitting: http://mywiki.wooledge.org/Arguments
19:32  NTU: can i just have an example please?
19:33  lhunath: example of?
19:33  greycat: !function
19:33  greybot: To define: funcname() { your code here; } ## To use: funcname arg1 arg2 ... ## function http://mywiki.wooledge.org/BashGuide/CompoundCommands#Functions
19:33  lhunath: an if statement?  ''help if''
19:33  NTU: x-gnome.sh: line 347: syntax error near unexpected token `}'
19:33  NTU: no. in a section
19:33  NTU: like my pastebin
19:33  lhunath: a section?
19:33  greycat: There is no 'section'.  You mean a function?
19:33  NTU: yes
19:33  nginr:  erUSUL:   grep -f 'inputPatterFile'   filename .. does it do a separate grep for each line in the file inputPatternFile .. or a single  grep  with or (-e) ?  actuall the file on which i m grepping is huge the list of patterns to be matched is big. I want grep -e  val1 -e val2 ...  rathan than grep val1; grep val2; grep val3 ..
19:33  lhunath: foo() { code; }
19:34  lhunath: the problem of your pastebin is that you failed to terminate your if block.
19:34  lhunath: look at what the syntax of if is.
19:34  lhunath: !conditionals > NTU
19:34  greybot: NTU: Conditional Structures: http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
19:34  greycat: nginr: It reads the input one time.
19:34  lhunath: plenty of useful help and examples there.
19:34  erUSUL: nginr: i do not know that much. use -F too if the patterns are just strings and no regex
19:35  NTU: i understand all that.
19:35  NTU: but this is more complex
19:35  lhunath: no, you don't.
19:35  lhunath: and no, it isn't.
19:35  nginr: greycat: so it does grep val1 ; grep val2 .. right ?
19:35  greycat: NTU: what, specifically, are you having trouble with?
19:35  NTU: greycat: i need to have this function run without errors. http://pastebin.com/UaBZrmw8
19:35  greycat: nginr: IT.  READS.  THE.  INPUT.  ONE.  TIME.   ***NOT***  One time per pattern.
19:35  NTU: a new pastebin
--- Log closed Mon Nov 22 19:41:31 2010
--- Log opened Mon Nov 22 19:41:52 2010
19:41 --- Users 543 nicks [0 ops, 0 halfops, 0 voices, 543 normal]
19:41  lhunath: no loss if it doesn't.
19:41  NTU: :D
19:42  NTU: im sorry if i annoyed any of you.
19:42  NTU: while sleep 0; do annoy all; done
19:42  NTU: :P
19:43 --- Channel #bash was synced in 80 seconds
19:43  xt3mp0r: lol
20:20  consumerism: i'm writing a script which contains a line i expect to throw an error. can i somehow ignore that error explicitly and still use #!/bin/bash -e ?
20:21  greycat: foo || true
20:21  consumerism: greycat: awesome.  thank you
20:36  mikedep333: hey, I know I can do: for file in filename*
20:36  mikedep333: is there a similar way to do that for directories?
20:37  jimbauwens: Hello, I'm getting crazy with this : if ((($(wc -c hosts_bad)!=0)) && (($changed==1)))
20:37  jimbauwens: Can anyone help me?
20:37  jimbauwens: it spits errors, and cant seem to fix it
20:37  greycat: You have too many (
20:37  lhunath: mikedep333: depends on what you mean by that.
20:38  lhunath: maybe you mean dirname*/
20:38  greycat: get rid of one of the (
20:38  mikedep333: let me pastebin my code
20:38  lhunath: and the )
20:39  lhunath: if doesn't need () around the command.
20:39  greycat: Oh.  I didn't even see the extra ) on the end.
20:39  greycat: !if > jimbauwens
20:39  greybot: jimbauwens: if <COMMANDS>; then <COMMANDS>; fi # http://bash-hackers.org/wiki/doku.php/syntax/ccmd/if_clause # http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
20:39  greycat: It's   if command   not    if (command)
20:39  lhunath: the command you pasted is not bad syntax; it isn't causing your error.
20:40  lhunath: it's just odd syntax.
20:40  jimbauwens: Ok, then I'm really going the wrong way :)
20:40  pantano: hi. Does anyone know some tool I can use to extract the plain text part of an e-mail?
20:40  greycat: Also, you need to REDIRECT the input into wc if you want wc to spit out just a number.
20:40  lhunath: pantano: a while read loop?
20:41  lhunath: awk?
20:41  greycat: if  (( $(wc -c < hosts_bad) != 0 && changed == 1 ))
20:41  lhunath: oh yeah, that must be erroring.
20:42  lhunath: jimbauwens: compare wc -c hosts_bad  vs wc -c < hosts_bad on the prompt.
20:42  lhunath: it doesn't know how to compare the former output with 0.
20:43  pantano: lhunath: that seems a bit harsh. An email has mime parts, each part can have an encoding. I wanted just the text properly handled.
20:44  jimbauwens: 'wc -c  hosts_bad' outputs '0 hosts_bad', didn't see that comming :)
20:44  jimbauwens: thanks :)
20:44  lhunath: pantano: and a while read loop or awk can give you that.
20:44  greycat: pantano: then find a tool that can extract that part of an email
20:44  lhunath: not sure what you mean with "harsh"
20:45  greycat: lhunath: you're going to demangle quoted-printable and so on?  in awk?
20:45  mikedep333: http://pastebin.com/ekaQgcgJ
20:45  pantano: greycat: that's why I ask if someone knows one
20:45  mikedep333: there's my code for iterating through a list of directories
20:45  greycat: metamail?  *shrug*
20:45  lhunath: well; recode could
20:45  greycat: mikedep333:  is it equivalent to    for dir in */
20:45  mikedep333: ok
20:46  jimbauwens: syntax error near unexpected token `then'  ....
20:46  mikedep333: so I should make it: for dir in worldbackup*/
20:47  pantano: hm, metamail seems to be exactly what I want, thanks
20:49  mikedep333: greycat, oh, wow, I needed a space between [[ and $dir
20:51  mikedep333: greycat, gotta go, thanks
20:52  jrm222: I have a case statement like: case $POINTS_TO IN /home/joey/*), but I'd like to do the opposite, i.e., do something if $POINTS_TO doesn't is *not* in /home/joey/*.  Can anyone suggest a way to do this?
20:52  greycat: case $foo in /home/joey/*) ;; *) whatever
20:52  greycat: or maybe you need a : before the ;; -- I'm not sure
20:53  jimbauwens: I'm so stupid
20:53  jrm222: Thanks greycat
20:53  jimbauwens: if  [$(wc -c < hosts_bad) != 0 && changed == 1] did the trick
20:53  jimbauwens: so simple...
20:53  nDuff: err
20:53  greycat: jimbauwens: and so wrong.
20:53  jimbauwens: why?
20:53  greycat: I think you hit three Pitfalls on that line.
20:54  greycat: !pitfalls > jimbauwens
20:54  greybot: jimbauwens: http://mywiki.wooledge.org/BashPitfalls
20:54  jimbauwens: :o
20:54  greycat: Three that I see immediately, anyway.
20:54  nDuff: jimbauwens, didn't greycat give you a corrected version of that line earlier, anyhow?
20:55  jimbauwens: did not work
20:55  jimbauwens: I'm not a good bash programmer
20:55  jimbauwens: :)
20:55  nDuff: "did not work" is undescriptive.
20:55  nDuff: How did it fail?
20:56  jimbauwens: wait, i'll test it again, probably it was me doing something stupid
20:57  nDuff: # echo $'one\ntwo' >hosts_bad; changed=1; if (( $(wc -c < hosts_bad) != 0 && changed == 1 )); then echo "true"; else echo "false"; fi
20:57  evalbot: nDuff: true
20:57  nDuff: # touch hosts_bad; changed=1; if (( $(wc -c < hosts_bad) != 0 && changed == 1 )); then echo "true"; else echo "false"; fi
20:57  evalbot: nDuff: false
20:58  nDuff: ...looks good to me.
20:58  antlong: whats the ls  arg to show files before folders?
20:59  greycat: what makes you assume there is such a thing?
20:59  greycat: It's possible that your OS's ls command has been extended with such an option, but there isn't one in POSIX.
20:59  antlong: thats strange
20:59  itr8r: --group-directories-first
21:00  nDuff: but that's a GNU extension
21:00  nDuff: not safe to use if your script might be run elsewhere
21:00  jimbauwens: Ok, it was me... I had a coding error somewhere... Sorry greycat, for blaming you (in some way i did)
21:05  jimbauwens: I did 'if if' and just looked over it
21:07  jimbauwens: Thanks nDuff and greycat for the help
21:12  prince_jammys: might as well reverse the order of those conditions
21:12  jimbauwens: I know, but I saw it too late
21:13  jimbauwens: Greycat, you are my hero!
21:13  prince_jammys: no point in "paying" for wc if $changed is not 1
21:13  jimbauwens: ah
21:13  prince_jammys: it's cheaper to test the latter
21:14  jimbauwens: reverse, speed improvement
21:14  prince_jammys: right
21:14  jimbauwens: ok thanks :)
21:14  prince_jammys: cool
21:15  prince_jammys: also, that wc command looks like test -s
21:16  prince_jammys: ... unless i miss something
21:16  greycat: You're probably right.  I am not really paying attention.
21:17  jimbauwens: actually ... i don't need wc anymore
21:18  prince_jammys: you can test for an empty file with bash's test builtin
21:18  prince_jammys: [ -s somefile ]  # see 'help test' in your shell
21:18  jimbauwens: Yes, but $changed only is good
21:18  greycat: if ((changed))
21:18  greycat: !bool
21:18  greybot: Bash doesn't have boolean variables, but you can shanghai integers for this purpose, just like in C. ok=1; while ...; foo && ok=0; ...; done; if ((! ok)); then whatever; fi
21:18  jimbauwens: there is no reason for to check if the file is empty
21:19  jimbauwens: Because if $changed=1, then the file is not empty
21:20  jimbauwens: greycat, cool :)
21:22  prince_jammys: just don't go making it '2' when false ;)
21:22  prince_jammys: hey, anything's possible around these parts
21:23  jimbauwens: ok :)
21:23  jimbauwens: Oh, man, I'm getting crazy looking at my code... Will continue later. Thanks prince_jammys and greycat :)
21:24  prince_jammys: welcome
21:25  jimbauwens: grep return 1 if it finds something, doesn't it?
21:25  greycat: other way around
21:25  greycat: !ifgrep
21:25  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
21:26  jimbauwens: ok, thanks
21:26  prince_jammys: 0 is success, when it comes to exit codes
21:27  jimbauwens: ok, then my code  is good :)
21:29  jimbauwens: Leaving now
21:29  jimbauwens: bye, and thanks
21:32  ket: hmm, so if grep will work compared to if [[ $( grep 'word' <(command) ]]
21:33  greycat: !ifgrep
21:33  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
21:33  prince_jammys: if command | grep -q regex
21:33  ket: excuse me: if [[ $( grep 'word' <(command) ) ]]
21:33  greycat: It just keeps getting worse.
21:34  ket: geez... >;|
21:34  prince_jammys: don't test output, just test the exit status as shown
21:34  prince_jammys: it's faster in several ways. (grep -q quits when it finds a match)
21:35  prince_jammys: and the [[ and $() just add more useless layers
21:35  ket: precisely err=0 ; { if [[ $( grep 'word' <(command) ) ]] ; then ... ; else ... ; fi ;} || let err+=1 ... and so on..
21:36  prince_jammys: the || business is just weird there
21:36  greycat: command | grep -q word; err=$?
21:36  ket: great... so 'if command | grep regex ' seems to be good..
21:37  greycat: (or possibly   err=$((! $?))   if you wanted it reversed)
21:37  ket: greycat: but what i tend to do is increment err=N in a function, then supply the psuedo _main_ on what to do based on the value of err...
21:37  ket: lulz..
21:37  prince_jammys: or just do it the dumb way, without assuming an error status of 1
21:38  ket: hahaha
21:38  ket: oh man.. gtg...
21:40  ket: newyz: it'd be something like func() { { comm || err+=1... loop || err+=1 ; loop || err+=1... statement || err+=1 ;} ... script script... ;} ... bleh.
21:40  greycat: so many { and ...
21:40  greycat: I can't even guess what you're donig.
21:41  ket: some example... brb
21:41  greycat: You appear to be *counting* the number of errors as if that total were meaningful in some way.
21:41  greycat: Instead of doing the obvious thing:   f() { command 1 || return 1; command 2 || return 1; ... }
21:41  ket: but incomplete: http://sprunge.us/CSIE
21:43  ket: but yea....
21:43  prince_jammys: overuse of && ||, in my opinion
21:43  greycat: tunchk() { local x; x=$(ifconfig); if [[ $x = *teredo* ]]; then tunint=teredo; return 0; elif [[ $x = *tun* ]]; then tunint=tun; return 0; fi; return 1; }
21:44 * greycat ignores the rest.
21:44  ket: heh...
21:44  TheBonsai: though i also tend to use some kind of "overall status indicator" in more complex code, usually some OK/WARN/FAIL thingy
21:45  ket: wait: test accepts regex... what have i been smoking... i've been using shopt -s extglob: if [[ $TERM == +(rxvt*) ]] ... for instance...
21:45  greycat: ket: Good.  Continue doing that.
21:45  greycat: !regex
21:45  greybot: Some people, when confronted with a problem, think ``I know, I'll use regular expressions.'' Now they have two problems. -- jwz
21:46  ket: hurray!
21:46  prince_jammys: why use exglob there anyway?
21:46  greycat: Although in THAT particular example you don't even need an extglob.  Just  [[ $TERM = rxvt* ]]
21:46  ket: and if rxvt* is quoted..
21:46  greycat: Never use a regular expression when an extended glob will do.  Never use an extended glob when a regular glob will do.  Never use a glob when a string will do.
21:46  ket: **double.(soft)
21:46  prince_jammys: * loses magic power
21:46  greycat: ket: don't quote it, idiot.
21:47  ket: kk..
21:47  ket: k...
21:48  ket: wait: we were just kidding about the idiot... right??
21:49 * ket : facepalms**
21:49  ket: l8r
21:50  greycat: If we were just kidding about quoting a glob then we were kidding about being an idiot.
21:51  ket: then that's where i probably should stfu..
21:52  bassliner: can i somehow create a sequence of hex numbers in bash?
21:52  greycat: !faq hex
21:52  greybot: http://mywiki.wooledge.org/BashFAQ/071 -- How do I convert an ASCII character to its decimal (or hexadecimal) value and back?
21:52  bassliner: as in {1..1000} but for hex?
21:52  bassliner: thanks.
21:52  greycat: printf '%x\n' {1..1000}
21:53 --- buntfalke_ is now known as buntfalke
22:20  dagni: damn
22:20  dagni: i would write some big script
22:20  dagni: but haven no idea what to write
22:20  dagni: is there some site with ideas ? :)
22:20  greycat: Big scripts suck.
22:20  dagni: ok, maybe little less than big
22:20  dagni: :p
22:20  NTU: i love big scripts
22:20  dagni: me 2
22:20  TheBonsai: size matters?
22:20  dagni: ;)
22:20  NTU: yes!
22:20  NTU: just like a penis!
22:20  greycat: If you're writing big scripts, you should be writing in some other language instead.
22:20  dagni: e-bash-penis
22:21  dagni: ;)
22:21  dagni: hmm
22:21  dagni: but i love bash..
22:21  NTU: greycat: python?
22:21  NTU: i dunno python..
22:21  dagni: why having script with 5 functions is better than script with 100 functions..
22:21  dagni: me neither
22:22  dagni: i know bash only
22:22  dagni: and C a little ;/
22:22  NTU: same!
22:23  dagni: my biggest script have 937 lines
22:24  NTU: thats not big
22:24  dagni: yes..
22:24  dagni: i wanted to make something really big, that would be challenge ;)
22:24  greycat: It's stupidly huge.
22:24  greycat: Consider switching to a more suitable language if you're writing anything over ~100 lines.
22:24  TheBonsai: well, script size isn't always an indicator for complexity
22:24  TheBonsai: maybe it's just long
22:25  TheBonsai: but no complexity
22:25  greycat: Usually it's an indicator of incompetence.
22:25  geirha: It's not done when there's nothing left to add, it's done when there's nothing left to remove
22:25  NTU: greycat: specify language
22:25  dagni: it have many many features, it is vps manager
22:25  greycat: NTU: ANY.
22:25  dagni: but if it's doable in bash then why should one use other lang
22:25  dagni: why?
22:25  NTU: exactly
22:25  greycat: !weakness
22:25  greybot: http://mywiki.wooledge.org/BashWeaknesses
22:25  dagni: lets see..
22:26  NTU: moving a folder, creating folders, renaming files, using git, etc in C?
22:26  lhunath: transparency; maintainability; performance
22:27  lhunath: code safety; testability
22:27  greycat: Why the fuck would it take you a thousand lines to mkdir; git?
22:27  dagni: there are 15 points listed, none in my 937 lines script, i guess in that case it's ok to have big bash script.. :)
22:27  dagni: and it work really fast..
22:27  NTU: haha
22:28  TheBonsai: was it hard to write 937 ":"?
22:29  NTU: just have a script filled with null echo lines, thats how you make it "bigger" :P
22:29  dagni: i personally disagree that anything above 100 lines should be written in other language, but it's just my oppinion and i guess im wrong here :p
22:29  NTU: I agree with dangi
22:29  NTU: *dagni
22:30  NTU: lol dangit
22:30  dagni: dang!
22:30  dagni: ;>>
22:31  dagni: anyway, movie time, bbl ;...
22:31  TheBonsai: i've done very complex stuff in Bash (greycat would say "bad"). Bash isn't able to handle the complexity above a specific level. impossible.
22:32  NTU: well technically you could use binary in bash so its not impossible
22:32  NTU: like reading binary data from executables
22:32  TheBonsai: then you reduce it to pure batch processing, which means CMD.EXE would do, too
22:33  greycat: The kids must be out of school this week.
22:33  greycat: Christ.
22:33  NTU: greycat: im home schooled
22:33  TheBonsai: for example sane error handling is extremely difficult, if not impossible
22:33  TheBonsai: well, let's say "waterproof"
22:35  helo: sounds like the adults all got laid off this week
22:36  NTU: HAHAHAH!!!!!!!!!
22:38 * lhunath took the liberty to add two paragraphs to BashWeaknesses on large scripts for the occasion.
22:38  lhunath: feel free to moderate.
22:40 --- Muzer is now known as MuzerAway
22:42  TheBonsai: helo: if you don't care if the processing works or not, you can code like you want. from the time your company looses money when you make mistakes, you should think about sane concepts and programs. that's all, not more, not less.
22:44  helo: sorry, what?
22:45  greycat: When I worked for a consulting company (last century), we used to LOVE it when clients had 2000-line backup scripts, because it meant business for us.
22:46  greycat: (No, that is NOT an exaggeration.  Actually I'm under-reporting the length.)
22:48 * nDuff believes.
22:48  nDuff: mind you, I've written long scripts before. They were broken down into individual functions, each of which was small, readable, and well-tested.
22:48  TheBonsai: the worst thing i had to debug (actually i finally replaced it) was a bash-script that generated shellscript on the fly over a ssh link which contained an embedded tcl/tk script which contained some escapes. there were many parts that looked like \\\\\\\\\\\\\\\
22:50  lhunath: TheBonsai: was the solution to the enigma "rewrite it in C"?
22:52 * nDuff makes a note to keep TheBonsai away from pallet's stevedore module
22:53  poisonbit: I've a simple rule... if i need a data structure more complex than a list, or I need requirements like "read the data from a microsoft excel", i just jump from bash to perl. Job done.
22:53  mehwork: i'm trying to printf a variable that contains an apache vhost string, so it has text like %{HTTP_HOST} in it that seems to be causing a syntax error with bash like '{`: invalid format character. i tried putting a \ before it to escape it but that didnt work. any ideas?
22:53  kunde: i have a problem with a command named 'xdotool'. according to the online man page "http://www.semicomplete.com/projects/xdotool/xdotool" it should read from STDIN or FILE. however, using ubuntu 10.04 it wont. now, thats a problem ....
22:53  greycat: mehwork: printf '%s\n' "$var"
22:53  TheBonsai: lhunath: use another processing concept and ease it all, reduce the need for complexity
22:53  TheBonsai: lhunath: KISS
22:53  lhunath: mwah.
22:54  mehwork: that seems to ahve worked greycat , thanks
22:54  TheBonsai: coward, i know :))
22:54  nDuff: mehwork, by the way, if you really had to put the % in the format string, you'd quote it as %%
22:54  kunde: ... becaus i wish to something like 'ping localhost | sed ...filter... | xdotool -
22:54  mehwork: greycat: is that how i should always printf any variable? i've been doing printf "$var" fine until now
22:54  nDuff: mehwork, ...but if you _really_ had to do that, you'd know that
22:54  nDuff: mehwork, no, printf "$var" is evil
22:54  nDuff: mehwork, really, really, _REALLY_ evil.
22:55  mehwork: makes sense, since % is magic to printf, thanks a lot. lesson learned
22:55  greycat: mehwork: Yes.  You should never do  printf "$var"   because \ or % in the variable will fuck things up.
22:55  TheBonsai: it opens doors for format string attacks in C, and isn't better in Bash either
22:55 * helo opens the door
22:55  mehwork: greycat: any particular reason you used single quotes for the first part of printf ?
22:56  poisonbit: because there are not variables into
22:56  TheBonsai: (yes, the ekiga format string vulnerability some years ago, it was me...)
22:56  kunde: is there a trick forcing the stream from the pipe down the throat of xdotool? i'm afraid the problem did not becoem clear, right?
22:56  TheBonsai: right.
22:56  greycat: !<( > kunde
22:56  greybot: kunde: Process Substitution -- <(cmd) and >(cmd) -- see http://mywiki.wooledge.org/ProcessSubstitution , or http://mywiki.wooledge.org/BashFAQ/024 for a common use
22:58  greycat: From the mailing list:  ionice -c 2 -n 0 -p `echo $$`
22:58  greycat: *headdesk*
22:58  TheBonsai: good night greycat
22:58  TheBonsai: hm, too early
22:59  kunde: greycat, thx
23:00  mehwork: i still need to escape $'s contained in $var even if i printf '%s\n' "$var" right?
23:00  mehwork: anythin else i need to escape
23:00  greycat: mehwork: no.
23:00 * helo tussles an inko
23:00  poisonbit: I use tu use less priority when I slow down I/O. ionice -c3 -p "$$" >/dev/null  (and renice +19 "$$" >/dev/null)
23:01  greycat: # var='$\"%'; printf '%s\n' "$var"
23:01  evalbot: greycat: $\"%
23:04  kunde: greycat, right now i cant check it out, because i'm sitting in front of a windows box. i'm afraid it wont work, because xdotool strictly will not accept from stdin. i thought about something like 'xdotool $X' where X is fed by the stream. does that sound reasonable?
23:05  TheBonsai: if it wants to seek() in there, it may not work
23:05  kunde: greycat, stupid problem, difficult to explain
23:05  greycat: kunde: the entire point of <(...) is that it provides a filename to the application
23:06  poisonbit: reading buffer...   dagni, NTU, 253 lines (203 sloc)  http://poisonbit.wordpress.com/2010/10/26/ttyshooter-did-you-ever-did-a-game-in-bash/    :P
23:07  kunde: greycat, i see. but i think my stupid ubuntu 'xdotool' will not accept files either. the parameter has to be given directly on the command line. using a variable, however, definitly works. like 'xdotool $X'
23:07  greycat: !cs > kunde
23:07  greybot: kunde: Command Substitution: The $(foo bar) causes the command 'foo' to be executed with the argument 'bar' and $(..) will be replaced by the *output*. See http://mywiki.wooledge.org/BashFAQ/002 and http://mywiki.wooledge.org/CommandSubstitution
23:08  greycat: kunde: fuckingthing "$(command)"
23:08  greycat: or fuckingthing "$(< file)"
23:08  greycat: I can't decipher what the hell you want.
23:10  kunde: greycat, interesting, i always tried this  xdotool `command` sort of thing. but that $ construct looks promising. so $(command) behaves like a variable? that probably will do the trick.
23:10  kunde: greycat, thank you
23:10  greycat: !`
23:10  greybot: The backquote (`) is used in the old-style command substitution, e.g. foo=`command`. This syntax is deprecated in favor of foo=$(command). Backslash handling inside $() is less surprising, and $() is easier to nest. See http://mywiki.wooledge.org/BashFAQ/082
23:11  greycat: Windows brain-damage.
23:11  kunde: alright
23:12  mehwork: to create a file with the contents of a variable, do i just echo "$var" > file?
23:12  greycat: printf is safer.
23:12  mehwork: printf '%s' "$var" > file?
23:12  mehwork: or is there an fprintf
23:13  greycat: If it's intended to be a text file, do not omit the newline.
23:13  mehwork: oh yeah needs to end with newline to be counted as a unix file
23:17  kunde: greycat,  "echo $(ping localhost)" wont work, right?
23:18  greycat: It will only "work" if your ping command exits for some reason.
23:18  kunde: right
23:18  greycat: E.g. if localhost is not a recognized hostname.
23:19  ss0: What's the best way to echo large chunks of text when building config files from scratch?
23:19  yitz_: cp
23:19  yitz_: Or a cat heredoc
23:19  ss0: !heredoc
23:19  greybot: Here documents. cat <<EOF followed by several lines of text, followed by the literal string EOF on a new line, NOT indented. The portion between the EOFs is passed to the command as standard input. If 'EOF' is 'quoted', substitutions WON'T be done; otherwise they are. See <<- for the indented variety.
23:20  ss0: Ah that seems to be exactly what I am looking for thanks, yitz_
23:20  usman: hi, i am making a bash script to check the makefile install, clean, uninstall is working correctly or not, the logic i am using is that if i do make clean then the bash script will check that will the file is removed or not.
23:21  greycat: You don't trust the exit status of make clean?
23:21  usman: i am using the following condition
23:21  usman: if [ -f $file1 ]
23:21  usman: where file1 is located in current directory file1=./testelectro
23:21  greycat: !umq > usman
23:21  greybot: usman: "USE MORE QUOTES!" They are vital. Also, learn the difference between ' and " and `. See <http://mywiki.wooledge.org/Quotes> and <http://wiki.bash-hackers.org/syntax/words>.
23:22 * helo thinks back on all of the times make clean hasn't worked
23:23  greycat: Are you allowed to fix the Makefile?
23:23  greycat: Or are you assuming an incompetent developer?
23:23  usman: yes only for some particular files
23:23  greycat: Fine.  Quote them.
23:24  usman: OR can i change my logic to use $? after every step of execution ?? can i do this way ??
23:25  usman: or some wildcard which check the .exe when the make install is runned
23:25  mczinger: i have a bunch of media files (from a TV series) that're named <stuff> S##E## <more stuff>.avi; i want to delete everything before the first two numbers ## and affix a show's name, and then spit out <show name>.##.##.avi
23:26  mczinger: for example: The Venture Bros. - S01E03 - Mid-life Chrysalis.avi -> the_venture_bros.01.03.avi
23:26  mczinger: for every file
23:26  mczinger: in the folder
23:26  ss0: mczinger:  that would be done very easily with awk, but that may not be covered by the bash channel.
23:27  mczinger: ss0: hm hm ... true
23:27  helo: oh, you have '-' characters
23:27  mczinger: helo: yeah. it's AWKward [[chuckle]]
23:27  erUSUL: !pe > mczinger
23:27  greybot: mczinger: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
23:27  helo: oh, you want the title to be converted to lowercase?
23:28  ss0: nice erUSUL
23:28  mczinger: well, it's all the same show, so the name doesn't have to be converted
23:28  erUSUL: 4# a="The Venture Bros" ; echo "${a^^}"
23:28  shbot: erUSUL: THE VENTURE BROS
23:28  mczinger: essentially i want the S01E03 to be extracted, then the #s can be appended to the_venture_bros. and then .avi at the end
23:29  mczinger: they're all avi
23:29  mczinger: and they're all the same show
23:29  mczinger: i just want the season and episode number from that long title mess
23:29  erUSUL: 4# a="The Venture Bros. - S01E03 - Mid-life Chrysalis.avi" ; echo "${a%%.*}"
23:29  shbot: erUSUL: The Venture Bros
23:30  erUSUL: 4# a="The Venture Bros. - S01E03 - Mid-life Chrysalis.avi" ; echo "${a%%-*}"
23:30  shbot: erUSUL: The Venture Bros.
23:30  erUSUL: 4# a="The Venture Bros. - S01E03 - Mid-life Chrysalis.avi" ; echo "${a%-*}"
23:30  shbot: erUSUL: The Venture Bros. - S01E03 - Mid
23:30  erUSUL: ouch; to much chaining
23:30  erUSUL: !faq string
23:30  greybot: http://mywiki.wooledge.org/BashFAQ/007 -- Is there a function to return the length of a string?
23:30  mczinger: i dont' really care about the NAME, since it's all the same name
23:30  mczinger: y'know?
23:31  erUSUL: !faq 100
23:31  greybot: http://mywiki.wooledge.org/BashFAQ/100 -- How do I do string manipulations in bash?
23:31  mczinger: How can you get "The Venture Bros. - S01E03 - Mid-life Chrysalis.avi" to echo .01.03.avi
23:31  mczinger: because then it can be appended to the_venture_bros
23:31  mczinger: since it's all the same
23:35  helo: for f in *.avi; do mid=$(echo $f|cut -d'-' -f2); season=${mid%E*} season=${season#*S}; episode=${mid#*E} episode=${episode% *}; echo ".$season.$episode.avi"; done
23:35  helo: probably bad form with 'echo $f'
--- Log closed Mon Nov 22 23:41:24 2010
--- Log opened Mon Nov 22 23:41:49 2010
23:41 --- Users 515 nicks [0 ops, 0 halfops, 0 voices, 515 normal]
23:43 --- Channel #bash was synced in 83 seconds
23:44  neurochrome: this is gonna seem really stupid I know, but how do I take the output of the clipboard (a url in this case) and use 'xclip -o' to send it to 'get_flash_videos' cli utility (which expects an example such as 'get_flash_videos http://www.example.com')
23:44  catsup: perl comes with this script called 'rename':  rename 's/^The Venture Bros\. - S(\d\d)E(\d\d).*\.avi/venture_bros.$1.$2.avi/'
23:44  neurochrome: I can only think of sending the output of xclip to a temp file and reading from that, but that seems clunky and I know I'm missing something
23:44  catsup: neurochrome: get_flash_videos $(xclip -o)
23:44  neurochrome: tried piping it but that doesn't work
23:45  neurochrome: catsup, you legend you
23:45  neurochrome: catsup, ahhh still no go
23:45  catsup: um
23:45  catsup: what does 'xclip -o' do?
23:46  neurochrome: nothing, silent if anything
23:46  catsup: if it outputs the clipboard to standard out, you should be good
23:46  catsup: i mean if you just run it on the command line
23:46  neurochrome: xclip -o prints the expected url
23:46  catsup: does a=$(xclip -o) print anything?
23:47  helo: wouldn't that only print errors?
23:47  catsup: helo: maybe it's printing to stderr...
23:47  catsup: which it shouldn't of course, but who knows
23:47  mczinger: catsup: is that for all files in the folder?
23:47  mczinger: and does that re-name them? or just echo the output?
23:48  catsup: mczinger: no, you woudl need to specify the files
23:48  neurochrome: still nothing with a=$(xclip -o)
23:48  neurochrome: I'm in the terminal
23:48  catsup: it renames them, or with -n, tells you how it would rename them
23:48  catsup: neurochrome: now try echo $a
23:48  neurochrome: my plan is to be able to copy a url and then press a keyboard shortcut to run a command that'll download the video from that url
23:49  neurochrome: echo $a gives : a=$(xclip -o)
23:49  catsup: neurochrome: btw, the firefox extension 'dwhelper' will give you a button to dl the video to your downloads folder
23:49  neurochrome: catsup, already have it, but prefer this method
23:49  catsup: erm, http://www.downloadhelper.net/
23:49  catsup: ok
23:50  neurochrome: I use get_flash_videos as it is quick and doesn't get in my way
23:50  catsup: wtf do you mean echo $a gives a=$(xclip -o)
23:50  neurochrome: when I type echo $a the next line reads a=$(xclip -o)
23:50  catsup: can you pastebin your terminal buffer
23:50  helo: hahaha
23:50  catsup: because that makes no sense
23:50  neurochrome: weird
23:51  neurochrome: catsup, how might one go about said pasting of said buffer ;0?
23:52  geirha: neurochrome: Did you possibly copy/paste the line a=$(xclip -o) and pasted in your terminal?
23:52  catsup: you don't know how to copy and paste from the terminal?  just select everything with the mouse, then middle click into the text box
23:52  geirha: If so, that's what a will contain ^^
23:52  steve___: catsup: and you thought this was going to be straight forward...  never under estimate the power of a PEBKAC
23:53  neurochrome: yeah I do... ctrl+shift+c ,etc
23:53  catsup: ^^ assuming you're using unix
23:53  neurochrome: didn;t know what you meant by buffer, my bad
23:53  catsup: steve___: haha
23:53  geirha: neurochrome: There are different buffers. The one you use with ctrl+shift+c etc, and the one where you only use the mouse; mark to copy, middleclick to paste
23:53  neurochrome: cheers steve___
23:54  geirha: xclip uses the latter by default
23:55  neurochrome: I don't claim to know any more than a beginners level bash, I'm not an idiot however so please don't get frustrated, if you don't want to help that's fine, but don't treat me like a 2nd class cheers ;0)
23:55  neurochrome: geirha, right
23:55  catsup: geirha: he said 'xclip -o' alone prints the url
23:55  neurochrome: geirha, had no idea there were different buffers
23:56  geirha: catsup: That was before he copy pasted the code you gave him
23:56  neurochrome: xclip -o prints the clipboard fine
23:56  steve___: neurochrome: you misinterpreted my comment.
23:56  catsup: does it still do so, neurochrome ?
23:56  neurochrome: not after that command you asked me to execute eariler, but I can rectify that by re-copying the url
23:57  catsup: yeah ok
23:57  geirha: experiment with  xclip -o  and  xclip -o -selection secondary
23:57  neurochrome: right so xclip is armed and ready to go with youtube rul
23:57  catsup: do that, and then once xclip -o gives the desired output, immediate try get_flash_videos $(xclip -o)
23:57  neurochrome: s/rul/url
23:58  geirha: No, get_flash_videos "$(xclip -o)"
23:58  catsup: geirha: i think he wants to nuke whitespace here actually
23:58  neurochrome: catsup, failed again
23:58  steve___: it iwll break on & without quotes
23:58  neurochrome: 2 secs
23:59 --- project2501b is now known as project2501a
23:59  neurochrome: and now xclip -o gives nothing
23:59  catsup: steve___: no it won't
23:59  catsup: does xclip -o remove the content from the clipboard once it prints it?
23:59  geirha: neurochrome: Mark the url (without hitting ctrl+c or anything), then type xclip -o
23:59  geirha: Then mark som other text and run xclip -o again
--- Log closed Tue Nov 23 00:00:02 2010
