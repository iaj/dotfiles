--- Log opened Mon Dec 20 00:00:06 2010
00:00 --- Users 530 nicks [0 ops, 0 halfops, 0 voices, 530 normal]
00:01 --- Channel #bash was synced in 121 seconds
00:03  e36freak: poisonbit: you have a point there
00:08  poisonbit: i've now a win7 license... but i do not use that having other O.S.s. anyway i'm ourious about test bash on windows some day
00:08  e36freak: i use cygwin when i have to
00:12  poisonbit: I work with windows users... (and OSX users and their fucking .DS_Store files everyplaces) so i repeat about NNN times/year "set utf8 in putty", "delete the windoes carriage returns" and "please never ever use chmod 777, fuck what google said"
00:13  e36freak: haha
00:13  e36freak: i also work with windows users, but i run arch on my work pc
00:14  poisonbit: arch uses lot of shell scripting, right ?
00:14  e36freak: it can
00:15  poisonbit: i mean for package management, etc
00:15  e36freak: its bare bones cli to begin with, you can do anything you want with it
00:15  e36freak: package manager is written in C, but its all cli
00:15  poisonbit: ah
00:16  peleg: I am having a script that outputs "Text: 17" (where 17 is any integer). How can I -- without using a variable, but instead using one command -- get the "17" as an output?
00:17  ferret: The International Command Shortage strikes again!
00:17  ferret: Only one per user!
00:18  ferret: Variables at an All Time Low!
00:18  peleg: thought of using awk, but it treats all of the line as one field. I think it is sensitive to tabs mostly.
00:18  grop: peleg, cut -d: -f2 ?
00:19  peleg: grop, hmm, didn't know about "cut". Thanks, I'll try!
00:19  tvm: peleg: you can use awk {' print $2 '}
00:19  tvm: also.
00:20  poisonbit: # echo $(( $( echo "Text: 17" | cut -d: -f2 ) + 1 ))
00:20  evalbot: poisonbit: 18
00:20  poisonbit: using peleg tip
00:20  peleg: tvm, oh, I guess the ' has made the difference? I have used " ...
00:21  poisonbit: errr... i mean... using grop tip
--- Log closed Mon Dec 20 00:25:15 2010
--- Log opened Mon Dec 20 00:30:38 2010
00:30 --- Users 522 nicks [0 ops, 0 halfops, 0 voices, 522 normal]
00:31 --- Unknown[NF] is now known as Unknown[OFF]
00:32  Bushmills: # arr=(a b); : ${arr[2]:=c}; echo "${arr[@]}"
00:32  evalbot: Bushmills: a b c
00:32  Bushmills: krzee: ^^^
00:32 --- Channel #bash was synced in 111 seconds
00:32  poisonbit: <peleg> poisonbit, no, it is for studying reasons. I'm just learning the system.    <----  OK for learning purposes, as you have seen, "there is more than one way to do it", just see another one: echo 'Text: 17' | perl -anE 'say $F[1] + 1;'
00:33  peleg: hehe, thanks :)
00:33  poisonbit: :)
00:34  Bushmills: # arr=(a b x); : ${arr[2]:=c}; echo "${arr[@]}"
00:34  evalbot: Bushmills: a b x
00:36  krzee: allow me to be more !exact  i will pastebin
00:37  krzee: http://pastebin.ca/2023991
00:37  peleg: ok, so I have another question. Suppose I want to run "script -n @@@ -r blabla.tex" where @@@ should be replaced by the output of some other script. How can I do that?
00:37  peleg: (again, no variables :) )
00:38  peleg: something like in printf, where %s comes at the end, or something like that. I want to pipe a result of a script into the middle of another command...
00:38  krzee: peleg <(otherscript)
00:38  krzee: err no thats a file
00:38  poisonbit: script -n "$(other)" -r blabla.te
00:38  krzee: i mean $(otherscript)
00:39  krzee: ahh right, quote it too
00:39  krzee: like poisonbit said
00:39  peleg: hmm... thanks!
00:39  geirha: krzee: ${array[index]}
00:39  Bushmills: krzee:  - in pe only chooses alternative value, but doesn't change variable contents.  := does
00:40  geirha: krzee: and array[index]=...
00:40  geirha: krzee: Hey wait, why are you setting index=test?
00:41  krzee: declare -a
00:41  geirha: indices must be numeric
00:41  krzee: the index name itself will be a variable in my script, im using bash 4
00:41  krzee: y
00:41  krzee: (the y was wrong window)
00:42  geirha: You want an associative array?
00:42  krzee: oops i meant declare -A
00:42  krzee: yes
00:42  geirha: Right, that changes things
00:43  krzee: sry, shoulda explained that better
00:45  geirha: You probably want the ${array[$index]:-0}
00:45  krzee: ahh yes i believe thats exactly what i want
00:46  krzee: yep, that works, thanks =]
00:47  peleg: Oh, the patent with awk is not working when it is done inside a Makefile. It outputs everything, instead of just the number. is anything different with the quotes inside a Makefile?
00:47  geirha: !make
00:47  greybot: make is not bash. It has its own syntax that looks a bit like bash, but it isn't. Ask in ##workingset or ##c and read http://www.gnu.org/software/make/manual/ or the help documents of your version of make
00:49  peleg: oh, interesting. Anyway, I can use cut, it'll do...
01:04  f0ster: what is the point of using an irc bnc?
01:06  jordanm: !nabq
01:06  greybot: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
01:17  djustice: ello all. i need to force a process to run in interactive mode..
01:18  djustice: stupid vague i know.. bash -i
01:18  RoadRunning: hi people =DD
01:18  djustice: but my app seems to not care.. and thinks it's noninteractive anyway..
--- Log closed Mon Dec 20 01:24:42 2010
--- Log opened Mon Dec 20 01:30:09 2010
01:30 --- Users 517 nicks [0 ops, 0 halfops, 0 voices, 517 normal]
01:30  RoadRunning: does anyone know a way to only read the line number 2 in a file
01:31  RoadRunning: ?
01:31 --- Channel #bash was synced in 100 seconds
01:33  qubit: the most efficient is probably `head -n 2 | tail -n 1` as it'll only read the few kb, which is good on large files
01:34  qubit: other than that a pure-bash would be to just pipe the file into a loop (while or for) and break after line 2 is read
01:36  e36freak: IFS=$'\n'; i=1; for line in $(cat file); do (( $i == 2 )) && { echo $line; break }; i=$((i++)); done
01:36  e36freak: or something like that
01:36  gniourf_gniourf: wow that's ugly
01:36  e36freak: probably
01:36  poisonbit: awk 'NR==2 {print;exit}' file
01:36  e36freak: haha
01:37  poisonbit: that also does not read the whole file
01:37  qubit: ya, i was thinking more: for (( i=0; i < 2; i++ )); do read line; done < /file
01:37  gniourf_gniourf: for line in $(cat file) is the worse thing you can imagine
01:37  gniourf_gniourf: that's not how you read a file, guys
01:37  geirha: { read -r; read -r; }Â < file; echo "$REPLY"
01:37  poisonbit: it's faq 1
01:37  e36freak: gniourf_gniourf: i see
01:38 --- Gallo_ is now known as Gallomimia
01:39  geirha: sed '2!d;q' file
01:44 --- julian11 is now known as the-game
01:44 --- the-game is now known as the-game-11
01:48  poisonbit: printf '%s\n' 'not' 'a' 'bash' 'file' > file | perl -ne 'print if ($. < 3);' file
01:50 --- Guest47180 is now known as pragma_
01:51  poisonbit: err...  s/|/;/
01:52  poisonbit: anyway i could think 2 times before:  head -n 2 | tail -n 1 being optimal...
01:52  poisonbit: it uses 2 non builtins, a pipe...
01:52  poisonbit: maybe it reads only 2 lines only, but... all "one command and no pipe" solutions offered that does the same, could be better
01:53  poisonbit: i'm lazzy for benchmarking it
01:53  poisonbit: now
01:58 --- the-game-11 is now known as julian11
02:56  chetnick: Hi, I want to delete single line from a text file. Google search came up with: sed '3d' textfile (where 3 is line number). But this only prints out, it doesn't actually remove it from the file. If I redirect it to the same file: sed '3d' textfile > textfile, I get an empty file.
02:57  chetnick: How would I remove it form a file?
03:03  e36freak: sed -i if you use GNU coreutils
03:04  e36freak: if not, sed '3d' textfile > newfile and then just mv it back
03:05  chetnick: e36freak: Thanks.
--- Log closed Mon Dec 20 03:25:01 2010
--- Log opened Mon Dec 20 03:30:27 2010
03:30 --- Users 509 nicks [0 ops, 0 halfops, 0 voices, 509 normal]
03:31 --- Channel #bash was synced in 96 seconds
04:16  LeeRock: I'm grepping for 'foo' in a file.  How do a write a condition if the output of my grep contains anything, do something?
04:16 --- thespider is now known as rustymyers
04:16  LeeRock: if [(grep foo file)=any]; then
04:19  grop: if grep foo file; then echo true; else echo false; fi
04:19  djustice: if [ "$echo(grep foo file)" != "" ] ;
04:19  djustice: grop: ha. u win
04:19  davek: LeeRock: [[ grep -q "foo" file ]] &&
04:19  djustice: even better
04:20  LeeRock: thanks
04:20  grop: The [[ are not necessary.
04:21  davek: grop: yeah, you're right.
04:21  LeeRock: if (grep -q "foo" file); then
04:22  grop: () not needed.
04:22  LeeRock: ok
04:22  e36freak: if grep -q foo file; then
04:22  grop: if grep -q foo file; then echo true; else echo false; fi
04:22  LeeRock: perfect
04:35  tmr: !ifgrep
04:35  greybot: if grep -q word "$file"; then blah blah; fi DO NOT use [[ or [ or ` or $() or any other crap. "if" expects a command. "grep" is a command. "[" is too. You don't need both, just the grep works because grep returns true (0) if a match is found, but not otherwise.
04:53  UnholyTerror: Is there a way to grab all STDOUT and STDERR (system wide) and display them in a terminal. So that any output in the system gets echoed to the terminal?
04:55  qubit: UnholyTerror: no. that'd be a gigantic security hole
04:58  UnholyTerror: qubit, well, i guess so, huh?!
05:10 --- streuner__ is now known as streuner
05:31  vaxerdec: hello, i am trying to capture all trace output from child shells into a file.  i have done "exec 3>trace.out" and exported BASH_XTRACEFD=3 and then "set -x" captures from my own shell (i.e. $$) successfully, but i want child shells.  they don't work though i.e. "bash -x somescript.sh" just puts on stderr as normal.  how to inherit? isn't the fd 3 inherited by child shells?
05:35 --- zach is now known as Guest87186
05:49  tharkun: !ls
05:49  greybot: ls shows you a representation of files. They are NOT file names (for simple names, they mostly happen to be equivalent). Do NOT try to parse it. http://mywiki.wooledge.org/ParsingLs
06:03  tharkun: Gentlemen sorry to bother as per the previous factoid, parsing ls is a pain. Any suggestions on parsing files withing a directory in a portable manner?
06:04  qubit: for file in /path/to/files/*; do foobar "$file"; done
06:05  e36freak: keep in mind * does not glob dot files
06:05  tharkun: qubit: lots of files, The theoretical extreme case says that it might go above 65K files per directory. I believe that goes beyond the shell's expansion capabilities
06:05  e36freak: for file in /path/* /path/.*; do foo bar; done
06:06  SiegeX: or just do 'shopt -s dotglob'
06:06  e36freak: that too
06:07  qubit: tharkun: then youre probably best of using find
06:07  qubit: s/of/off/
06:07  tharkun: qubit: thx i'll research further into find
06:08  SiegeX: while read file; do *stuff here*; done < <(find /some/path -type f)
06:08  tharkun: e36freak, SiegeX: thx also for your suggestions, i am coding for the worst case scenario
06:08  SiegeX: maybe even through in a '-name "*.jpg"' or what have you
06:08  qubit: SiegeX: and what if the filename contains a newline?
06:09  SiegeX: then you'll need to -print0 and use read to delimit on NUL
06:09 * tharkun knows qubit understands his problem
06:09  qubit: that would work
06:10  vaxerdec: you could use the completer i.e. compgen
06:10  qubit: it really depends what your doing. `find /whatever -exec foobar {} \;` is simiplest. if you need to do complex operations SiegeX's idea (with print0) will work
06:12  SiegeX: while IFS= read -r -d $'\0' file; do *stuff here* ; done < <(find /some/path -type f -print0)
06:12  SiegeX: that aught to cover it
06:13  SiegeX: also, what qubit said. Except I would terminate find with '+' instead of '\;' in that case
06:14  qubit: you can terminate find -exec with +?
06:15  qubit: is that a gnu find option, or is it portable
06:15  SiegeX: I forget what version it came in, but its been there for a few.  it acts much like xargs
06:15  SiegeX: its posix
06:15 * qubit uses solaris a lot
06:15  qubit: many solaris programs are missing arguments from their gnu counterparts
06:17  SiegeX: Well I cant say for sure that solaris supports it, but it is in the POSIX standard for 'find'  http://pubs.opengroup.org/onlinepubs/009695399/utilities/find.html
06:17  SiegeX: -exec  utility_name  [argument ...] ;
06:17  SiegeX: -exec  utility_name  [argument ...]   {} +
06:17  qubit: yum solaris supports it. i'll have to switchto using it, much nicer than \;
06:17  qubit: damn i cant type tonight
06:18  SiegeX: ya, and much nicer than having to deal with xargs
06:18  vaxerdec: oh interesting, i didnt' know about execdir
06:18  SiegeX: that one might be a gnuism
06:20  vaxerdec: xargs does find and replace though
06:20  vaxerdec: making it less necessary to transform filenames manually in a subshell
06:22  vaxerdec: i guess you could probably just use ${//} and friends too but it's still kind of manual
06:22  SiegeX: generally I just use parameter expansion for that
06:22  SiegeX: yep
06:22  SiegeX: !xargs
06:22  greybot: xargs(1) is dangerous (broken) when processing filenames that are not NUL-terminated. If you're working with filenames, use find's -exec {} + instead (yes, it does multiple-filenames-per-invocation, too).
06:22  vaxerdec: i don't know what peoples' problem is putting spaces in filenames.  they should be shot.
06:22  e36freak: i hear that
06:23  e36freak: caps too, to a lesser extent
06:24  vaxerdec: i wish there was a bash debugger that worked for complex code
06:26  redtricycle: How do I output the pid of a file?  tryin gto make a PIDfile in a script
06:26  vaxerdec: i can't seem to find a bash scm tree anywhere, just point releases on ftp.gnu.org.  is it privately developed?
06:27  vaxerdec: redtricycle: "pid of a file?"
06:27  redtricycle: pid of the last run process
06:27  e36freak: $!
06:30  vaxerdec: that only does last backgrounded command though looks like? i'm trying to figure out some way to test it.
06:30  e36freak: # sleep 100; echo $!
06:30  e36freak: nope
06:30  evalbot: e36freak: no output within the time limit
06:30  vaxerdec: like if /bin/true; echo $! would be pid of /bin/true or if it needs /bin/true &
06:31  e36freak: yeah, youd have to background
06:31  e36freak: you can use wait
06:31  vaxerdec: ahh right perfect
06:33  vaxerdec: here's an interesting one: given two strings, output one copy of characters that occur in both
06:37  vaxerdec: try that in a scripting language.  hah!
06:37  e36freak: it can be done, just thinking
06:38  qubit: theres a program that does it already. cant remember the name though
06:38  e36freak: comm does files
06:38  e36freak: not strings
06:38  qubit: you could do it with tmp files and comm
06:39  vaxerdec: e36freak: i think a C program is best for that one.
06:39  qubit: vaxerdec: it can be done in bash, but it'd be weird
06:39  e36freak: i was thinking temp files and comm, or an array
06:40  e36freak: well, 2 arrays.
06:40  vaxerdec: someone i work with said google asked them to do it in a job interview with code as fast as possible
06:40  qubit: loop through the first string by taking 1-char substrings and using bash matching on the second string
06:40  e36freak: there you go
06:42  qubit: like for (( i=0; i<${#string1}; i++ )); do if [ -n "${string2/${string1:$i:1}}" ]; then allchars="${allchars}${string1:$i:1}"; fi; done
06:54 --- hunterm is now known as julian_assange
06:58  vaxerdec: trying to figure out how to do this more succinctly: "echo testing | while read -n 1 char; do echo $char; done"
06:59  vaxerdec: like with IFS=$'\n' and using $* or something
06:59  julian_assange: leakin wikis all up in dis
07:00  pragma_: julian_assange: try some Depends for Men
07:00  julian_assange: lol
07:00  vaxerdec: it's intentional leak imo
07:01  vaxerdec: either israelis want to justify attack on iran (rest is noise for distraction) or US wants to prep populace before foreign policy shift
07:01  vaxerdec: that's extremely off topic though heh
07:03  vaxerdec: i always feel like even those plots are just the first and second layers in.  anyone here see the british miniseries, "the prisoner?"
07:04  geirha: # string1=abc string2=bcd; for ((i=0;i<${#string1};i++)); do char=${string:i:1}; [[ $string2 = *"$char"* ]] && echo "$char"; done
07:04  evalbot: geirha: no output
07:04  geirha: # string1=abc string2=bcd; for ((i=0;i<${#string1};i++)); do char=${string1:i:1}; [[ $string2 = *"$char"* ]] && echo "$char"; done
07:04  evalbot: geirha: b
07:04  evalbot: geirha: c
07:06  geirha: Not really a task you can do that efficiently in bash.
07:06  e36freak: efficiently no, but there are ways to do it
07:09  vaxerdec: kind of ugly but: common=$(echo "${s1}${s2}" | while read -n 1 char; do echo $char; done | sort -u | tr -d '\n')
07:10  geirha: Oh, the union?
07:10  vaxerdec: oh, hm.  did i read my own question wrong?
07:11  vaxerdec: isn't that intersection?
07:11  vaxerdec: oh wait, i see my error.
07:12  vaxerdec: hah, that isn't even on the right track.
--- Log closed Mon Dec 20 08:31:21 2010
--- Log opened Mon Dec 20 09:19:44 2010
09:19 --- Users 502 nicks [0 ops, 0 halfops, 0 voices, 502 normal]
09:20  Bushmills: your choice
09:20  DestinyAwaits: but which one is more flexible for this kinda task
09:20  Bushmills: awkers might say "awk or perl".  others 'd tell you "python"
09:20  DestinyAwaits: so it wont restrict me with features
09:20  mastro: geirha, I see how to use help... but I still don't know how to found the same format as the one I see here: http://ss64.com/bash/read.html (that resemble a man page)
09:21  pgas: both are general purpose languages
09:21 --- Channel #bash was synced in 99 seconds
09:21  geirha: mastro: It's just the ''help "rea[d]"'' output formated like a man-page.
09:21  pgas: DestinyAwaits: perl is typically made for this stuff, and is generally more available across all the unix flavors. Now if you work on linux, python should not be a problem, unless you want l33t oneliners
09:21  mastro: geirha, ok.. so how do I format the help output as a man page?
09:22  DestinyAwaits: l33t?
09:22  geirha: mastro: Actually, that page is missing info
09:22  pgas: DestinyAwaits: elite, cryptic and cool looking
09:22  geirha: Ah, no it's further down, in different font.
09:22  pgas: DestinyAwaits: awk is more limited but maybe more simple to learn
09:22  mastro: geirha, so you area saying "they" did it manually to place it on the website?
09:22  DestinyAwaits: ok
09:23  geirha: mastro: I believe so, yes.
09:25  pgas: there is: help -m in bash 4
09:26  geirha: Ah, neat.
09:26  DestinyAwaits: pgas: one last question. can python do each and everything that perl can do ?
09:26  geirha: Still different from that page though
09:28  pgas: DestinyAwaits: don't worry about that, if you prefer python go ahead
09:29  DestinyAwaits: pgas: well thanks. as far it can do all what can be done with perl i have no problems
09:29  DestinyAwaits: and Thanks for the help :)
10:17  vdubhack: Does any one know how to drop to runlevel 3 in a bash then continue with the script and not have to log in then when needed switch to run level 5 without having to log in and finish the script?
10:20  trash: Sounds like an OS question to me
10:21  vdubhack: trash: ok thanks I tried in the fedora kde chan some thought maybe here :P Not having much luck with this one oh well
10:23 --- Unknown[OFF] is now known as Unknown[NF]
10:48 --- Laynef_ is now known as Laynef
10:52  olskolirc: im trying to understand the \ in form new line...does that mean: Acommand\ Bcommand \Ccommand will show up as A B C commands on new lines?
10:54 --- abstract3d is now known as tzorvas
10:55  pgas: you mean  \ before newlines? yes, bash will act as if the newline doesn't exist
11:08  netsan: hey there, i have some script that send mail, echo -e $MESSAGE | mailx -s "Scripts status: $STATUS" $ADMIN_MAIL < /home/user/tasks/screenlog.0 , but i dont know why, he cant find the path.
11:09  netsan: but the file "screenlog.0" is there.
11:12  pgas: well, for a start you are redirecting stdin of mailx twice, only once will be taken into account, in your case echo -e $MESSAGE does nothing
11:12  pgas: what's the error message exactly?
11:14  netsan: No such file :|
11:18  geirha: Wild guess
11:18  geirha: !cr > netsan
11:18  greybot: netsan: Carriage Return (ASCII 13). Often written as ^M or \r. CRs are found just before newlines in text files generated by DOS/Windows apps. You can see them with "cat -e". See http://mywiki.wooledge.org/BashFAQ/052 to get rid of them.
11:18  mamooth: hey there
11:18  netsan: btw, also
11:18  netsan: i fix it by adding " " to MESSAGE, but it seems its not add the message to the mail body, i have only subject.
11:18  geirha: netsan: Doesn't mailx have an option for attaching files?
11:18  netsan: yep <
11:19  geirha: netsan: That's not an option, that's shell redirection.
11:19  netsan: oh,
11:21  geirha: netsan: You are first redirecting echo's output to mailx's stdin.
11:21  geirha: Then you are redirecting the file to mailx's stdin. So echo's output is going nowhere.
11:22  netsan: OH
11:22  netsan: now it works great
11:22  geirha: !wordsplitting
11:22  greybot: echo $foo; rm $foo -- If you leave $foo unquoted, bash will *remove* all whitespace (newlines, spaces, tabs) while expanding it, take each *word* as a separate argument. `echo` prints these words separated by one space and `rm` deletes each word. So ALWAYS *quote* your parameter expansions: echo "$foo"
11:22  geirha: !varcap
11:22  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
11:22  geirha: for further improvement ^
11:22  geirha: Why are you using echo -e btw?
11:25  netsan: for the body
11:26  twkm: sounds risky.
11:26  ideamonk: Hey guys how do I pass N lines of text to a bash function? I tried piping it to xargs but didn't work out. - http://paste.pocoo.org/raw/307306
11:26  ideamonk: pass as an argument, one by one
11:26  geirha: Yes, but instead of -e, you should add literal newlines... I'm assuming you are using it to have "\n" replaced by newlines.
11:27  ideamonk: I'm using it to ignore folders like .svn, .git in my tree output
11:28  netsan: but i really dont know why
11:29  netsan: my "echo -e .." | tunrin to attachments, sorry for the double line.
11:29  geirha: xargs is an external command. It has no knowledge of whatever functions or aliases you may have in your shell.
11:29  ideamonk: hmm geirha okay
11:30  geirha: ideamonk: find . -name .svn -prune -o -print
11:31  geirha: There, now you don't need xargs, nor your function.
11:32  ideamonk: :) Thanks!!!
11:47  skraito: hi guys anyone can enlighten me how to get bash pid using a script
11:47  erUSUL: # echo $$
11:47  skraito: echo $$ if using a script will get another pid instead of running pid
11:47  evalbot: erUSUL: 229
11:48  skraito: erusul it will invoke another bash i want to get my running pid
11:48  skraito: of bash that i login
11:48  skraito: example in shell > echo $$ is equal to 1234
11:48  skraito: but if you write it in script it will be 1233
11:49  skraito: i want to get the value of 1234
11:49  skraito: anyway we can do it ?
11:50  erUSUL: skraito: you want the pid of the shell from where you launched the script?
11:51  skraito: yes
11:51  erUSUL: skraito: maybe --> ps -o ppid $$
11:52  skraito: thx gonna try it
11:52  erUSUL: # ps -o ppid= $$
11:52  evalbot: erUSUL:     1
11:54  skraito: yap thats the one thank you
11:55  saimon_: hi all...I'm having trouble with escaping quotes: su - john -c '/bin/bash -c "echo 'hello'"' I'm trying to properly quotes that so it outputs => 'hello' but been failing miserably...
11:56  pgas: you cannot put ' ' inside ' '
11:57  pgas: !'
11:57  greybot: Single quotes (') cause everything between them to be taken literally by bash. If you want to embed a ' inside a '...', write it as the four characters, '\'': echo 'It'\''s a blast!'
11:57  saimon_: pgas: thanks let me try that...
11:57 --- phox is now known as Guest19535
11:59  saimon_: pgas: I tried: su - john -c '/bin/bash -c "echo '\''hello'\'''"' and it's unbalanced (i.e. it's waiting for more input)
11:59  erUSUL: saimon_:                                                              ^
12:00  erUSUL: saimon_: you have an extra one after hello afaics
12:00  saimon_: erUSUL: ah yes good catch
12:01  saimon_: hmm still just prints: hello not 'hello'
12:03  pgas: saimon_: it executes: echo 'hello'
12:03  saimon_: pgas: Then I need it to execute echo "'hello'"
12:04  pgas: yes, if you want to see the ' ' you need yet another layer of quotes
12:04  saimon_: pgas: the echo is just for testing. I'll be adding git notes add -m 'bla' instead
12:05  saimon_: so I need to do '\'''\''hello'\'''\'' ?
12:05  pgas: probably not, you often don't want to pass the quotes to the commands
12:11  saimon_: pgas: su - john -c '/bin/bash -c "git notes add -m '\'''hello world'\''"'
12:12  saimon_: world\": -c: line 0: unexpected EOF while looking for matching `"'
12:12  saimon_: world\": -c: line 1: syntax error: unexpected end of file
12:13  saimon_: pgas: same result if I double up the '\'' on either side of hello world
12:13  saimon_: so I'm still lost with this.
12:15  pgas: remove the bash -c,  no ned to make things more complicated
12:16  pgas: (since it works with echo there is no reason for the syntax to be different)
12:17  saimon_: ok I'll try that thanks
12:33  zplinux: hi
12:33  zplinux: how to call a function from a bash script ? not the whole script
12:34 --- methym_ is now known as methym
12:36  pgas: zplinux: no way, you have to source the script before being able to use the function
12:36  zplinux: ./script.sh ; func1()
12:36  zplinux: right?
12:37  pgas: . ./script.sh;func1
12:37  zplinux: o ok
12:37  zplinux: can I write this better?
12:37  zplinux: BRIDGE=`ls -l /sys/class/*net*/${IFACE}/brport/bridge |sed 's|.*/||'`
12:38  twkm: BRIDGE=bridge
12:39  lhunath: entertaining.
12:39  zplinux: to source I need to run: source ./enviroment.sh
12:40  pgas: . and source are the same thing, but . is standard
12:40  zplinux: pgas: I was hopin gto get the bridge name in that line
12:40  zplinux: min
12:41  twkm: at a guess you want bridge=$(cat /sys/class/*net*/$IFACE/brport/bridge).
12:41  zplinux: hmm
12:41  zplinux: ok, let me see
12:58  TheBonsai: y0
13:21  zplinux: seems I got it
13:32  dilbert: hello
13:32  dilbert: can i use a grep in a if and return 0 or 1 . i would like to make the grep on a result from a command not a file..
13:33  TheBonsai: if foo | grep -q bar; then
13:34  dilbert: TheBonsai, like for example ; if ifconfig | grep -q eth0; then echo "found";fi ?
13:34  lhunath: yes.
13:34  dilbert: oki
13:34  dilbert: great
13:34  dilbert: thanks :D
13:34  lhunath: !conditionals > dilbert
13:34  greybot: dilbert: Conditional Structures: http://mywiki.wooledge.org/BashGuide/TestsAndConditionals
13:34  dilbert: thanks lhunath
13:53  esd: how can i change the From frield while sending mail?
13:54  Fatal: with your mta, mua etc
13:54  esd: hmm well ive tried with netcat but it's not quite working :S
13:54  esd: i mean, it's not sending mail
13:54  Fatal: !nabq > esd
13:54  greybot: esd: Not A Bash Question. Ask the channel that supports your software, hardware, or OS.
13:54  twkm: /me chortles
14:11 --- Nemphilis is now known as Guest79225
14:21 --- jzacsh is now known as jzacsh_
14:38  briareus: hi all. I was looking at find command, trying to use mtime (not sure if that's right thing). I'm trying to find all IMG_*.JPG that I've put onto my computer in last 7 days. I'm trying to find one particular picture for work that I doubt I destroyed, just can't find it.
14:38  briareus: I was trying
14:38  briareus: find  -name '*.JPG' -mtime 2 -exec ls -l {} \;
14:38  briareus: but that's not working
14:38  briareus: any ideas?
14:44  dagon666: you guys know any good way to extract everything inside a pair of " " ?
14:45  dagon666: Im trying to create a sed regular expression but without luck so far
14:47  koala_man: dagon666: sed -e 's/.*"\(.*\)".*/\1/'
14:47  dagon666: koala_man: thanks it works :)
14:48  briareus: any ideas for my query?
14:48  geirha: !find > briareus
14:48  greybot: briareus: http://mywiki.wooledge.org/UsingFind
14:48  briareus: thanks
14:50  pgas: dagon666: don't try too hard to use sed and regexp...you can use, say, cut
15:33  mar77i: !pe
15:33  greybot: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
15:34  mar77i: # str="everyone uses sed"; echo "${str/everyone/anyway, who}?"
15:34  evalbot: mar77i: anyway, who uses sed?
15:52  EvanR-work: my mysql command outputs lines of the form x<TAB>y, how do i loop through x y pairs?
15:53  pgas: ! faq 1 > EvanR-work
15:53  pgas: !faq 1 > EvanR-work
15:53  greybot: EvanR-work: http://mywiki.wooledge.org/BashFAQ/001 -- How can I read a file (data stream, variable) line-by-line (and/or field-by-field)?
15:53  EvanR-work: ok
15:54  pgas: while IFS=$'\t' read -r x y;
15:55  TheBonsai: # printf ' A \t B \t C \nD\tE\tD\n' | while IFS=$'\t' read one two three; do echo "$one-$two-$three"; done
15:55  evalbot: TheBonsai:  A - B - C
15:55  evalbot: TheBonsai: D-E-D
15:55  TheBonsai: DED?
15:55  The-Compiler: D-E-A-D
15:55  TheBonsai: fail..
15:58  EvanR-work: great!
16:08  xelister: hi, how to count how many lines in subdirs of foo/  contain text  $something,  where something !='html' and !='form'.  So line "$x" counts, like "$html" does NOT count, and "$html $foo" counts again.
16:09  dagon666: # echo test
16:09  evalbot: dagon666: test
16:09  dagon666: nice :)
16:09  lazyliberal: :)
16:10  dagon666: # echo $(ls ~)
16:10  evalbot: dagon666: no output
16:10  dagon666: # echo $(ls /)
16:10  evalbot: dagon666: bin dev etc lib proc root tmp
16:10  pgas: you can play with evalbot in pm or in #evalbot
16:12  lazyliberal: !ps
16:12  greybot: Don't use ps(1) in scripts -- see http://mywiki.wooledge.org/ProcessManagement instead.
16:12  vrs: xelister: i don't understand your question
16:13  vrs: but i guess find -exec grep and wc -l might help you
16:14  consumerism: i'm writing a script which contains a function which is basically a wrapper for rsync. i am parsing flags with getopts, my question is can i have a single rsync command and give it different options depending on flags? right now i just have several conditionals checking flags and inside each is a full rsync command with flags, lots of duplication and messy. i want just one instance of each possible
16:14  consumerism: flag, conditionally included with a single rsync...is it possible?
16:14  xelister: vrs: the problem with this, is, how to egrep for pattern "\$word" where word!=html and word!=form
16:14  vrs: grep -v
16:16  vrs: consumerism: rsync $SOME_OPTIONS etc etc could do
16:16  trash: vrs: Fail.
16:17  trash: vrs: If you have several arguments, put them inside an array.
16:17  cthuluh: xelister: when you ask a question on one chan, don't ask the same question on $n other channels, or please say so...
16:17  trash: vrs: Also:
16:17  trash: !varcaps > vrs
16:17  greybot: vrs: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
16:17  vrs: trash: worked for me so far, though i only used it for a single option yet
16:18  consumerism: vrs, trash: thanks
16:18  xelister: cthuluh: yeah, I also asked in chans like grep and awk
16:18  xelister: seemed like possible good tools
16:18  xelister: vrs: grep -v is not good, since it will again  kill  line  $html $somethinggood
16:18  xelister: while this line counts because of $somethinggod
16:19  consumerism: trash: do you know of an example of passing the elements of an array as flags for a program? or should i put all the needed flags into a string and use that with my final call to rsync?
16:19  vrs: my question: i have a command that reads from two files, but i can only use one stdin (-). how can i read from two pipes without using named pipes? I don't want to use tempfiles
16:20  vrs: !varcaps
16:20  greybot: By convention, we capitalize environment variables (PAGER, EDITOR, ..) and internal shell variables (SHELL, BASH_VERSION, ..). All other variable names should be lower case. Remember that variable names are case-sensitive; this convention avoids accidentally overriding environmental and internal variables.
16:20  vrs: ah
16:21  cthuluh: vrs: script < <(command) 3< <(other command)   # then use read -u3
16:23  xelister: seriously noone knows how to count this? :(
16:25  consumerism: xelister: have you tried grep word | grep -v notthis | grep -v orthis | wc -l
16:25  consumerism: oh, i see you want lines containing both to count
16:26  Bushmills: your example asked about "$html $foo" - i suppose your question with "$somethinggood" is a different one - or has the problem description merely changed into a different problem?
16:26  consumerism: in your grep -v you will need some regex to specify your requirements
16:27  Bushmills: i suppose you first filter the lines you want to count (or remove those you don't) from output, then you count the rest
16:27  vrs: cthuluh: hm, but it's comm/diff, not a script of mine
16:27  consumerism: or you could just grep all then do some math between several greps to work out which lines have both
16:28  cthuluh: vrs: so you want comm(1) to compare line-by-line the output of two commands?
16:28  vrs: yes
16:29  cthuluh: comm <(command1) <(command2), then
16:29  cthuluh: !<(
16:29  greybot: Process Substitution -- <(cmd) and >(cmd) -- see http://mywiki.wooledge.org/ProcessSubstitution , or http://mywiki.wooledge.org/BashFAQ/024 for a common use
16:29  vrs: neat
16:30  erUSUL: xelister: i do not know if i understood the question well enough .... --> find foo/ -type f -exec cat {} + | grep foo | grep -c bar
16:38  xelister: erUSUL: no.. its not that
16:38  xelister: how hard is it people ;)
16:39  xelister: count how many lines contain text "$something" where $ is a literal dolar sign, follow by some [a-zA-Z0-9]*.
16:40  erUSUL: xelister: adjust the grep regex to do what you want
16:40  xelister: ...while also assuming that the something string must be OTHER then html and form. so, do not count lines that just include  $html  in them, unless they [also] have some other thing like $foobar there
16:40  xelister: erUSUL: yeah, apparently noone knows how to do it...
16:40  Bushmills: 'count ..  linescount ..  lines .. where something !='html' .. like "$html" does NOe count, and "$html $foo" count' .... all clear?
16:41  Bushmills: i suppose the replies you get aren't what you're looking for because you didn't describe well what you want to filter
16:43  Bushmills: of lines with just  "html", "html foo" and "html goodstuff" i wouldn't know which ones to count and which ones not.
16:44  xelister: count all lines that contain words that are not "html" nor "form" and are starting with literal dolar
16:44  Bushmills: ah, and "$something" should not be counted, but "$something[a-zA-Z0-9]*." should
16:45  Bushmills: so you know the total number of lines, and subtract the number of lines containing "html" or "from"
16:45  xelister: count all lines that contain words that are starting with literal dolarare while not being word "$html" nor "$form"
16:46  Bushmills: that is, you remove the lines containing either "html" or "form"
16:46  xelister: Bushmills: this totall lines matching and subtract will not work, because it would wrongly subtract lines like "$html $good"
16:46  erUSUL: xelister: but you want to count lines with both $html or $form and $somethingelse;
16:47  Bushmills: but "count all lines that contain words that are starting with literal dolarare while not being word "$html" nor "$form"" ask to remove the line with  "$html $good"
16:47  xelister: Count all lines, that contain words that are not "$html" nor "$form" and are starting with literal dolar character ($).
16:47 * xelister ponders
16:48  xelister: ok, more clear:
16:48  xelister: Count all lines, that contain at least one word that is not "$html" nor "$form" and that is starting with literal dolar character ($).
16:49  Bushmills: so from all lines, you remove those which contain $html or $form only
16:49  Bushmills: the non-empty remaining lines are those you want to count
16:50  Bushmills: unless those lines must contain at least a word, starting with $.
16:50  Bushmills: grep those lines for words with leading $. the remaining lines are those you want to count
--- Log closed Mon Dec 20 16:50:57 2010
--- Log opened Mon Dec 20 16:51:41 2010
16:51 --- Users 532 nicks [0 ops, 0 halfops, 0 voices, 532 normal]
16:51  Bushmills: simply incrementally remove what you don't want.  by elimination, what you want to count will remain
16:52  e36freak: grep ^\$ | sed '/html/d;/form/d' ?
16:52  e36freak: grep ^\$ | sed '/html/d;/form/d' | wc -l
16:52 --- Channel #bash was synced in 84 seconds
16:53  callumacrae: That's odd, how come ~/.bash_profile isn't being called for root?
16:53  e36freak: callumacrae: as in /root/.bash_profile?
16:53  callumacrae: yup
16:57  e36freak: as in when you su - ?
16:57  xelister: Bushmills: ok that is a good idea
16:57  e36freak: ive never been able to figure that one out, im looking into it. .bashrc works fine when you su
16:58  callumacrae: Is there a difference? :/
16:58  e36freak: yes
16:59  e36freak: its whether or not your logging in as root in a login shell, man su
16:59  callumacrae: oh okay
17:00  callumacrae: I'm just trying to set an alias basically, is there a way to do it that doesn't use .back_profile?
17:00  e36freak: yeah,there you go. if you su -, it will use .bash_profile, otherwise .bashrc
17:01  e36freak: put it in /root/.bashrc
17:01  callumacrae: ah
17:01  callumacrae: okay
17:01  callumacrae: thanks :)
17:01  e36freak: and just make .bash_profile ". $HOME/.bashrc"
17:01  e36freak: i did that and got it working for both su and su - just now
17:02  callumacrae: thanks
17:02  e36freak: np
17:02  callumacrae: what does rc actually mean? A few apps use it
17:02  geirha: run commands I think
17:03  e36freak: basically scripts that run on the invocation of something
17:03  e36freak: .vimrc runs when you start vim, .bashrc bash, etc
17:03  callumacrae: rcapache2 :)
17:04  e36freak: arch and BSD use rc scripts instead of init.d as well, rc.conf, rc.d, rc.local, rc.multi
17:04  e36freak: all run at system stat
17:04  e36freak: start**
17:04  erUSUL: system V style init vs BSD style init
17:05  e36freak: yeah, that. didnt remember the name for the normal one
17:05  callumacrae: runcom, or run commands
17:05  callumacrae: :)
17:12  lazyliberal: !while
17:12  greybot: The while-loop structure: http://bash-hackers.org/wiki/doku.php/syntax/ccmd/while_loop
17:19  slidesinger: a bash behavior question:  if I put something in my bash_profile, which is executed on login, does that carry over when I start a subshell?
17:20  vrs: bashrc is only executed for interactive shells afaik
17:20  nDuff: slidesinger, well, a true "subshell" started by a fork() call with no exec inherits everything...
17:20  nDuff: slidesinger, ...but if you care about whether shells started via an exec() will inherit variables, it depends on whether you exported them into the environment.
17:27  slidesinger: nDuff: Thanks.  In this case, just trying to figure out where I want to put my alias list and common configuration, of course, being that everything is so flexible, there are lots of opinions as to what goes in each file, .bash_profile, .bashrc, etc.
17:27  slidesinger: Understanding the behavior lets me figure it out.  I tried it first and the alias list worked in an xterm regardless of which file I put it in.
17:28  nDuff: slidesinger, ...for aliases, .bashrc is generally the Right Thing.
17:28  slidesinger: nDuff: Thanks.
17:28 * nDuff avoids aliases as much as possible, however -- functions being far more flexible and less caveat-ridden
17:30  cite: Der General BergfrÃ¼hling!
17:30  cite: ECHAN
17:31 --- [1]The-Bat is now known as The-Bat
17:33  slidesinger: nDuff: I use aliases to invoke remote connections, with ports, etc. on the servers I manage.  Always put them in .bashrc, then I came across a reasoned argument for putting them in .bash_profile, although the guy writing the article did a strange thing, I think, in sourcing .bashrc to do it.
17:33  heiner_: I get the following error message: "this should not be happening! arrgggggh!" :-)
17:34  nDuff: slidesinger, notably, there's a lot you can do with ~/.ssh/config -- you can tell it "if I give you hostname FOO, that means to connect to host BAR on port 123".
17:35  slidesinger: Really?  I'll have to reread the docs on that.  That sounds interesting.
17:36  slidesinger: nDuff: Thanks much.  Off to read.
17:36  nDuff: np; the advantage there, too, is it works where aliases don't -- for ssh instances invoked by rsync, for instance.
17:38  crimeboy: what parameter of find command i have to use to list a range of time of files, ex.: files created between 9:30 and 9:35pm ?
17:38  crimeboy: -atime -cmin?
17:40  nDuff: crimeboy, use touch to create sigil files with the timestamps you want
17:40  erUSUL: -newer foo ! -newer bar ? where foo and bar where created using touch with the correct dates?
17:40  nDuff: crimeboy, then use -newer and -older
17:40  nDuff: exactly
17:43  crimeboy: ok
17:43  crimeboy: thank u
18:17  tsolox: if testfile has a modification time of 01:00:00, will `find testfile -mmin -10` see the file when the find command is run at exactly 01:10:00?
18:19  tsolox: sort of hard for me to verify. It can't see the file after 01:10:01 since that is already outside the 10 minutes window. But I am not sure at exactly 01:10:00
--- Log closed Mon Dec 20 21:34:39 2010
--- Log opened Mon Dec 20 21:40:00 2010
21:40 --- Users 547 nicks [0 ops, 0 halfops, 0 voices, 547 normal]
21:40  MrKeuner: how can I check the hexadecimal code of a character?
21:40  poisonbit: nDuff, hehe it's a bit longer that I would like (one expresion/substitution/p.e.), but is great it is what i requested :)
21:40  nDuff: !faq 71 > MrKeuner
21:40  greybot: MrKeuner: http://mywiki.wooledge.org/BashFAQ/071 -- How do I convert an ASCII character to its decimal (or hexadecimal) value and back?
21:40  nDuff: anon33_, man readlink
21:41 --- Channel #bash was synced in 86 seconds
21:42  anon33_: nDuff: thanks - i got it to work. when you gave me that command earlier for cp -L -t target-directory "${symlinks[@]}", will that iterate over each item in the array?
21:42  bwallen: I'm making a script that will post server status messages to twitter. I want a program to call my script by something like ~$ myscript --messageToTweet "this is a message". How do I tell the script to read the "this is a message" part?
21:42  anon33_: because doing the same command piped to readlink doesn't work so hot
21:42  erUSUL: !faq easily
21:42  greybot: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
21:43  bwallen: erUSUL: thanks!
21:49  anon33_: nDuff? did you see my question?
21:51  nDuff: anon33_, it puts all the items in the array  onto the cp command all at once
21:51  anon33_: ahh, and that's why readlink won't work
21:51  anon33_: since cp handles multiple arguments
21:52  anon33_: is there a way to shorthand iterating over the array or is a for loop necessary?
21:52  hacim: is there a better way to utilize return codes, than having to force them like this: if [ `ps auxw |grep nagios-statd |grep -v grep |wc -l` = 3 ]; then true; else false; fi
21:52  nDuff: anon33_, well, the _way_ cp handles multiple arguments is why I added the -t, which is important in that case
21:52  nDuff: anon33_, ...and yes, you'll probably need a for loop. for item in "${array[@]}"; do ... isn't that bad, though.
21:52  nDuff: !ps > hacim
21:52  greybot: hacim: Don't use ps(1) in scripts -- see http://mywiki.wooledge.org/ProcessManagement instead.
21:52  anon33_: will -t handle both directories and types? since -r was ommitted
21:52  nDuff: anon33_, read the man page to see what it does.
21:53  anon33_: okay - should have done that anyways. thanks again for your help
21:53  nDuff: anon33_, (and no, it doesn't recurse; you'll want to add -r if you want it)
21:53  hacim: nDuff: yeah, that was just an example, I'm not actually using ps
21:54  nDuff: hacim, you can use the PIPESTATUS array to read return codes from any element in a pipeline, or you can just do if my | pipe | line; then ... to base the if statement's decision on the exit status of the last element.
21:54  nDuff: !pf
21:54  greybot: nDuff: No matches found at http://mywiki.wooledge.org/BashPitfalls
21:55  nDuff: hacim, ...also, grep -q is your friend (to get only exit status, not stdout; also runs faster since it can stop scanning and exit at the first match)
21:56  MrKeuner: !lynx
21:57  nDuff: !html > MrKeuner (perhaps you wanted this?)
21:57  greybot: MrKeuner (perhaps you wanted this?): You can't realistically parse tag-based markup languages like HTML and XML using Bash or utilities such as grep, sed or cut. If you just want to dump/render HTML, see (links|links2|lynx|w3m) -dump, html2text, vilistextum. For parsing out pieces of data, see tidy+(xmlstarlet|xmlgawk|xpath|xml2), or learn xslt. Ask #xml and #html for more help. See http://www.codinghorror.com/blog/archives/
21:59  hacim: is there a way to see if a parent process has any children, without trying to parse the ps tree?
22:01  anon33_: !for
22:01  greybot: The ''for var in ..'' statement iterates over arguments. for ((i=0; i < n; i++)) iterates over a numeric range. To iterate over filenames, use ''for file in [glob]''. Do *NOT* do ''for foo in `cat,ls,find,...`'': Here, for will iterate over resulting WORDS, NOT the "filenames", or "lines" that the command outputs.
22:02  anon33_: is there a wiki page for for? my code doesn't seem to work right..for item in "${array[@]}" do readlink "$item" done
22:02  anon33_: (with newlines in the script)
22:03  skered: With "trap var ERR" is there an env of the pervious command?
22:03  skered: I guess that doesn't really have anything to do with trap... but if I had a function var and 'trap var ERR' was set.. is there an env var that's the command last ran?
22:04  greycat: I think you mean a variable, but I don't know.
22:04  greycat: I can't think of any reason such a variable, if it exists, would be exported to the environment.
22:06  nDuff: anon33_, you're running readlink and letting the result go to stdout, not changing the element in the array
22:06  nDuff: anon33_, ...I doubt very much that that's what you want to do. (Also, your for syntax is slightly wrong -- you're missing a semicolon)
22:06  hacim: how do you get pidof to work with a process that has a space in its name? such as '/usr/bin/python /usr/sbin/nagios-statd' ?
22:06  greycat: !pm > hacim
22:06  greybot: hacim: http://mywiki.wooledge.org/ProcessManagement
22:06  hacim: arg
22:07  hacim: greybot: that page doesn't help me if I didn't spawn the process
22:07  skered: :w
22:07  skered: and this isn't vi
22:07  greycat: If you didn't spawn it, you're fucked.  So be the one who spawns it.
22:07  greycat: And 1995 called.  They want their pidof command back.
22:08  nDuff: hacim, if you read the ProcessManagement page, you'd know about pgrep, and would have checked its manpage, and would have an answer to your question.
22:09  nDuff: (re: child processes, I've always thrown portability to the wind and read /proc in those cases)
22:09  greycat: He'd have the *wrong* answer, but apparently he wants wrong answers, so perhaps he'd be happy.  Until it breaks.
22:09  e36freak: ok, i have an array of numbers, and i want the number of occurences for each unique number in the array. if foo=( 2 3 3 5 6 ); id like to know that 3 appears twice and the rest once. what is the best way to go about this?
22:09  nDuff: e36freak, uniq -c will handle that
22:09  e36freak: k
22:09  greycat: e36freak: dump the array | sort | uniq -c
22:09  hacim: nDuff: aha, i didn't notice pgrep can operate on PPID... how would you grab that from /proc?
22:09  nDuff: e36freak, or you can use an array to store the count and do it yourself
22:10  hwilde: hi I have a variable in a while loop that I would like to save for the next time through the loop... any suggestions?
22:10  greycat: e36freak: in order to "do it yourself" without sorting first, you'd need an associative array.  Sorting first, you could do it by noting when the value changes.
22:10  anon33_: nDuff: my intention is to run readlink and let the result go to stdout , i'd like to see where each link leads (i'm just testing/learning at this point - your earlier function serves my needs entirely)
22:10  nDuff: hacim, see the format for /proc/PID/stat
22:10  greycat: hwilde: x=$y
22:10  e36freak: right. uniq -c is what i was looking for, thanks
22:10  hacim: what I'm trying to figure out is what is the best way to determine if I have a child process spawned by a parent... when I don't spawn the parent myself
22:11  greycat: You want to determine whether foreign process P has any children?  You could parse ps ax...
22:11  hwilde:  greycat that doesn't give an error, but next time thru the while loop that value is not $y :/
22:11  greycat: Well, no, not just ax.
22:11  nDuff: greycat, he said it's numbers, not arbitrary contents, so it doesn't necessarily need to be a bash 4 associative array by my read.
22:11  greycat: You want to determine whether foreign process P has any children?  You could parse ps -ef ...
22:12  greycat: nDuff: I suppose.
22:12  hacim: greycat: yeah, I was trying to avoid ps ax parsing
22:12  greycat: The proposal you gave IS parsing ps.
22:12  greycat: ps and pgrep and pidof all get their information from the same place.
22:12  nDuff: ...whereas reading from proc is getting the data from the same place ps does, and doing the work yourself
22:13  greycat: It's equally worthless no matter what, if you are looking at the evil CMD field.
22:13  nDuff: well, working with /proc you can work with the actual argv
22:13  greycat: You might start by observing that field 3 of "ps -ef" on Debian 5.0 is the PPID.
22:13  nDuff: delimiters and such still in place
22:14  nDuff: s/^/null/
22:14  greycat: So, "determine whether foreign process P has any children" => ps -ef | awk "\$3 == $P"
22:14  greycat: That will tell you, yes or no, whether such children exist.  You could also parse their PIDs out of it pretty safely (field 2).
22:14  hacim: is there something better than doing "if [ `ps ax |grep -c nagios-statd' ]; then true; else false; fi"
22:14  greycat: You should NOT attempt to get their names from that for any purpose other than showing a human.
22:15  greycat: hacim: Ignore what I say some more.  Go on.  I love it so much.
22:15  hwilde: you can do ps -C
22:15  hacim: i was busy typing, so I hadn't read it yet, but I am now
22:15  greycat:        -C cmdlist      Select by command name.
22:15  greycat: DO NOT DO THAT.
22:15 * nDuff gives up on hacim (who also ignored the early, early advice nDuff gave him re: avoiding the stdout+test redundancy in favor of if grep -q ...)
22:16  greycat: The CMD field of ps is a LIE.  It is worse than useless.  It is full of malice.
22:16  hwilde: how to subtract two variables and capture the result in a third variable?
22:16  nDuff: hwilde, c=$((a - b))
22:16  greycat: You cannot trust the name of a process unless you're a human being able to see the entire process list and exercise non-computer judgment about it.
22:16  greycat: !math > hwilde
22:16  greybot: hwilde: Add 7 to a variable: let a+=7; ((a+=7)); a=$((a+7)); See http://mywiki.wooledge.org/ArithmeticExpression
22:17  hwilde: does that not work with decimals or something?
22:17  greycat: !faq float > hwilde
22:17  greybot: hwilde: http://mywiki.wooledge.org/BashFAQ/022 -- How can I calculate with floating point numbers instead of just integers?
22:17  hacim: nDuff: I didn't ignore it, I was simply looking at grep -c as an alternative
22:17  greycat: grep -c counts lines in a data stream that match a regular expression or string.  What the hell does that have to do with process management?
22:17  nDuff: hacim, huh? grep -c was given as an answer to an entirely different question.
22:18  nDuff: (asked by a different person)
22:18  hwilde: sorry that faq just says it's not possible?
22:18  hwilde: how do I subtract like  2.5 - 3.27
22:18  nDuff: hwilde, and suggests tools to use instead
22:19  greycat: It's not possible *in bash*.
22:19  nDuff: hwilde, read the whole thing.
22:19  greycat: That's why it goes on to show non-bash alternatives.
22:20 * nDuff has met his weekly quota for despair for humanity. Yaay, IRC!
22:20  hwilde: ok and what is the proper way to do abs
22:20  greycat: hwilde: same way you would do it in ANY other programming language.
22:20  hacim: ps -ef | awk "\$3 == $P" is pretty interesting. i need to devise a test that will tell me if there are results there, since I can't rely on the $?
22:21  greycat: E.g. from C, you would know that you can do    abs=$((x<0?-x:x))
22:21  greycat: Which may or may not need some parens.  I can never remember.
22:21  hwilde: from C I would just include math.h and say abs(x)
22:21  nDuff: also can be done with string manipulation
22:21  Bushmills: # echo $((2500-3270))  # think of last three digits behind decimal point
22:21  evalbot: Bushmills: -770
22:21  nDuff: just use PE to take the - sign off the front of the variable
22:21  nDuff: !pe > hwilde
22:21  greybot: hwilde: Parameter Expansion is the expansion of a parameter: "$foo", "$1". You can use it to perform string operations: "${file%.mp3}", "${0##*/}". Remember to *always* quote them. See http://mywiki.wooledge.org/BashSheet#Parameter_Operations
22:21  greycat: Fair enough.
22:22  hwilde: I have a variable x how do I get the abs(x)
22:22  greycat: I just told you.
22:22  greycat: And nDuff told you another way.
22:23  hwilde: you told me to define my own function?  and nDuff said something about PE that doesn't make sense... how does that take the negative sign off?
22:24  nDuff: hwilde, the thing I said included a wiki link.
22:24  greycat: hwilde: You are pissing me off.
22:24 * Bushmills leans back and enjoys this evening's entertainment
22:24  hwilde: this should be a really simple answer but you are making it very complicated.
22:24  nDuff: hwilde, you're trying to be handed answers on a plate. We're trying to help you learn.
22:24  greycat: # x=-42; abs=$((x<0?-x:x)); echo "HEY HWILDE YOU DENSE FUCKER, abs=$abs"
22:24  evalbot: greycat: HEY HWILDE YOU DENSE FUCKER, abs=42
22:25  nDuff: hwilde, it's a give-a-man-a-fish scenario.
22:25  hwilde: you are the creators of your own suffering :)
22:25  greycat: I even GAVE HIM A FUCKING FISH already.
22:25  greycat: hwilde: *plonk*
22:25  nDuff: !plonk > hwilde (FYI)
22:25  greybot: hwilde (FYI): The sound a name makes when it hits a kill file (or /ignore list).
22:25  greycat: No, you created my suffering by ignoring the literal ready-cooked answer I gave you AS WELL AS the how-to-do-it-another-way guide nDuff proposed.
22:26  greycat: Plus, how bloody long would it have taken him to do   if (( x < 0 )); then abs=$((-x)); else abs=$x; fi   ?
22:26  greycat: Seriously!
22:27  greycat: Even WITHOUT the spoon-feeding, he should have been able to do that!
22:27  greycat: ANY programmer should be able to do that, or I don't want to hear their questions.  Ever.
22:27  nDuff: well, they might have legitimate questions about $(( or the like if they don't know the language yet
22:28  nDuff: but not knowing how to get an absolute value without a library function is indeed... oy.
22:29  greycat: I thought everyone learned how to do    #define ABS(x)  ((x)<0?-(x):(x))   as soon as they get to the #define chapter in C.
22:29 --- xelister is now known as xelister_
22:30  greycat: Complete with explanations of why you need all those () and so on.
22:30  greycat: Nobody uses math.h for this.
22:30  nDuff: well, obviously, _somebody_ does
22:33  greycat: What the fuck is this -et thing someone put on Bashism?
22:33  nDuff: (?)
22:33  greycat: I just checked the ksh88 man page too, and it's definitely -ef there.
22:36  edgy: Hi, why: x=""; test -z x && echo this is zero-length string // isn't printing the message?
22:37  greycat: because you used the literal string x there instead of the contents of the variable named x
22:37  grop: edgy, $x
22:37  greycat: grop, "$x"
22:38  grop: yup
22:38  jeeger: Greetings! How do I access the first non-option argument after getopt has parsed the options? I tried using OPTIND, but that didn't work properly.
22:38  edgy: greycat, grop: ah! thanks a lot
22:38  greycat: !faq easily > jeeger
22:38  greybot: jeeger: http://mywiki.wooledge.org/BashFAQ/035 -- How can I handle command-line arguments (options) to my script easily?
22:43  jeeger: Hm, I want to access the first positional argument after the getopts arguments. However "DESTINATION="${@[$OPTIND]}"" gives me an invalid substitution error. It's probably some misunderstanding on my part about bash array variables...
22:44  greycat: If you want positional parameter 7, where 7 is held captive in variable x, then it's ${!x}
22:44  greycat: or ${@:x:1} if you prefer
22:44  jeeger: um
22:45  greycat: But normally you DO NOT APPROACH the problem that way.
22:45  greycat: You shift the options away as they are processed (or all at once).
22:45  greycat: Then the option you want is... $1.
22:45  jeeger: greycat: oh
22:45  jeeger: that makes even more sense
22:45  jeeger: gah
22:47  TheBonsai: y0
22:50  jeeger: One final stupid question: Why do I get "<blablabla>: File not found" on this expansion ${DESTINATION:="root@crazytom::/data/backups/dumper"}? It doesn't have anything to do with files, or does it?
22:51  nDuff: jeeger, you probably want to actually do something with that result, not execute it as a command
22:51  greycat: !exact
22:51  greybot: Please tell us EXACTLY what you typed, and EXACTLY what the error is.
22:51  nDuff: jeeger, you're literally running that expansion on its own line, I'm presuming?
22:52  greycat: If you're attempting the "assign a default value" trick, you forgot your : command.
22:52  afink: Hello everyone, I am trying to find out how I can automate moving files up one directory with bash, then delete the directory that the files were removed from.  Could someone please give me a hand.  Thanks in advance.\
22:52  edgy: what's the difference between: if [[ $a -lt $b ]] and if ((a<b))?
22:52  jeeger: greycat: Ah, that also makes sense. I thought it would expand to nothing (the empty string)
22:53  nDuff: edgy, the latter is more readable and generally preferred.
22:53  greycat: edgy: Not much.  The biggest one, I think, is that if a happens to contain some string, that string is treated as a variable name and there's a recursive resolution, in the ((...)) variant.
22:53  greycat: But passing non-numbers to a math context is generally just a bad idea.
22:53  greycat: # a=q; q=fuck; fuck=6; b=7; if ((a<b)); then echo "$((a)) is less than $((b))"; fi
22:54  evalbot: greycat: 6 is less than 7
22:54  greycat: Math context has some weird behaviors, as you can see.
22:57  edgy: greycat: I tried if [[ $a -lt $b ]] with your example and nothing changed so I couldn't understand your point
22:57  greycat: You asked how the math-context version ((...)) differed from the [[...]] version.
22:57  greycat: Now you have seen one way.
22:58  erUSUL: afink: automate? you want to make a function that does that given a dir as parameter or what?
22:58  paissad: --color option is deprecated in Bash now ?
22:58  edgy: greycat: execuse my ignorance but I can't see the difference still
22:59  edgy: greycat: even [[]] supports the recursion
22:59  greycat: Oh, ... well damn.
22:59  erUSUL: paissad: did it ever has such option?
22:59  paissad: erUSUL, ls --color=always (to have colors)
22:59  paissad: erUSUL, but now i use ls -G
22:59  greycat: paissad: ls is not bash.
22:59  erUSUL: paissad: that's ls not bash
22:59  greycat: arc3:~$ man bash | grep -- --color
22:59  greycat: arc3:~$
22:59  paissad: oh sorry, indeed
23:00  edgy: greycat: oh I think you mean the $((a)) part that I cannot do with [[....]], right?
23:00  greycat: edgy: well then I don't know.  Nobody here really uses -lt, for anything.
23:01  greycat: (Unless they're writing for sh.)
23:01  afink: erUSUL: a script should work,  I think this should do it?  http://pastebin.com/3jBp3z3Y
23:01  greycat: (In which case they cannot use [[, so you get bash: [: q: integer expression expected anyway.)
23:03  erUSUL: afink: that would do it for every dir in a given dir... also you should use Â« mv -- * ../ Â» to avoid problems with filenames beggining with - ; and you do not have any error handling. what about dot (hidden) files?
23:04  erUSUL: afink: you could also do Â« for d in */; do ....; done Â» and avoid the test and conditional
23:04  erUSUL: afink: */ expands to only dirs
23:05  erUSUL: !quotewhen
23:05  greybot: "Double quote" *EVERY* argument that contains whitespace or expansions ("$foo", "$(foo)", "`foo`"). 'Single Quotes' prevent expansions from happening at all. Also quote *, [, ], ? etc. if you don't want bash to expand them into filenames.
23:06  afink: ok thanks, I'm not worried about hidden files on this one, it is good to know though
23:08  erUSUL: afink: also what to do in case of filenames clashes?
23:08  afink: get a bunch of errors in the console ;)
23:08  greycat: I cannot find where the math-context-like behavior of [[ $a -lt $b ]] is defined in the manual.
23:09  ghoti: Is there a way in bash to put a command line you've typed into the history buffer *without* actually executing it?  I mean, other than prepending an `echo` then stripping it off later?
23:09  erUSUL: afink: well looking at gnu's mv it has a --backup option that you could put to good use
23:10  greycat: In vi mode, you can use ESC # to put it in the history with a # in front of it.
23:10  greycat: It's basically a shortcut for ESC 0 i # Enter
23:10  afink: erUSUL: I'm just organizing my music, and I have absolutely almost 0 experience in bash besides the most simple admin tasks.  Ok ill check the man for --backup.  Thank you again for you help
23:10  ghoti: If I do a really long line with pipes and an inline awk script, multiple types of quotes, etc, then I realize I should be running this inside screen, it would be handy to be able to shunt the line into .bash_history to be picked up by the shell inside screen.
--- Log closed Mon Dec 20 23:31:37 2010
--- Log opened Mon Dec 20 23:31:58 2010
23:31 --- Users 531 nicks [0 ops, 0 halfops, 0 voices, 531 normal]
23:32  Bushmills: # ((start=a=b=c=d=e=f=g=42)); echo "$start"
23:32  evalbot: Bushmills: 42
23:32  pyoor: Ah, my apologies.  I'm a bit scatter brained today.  I have a script "attempts" to remove any duplicating spaces and replace it with a single space.  It also attempts to replace all \n's with \r's and then remove any repeating \r's with a single \r.  Lines 4 and 5 of the pastebin I posted do not work.  I understand sed is not the preferred tool but I don't know how to use tr in a way that will allow me perform these operations outside of 2 delimiters
23:33 --- Channel #bash was synced in 86 seconds
23:36  ghoti: pyoor: sed isn't a bad tool at all.  And you can string your sed commands together a little better...  sed -E -e 's/  +/ /g;s/\\r(\\r)+/\\r/g' ... etc
23:36  ghoti: Note that I'm using FreeBSD, so the -E gets me extended regexps.  Spice to taste.
23:37  pyoor: hrmm.  I'm on fedora.  What version of sed are you using?
23:37  ghoti: the one that comes with FreeBSD.  You should check your sed man page to see how to adjust your regexp evaluation.  Might be something like -r.
23:37  Bushmills: # var="a               b                c"; echo $var
23:37  evalbot: Bushmills: a b c
23:37  ghoti: Been a while since I had to do this in linux.  :)
23:38  nDuff: pyoor, the BSDs are complete operating systems -- they don't need a sed from GNU, for instance, they ship with their own.
23:38  pyoor: ahh I see
23:39  Bushmills: "quotes! use fewer quotes!" :D
23:40  pyoor: using gnu sed, am I able to replace all \n's with \r?
23:40  pyoor: or as an alternative is there a way to have tr do this but outside of the 2 delimeters?
23:41  nDuff: pyoor, one approach is just to only feed tr the subset of the file you want it to handle
23:41  nDuff: pyoor, as in construct your stream first by the initial part of the file, then use sed to extract the part you care about it and feed that part through tr, then extract only the end.
23:42  nDuff: eugh
23:42 * nDuff 's grammar was atrocious there
23:42 * nDuff needs sleep
23:42  pyoor: hrmm.  I think that's beyond my ability atm.
23:42  pyoor: not really sure how I would accomplish that.  Plus since the file contains binary data I'm afraid of messing it up when I piece it back together/
23:43  ghoti: # foo="a    b       c\r\r\r"; bar="${foo/  / }"; echo $bar
23:43  evalbot: ghoti: a b c\r\r\r
23:43  ghoti: but unfortunately:
23:43  ghoti: # foo="a    b       c\r\r\r"; bar="${foo/  / }"; baz="${bar//\\r\\r/\r}"; echo $baz
23:43  evalbot: ghoti: a b c\r\r
23:44  nDuff: pyoor, there's nothing hard about it. Use three separate commands.
23:45  nDuff: pyoor, you can write a command which will extract only the first part of the file, right?
23:45  nDuff: pyoor, ...and you can write a command to extract the middle, right?
23:45  ghoti: pyoor: what kind of file is it that you're trying to modify?
23:45  pyoor: pdf
23:45  ghoti: oh, then you may have some excitement.
23:45  nDuff: pyoor, so: get_file() { get_first_part; get_second_part|tr; get_third_part; }
23:45  pyoor: pdf is really loose on their interpretations of whitespace so this script is intended to normalize the whitespace
23:46  pyoor: since \r\r\r\r\r is the same as \r in pdf
23:46  pyoor: the first sed line in my script works perfectly:  sed -i -e '/stream/,/endstream/b' -e 's/  //g' "$1"
23:47  pyoor: I was hoping I might be able to use a similar line to replace \n with \r and \r\r with \r.
23:47  hepheastus: "Mr. Assange," she giggled, look down at yourself."  I again did as I was commanded.  My nuts were absolutely bloated.  My scrotum hung down about 4" below my crotch, and my balls themselves must have been three inches across _each_.  Above my exaggerated testicles hung a twitching erection that was now at least nine inches long.  What _had_ this woman done to me?  Aside from the feeling of nearly-numbing cold, there was also the impression that I had a
23:47  hepheastus: reminder that my will was not my own.  I'd do anything I was told.  "We go now.", she said, and opened the door to her office.  I followed behind her like a duckling behind it's mother as she crossed the hall to the other door.  I could still smell the scent of her sex as I waddled along into the other room, my grotesquely swollen balls flopping against my thighs.  The room we entered looked like a combination Buddhist temple and torture chamber.  The c
23:48  hepheastus: as if she lacked the strength to even make an attempt at escape.  I thought of Madame Twon's suppository, and glanced down at my still-growing genitalia.  My erection was at least 10 inches long now.  Also standing by the table was a man with a collar around his neck.  A leash was attached to the collar, and one of the women was holding the leash.  At either side of the bound girl's head was a large brazier belching blue smoke, which filled the room wit
23:48  krzee: # echo "someone ban that guy!"
23:48  evalbot: krzee: someone ban that guy!
23:48  TheMusicGuy: Alright...I'm having the hardest time trying to copy my home dir's . hidden files (and ONLY the hidden files) over to my new machine. When I try rsync, it copies _everything_, and when I try tar, it copies stuff that's not even in my homedir.
23:49  TheMusicGuy: My command:
23:49  TheMusicGuy: rsync -vaz \.* sigmund:/home/brad/oldhome/
23:49  The-Compiler: TheMusicGuy: .* includes .. and . :p
23:49  TheMusicGuy: Yes, I'm trying to get a literal . and not a bash .
23:49  TheMusicGuy: (for hidden files only)
23:49  The-Compiler: try .[^.]* (that's a bash glob though)
23:50  nDuff: or use GLOBIGNORE
23:50  nDuff: TheMusicGuy, eh? . is a literal .
23:50  nDuff: TheMusicGuy, it's not a bash thing, it's an OS thing
23:50  nDuff: TheMusicGuy, '.' is literally a directory entry in UNIX.
23:50  TheMusicGuy: I thought that the \ would escape it.
23:50  nDuff: TheMusicGuy, there's nothing to escape. IT REALLY IS LITERAL.
23:50  TheMusicGuy: Then what do I do?
23:51  nDuff: use GLOBIGNORE to tell your shell to leave it out when expanding
23:51  nDuff: or do what The-Compiler suggested
23:51  TheMusicGuy: I'm not familiar with GLOBIGNORE
23:51  nDuff: it's covered in the bash man page
23:52  The-Compiler: TheMusicGuy: .* is a bash glob, in which . is literal, and * is for "any count of any characters", so .* means "everything which begins with a dot"
23:52  nDuff: ...and . is in fact a genuine directory entry, which begins with a dot, hence it's an available expansion.
23:52  The-Compiler: TheMusicGuy: .[^.]* means "everything which starts with a dot, which is followed by anything but a dot, followed by any count of any character
23:52  TheMusicGuy: nDuff, I see.
23:53  TheMusicGuy: I didn't think of that.
23:53  The-Compiler: and yeah, .* unfortunately includes ..
23:53 --- michaelr_ is now known as michaelr
23:53 --- dojo_ is now known as dojo
--- Log closed Tue Dec 21 00:00:37 2010
