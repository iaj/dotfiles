--- Log opened Sun Jan 16 00:00:51 2011
00:03  gionnico: pr3d4t0r: uhm my start condition works, the end condition doesn't 
00:03  gionnico: and using awk instead of grep print $2 is all empty and $1 contains everything (except starting spaces)
00:04  cthuluh: did you set FS?
00:05  gionnico: FS?
00:05  cthuluh: using -F, for example
00:05  gionnico: ah no^^
00:05  cthuluh: Field Separator
00:06  gionnico: ah cool now i have an only oneliner
--- Log closed Sun Jan 16 00:10:19 2011
--- Log opened Sun Jan 16 00:10:40 2011
00:10 --- Users 85 nicks [0 ops, 0 halfops, 0 voices, 85 normal]
00:12 --- Channel #awk was synced in 116 seconds
00:14  gionnico: { print NOME=$2 }
00:14  gionnico: does it work to save $2 to bash variable called NOME ?
00:15  gionnico: or how should i do that?
00:26  waldner: NOME=$(awk '{print $2}')
00:26  waldner: but most certainly there's another/better way
01:01  pr3d4t0r: Heh - he left.
01:01  pr3d4t0r: waldner: I think those NOME variables would end up being some kind of list.
--- Log closed Sun Jan 16 02:10:38 2011
--- Log opened Sun Jan 16 02:11:03 2011
02:11 --- Users 85 nicks [0 ops, 0 halfops, 0 voices, 85 normal]
02:12 --- Channel #awk was synced in 110 seconds
--- Log closed Sun Jan 16 12:29:55 2011
--- Log opened Sun Jan 16 12:30:17 2011
12:30 --- Users 80 nicks [0 ops, 0 halfops, 0 voices, 80 normal]
12:31 --- Channel #awk was synced in 110 seconds
12:51 --- ramok_ is now known as ramok
--- Log closed Sun Jan 16 14:52:29 2011
--- Log opened Sun Jan 16 14:52:50 2011
14:52 --- Users 82 nicks [0 ops, 0 halfops, 0 voices, 82 normal]
14:54 --- Channel #awk was synced in 110 seconds
17:17 --- Varazir_ is now known as Varazir
--- Log closed Sun Jan 16 18:52:39 2011
--- Log opened Sun Jan 16 18:53:03 2011
18:53 --- Users 81 nicks [0 ops, 0 halfops, 0 voices, 81 normal]
18:53 --- Server: [card.freenode.net] [freenode-info] channel trolls and no channel staff around to help? please check with freenode support: http://freenode.net/faq.shtml#gettinghelp
18:54 --- Channel #awk was synced in 110 seconds
20:55  skskks: what the best way to passing awk variable to bash ?
--- Log closed Sun Jan 16 20:59:03 2011
--- Log opened Sun Jan 16 21:12:14 2011
21:12 --- Users 83 nicks [0 ops, 0 halfops, 0 voices, 83 normal]
21:12  pr3d4t0r: skskks: Please use http://eugeneciurana.com/pastebin or any other pastebin instead of posting this on-line :)
21:12  skskks: ok sorry
21:12  pr3d4t0r: skskks: And you don't need sed :)
21:12  waldner: you could eval that, but that opens a big can of worms
21:12  waldner: I'm sure there's a way to do it all in aw, or to approach it differently
21:12  waldner: *awk
21:12  skskks: i want juste the best way
21:12  skskks: just
21:12  waldner: "the best" means nothing
21:12  waldner: it depends on what you need it for
21:12  pr3d4t0r: skskks: Your query string - it's all parsable in awk.  Are you parsing a GET or a POST?
21:13  skskks: pr3d4t0r, yes
21:13  skskks: a GET 
21:13  skskks: QUERY_STRING=a=1&b=1&c=1
21:13  skskks: i need to get variables
21:15  pr3d4t0r: skskks: awk -F '&' '/QUERY_STRING/ { gsub("QUERY_STRING=", ""); for (f = 1; f <= NF; f++) print($f); }'
21:16  pr3d4t0r: skskks: That's one way.
21:16  pr3d4t0r: skskks: A lazy way to get rid of the QUERY_STRING bit.
21:16 --- Channel #awk was synced in 431 seconds
21:17  pr3d4t0r: skskks: Throw that in $(awk command here) and you can catch the three variables in a bash variable, like waldner indicated earlier.
21:17  pr3d4t0r: skskks: Another way would be to use a pointer to the first actual variable.
21:18  pr3d4t0r: skskks: Another would be to use a regular expression and the match() function.  Since this looks like a one-time thing, and efficiency isn't the top priority, I did the lazy thing :)
21:18 * pr3d4t0r gets back to work.
21:19  skskks: pr3d4t0r, thks
21:19  pr3d4t0r: skskks: Cheers.
21:19  pr3d4t0r: skskks: I'm also with waldner in that whatever you're doing may be better to complete in full awk or full bash.  There may not be a need to mix-n-match like this.
21:20  pr3d4t0r: skskks: But solve this problem first and we can discuss for later :)  It all depends on how long-lasting a solution wyou want.  If this is a one-off, just get it out of the way; if this is something that will eventually become production and need maintenance, then it's better to pick one or the other.
21:21  skskks: yes but is it possible do all with awk?
21:21  skskks: i want the best solution, not lazy way
21:21  skskks: more eficient
21:26  pr3d4t0r: skskks: Sure.
21:26 --- y3llow_ is now known as y3llow
21:26  pr3d4t0r: skskks: You can call anything in your PATH from awk.  It's a bit more involved than in shell scripting, but easy to do.
21:26  pr3d4t0r: skskks: If you have to pass data back and forth between awk and shell the tradeoff is this:
21:26  skskks: pr3d4t0r, but i need to save to sqlite3 the result
21:27  skskks: not just in a file
21:28  pr3d4t0r: skskks: Do it all in awk and then you have to do 1 - 3 lines per external command (e.g. a call to /usr/bin/ls may become system("ls"); or "ls" | getline v ; close("ls"); or something).
21:28 --- cuba33ci_ is now known as cuba33ci
21:29  skskks: "ls" | getline v ; close("ls");
21:29  skskks: but this way is a clean way?
21:29  skskks: is faster like "ls" in bash?
21:30  pr3d4t0r: skskks: Do it all in shell, then you have to figure out how to get the results out and combine them with your shell script.
21:31  skskks: eheh
21:31  pr3d4t0r: skskks: Well, if you have a lot of non-trivial awk processing, and it has to go back and forth between bash and awk, that's a sign that you may want to do the whole thing in awk.
21:31  pr3d4t0r: skskks: For example:  I have an IDS written 100% in awk.
21:32  pr3d4t0r: skskks: Version 1.0 was bash + awk (it looks at logs and other stuff to determine if the server is under attack).
21:32  skskks: nice :)
21:33  pr3d4t0r: skskks: When exchanging data between bash and awk became too much of a pain in the arse, we just moved the calls to iptables/ipfw/etc. into the awk script.
21:33  skskks: awk haver the option "-v" for import variables from bash
21:33  pr3d4t0r: skskks: That's how the IDS became awk-only :)
21:34  pr3d4t0r: skskks: Right.
21:34  pr3d4t0r: skskks: But that's dirty and makes the script harder to read.
21:34  skskks: for export have nothing right?
21:34  pr3d4t0r: skskks: For export you just print, and catch the output in a variable.
21:34  pr3d4t0r: skskks: x=$(awk 'your script here')
21:35  pr3d4t0r: skskks: The problem occurs if you need to process more than one datum, or you need multiple awk scripts for doing different things, and so on.
21:35  skskks: yes but for big script is not very good eheh
21:36  pr3d4t0r: skskks: Back to our IDS example:  the original version used a separate awk script for checking each type of attack (e.g. ssh login, HTTP, invalid port knocking, and so on).
21:36  pr3d4t0r: skskks: All the non-trivial logic was in awk, and capturing what we needed in bash became a pain; we had to maintain six or seven things, with a new awk script and a change to bash every time we added a feature.
21:37  pr3d4t0r: skskks: By shifting to awk we ended up with a much smaller program, and a *single* file to maintain.
21:37  pr3d4t0r: skskks: So one file == handles 20 attacks in awk.
21:37  skskks: smaller and faster is better :)
21:38  pr3d4t0r: skskks: In bash == 21 file; 1 bash orchestrator, and 20 awk scripts for each attack case.
21:39  pr3d4t0r: skskks: Instead of bullshitting about it, just go to code.google.com/logcop and take a look, or wait a second and I'll put the script on the pastebin.  The latest version we support has many features that don't exist in the Google Code version :)
21:39  pr3d4t0r: skskks: http://eugeneciurana.com/pastebin/pastebin.php?show=43731
21:41  pr3d4t0r: skskks: As you can see here, adding a new filter is just adding processing for a new case condition.  This is also cross-portable to OS X, Linux, and Solaris.
21:41  skskks: this script use lot of times system(
21:41  pr3d4t0r: skskks: Sure.  That's the tradeoff.
21:41  skskks: this way turn not the script slow?
21:42  pr3d4t0r: skskks: Not really.  Attack my server and you'll see how fafast it bans your arse ;)
21:42  pr3d4t0r: Er, fast.
21:42  skskks: eheh
21:42  pr3d4t0r: skskks: Notice that it also does a lot of non-trivial things, like keeping white, black, and grey lists, IP manipulation, and so on.
21:43  pr3d4t0r: skskks: It writes its output to the syslog, so you can pick this up with standard monitoring software like Hyperic or Splunk.
21:44  pr3d4t0r: skskks: Since we'd have to go back and forth between awk and bash if bash were the shell, the script would be harder to maintain.
21:45  pr3d4t0r: skskks: The prices of using system() or "command"; close("command"); is a small price to pay in exchange of having easier to read logic, and easier maintenance.
21:45  pr3d4t0r: Heh - in fact, I just found a bug.
21:46  skskks: awk is good
21:46  pr3d4t0r: Line 81 - it needs close("whoami");
21:47  skskks: lot of people say than perl is better because use all in one
21:47  skskks: is true?
21:48  skskks: awk is faster or slower?
21:48  pr3d4t0r: skskks: I'd probablbly use Perl for something more complex, if I knew Perl :)
21:48  pr3d4t0r: skskks: I have no idea.  Perl probably wins the speed competition.
21:49  pr3d4t0r: skskks: But then if I want speed I will probably  use Java or C, depending on the situation, not Perl or awk, and only if we're talking about text data.
21:49  pr3d4t0r: Er, about non-text data.
21:49  skskks: yes but c is more dificult for analise like awk
21:49  pr3d4t0r: skskks: For text manipulation, awk and Perl are so close to Java that the trade off is speed of implementation (way faster in awk, Perl) vs. speed in execution (roughly 5% faster in Java).
21:50  pr3d4t0r: skskks: Exactly.
21:50  pr3d4t0r: skskks: If I'm processing massive amounts of data, though, and my business depends on it, the cost of developing this in Java or C offsets the awk/Perl speed of implementation.  I want that in Java or C :)
21:51 * pr3d4t0r is working with that exact use case these days :)
21:51  skskks: yes sure
21:51  pr3d4t0r: Anyway, gotta go.
21:51  pr3d4t0r: skskks: Good luck - may The Source be with you.
21:51  skskks: ok thks for help
21:51  pr3d4t0r: skskks: Any time.
23:05  variable: http://pastebin.com/WppqpWrF I'm obviously doing something wrong - question is what? I'm trying to see how many times $6 comes up :-}
23:05  variable: (for each time of string $6
23:05  variable: wait - that's the wrong version
23:05  variable: meh
23:06  variable: and I figured out my bug - twas a typo
23:06 * variable smacks self
23:07  vkues: fuck, why didn't he tell me how that works correctly :/
23:12  cthuluh: "print $c"; the array is called count
23:16  waldner: I hardly doubt that just fixing a typo in that code made it work
23:16  waldner: -1s/hardly/strongly/
23:16  waldner: ah, you said it was wrong
23:17 * waldner should enable join/leave message to avoid ESELFTALK
--- Log closed Mon Jan 17 00:00:47 2011
