--- Log opened Sun Dec 12 00:00:40 2010
07:16  Boss: This is my AWK Script : http://pastebin.com/K0iyrRSS .  It show errot like : awk: ./ts.awk:31: NR==FNR{arr1[$1];next} {if (!($4 in arr1) && !(substr($7,index($7,"@")+1) in arr2)) awk: ./ts.awk:31:        ^ syntax error. Any help?
07:17  Boss: I executing the script like this in command line :   ./ts.awk  notclient.conf VMList_User.txt 
07:18  Boss: ts.wk is script and  notclient.conf VMList_User.txt are input files
07:19  Boss: at line  10 :  $1 !~ /^DomainRouters/ {  } without this 
07:19  Boss: the script works fine
07:20  Riviera: is there a !~ operator?
07:20  Riviera: ah, yes, there is, sorry.
07:21  Boss: I want to execute the main block if the record does not starts with  string "DomainRouters"
07:22  cthuluh: indeed that line (10) looks weird
07:22  cthuluh: the main process is only the whole gsub part?
07:23  Boss: no the entire code
07:23  cthuluh: well
07:23  cthuluh: where you see only { code }
07:23  cthuluh: just strip the curly braces
07:23  cthuluh: where you see condition { code }
07:24  cthuluh: do if (condition) { code }
07:24  cthuluh: or
07:24  cthuluh: hmmm
07:24  Boss: I don't understand what your saying
07:24  cthuluh: oh
07:24  cthuluh: that's not a problem :P
07:25  cthuluh: there's probably a better way
07:25  cthuluh: $1 ~ /DomainRouters/ { next; }
07:26  cthuluh: is that ok?
07:26  Boss: wait I will check
07:27  Boss: you mean : $1 ~ /DomainRouters/ { next;  entire code}  right?
07:27  cthuluh: nope
07:27  cthuluh: $1 ~ /DomainRouters/ { next; }
07:27  cthuluh: { code }
07:28  cthuluh: { other code }
07:28  cthuluh: the next statement will discard the line
07:28  cthuluh: and thus not apply the rest of the script
07:29  cthuluh: 4# echo -e 'a\nb\c' | awk '$1 ~ /b/ { next; } { print NR,$1 }'
07:29  shbot: cthuluh: 1 a
07:30  Boss: cthuluh : thanks
07:30  cthuluh: 4# echo -e 'a\nb\nc' | awk '$1 ~ /b/ { next; } { print NR,$1 }'
07:30  shbot: cthuluh: 1 a
07:30  shbot: cthuluh: 3 c
07:30  cthuluh: rather :)
07:30  cthuluh: yw
07:31  probonono: Boss, your code structure (something like):  BEGIN {code}  /DomainRouters/ { code "pattern" {code}}   is not valid awk structure, needs to be  "pattern" {code}  "pattern" {code}
07:34  Boss: probonono : record does not start with  DomainRouters . Then I have to process the code 
07:34  probonono: or in the case of "pattern" { code "pattern" {code}}  replacing it with  "pattern" {code if("pattern"){code}}  as per cthuluh's suggestion.
07:34  probonono: Well, I think cthuluh gave you a working structure, but this is why your code generates the error.
07:36  Boss: probonono: could you please point some good awk code url?
07:36  Boss: I not well in awk structure 
07:36 * cthuluh laughs
07:37  cthuluh: Boss: open your eyes ;)
07:37  cthuluh: see the /topic
07:38  probonono: Boss, it's really quite simple, you just need to spend a little time studying and experimenting with examples etc. Any tutorial will give you the basics.
07:39  Boss: ok...
08:24 --- stockhol1 is now known as stockholm
08:30  kingsley: At least for me, the "paste" command starts requiring virtual memory, and slowing, when one of the files being joined is about a third of the size of my RAM. 
08:30  kingsley: Is there a more memory efficient way paste two files together?
08:30  kingsley: I'm thinking along the lines of...
08:31  kingsley: getline var1 <file1
08:31  kingsley: getline var2 <file2
08:31  kingsley: print var1,var2
08:32  kingsley: My limited understanding is that file pointers would automatically be maintained for both inputs, and the output, thus replacing RAM with disk.
08:32  kingsley: However, I find myself wondering how awk would know when to stop.
08:33  pgas: getline returns a negative number
08:33  pgas: hmm, or 0 at eof, ie check if getline  >0
08:33  kingsley: pgas: Does getline return a negative number when its pointer is pointing past the end of the file?
08:34  kingsley: s/negative number/negative number (or possibly zero)/
08:36  kingsley: I answered my own question.
08:36  kingsley: awk's man page says "The getline command returns 0 on end of file and -1 on an error.".
08:36  pgas: yeah, that's what I said too ;)
08:38  kingsley: Maybe something like ...
08:40 --- maxim is now known as Guest3968
08:41  kingsley: awk 'BEGIN{while (getline LHS_line <LHS_file) while (getline RHS_line <RHS_file) print LHS_line,RHS_line }'
08:41  kingsley: or
08:41  kingsley: awk 'BEGIN{while (getline LHS_line <LHS_file && getline RHS_line <RHS_file) print LHS_line,RHS_line }'
08:42  pgas: I'd check the return status of getline
08:43  kingsley: How about ...
08:43  kingsley: awk 'BEGIN{while (0 < getline LHS_line <LHS_file && 0 < getline RHS_line <RHS_file) print LHS_line,RHS_line }'
08:44  pgas: what if on of the file has more lines than the other?
08:45  kingsley: pgas, you ask a very reasonable question.
08:46  kingsley: In that circumstance, data would be lost.
08:46  kingsley: But,
08:46  kingsley: I'm checking upstream.
08:49  pgas: If it's more efficient than paste then i'd say paste is buggy. I don't see why paste would use a lot of memory except in case of very long lines
08:51  kingsley: You're perceptive.
08:51  kingsley: As you suspected, the file does have long lines. 
08:52  kingsley: They can be over 1 MB long.
09:02  g0pher: does No One here have experience re the Chrome OS ?
09:13  kingsley: pgas: In the interest of full disclosure, I just benchmarked paste by itself with the big file, and it performed well. 
09:13  kingsley: pgas: I'll check it out.
09:18  kingsley: pgas: FYI: I just looked in #bash and saw your question: "are you sure it's the paste command?".
09:21  g0pher: You all Have No Concept What the Internet is About
09:45  kingsley: pgas: FYI: I think I found my mistake. A script was occasionally feeding more data to the "paste" command than I thought.
14:49  waldner: http://groups.google.com/group/comp.lang.awk/browse_thread/thread/a4e5bbd4d2cbe3a7
18:32  SunDragon: what is a good way to do nested lists in awk?  here is an example expression in pseudo-code.  [[1], 2, [[3,4], 5], [[[]]], [[[6]]], 7, 8, []]
18:32  waldner: no good way
18:33  waldner: but gawk 4 will have them
18:33  waldner: or something close
18:35  SunDragon: thanks
18:45  waldner: however there may be other ways to solve your problem with the existing features
18:46  SunDragon: i was thinking about how I would do this in awk: http://rosettacode.org/wiki/Flatten_a_list
18:47  waldner: ah well, that's difficult because there's no way to represent the initial data in awk
18:47  waldner: I thought that was coming from an actual problem
19:09 --- ltratcliff is now known as ApHeX321
--- Log closed Sun Dec 12 19:36:44 2010
--- Log opened Sun Dec 12 19:52:10 2010
19:52 --- Users 104 nicks [0 ops, 0 halfops, 0 voices, 104 normal]
19:53 --- Channel #awk was synced in 112 seconds
--- Log closed Sun Dec 12 20:18:37 2010
--- Log opened Sun Dec 12 20:23:58 2010
20:23 --- Users 105 nicks [0 ops, 0 halfops, 0 voices, 105 normal]
20:25 --- Channel #awk was synced in 115 seconds
20:26  xevious: I have a program with output similar to this: 2 0 0 0 /usr/bin/pspax
20:27  xevious: I would like to only output lines that have numbers above 0 for the first two columns.
20:27  xevious: Is awk or grep more appropriate?
20:27  waldner: awk
20:27  waldner: awk '$1>0 && $2>0'
20:28  waldner: awk '$1 && $2' even, probably
20:29  waldner: with grep, you do grep '^[^0] [^0]' maybe
20:29  waldner: but it depends how long can the numbers be
20:29  waldner: with awk you don't have to worry
20:30  xevious: Awesome! Thanks for the very detailed response.
20:30  xevious: Do you mean that grep couldn't handle if it went above a single digit?
20:31  xevious: (since it's working on a character level...)
20:35  waldner: maybe it could, but it would become quite complex
20:36  waldner: ah, but
20:36  waldner: this may work after all
20:36  waldner: grep -v '^0 0 '
20:37  waldner: but then so would awk '!/^0 0 /'
20:37  xevious: Well I need to eliminate lines such as "2 0" and "0 1" also, not only the ones that start with "0 0"
20:38  xevious: awk '$1 && $2' worked
20:38  waldner: strange
20:38  waldner: that shouldn't work 
20:38  waldner: (given your new requirement)
20:38  waldner: ah no, right
20:38  waldner: awk works
20:38  waldner: ah I see what you mean
20:38  waldner: well
20:39  waldner: grep -E '^(0 [0-9]+ |[0-9]+ 0 )'
20:41  xevious: -vE for my purposes, but cool. Thanks for the alternate perspective.
20:42  waldner: yes, -vE
20:42  waldner: forgot to add the -v
20:42  xevious: awk wins, though! Check it out... grep:
20:42  xevious: real    0m13.711s
20:42  xevious: user    0m5.473s
20:42  xevious: sys     0m5.687s
20:42  xevious: awk:
20:42  xevious: real    0m11.741s
20:42  xevious: user    0m3.924s
20:42  xevious: sys     0m5.699s
20:42  waldner: cool
20:42  waldner: if you run it with LC_ALL=C, both may be faster
20:43  waldner: eg LC_ALL=C grep ....
20:43  waldner: or LC_ALL=C awk ...
20:44  xevious: grep:
20:44  xevious: real    0m12.628s
20:44  xevious: user    0m3.998s
20:44  xevious: sys     0m6.231s
20:45  xevious: awk:
20:45  xevious: real    0m11.454s
20:45  xevious: user    0m3.738s
20:45  xevious: sys     0m5.572s
20:45  xevious: Bigger improvement for grep, but awk still wins.
20:53  Riviera: well.
20:53  Riviera: :)
20:53  Riviera: That looks very suspicious ;)
20:54  Riviera: (Because of the system line)
20:55  waldner: that's the time spent for read()/write(), I guess
20:55  Riviera: yes
20:55  xevious: What's suspicious about it?
20:56  xevious: If you're curious, I'm scanning my system's binaries for stat() and stat64() usage.
20:58  Riviera: Yes, I am curious, but not rather about what you are doing but why you are doing it :)
20:58  xevious: I didn't know about the inode64 mount option with XFS.
20:59  xevious: But I did some research and found that some programs can have issues with it.
21:00  Riviera: And you can reproduce these errors with stat() / stat64()?
21:04  xevious: Well the thread I was reading (lost the link, sorry) pointed to this script that scans your binaries for 32/64bit stat usage: http://sandeen.net/misc/summarise_stat.pl
21:04  xevious: I came in here to ask that question about parsing this script's output...
21:04  xevious: I'm still at the early stage of research...
21:04  xevious: (btw, I set debug=1 in the script)
21:05  Riviera: interesting, thanks :)
21:08  xevious: I have several PXE booting systems, and my roommate PXE boots a 62 core render farm, so having functional NFS is very important.
--- Log closed Sun Dec 12 21:18:55 2010
--- Log opened Sun Dec 12 21:24:18 2010
21:24 --- Users 104 nicks [0 ops, 0 halfops, 0 voices, 104 normal]
21:25 --- Channel #awk was synced in 109 seconds
22:04  Chunky_Ks: Heya all. I'm creating a CSV file by dumping it directly from sqlite3 on the command line. For gnuplot to render something the way I want, I need to put a blank line in the file whenever the values in a specific column change
22:04  waldner: sample line?
22:04  Chunky_Ks: http://pastey.net/143840
22:04  Chunky_Ks: sorry, was typing it up
22:05  Chunky_Ks: I'm sure awk's the right tool for the job but I don't get how
22:05  waldner: awk '$1!=p { if(p"") print"";p=$1}END{if(p"")print""}'
22:05  waldner: ah
22:06  waldner: awk '$1!=p { if(p"") print"";p=$1}1; END{if(p"")print""}'
22:06  Chunky_Ks: awk folk are awesome. Thank-you.
22:06  waldner: wait, it may be utterly wrong.
22:07  waldner: yes, remove the END block
22:07  Chunky_Ks: k, I need to catch up one sec
22:07  Chunky_Ks: I only started writing the rest of the script just now 
22:07  Chunky_Ks: [I *was* doing this with C, but that sucks]
22:08  waldner: awk '$1!=p { if(p"") print"";p=$1}1'
22:11  Chunky_Ks: hrm
22:11  Chunky_Ks: that's putting a blank line after every line
22:11  waldner: works for me with your sample
22:12  Chunky_Ks: oh, I see
22:12  Chunky_Ks: one sec
22:14  Chunky_Ks: ok, it's working except the first tiem through. http://pastey.net/143841
22:14  Chunky_Ks: that's an actual extract
22:14  Chunky_Ks: it does it right between 1 and 2, 2 and 3, 3 and 4
22:15  Chunky_Ks: but between zero and one it doesn't insert a line
22:15  waldner: yes
22:15  Chunky_Ks: I could just prefix with 'p="cookies"' or some other silly value
22:15  waldner: awk 'p"" && $1!=p"" {$0=RS $0}{p=$1}1'
22:16  Chunky_Ks: aha
22:16  Chunky_Ks: perfect
22:16  Chunky_Ks: thank-you
22:16  waldner: np
--- Log closed Sun Dec 12 23:19:05 2010
--- Log opened Sun Dec 12 23:24:28 2010
23:24 --- Users 104 nicks [0 ops, 0 halfops, 0 voices, 104 normal]
23:26 --- Channel #awk was synced in 109 seconds
--- Log closed Mon Dec 13 00:45:14 2010
