--- Log opened Fri Dec 24 00:02:50 2010
00:02 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
00:04 --- Channel #awk was synced in 112 seconds
--- Log closed Fri Dec 24 00:57:37 2010
--- Log opened Fri Dec 24 01:02:59 2010
01:02 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
01:04 --- Channel #awk was synced in 127 seconds
01:28  Claytonarvixe: Alright, in the tutorials y'all have i'm not finding what i'm trying to do.
01:28  Claytonarvixe: I have a text file with login:whatever on one line and email:whatever@whatever.com on another
01:28  Claytonarvixe: I just need to get the information after the : when running cat file | awk print ($2) or something of the sort.
01:44  steve___: awk -F: '{print $2}' file
01:44  steve___: Claytonarvixe: 
01:44  Claytonarvixe: yes, i got it finally steve.
01:44  Claytonarvixe: Now I just have to figure out how to get the data that I have to point onto one line
01:45  Claytonarvixe: And remove empty lines
01:45  steve___: use printf
01:45  Claytonarvixe: what do you mean by printf?
01:46  steve___: 4# echo -e "ooga:foo\nbooga:bar" | awk -F: '{printf "%s ",$2}'
01:46  shbot: steve___: foo bar 
01:55  Claytonarvixe: stepnem, was that for me or shbot?
01:56  steve___: Claytonarvixe: for you
01:56  g0pher: think u want - BEGIN{FS=":"}  {s=$2; next; print s " " $2}
01:56  Claytonarvixe: Ok, now its all on the same line
01:56  Claytonarvixe: Just have to figure out how to get a line break after the information I need.
01:57  g0pher: use "\n"
01:57  steve___: Claytonarvixe: at the end of the line?
01:57  Claytonarvixe: yea
01:57  Claytonarvixe: doing that now.
01:57  steve___: 4# echo -e "ooga:foo\nbooga:bar" | awk -F: '{printf "%s ",$2}; END {print ""}'
01:57  shbot: steve___: foo bar 
02:17  Claytonarvixe: Where do I put the "\n" I added it in the {printf "%s ",$2, "\n"} but it didn't work
02:20  steve___: Claytonarvixe: did you see what i wrote?
02:20  Claytonarvixe: awk < test3 -F: '{printf "%s ",$2, "\n"}; END {print ""}' that?
02:21  steve___: awk -F: '{printf "%s ",$2}; END {print ""}' file
02:23  Claytonarvixe: still all on the same line
02:23  Claytonarvixe: Not line breaks
02:24  steve___: Claytonarvixe: you want 'whatever whatever@whatever.com\n', right?
02:25  Claytonarvixe: yes
02:26  steve___: 4# echo -e "login:whatever\nemail:whatever@whatever.com" > file ; awk -F: '{printf "%s ",$2}; END {print ""}' file
02:26  shbot: steve___: whatever whatever@whatever.com 
02:27  steve___: Claytonarvixe: that should work
02:27  Claytonarvixe: it puts them all on the same line
02:28  Claytonarvixe: I need a line break after each name email
02:31  pr3d4t0r: Hola.
02:31  Claytonarvixe: steve___, i'm assuming that possible with a \n somewhere
02:31  Claytonarvixe: linus_rome@msn.com^M diablo55^M  David_Duschl@msn.com^M Cooldave98765^M  David_Duschl@msn.com^M Cooldave1^M  linus_rome@msn.com^M diablo55^M  david_duschl@msn.com^M Cooldave98765^M  David_Duschl@msn.com^M Cooldave1^M  boenke@msn.com^M (null)^M  zsuika@msn.com^M napraforgo^M 
02:31  Claytonarvixe: Thats what is shows now all on the same line
02:32 --- cuba33ci_ is now known as cuba33ci
02:33  Claytonarvixe: steve___, i'm totally missing something
--- Log closed Fri Dec 24 02:58:07 2010
--- Log opened Fri Dec 24 03:03:27 2010
03:03 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
03:05 --- Channel #awk was synced in 107 seconds
03:09  geirha: awk -F: '$1=="login" {login=$2; next} $1=="email" {print login, $2}'
03:10  geirha: Why does it have carriage returns?
03:13  g0pher: print is same as printf("%s\n", s) - so use printf("%s", s) if u want no CR
03:17  geirha: No, that won't remove the CRs (\r)
03:27  g0pher: <geirha> what system are you on ? iirc printf("%s", s)  prints the string with no terminator on every system ??
03:28  pr3d4t0r: geirha: If you have \r in there your source probably came from a DOS/Windows machine or a very old Apple system.
03:28  pr3d4t0r: geirha: Just run this before processing:  gsub("\r", ""); - this will remove all \r from the current line.
03:29  pr3d4t0r: geirha: If you're running this on UNIX, then you could have multiple \r on a line and still see it as a single record.  If the file is old Apple, with only \r and no \n, then you could also do gsub("\r", "\n"); instead, and convert them all to line feeds.
03:30  pr3d4t0r: g0pher: If you call me Eugene again here I'll /kickban you ;)
03:34  g0pher: pr3d4t0r: Aplogy - just was trying to be personnel - my bad
03:35  pr3d4t0r: g0pher: :*
03:38  pr3d4t0r: g0pher: You're welcome to call me whatever you want in real life.  On-line, though, stick to the /nick, mon :)
03:40  g0pher: ok 
03:40  steve___: Claytonarvixe: awk -F: 'ORS=NR%2?" ":"\n" {print $2}' file
03:53 --- luptenschteiner is now known as probonono
04:03  geirha: pr3d4t0r: I know. I was asking Claytonarvixe why his data had carriage returns.
04:10  pr3d4t0r: geirha: Ah.
04:10  pr3d4t0r: geirha: :)
05:00 --- prince_j1mmys is now known as prince_jammys
--- Log closed Fri Dec 24 06:56:54 2010
--- Log opened Fri Dec 24 07:02:36 2010
07:02 --- Users 91 nicks [0 ops, 0 halfops, 0 voices, 91 normal]
07:04 --- Channel #awk was synced in 98 seconds
07:11 --- yitz__ is now known as yitz_
09:07  SiegeX: 4# echo "2547123456789,5391074043372870,639027123456789" | awk -F, '{len=split($2,a,"[0-9]"); print len,a[0],a[1],a[2]}'
09:07  shbot: SiegeX: 17   
09:07  SiegeX: why doesn't that print '17 5 3 9' ?
09:08  SiegeX: split says it split the 2nd field into 17 fields into array 'a'
09:08  SiegeX: so shouldn't a[0] - a[16] contain one number of $2?
09:08  SiegeX: oh wait, [0-9] is the field separator, so it just split it into 17 fields of nothing
09:09  SiegeX: so how do I get access to each character of a field
09:09  SiegeX: ah ha! make the regex the nul string ""
09:10  SiegeX: 4# echo "2547123456789,5391074043372870,639027123456789" | awk -F, '{len=split($2,a,""); print len,a[0],a[1],a[2]}'
09:10  shbot: SiegeX: 16  5 3
09:10  SiegeX: thanks SiegeX!
09:10  SiegeX: you're welcome SiegeX!
09:50  SiegeX: does awk have a way to print an entire array without iterating over it like bash's ${array[@]} ?
10:53  geirha: SiegeX: I don't think so.
10:53  geirha: With bash you can do printf '%s\n' "${array[@]}" btw
--- Log closed Fri Dec 24 10:57:59 2010
--- Log opened Fri Dec 24 11:03:33 2010
11:03 --- Users 86 nicks [0 ops, 0 halfops, 0 voices, 86 normal]
11:04 --- Channel #awk was synced in 95 seconds
11:13  pgas: for (i in a) print a[i] # is probaby short enough ;)
12:36  waldner: http://groups.google.com/group/comp.lang.awk/browse_thread/thread/06947054b62dbc62#
12:45  pgas: arrays or array hmm
--- Log closed Fri Dec 24 14:57:45 2010
--- Log opened Fri Dec 24 15:03:15 2010
15:03 --- Users 87 nicks [0 ops, 0 halfops, 0 voices, 87 normal]
15:04 --- Channel #awk was synced in 93 seconds
