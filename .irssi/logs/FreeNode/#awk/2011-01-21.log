--- Log opened Fri Jan 21 19:14:09 2011
19:14 --- Users 92 nicks [0 ops, 0 halfops, 0 voices, 92 normal]
19:14  vkues: exec awk -v "pid=$$"
19:14  vkues: maybe
19:14  taylanub: that'd be shell pid
19:14  vkues: hence the exec
19:14  taylanub: oh, exec doesn't change pid eh?
19:15  taylanub: that's interesting. thanks for the idea
19:15  vkues: exec does not fork a new process, hence the pid stays the same, what was the shell becomes awk, so the shell is ended
19:16  vkues: it might become complicated when that's not desired because subshells have the pid of the mother shell in $$
19:16 --- Channel #awk was synced in 123 seconds
19:16  waldner: better not to run that at the command prompt though
19:17  taylanub: oh right ... will have to sh -c then
19:18  meth[phone]: what is "in" reserved for ?
19:18  meth[phone]: ah yea... for (x in array)
19:19  vkues: and if (x in array)
19:19  meth[phone]: what that works too ?
19:20  cthuluh: try it
19:20  waldner: and also while (x in array), then
19:21  meth[phone]: same thing
19:21  meth[phone]: thanks
19:22  meth[phone]: what about string concatenation ? apparently nothing like str+="xxx" ? exists ?
19:22  meth[phone]: seems to be numeric operator
19:22  cthuluh: no need for an operator
19:22  cthuluh: "string" "other string"
19:22  meth[phone]: yes but to append to a variable that holds a string
19:22  meth[phone]: x="string"; x+="string";
19:23  cthuluh: += is only a shortcut, how would you do without it?
19:23  meth[phone]: omg...
19:23  meth[phone]: what is this programming 101
19:23  taylanub: x = x "foo"
19:23  meth[phone]: obviously
19:23  taylanub: += converts to number
19:24  meth[phone]: yep... i just find list[$2]=list[$2] " " $1; to be combersom
19:25  waldner: there's no += operator, because there's no concatenation operator in the first place
19:25  waldner: so it'd have to be "=" but that obviously that can't work
19:26  meth[phone]: ok thanks
19:26  lunaphyte_: given a list of hostnames with an arbitrary number of dots, how can i print only the second level domain?
19:26  lunaphyte_: sample input: http://www.example.com/ us.http://www.example.com/ example.com - each should print only example.com
19:27  lunaphyte_: bah
19:27  waldner: one hostname per line?
19:27  The-Compiler: us.http:// eh
19:27  waldner: print $(NF-1)"."$NF
19:27  lunaphyte_: sample input: www.example.com us.www.example.com example.com - each should print only example.com
19:27  lunaphyte_: sorry, stupid paste retained the "formatting"  :)
19:27  waldner: otherwise loop over the fields, split on ".", and output the last two parts
19:29  The-Compiler: # echo $'www.example.com\nus.www.example.com\nexample.com' | awk -F'.' '{ print $(NF-1)"."$NF'
19:29  The-Compiler: 4# echo $'www.example.com\nus.www.example.com\nexample.com' | awk -F'.' '{ print $(NF-1)"."$NF'
19:29  shbot: The-Compiler: awk: cmd. line:1: { print $(NF-1)"."$NF
19:29  shbot: The-Compiler: awk: cmd. line:1:                      ^ unexpected newline or end of string
19:29  The-Compiler: whoops
19:29  The-Compiler: 4# echo $'www.example.com\nus.www.example.com\nexample.com' | awk -F'.' '{ print $(NF-1)"."$NF }'
19:29  shbot: The-Compiler: example.com
19:29  shbot: The-Compiler: example.com
19:29  shbot: The-Compiler: example.com
19:29  lunaphyte_: oh - yes, one hostname per line.
19:37  lunaphyte_: the example works, but cat data.log | awk -F '.' '{ print $(NF-1)"."$NF }' says awk: (FILENAME=- FNR=1) fatal: attempt to access field -1
19:37  waldner: then you have some empty lines
19:37  waldner: or lines with a single field
19:38  lunaphyte_: ah - yes, empty lines.  that was it.
19:38  waldner: no, empty
19:38  waldner: yes
19:39  lunaphyte_: thank you, that seems to work well.
19:41  waldner: np
22:31  petan: anyone has a sample script to count how many of each same lines are in file
22:31  petan: I mean if you have a file with many same lines and need to know how many of them you have like result would be name and count
22:32  petan: if I am asking on wrong place tell me
22:33  steve___: petan: sort | uniq -c
22:33  vkues: like sort | uniq -c
22:33  vkues: hehe
22:33  cthuluh: heh...
22:33  petan: I am totaly new
22:33  petan: what that would do
22:33  cthuluh: awk '{ lines[$0]++ } END { for (line in lines) print line,lines[line] }' 
22:33  petan: thanks
22:34  steve___: petan: try 'sort FILENAME | uniq -c'
22:34  petan: that is command or part of script
22:34  steve___: commands
22:34  petan: it looks like cmd to me :)
22:34  petan: ok
22:34  petan: how the output would look
22:34  steve___: try it
22:35  petan: the file has like 80mb
22:35  steve___: ... on a test file
22:35  petan: so there are thousands of those lines
22:35  cthuluh: ... | less
22:35  petan: ok
22:36  vkues: then create a small subset
22:36  vkues: like
22:36  vkues: head -n 300 80-mb-file > testfile
22:37  vkues: and try it on that
22:37  petan: actually this is test file the right has 15gb
22:37  petan: would it run also on such large file?
22:37  vkues: that depends
22:37  petan: I mean if it does not eat ram
22:37  petan: I have just around 3 gb ram here
22:37  vkues: you might into trouble with many different lines
22:38  petan: there could be hundreds of different
22:38  cthuluh: I think that sort might have more problems than awk, here
22:38  vkues: you could hash it somehow
22:38  vkues: yes, cthuluh is probably right, but some versions of sort treat situations like that in smart ways
22:38  vkues: using temporary files and such
22:39  vkues: but on such amount of data sorting is a bit of an overhead :)
22:39  petan: I tried sort it's still running but eats less cpu than before
22:39  vkues: assuming that awk uses clever internal hashing of array indices
22:40  petan: I made a sh script which was filtering it with sed it was slow but I could see how much I already parsed
22:42  vkues: you could split the huge file into smaller files to speed up things
22:42  petan: I will try sort again on smaller file, anyway I don't want to wait like month on the large one :)
22:42  petan: indeed
22:42  vkues: like all lines starting with "aa", all with "ab", all with "ac", etc.
22:42  vkues: that's some sort of hasing.
22:42  vkues: hashing
22:42  vkues: of course, that makes less sense of the first two characters are not representative for the diversity
22:43  petan: I will try
22:43  petan: in awk
22:43  petan: sort worked
22:45  petan: awk worked too much faster than sort
22:45  vkues: :)
22:45  petan: thanks
--- Log closed Sat Jan 22 00:00:47 2011
