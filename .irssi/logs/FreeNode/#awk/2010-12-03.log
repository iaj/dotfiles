--- Log opened Fri Dec 03 13:04:41 2010
--- Log closed Fri Dec 03 13:07:43 2010
--- Log opened Fri Dec 03 13:07:53 2010
13:07 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
13:10 --- Channel #awk was synced in 141 seconds
13:51  zltan: hi all
13:51  pgas: hey you
13:51  waldner: out there in the cold...
13:52  waldner: (SCNR)
13:52  zltan: i have a log file with each line contains a segment of "time[xx yy zz]", how can i write a awk string to calculate the average value of xx?
13:53  zltan: i think it would be "tail  -20000 bs.log | awk -F"[][]" '{n += $16}END{ print "t="n/NR }'", is that correct?
13:53  pgas: waldner: I wish! 20C at 8 this morning...
13:54  waldner: ah, here it's -4 or so
13:54  waldner: I wish I had 20C!
13:54  pgas: zltan: looks ok, you might want printf in the end to format the result
13:55  zltan: pgas: thanks, :)
13:55  waldner: be careful that a FS of [][] will put "xx yy zz" in the same field
13:56  waldner: though probably when coerced to a number it will evaluate to xx, but still...
13:56  zltan: waldner: so what should i do if i need xx only?
13:56  pgas: yeah, you might want to give us a real example of your line
13:57  pgas: you might just use the default FS and remove the trailing ] with sub or substr
13:58  zltan: NOTICE: 12-03 16:58:24:  bs * 1315006816 s[9a6652de91a40d41] site[b.faloo.com] ip[150.199.244.113] mt[0,1,1,0,200,200,10] pt[1,0,0,0] it[0,1] lt[0,0] ttime[6022 3 223 5732 61] time[(0,1:22,24,2|t=1,r=1,s=1|1,1,0)(1,2:3,1,1|t=4469,r=83,s=902|2,1,1)(2,3:11,1,1|t=1,r=1,s=1|1,1,1)(3,4:77,1,1|t=62,r=2,s=1|1,0,1)] num[(0,1:0,0,0,0)(1,2:7243,760,760,140)(2,3:0,0,0,0)(3,4:0,0,0,0)] module[(0,1|trigger_kt:|rank_partialmatch:|select_sitectr:)(1,2|trigger_pt: tp_time:4431
13:58  pgas: what number do you want in this line?
13:59  zltan: ttime[aa bb cc dd ee], as you can see, i need to calculate the average value of aa
13:59  pgas: so the 6022 above?
13:59  zltan: yea
14:00  pgas: I'd do something like: awk -F'ttime[[]' 'NF>1{sub(/ .*/,"",$2);n+=$2} END{ print n/NR}'
14:03  pgas: you might prefer using awk -F'ttime[[]| +' and use the correct field
14:03  zltan: pgas: ok, it gives a similar result
14:04  zltan: thanks you guys, i gonna home now :)
15:10 --- ollip is now known as oliver1804
17:53  u42p: hi, it would take me ages to find out myself, so i want to ask: how can i get a file with lines like "1 this that hello" into a form with lines being "1 this", "1 that", "1 hello". i want to import the end result into a database.
17:55  waldner: awk '{for(i=2;i<=NF;i++)print $1,$i}' file
17:56  u42p: blimey, i was really close as i looked at i see http://hibernia.jakma.org/~paul/awk-faq.html#field-row is close. 
17:56  u42p: err
17:56  u42p: blimey, i was really close as i looked at http://hibernia.jakma.org/~paul/awk-faq.html#field-row . 
17:56  u42p: thank you very much
17:57  waldner: np
18:51  steve___: waldner: besides breaking on multiple spaces, is there any reason this is suboptimal?
18:51  steve___: awk -v RS=' ' 'NR>1{print 1,$1}' <<< "1 this that hello"
18:54  u42p: it is much less readable for someone like me :)
18:54  waldner: that's fine, but as long as the input is a single line
18:55  waldner: and you probably want to save the first record, just in case it's not always "1"
18:55  waldner: so maybe awk -v RS=' ' 'NR>1{print first,$1} NR==1{first=$0}' <<< "1 this that hello"
18:56  waldner: or even print first,$0 for that matter
19:01  steve___: waldner: yes, I see what you're saying.  Thank you.
19:02  waldner: yw
19:18  waldner: the generalized version of that, if there are multiple input lines, each with 4 fields, is awk -v RS=' ' 'NR%4!=1{print first, $0}NR%4==1{first=$0}'
19:19  waldner: no, wrong
19:19  waldner: it needs RS='[ \n]' but then it's no longer standard
19:22  steve___: Yeah  can see where that solution starts to break down.  I need to get into the habit of thinking about a loop when dealing with fields.
20:00  ket: horrible hack: awk '{ gsub(".*", "", $1) ; gsub(".*", "", $2) ; print}' 
20:01  geirha: $1=""; $2=""
20:02  ket: geirha: thankyou, my example leaves spaces...
20:03  geirha: ket: So does that
20:04  geirha: {sub(/[[:blank:]]*[^[:blank:]]*[[:blank:]]*[^[:blank:]]*[[:blank:]]*/,""); print}
20:05  geirha: {for (i=3;i<NF;i++) printf "%s ",$i; print $i}
20:06  geirha: The latter will squeeze blanks though
20:07  ket: geirha: why am i have trouble testing your example??: $1=="" $2==""
20:07  geirha: awk '{$1=""; $2=""; print}'
20:08  geirha: I think some awks don't allow you to assign to $i though
20:09  ket: <.<
20:09  ket: >.>
20:10  geirha: 4# echo 'foo  bar   baz  quux' | awk '{$1=""; $2=""; print}'
--- Log closed Fri Dec 03 20:13:33 2010
--- Log opened Fri Dec 03 20:13:45 2010
20:13 --- Users 97 nicks [0 ops, 0 halfops, 0 voices, 97 normal]
20:13 --- Server: [card.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
20:14  ket: heh/lol: sea dock..
20:14  geirha: Would be hard to join the two I think
20:15  ket: would raise too many conflictions?
20:16 --- Channel #awk was synced in 146 seconds
20:17  ket: wait: that is true..
20:24  u42p: ze dog
20:44  ket: i'm late but i could've just added gsub(/^[[:space:]]/,"",$0) to the others...
20:44  ket: oops..
20:45  ket: "gsub(/^[[:space:]]*,"",$0);"
20:47  geirha: s/gsub/sub/
20:47  geirha: The remaining whitespace is still squeezed though, which may or may not be an issue
20:48  geirha: That task is actually easier to do in a POSIX shell btw.
20:48  geirha: while read -r _ _ rest; do printf '%s\n' "$rest"; done < file
21:07  malorie: how can I use a "negated" ERE as a field-separator? eg, awk -F '!~ [0-9]+' { for (i = 1; i <= NF; ++i) print $i }'
21:09  malorie: given the line "989abc34def1ghi12" this should produce "abc\ndef\nghi"
21:10  malorie: err, I mean. "989\n34\n1\n12"
21:11  waldner: [^0-9] perhaps
21:12  malorie: isn't ^ matching against beginning-of-line?
21:12  malorie: (it seems to work though)
21:13  geirha: when ^ is the first char in [Â ], it "negates" the [...]. I.e. all characters _except_ these
21:13  geirha: s/all/any/
21:14  malorie: ah. I see
21:15  geirha: And when ^ is the first char of a regex, it doesn't indeed match start of line
21:15  geirha: gah
21:15  geirha: s/doesn't/does/
21:15  malorie: seems, it throws in too many '\n's, though
21:16 --- y3llow_ is now known as y3llow
21:16  geirha: awk -F'[^0-9]+' '{$1=$1;print}'
21:16 --- cuba33ci_ is now known as cuba33ci
21:18  geirha: or awk -F'[^0-9]+' '{for (i=1;i<NF;i++) printf "%d%s",$i,OFS; print $i}'
21:19  geirha: print appends a newline at the end, printf doesn't.
21:19  malorie: what I want is, to separate the fields into lines. (one field per line, that is)
21:21  malorie: I don't understand what $1 = $1 could possibly do
21:21  geirha: Ah, and if the line starts with a non-digit, then $1 will be empty
21:21  geirha: So you get some empty lines, I see.
21:22  steve___: 4# echo 989abc34def1ghi12 | awk -v OFS='\n' -F'[^0-9]+' '{$1=$1;print}'
21:22  shbot: steve___: 989
21:22  shbot: steve___: 34
21:22  shbot: steve___: etc... ( http://pastebin.com/sSLfXYyf )
21:23  waldner: gsub(/[^0-9]+/,ORS); print
21:24  malorie: awk is kinda awesome. little wierd at first, though :)
21:25  geirha: awk -F '^[^0-9]*|[^0-9]+' '{for (i=2;i<=NF;i++)print $i}'
21:25  geirha: Hm. No, didn't work either :/
21:26  ket: o.. just saw it... it's official -- using readline is better...
21:26  geirha: waldner: It still outputs an empty line if the line starts with a digit
21:27  waldner: right
21:27  waldner: so I suppose a sub(/^\n/,"") after should do it
21:27  waldner: ok, not very elegant
21:27  waldner: and if it starts with a digit, one may assume that there is an empty leading data field
21:27  waldner: so it may not be wrong either
21:28  waldner: (if FS="x" and data is x1x2, awk sees three fields, $1 emty)
21:29  geirha: Yeah, that's what I tried with ^[^0-9]*
21:31  malorie: artificially prefixing every line with a valid field, doesn't seem very elegant either
21:32  waldner: well, you may just use [^0-9]+ as separator, and if $1 is empty, take from $2 onwards
21:33  malorie: that'd do too, yeah
21:33  waldner: ie base=$1""?1:2; for(i=base;....
21:33 * geirha hands waldner two equal signs
21:33  geirha: ;P
21:34  geirha: Or was that intentional?
21:34  waldner: it's intentional
21:34  waldner: it assigns 1 or 2 to base depending on whether $1 is empty or noy
21:34  waldner: *not
21:35  waldner: or one could also just do for (i=$1""?1:2; i<=NF; etc.
21:35  geirha: Ah, you make sure it's treated as a string
21:35  waldner: ys
21:35  waldner: keyobard is bad toady
21:35  waldner: grr
21:35  waldner: *today
21:35  geirha: That'll save me a couple of bytes for future awk scripts :)
21:36  waldner: it's just habit in fact
21:36  waldner: here it's not needed, as $1 will always be a non-digit anyway
21:36  steve___: toady, snicker
21:36  geirha: waldner: No, $1 may be a digit ...
21:36  steve___: keeps hopping around on you  :)
21:36  waldner: the $1"" is there for the case where $1 is "0"
21:37  waldner: no, because all digits were removed
21:37  waldner: ah right
21:37  geirha: waldner: No, all non-digits were removed :P
21:37  waldner: only digits remain
21:37  waldner: yep
21:37  waldner: so it's ok, $1""
21:37  malorie: thanks for all the help
21:45  malorie: so `if ($1)' yields false when $1 is either "" or "0"?
21:46  waldner: yes
21:46  malorie: "0""" is equal to "0" though. is it?
21:46  waldner: yes
21:47  waldner: but there you have an explicit string literal, so the concatenation is useless anyway
21:47  geirha: while "0" will be treated as 0 (false)
21:47  waldner: no, that will be always true
21:47  waldner: while(0) will always be false
21:48  waldner: while("0") is true
21:48  waldner: (I think, need to try)
21:48  geirha: Indeed
21:48  geirha: 4# awk 'BEGIN{i="0"; if (i) print "yes"; else print "no"}'
21:48  shbot: geirha: yes
21:48  geirha: awk is still mysterious
21:48  waldner: yes, because then awk remembers the type and gives i type string
21:48  geirha: :)
21:49  waldner: variables start out as strnum
21:49  waldner: initialized to 0 and ""
21:49  waldner: but if you do i="0" then i becomes string
21:49  waldner: and awk remembers that
21:49  geirha: Yeah, makes sense now.
21:49  waldner: for fields, it's slightly different
21:50  waldner: because there's no explicit assignment usually
21:50  waldner: but values come from the input
21:50  waldner: so awk keeps the strnum type, and tries to do the right thing when the field is used in expressions
21:50  malorie: by appending "" it's forced to use string, then?
21:50  waldner: but in an expression like if($2) it may guess wrong
21:51  waldner: yes
21:51  waldner: and if you add 0 you force numeric
21:51  malorie: yeah. makes sense now
21:51  waldner: http://www.gnu.org/manual/gawk/gawk.html#Variable-Typing
21:52  waldner: that has all the (subtle) details
21:52  malorie: so the only string that'll yield false in a boolean expression is the empty-string
21:52  waldner: yes
21:52  malorie: awesome. thanks again!
21:52  waldner: if it's explicit, or you're using a string variable
21:53  waldner: ie, you're doing if("") or if(i) and i is of type string
23:37  skered: Can you read/write awk arrays to disk?
23:37  skered: from/to
23:39  geirha: If none of the elements can contain newlines, that's easy.
23:40  geirha: If you need to use something like \0 as delimiter, it gets hard with awk. You might want to consider bash or ksh93 instead if that is the case.
23:43  skered: This isn't something that awk can do nativly though right?
23:50  waldner: there's no awk instruction to say "read array from disk", but of course if one does {array[NR]=$0} etc...
23:51  waldner: though as geirha said, if you want to do this for arbitrary data, it may become difficult (awk is designed mostly to process text)
23:51  skered: Yeah, I was trying to do this with an associative awk array. 
23:52  waldner: all arrays are associative in awk
23:52  waldner: what's your final goal?
23:56  skered: Nothing right
23:57  skered: Nothing right now
--- Log closed Sat Dec 04 00:00:40 2010
