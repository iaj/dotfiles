--- Log opened Wed Dec 01 00:00:31 2010
--- Log closed Wed Dec 01 01:15:19 2010
--- Log opened Wed Dec 01 01:15:40 2010
01:15 --- Users 90 nicks [0 ops, 0 halfops, 0 voices, 90 normal]
01:17 --- Channel #awk was synced in 130 seconds
01:17  boss: I have data like this : http://pastebin.com/CiY6rQ5h. I feching this data from MySQL in shell script and piping the output to awk.  id,data,storage,bandwidth_sent, bandwidth_received are five column. The storage and bandwidth information is acumulated one. I need to find the daily usage for all id. I need to subtract yesterday value from today value. If you look the sample data there is two entry fio each column, one is for yesterday data and another one is tod
01:17  boss: ays data. I need to subtract todays from yesterday. I need clue of how to achive this. any help on this?
01:18  yitz_: select (select sum(bandwidth_received) from the_table where date = now()) - (select sum(bandwidth_received) from the_table where date = date(now() - interval 1 day));
01:28  boss: yitz_ :  select (select bandwidth_received from bandwidth_usage where date = now()) - (select bandwidth_received from bandwidth_usage where date = date(now() - interval 1 day));  I no need to sum. removing the some give : ERROR 1242 (21000): Subquery returns more than 1 row. there may be way to tell mysql to return one row at a time. sorry to ask mysal question here.
02:41  MTecknology: So... I have a big long string that looks like 'blah --foo=blah --a=b --variabl=value --c=d --potatoe=fry"
02:42  MTecknology: I'm trying to figure out how I can grab the value of '--variable=' from that string so I can return 'value'
02:42  MTecknology: How hard is that?
02:46  MTecknology: I 'could' just use awk to pick a certain column ($3 or w/e) and split on = but that wouldn't work because I don't know exactly where it will appear
02:48  Riviera: and
02:49  Riviera: --foo=--variable=
02:49  Riviera: etc
02:49  Riviera: should also not break it, right?
02:49  MTecknology: you lost me
02:50  MTecknology: sorry
02:50  Riviera: sorry :)
02:50  Riviera: Why do you do this, if I may ask?
02:51  MTecknology: I'm trying to parse the output of 'nginx -V' to find a specific configure option and use that in a script
02:52  MTecknology: nginx -V displays all configure options used during compile
02:52  Riviera: what about just writing a script in a scripting language that supports these long options
02:53  Riviera: letting it find out the value in question and use that in a script
02:53  MTecknology: This is what it looks like - http://dpaste.com/281761/
02:56  Riviera: now assume
02:56  Riviera: there would appear somewhere in that string
02:57  Riviera: --http-log-path='this is not a log path but it contains whitespace --variable=hehehe'
02:57  Riviera: then this --variable=hehehe thing would belong to --http-log-path
02:57  Riviera: so, you'd need a parser in these situations
02:57  Riviera: but that's certainly not possible
02:57  Riviera: but
02:57  Riviera: what you want surely is easy to do in awk
02:58  Riviera: but the question is ... what do you think about the approach i suggested?
02:59  MTecknology: about using a different scripting language to parse?
03:00  MTecknology: heh... I just realized nginx -V sends to stderr instead of stdout
03:00  Riviera: about using a scripting language that features the ability to parse strings like that
03:01  MTecknology: I was shooting for bash just because it means no added dependencies since bash and awk are marked as required on the system
03:01  MTecknology: otherwise I'd say sure
03:02 * k[l i've learned some bash and became slightly literate in sed and awk, what's next?
03:03  Riviera: MTecknology: okay
03:03  MTecknology: Riviera: is what I'm trying to do really ugly in awk?
03:03  Riviera: MTecknology: does it have to parse --variable or also stuff like --varia= --variab= etc.?
03:04  MTecknology: no
03:05  Riviera: MTecknology: okay
03:05  Riviera: let's see
03:07  Riviera: 4# awk -v "o=--variable" 'BEGIN { l = length(o) } match($0, /--variable=[^[:blank:]]*/) { print substr($0, RSTART + o, RLENGTH - o) }' <<< ''blah --foo=blah --a=b --variable=value --c=d --potatoe=fry'
03:07  shbot: Riviera: Missing terminating quote, bracket or keyword
03:07  Riviera: 4# awk -v "o=--variable" 'BEGIN { l = length(o) } match($0, /--variable=[^[:blank:]]*/) { print substr($0, RSTART + o, RLENGTH - o) }' <<< 'blah --foo=blah --a=b --variable=value --c=d --potatoe=fry'
03:07  shbot: Riviera: --variable=value
03:07  Riviera: Damn.
03:08  Riviera: 4# awk -v "o=--variable=" 'BEGIN { l = length(o) } match($0, o "[^[:blank:]]*") { print substr($0, RSTART + l, RLENGTH - l) }' <<< 'blah --foo=blah --a=b --variable=value --c=d --potatoe=fry'
03:08  shbot: Riviera: value
03:08  MTecknology: :D
03:09  MTecknology: Riviera: so.. how hard is it to redirect stderr to stdin without sending to a file? I'm aware of 2> but not aware of anything like 2|
03:10  Riviera: 2>&1
03:10  Riviera: 4# echo stderr >&2 | sed 's/^/bla: /'
03:10  shbot: Riviera: stderr
03:10  Riviera: and
03:10  Riviera: 4# echo stderr >&2 2>&1 | sed 's/^/bla: /'
03:10  shbot: Riviera: stderr
03:10  Riviera: err
03:10  Riviera: 4# ( echo stderr >&2 ) 2>&1 | sed 's/^/bla: /'
03:10  shbot: Riviera: bla: stderr
03:10  Riviera: :)
03:12  MTecknology: hm.. it only seems to grab the next character, not until space
03:13 * k[l wonders why this works...
03:14  k[l: # {echo :stderr >&2 ;} 2>&1 | sed 's/^/:foo /'
03:14  k[l: 4# {echo :stderr >&2 ;} 2>&1 | sed 's/^/:foo /'
03:14  shbot: k[l: bash4: syntax error near unexpected token `}'
03:14  Riviera: MTecknology: but it grabbed the whole "value" here.
03:14  k[l: great...
03:15  k[l: 4# { echo :stderr >&2 ;} 2>&1 | sed 's/^/:foo /'
03:15  shbot: k[l: :foo :stderr
03:16  MTecknology: 4# awk -v "o=--conf-path=" 'BEGIN { l = length(o) } match($0, o "[^[:blank:]]*") { print substr($0, RSTART + l, RLENGTH - l) }' <<<$(echo "configure arguments: --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi")
03:16  shbot: MTecknology: /etc/nginx/nginx.conf
03:16  MTecknology: hm....
03:16  MTecknology: works perfect here - but not on my system
03:16  MTecknology: # awk -v "o=--conf-path=" 'BEGIN { l = length(o) } match($0, o "[^[:blank:]]*") { print substr($0, RSTART + l, RLENGTH - l) }' <<<$(echo "configure arguments: --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-client-body-temp-path=/var/lib/nginx/body --http-fastcgi-temp-path=/var/lib/nginx/fastcgi")
03:18  MTecknology: Riviera: Any ideas why it won't work on my bash shell but works perfect here?
03:18  Riviera: MTecknology: do you use mawk?
03:19  MTecknology: looks like it
03:19  MTecknology: man page says mawk
03:20  Riviera: I don't know, it looks like a bug, because it does work with [^ ]* instead of [^[:blank:]]*
03:21  MTecknology: heh..
03:21  MTecknology: Riviera: thanks :D
03:26  MTecknology: Riviera: ok- so I've been looking at it and I finally an able to read that :D
03:28  Riviera: great
04:37  steve___: Riviera: would this work?
04:37  steve___: 4# awk -F= -v RS=' ' '/variable/ {print $2}' <<< 'blah --foo=blah --a=b --variable=value --c=d --potatoe=fry'
04:37  shbot: steve___: value
--- Log closed Wed Dec 01 05:15:00 2010
--- Log opened Wed Dec 01 05:15:22 2010
05:15 --- Users 90 nicks [0 ops, 0 halfops, 0 voices, 90 normal]
05:17 --- Channel #awk was synced in 130 seconds
--- Log closed Wed Dec 01 08:03:39 2010
--- Log opened Wed Dec 01 08:03:58 2010
08:03 --- Users 89 nicks [0 ops, 0 halfops, 0 voices, 89 normal]
08:06 --- Channel #awk was synced in 130 seconds
--- Log closed Wed Dec 01 12:32:10 2010
--- Log opened Wed Dec 01 12:32:29 2010
12:32 --- Users 93 nicks [0 ops, 0 halfops, 0 voices, 93 normal]
12:34 --- Channel #awk was synced in 137 seconds
--- Log closed Wed Dec 01 13:56:45 2010
--- Log opened Wed Dec 01 13:57:38 2010
13:57 --- Users 95 nicks [0 ops, 0 halfops, 0 voices, 95 normal]
14:01 --- Channel #awk was synced in 229 seconds
16:56  ItsMeMario: where am i? is this a programing language????
16:58  j_wright: they were looking for #auk maybe
17:02  Riviera: And what is that?
17:03  j_wright: a penguin-like bird
17:05  j_wright: can fly though
17:05  iaj: oO
17:07  Riviera: cute
17:08  j_wright: http://awk.info/?who/greatauk
17:08  j_wright: interesting though, the great auks are extinct and couldn't fly
17:13  Riviera: Lived among the dinosaurs :)
18:26  iaj: :-)
18:34  cham: Hy all, i need help 'cause i'm going crazy to get pkts value from this output http://pastebin.com/a88cWDa3 .
18:36  cham: I'd like to have output parsed like inet_SSH-eth1_in.value $1 (referred to line 6 for ex)
18:36  cham: cam anyone help me please ? 
18:37  cham: can anyone help me please ? 
18:42  waldner: the output of iptables-save is easier to parse
18:43  waldner: ah, you want the final comment but with .value and the first field
18:43  waldner: munin plugin, eh?
18:44  cham: waldner: i know ... but i need it a 'live' count
18:44  waldner: so? iptabls-save gives you the live count
18:44  cham: waldner: YES !! it for munin
18:44  waldner: I wrote a munin plugin myself for traffic accounting and I use iptables-save
18:44  waldner: but let's see here
18:45  waldner: awk 'match(/\/\*.*\*\//){print substr($0, RSTART+3, RLENGTH-3)".value " $1}'
18:46  waldner: actually it should probably be RLENGTH - 6 or -7
18:46  waldner: to account for the closing */
18:46  cham: waldner: but iptables-save do not give you pkt count. isn't it ? 
18:46  waldner: of course it does
18:47  waldner: what do you think the [1234:5678] numbers are?
18:47  waldner: you have to use -c
18:48  cham: waldner: -c is missing ! 
18:48  waldner: strange, must be a very old version then
18:48  waldner: try the above code then
--- Log closed Thu Dec 02 15:16:28 2010
