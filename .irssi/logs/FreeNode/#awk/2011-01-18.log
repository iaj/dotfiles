--- Log opened Tue Jan 18 00:00:37 2011
--- Log closed Tue Jan 18 00:13:44 2011
--- Log opened Tue Jan 18 00:14:05 2011
00:14 --- Users 82 nicks [0 ops, 0 halfops, 0 voices, 82 normal]
00:15 --- Channel #awk was synced in 108 seconds
--- Log closed Tue Jan 18 01:33:10 2011
--- Log opened Tue Jan 18 01:33:31 2011
01:33 --- Users 83 nicks [0 ops, 0 halfops, 0 voices, 83 normal]
01:33 --- Server: [verne.freenode.net] [freenode-info] please register your nickname...don't forget to auto-identify! http://freenode.net/faq.shtml#nicksetup
01:35 --- Channel #awk was synced in 105 seconds
--- Log closed Tue Jan 18 02:20:02 2011
--- Log opened Tue Jan 18 02:20:26 2011
02:20 --- Users 80 nicks [0 ops, 0 halfops, 0 voices, 80 normal]
02:22 --- Channel #awk was synced in 102 seconds
02:24  variable: I have some data in the format    blah | blah | blah | A  B C | blah | blah; I need $1, $2, etc
02:24  variable: but I also need to be able to get A B C separately 
02:24  variable: how can I "sub-awk" a record or whatever the term is?
02:36  user__: simples
02:36  user__: simple
02:37  variable: user__, hrm ?
02:41  variable: also - is there a variable that holds an entire field - so I could do something like $7 ~ /foo/ { print FULL_LINE }
02:41  variable: *record not field
02:41  variable: user__ ?
02:41  variable: ooh - I found the split function
02:44  user__: just a moment
--- Log closed Tue Jan 18 02:51:41 2011
--- Log opened Tue Jan 18 02:52:04 2011
02:52 --- Users 80 nicks [0 ops, 0 halfops, 0 voices, 80 normal]
02:52 --- Server: [holmes.freenode.net] [freenode-info] if you're at a conference and other people are having trouble connecting, please mention it to staff: http://freenode.net/faq.shtml#gettinghelp
02:53 --- Channel #awk was synced in 102 seconds
02:55  steve___: variable: awk -F'( \\| | *)' '{for (i=1;i<NF;i++) print $i}' <<< 'blah | blah | blah | A  B C | blah | blah'
02:57  variable: steve___, erm I need "A B C" as $5 or whatever. and then I need to be able to say $5.1 $5.2 etc. ie sometimes I need them together and sometimes separate.   split() looks interesting 
02:57  variable: user__, and yeah - that pastebin is what I want
02:57 * variable is pretty sure split does it
02:57  user__: echo "blah | blah | blah | A  B C | blah | blah"| awk -F"|" '{for (i=1; i<=NF; i++) {print $i}}'| awk -F" " '{printf("%s\t%s\t%s\n",$1,$2,$3)}'
02:58  user__: variable, if you want all in one is possible too
02:58  variable: nah - its alright
02:58  variable: thanks
02:58  user__: :)
--- Log closed Tue Jan 18 04:12:07 2011
--- Log opened Tue Jan 18 04:12:31 2011
04:12 --- Users 83 nicks [0 ops, 0 halfops, 0 voices, 83 normal]
04:14 --- Channel #awk was synced in 107 seconds
--- Log closed Tue Jan 18 04:37:43 2011
--- Log opened Tue Jan 18 04:38:06 2011
04:38 --- Users 82 nicks [0 ops, 0 halfops, 0 voices, 82 normal]
04:39 --- Channel #awk was synced in 103 seconds
--- Log closed Tue Jan 18 05:05:17 2011
--- Log opened Tue Jan 18 05:05:38 2011
05:05 --- Users 85 nicks [0 ops, 0 halfops, 0 voices, 85 normal]
05:07 --- Channel #awk was synced in 105 seconds
--- Log closed Tue Jan 18 05:34:51 2011
--- Log opened Tue Jan 18 05:35:13 2011
05:35 --- Users 85 nicks [0 ops, 0 halfops, 0 voices, 85 normal]
05:36 --- Channel #awk was synced in 103 seconds
06:42  FranciscoD: hello, How do I redirect a print statement to a file whose name is $FILENAME.safe?
06:43  FranciscoD: I'm new at awk, I just read up the manual last night :)
06:44  gnomon: FranciscoD, you could try this: awk -v "outfile=$FILENAME.safe" 'BEGIN{print 'wibble wibble wibble' > outfile; close(outfile)}'
06:44  FranciscoD: gnomon: one sec
06:46  FranciscoD: gnomon: i need to do this : print | sort > $FILENAME.safe
06:46  FranciscoD: I've written "command = 'sort -r > outfile', and then used it as print $1 | command
06:46  gnomon: FranciscoD, that doesn't sound like an awk question - is it?
06:46  FranciscoD: but it doesn't work here, 
06:47  FranciscoD: It is, I think. I get a file "outfile" instead
06:47  FranciscoD: gnomon: awk -v outfile1=$FILENAME.safe -v outfile2=$FILENAME.unsafe 'BEGIN {FS = "*"}; /All unsafe derefs/,/All safe derefs/ {command = "sort -r > outfile1 "; if(/^[[:digit:]]+/) {print $2 | command}} /All safe derefs/,/Categorization of bug reports/ { command = "sort -r > outfile2 "; if(/^[[:digit:]]+/) {print $2 | command  }}' $file
06:47  FranciscoD: that is awk, isn't it? :D
06:48  FranciscoD: at the moment, I'm getting outputs in two files called 'outfile1' and 'outfile2'
--- Log closed Tue Jan 18 06:53:13 2011
--- Log opened Tue Jan 18 06:53:32 2011
06:53 --- Users 84 nicks [0 ops, 0 halfops, 0 voices, 84 normal]
06:54  FranciscoD: gnomon: sorry, I got disconnected. Did you say anything? 
06:55 --- Channel #awk was synced in 107 seconds
06:55  FranciscoD: gnomon: this is the script actually : http://eugeneciurana.com/pastebin/pastebin.php?show=43754
06:55  gnomon: FranciscoD, not quite yet, I'm working on a test case.
06:55  FranciscoD: OK. Thanks
07:15  FranciscoD: gnomon: I can't undestand why it's value isn't being subbed in. Is it something to do with shell quotation rules?
--- Log closed Tue Jan 18 07:19:45 2011
--- Log opened Tue Jan 18 07:20:05 2011
07:20 --- Users 84 nicks [0 ops, 0 halfops, 0 voices, 84 normal]
07:20  FranciscoD: gnomon: awk  'BEGIN {FS = "*"}; outfile1=FILENAME".safe" { }; outfile2=FILENAME".unsafe" { };  /All unsafe derefs/,/All safe derefs/ {command = "sort -r > "; if(/^[[:digit:]]+/) {print $2 | command outfile1}} /All safe derefs/,/Categorization of bug reports/ { command = "sort -r > "; if(/^[[:digit:]]+/) {print $2 | command outfile2 }}' $file
07:20  FranciscoD: that works
07:20  FranciscoD: so what was I doing wrong? I think -v outfile=FILENAME didn't work because filename isn't assigned the value until reading of the file begins
07:21 --- Channel #awk was synced in 106 seconds
07:23  gnomon: Honestly, I'm having some trouble parsing the code which you say works for you.
07:23  gnomon: It's a little... odd.
07:23  FranciscoD: heh
07:25  FranciscoD: gnomon: i landed up here and tried some stunts i guess: http://hibernia.jakma.org/~paul/awk-faq.html
07:31  gnomon: FranciscoD, where is $FILENAME defined?
07:32  gnomon: FranciscoD, http://eugeneciurana.com/pastebin/pastebin.php?show=43755
07:32  gnomon: Ah.  Well.  Never mind, then, I guess.
--- Log closed Tue Jan 18 09:02:36 2011
--- Log opened Tue Jan 18 10:14:49 2011
10:14 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
10:16  roadt: seems i misuderstanding RS and FS. problem sovled. thanks 
10:16 --- Channel #awk was synced in 106 seconds
10:26  waldner: you can do -F, or BEGIN{FS=","}
10:26  waldner: or you can do -v RS=, or BEGIN{RS=","}
--- Log opened Tue Jan 18 14:48:26 2011
14:48 --- Users 90 nicks [0 ops, 0 halfops, 0 voices, 90 normal]
14:48  elkng: I've a very long string "xxxx xxx <str word1> xxx xx <str word2> xxxx xxx <str word3> xxx xx <str word4> xxxx xxx <str word5> ..." how can I get all symbols between "<str " and ">" all those "word1 word2 ..." ?
14:50 --- Channel #awk was synced in 109 seconds
14:50  fraff: html ?
14:50  elkng: fraff: maybe
14:52  pgas: please don' t cross post it' s annoyng
14:52  fraff: ok, I would use tr and sed ... (or get a piece of code from lynx) but I don't know how to do with awk
14:53  pgas: answer to these questions depends very much on the exact format of the source
14:53  pgas: ie is it all on one line?
14:54  pgas: awk -v RS=\> -F'<st'  'NF>1{print $2}' 
14:54  pgas: 4# echo " xxx <str word3> xxx xx <str word4> xxxx xxx <str word5> ..." | awk -v RS=\> -F'<st'  'NF>1{print $2}' 
14:54  shbot: pgas: r word3
14:54  shbot: pgas: r word4
14:54  shbot: pgas: r word5
14:54  pgas: 4# echo " xxx <str word3> xxx xx <str word4> xxxx xxx <str word5> ..." | awk -v RS=\> -F'<str '  'NF>1{print $2}' 
14:55  shbot: pgas: word3
14:55  shbot: pgas: word4
14:55  shbot: pgas: word5
14:56  elkng: pgas: yes, its just one long line with, and I want just some chunks of text, only between "<str " and ">"
14:57  pgas: ok then you got your answer
14:58  elkng: pgas: thanks
17:07  skered: With gawk can you find the difference between two times with the example format "Mon Jan 17 18:00:00 EST 2011"
17:11  gnubien: skered: only hours minutes and seconds, maybe, if not use epic
17:11  fraff: I would use strptime ...
--- Log closed Tue Jan 18 17:15:31 2011
--- Log opened Tue Jan 18 17:15:42 2011
17:15 --- Users 86 nicks [0 ops, 0 halfops, 0 voices, 86 normal]
17:17 --- Channel #awk was synced in 114 seconds
17:37  skered: blah to bad that wasn't 01 instead of Jan
17:45  skered: umm....  print t; ts = mktime( t ); print ts;... 
17:45  skered: 2011 01 17 180100
17:45  skered: -1
17:45  skered: er I need spaces between h m s
18:27 --- fraff is now known as fraff_
19:10 --- ghoti_ is now known as ghoti
20:05 --- schrodin1er is now known as schrodinger
--- Log closed Tue Jan 18 21:21:56 2011
--- Log opened Tue Jan 18 21:22:19 2011
21:22 --- Users 80 nicks [0 ops, 0 halfops, 0 voices, 80 normal]
21:24 --- Channel #awk was synced in 114 seconds
21:55 --- y3llow_ is now known as y3llow
--- Log closed Tue Jan 18 23:35:29 2011
--- Log opened Tue Jan 18 23:40:57 2011
23:40 --- Users 78 nicks [0 ops, 0 halfops, 0 voices, 78 normal]
23:42 --- Channel #awk was synced in 108 seconds
--- Log closed Wed Jan 19 00:00:10 2011
