--- Log opened Mon Dec 27 00:00:04 2010
00:09  Geralt: I want to iterate over a multidimensional array, is there no convenient for((index1,index2,...,indexN) in array) construct?
00:19  waldner: no
00:20  waldner: you have to either use the very latest gawk, or reformulate the solution, or not use awk
02:28  pr3d4t0r: waldner: Heh - a good time to try Python :)
--- Log closed Mon Dec 27 02:33:50 2010
--- Log opened Mon Dec 27 02:39:17 2010
02:39 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
02:40 --- Channel #awk was synced in 93 seconds
--- Log closed Mon Dec 27 06:32:37 2010
--- Log opened Mon Dec 27 06:37:59 2010
06:37 --- Users 85 nicks [0 ops, 0 halfops, 0 voices, 85 normal]
06:39 --- Channel #awk was synced in 95 seconds
07:40 --- _qwerty is now known as qwerty
--- Log closed Mon Dec 27 10:32:22 2010
--- Log opened Mon Dec 27 10:37:51 2010
10:37 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
10:39 --- Channel #awk was synced in 95 seconds
13:07  Jacksson: hello! How can i perform math on hex values in awk? For example, if i have read "0x001" (it is in my $1) and i want to add 1 to it, how should i convert it to a normal number? 
13:08  waldner: with gnu awk , you can use --numeric-data (IIRC)
13:09  waldner: ah no it's --non-decimal-data
13:09  Jacksson: nope, it doesn't work :(
13:10  waldner: 4# gawk --non-decimal-data 'BEGIN{a=0x123+1;print a}'
13:10  shbot: waldner: 292
13:10  waldner: works for me
13:10  Jacksson: there's a printf, i am wondering if there is something like scanf as well, or maybe i could parse it as regexp... Because when i add a number to 0x001, i get a strange illogical number :(
13:10  waldner: paste your code
13:10  Jacksson: *waldner i dot have gawk as a standard toolset unfortunaly
13:11  waldner: ah, ok
13:11  Jacksson: there's no way to do that on awk?
13:12  waldner: I think sprintf can convert it?
13:12  waldner: 4# awk 'BEGIN{a=sprintf("%d",0x123); print a}'
13:12  shbot: waldner: 291
13:12  waldner: seems to work
13:12  waldner: but again, don't know if it's a gawk-only thing
13:13  waldner: seems so
13:14  waldner: (--non-decimal-data has nothing to do with this, btw)
13:14  waldner: if your hex data comes from the input, you can preprocess it to convert it to decimal
13:16  Jacksson: waldner by preprocessing you mean sprintf?
13:16  Jacksson: wall, thanks
13:16  waldner: no
13:16  waldner: preprocess so that when awk sees it, it's in decimal format
13:16  waldner: using some other tool
13:17  waldner: or you can, of course, write an awk function to do the conversion
13:17  Jacksson: ok, thanks!
13:18  waldner: it's just a matter of doing 16*(nth_digit) + 256*(n-1th_digit) etc.
13:18  waldner: well, not so easy but that's the algorithm
13:19  Jacksson: seems like sprintf idea doesnt really work
13:19  waldner: no, scratch that
13:19  waldner: basically, it's just that gawk recognizes octal and hex constants
13:20  waldner: but it seems to be a gawk feature
13:20  waldner: 4# awk 'BEGIN{a=0x123+0123+1; print a}'
13:20  shbot: waldner: 375
13:21  waldner: --non-decimal-data extends that to numbers in the input data
13:21  waldner: but still we're talking of gawk enhancements
13:21  waldner: (maybe you can install gawk on your system?)
13:21  Jacksson: waldner i only need it as input, but yeah, seems like i need to externally preprocess it
13:22  Jacksson: thanks for the advices! and no i can't, i am just asking about ordinary mac, where only awk is awailable :( I guess i should learn perl for hex operations then :)
13:23  waldner: I'm pretty sure gawk is available for mac too
13:24  waldner: http://gawk.darwinports.com/
13:26  Jacksson: thank you
13:40  waldner: Jacksson: http://pastebin.com/raw.php?i=0g1rxZRq
--- Log closed Mon Dec 27 14:33:10 2010
--- Log opened Mon Dec 27 14:38:38 2010
14:38 --- Users 86 nicks [0 ops, 0 halfops, 0 voices, 86 normal]
14:40 --- Channel #awk was synced in 96 seconds
--- Log closed Mon Dec 27 15:38:06 2010
--- Log opened Mon Dec 27 15:38:36 2010
15:38 --- Users 87 nicks [0 ops, 0 halfops, 0 voices, 87 normal]
15:39 --- Channel #awk was synced in 97 seconds
16:08  stockholm: hi
16:08  stockholm: i have fields in a csv list. 
16:08  stockholm: the -F, is no problem
16:08  stockholm: but how do i remove the " " around the text fields?
16:11  cthuluh: you may want to read this: http://awk.freeshell.org/AwkTips#toc6
16:30  stockholm: cthuluh: that defines FS. is that an environment variable?
16:30  cthuluh: not at all, it's an awk internal variable
16:31  cthuluh: when using -F, all you do is to set FS
16:31  cthuluh: -F, <==> BEGIN { FS="," }
16:32  stockholm: ah
16:38  waldner: or maybe gsub(/^"|"$/,"",$3)
16:38  waldner: for example
--- Log closed Mon Dec 27 17:51:11 2010
--- Log opened Mon Dec 27 17:51:31 2010
17:51 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
17:53 --- Channel #awk was synced in 97 seconds
--- Log closed Mon Dec 27 18:32:45 2010
--- Log opened Mon Dec 27 18:38:07 2010
18:38 --- Users 86 nicks [0 ops, 0 halfops, 0 voices, 86 normal]
18:39 --- Channel #awk was synced in 95 seconds
18:47 --- bllb is now known as ldfsilva
18:56  zxd: hi
18:56  zxd: need a little help here
18:56  zxd: i have  : 
18:56  zxd:  1 [UsbAudio       ]: USB-Audio - C-Media USB Headphone Set
18:56  zxd: want to print only : UsbAudio
18:59  waldner: awk '{print substr($2,2)}' but it may fail with different data
18:59  zxd: why?
19:00  zxd: it dosen't print good stuff
19:00  zxd: ah ok
19:01  zxd: how about same crazy -F
19:01  waldner: you don't have to change it
19:01  waldner: 4# awk '{print substr($2,2)}' <<< ' 1 [UsbAudio       ]: USB-Audio - C-Media USB Headphone Set'
19:01  shbot: waldner: UsbAudio
19:02  zxd: btw, how do I make it stop processing the file after the first line
19:02  zxd: BEGIN ?
19:02  waldner: perhaps using the aptly-named "exit" command?
19:02  zxd: ok
19:04  zxd: waldner: why wouldnt it work with different data
19:06  Geralt: Is there a way to return multiple return values, or to pass a reference? I need a function to return an integer and a string
19:08  waldner: nope
19:08  waldner: but variables are global by default, so you could just pick two variables and use those
19:09  waldner: zxd: it assumes that the information you want is always in the second field, and always has a [ in front of it
19:09  waldner: if for example it has a space in it, it will break
19:09  waldner: eg  1 [Usb Audio     ] etc.
19:13  Geralt: waldner: that's my current workaround, so I'll stick with it, thanks
19:13  waldner: yw
19:13  waldner: using an array may be slightly less "dirty"
20:21 --- bllb is now known as ldfsilva
--- Log closed Mon Dec 27 20:25:23 2010
--- Log opened Mon Dec 27 20:25:45 2010
20:25 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
20:27 --- Channel #awk was synced in 93 seconds
--- Log closed Mon Dec 27 20:52:39 2010
--- Log opened Mon Dec 27 20:53:04 2010
20:53 --- Users 89 nicks [0 ops, 0 halfops, 0 voices, 89 normal]
20:54 --- Channel #awk was synced in 95 seconds
--- Log closed Mon Dec 27 22:10:47 2010
--- Log opened Mon Dec 27 22:11:07 2010
22:11 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
22:12 --- Channel #awk was synced in 95 seconds
--- Log closed Mon Dec 27 22:34:02 2010
--- Log opened Mon Dec 27 22:39:26 2010
22:39 --- Users 88 nicks [0 ops, 0 halfops, 0 voices, 88 normal]
22:40 --- Channel #awk was synced in 97 seconds
23:09  stockholm: how do i split up hex values (of mac addresses) from aabbccdd... into the known aa:bb:cc:dd: form?
23:16  waldner: gsub(/../,":&",mac); print substr(mac,2)
23:17  stockholm: ah
23:22  stockholm: thanks, that works well
--- Log closed Tue Dec 28 00:00:04 2010
