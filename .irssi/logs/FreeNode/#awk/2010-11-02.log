--- Log opened Tue Nov 02 00:00:13 2010
00:54  g0pher: added awk_V7.pdf  -  http://awk.freeshell.org/g0pher
02:11  k[t: shhhiitttttttt..
02:25  k[t: better: =)
--- Log closed Tue Nov 02 05:10:54 2010
--- Log opened Tue Nov 02 07:45:23 2010
07:45 --- Users 95 nicks [0 ops, 0 halfops, 0 voices, 95 normal]
07:46 --- Channel #awk was synced in 97 seconds
07:47  Quintin: I have a file, format is (some spaces)(a number)(tab)(a text name).  how do I make this file into what it is now, but divide that number by 1024 ?
07:57  g0pher: $1 / 1024
07:57  probonono: Quintin, do you have to retain exactly the existing spaces or can you simply generate them (i.e. are they known in advance or does the number of spaces vary)?
07:57  Quintin: probonono: that number of spaces varies
07:58  Quintin: basically it's a list with bytesize of installed packages, I want it to be megabyte size
--- Log closed Tue Nov 02 09:14:15 2010
--- Log opened Tue Nov 02 09:14:39 2010
09:14 --- Users 100 nicks [0 ops, 0 halfops, 0 voices, 100 normal]
09:14  g0pher: pgas: Apology - may i remind you that this is the #awk channel - and awk solutions are appreciated here 
09:15  optraz: g0pher: could you please paste again the awk command you suggested?
09:16 --- Channel #awk was synced in 100 seconds
09:16  g0pher: my awk solution was perhaps lame - But pgas grep solution was imho off topic If there is an awk solution ?
09:17  optraz: 16:08 < g0pher> whats wrong with $1="" - then $0 is whats left eg $2 to end ?
09:17  optraz: this something interesting.
09:17  optraz: im looking way to do the change , at least minimize the change.
09:18  pgas: g0pher: not lame, it just needed a bit more work
09:19  pgas: awk -F= -v foo="$bar" -v OFS== '$0 ~ foo{$1="";print substr($0,2)}'
09:19  pgas: which is on topic but perhaps a bit more involved than grep | cut
09:20 * optraz testing the new suggestion 
09:20  optraz: thank you
09:21  pgas: if bar is the key part, then you might want $1 == foo , instead of $0 ~ foo
09:23  optraz: i see
09:23  optraz: yes, it is key
09:23  optraz: ok, i change to $1 == foo
09:25 * optraz reading on $1 $0 and ~ in man awk
09:27  g0pher: <pgas> - thanks
09:32  pgas: aawk -F= -v foo="$bar" '$1 == foo{sub(/[^=]*=/,"");print}'
09:34  optraz: mmm.. nicer without OFS
09:34  optraz: *and* using awk function, sub
09:39  neonoe_: hi, awk -F '^[[]|[]]$|[]]\t[[]' '/^.AD/ { for (i=11; i<16;i++) if ($11 == "1" || $12 == "1" || $13 == "1") printf $_"\n" }'
09:39  neonoe_: oups
09:39  neonoe_: Suppose this line:  awk -F '\t' '/^LIGNE/ { for (i=11; i<16;i++) if ($11 == "1" || $12 == "1" || $13 == "1") printf $_"\n" }'
09:40  neonoe_: It prints the line 4 times if it matches
09:40  neonoe_: how to print only one times if $i matches ?
09:43  pgas: { printf "%s\n",$i;break; }
09:44  pgas: I supposed the _ is a typo and you mean i, also avoid to put data in the format string
09:45  neonoe_: ok
09:45  pgas: in this case you can also simply do: print $i
09:46  neonoe_: for the entire line ?
09:47  pgas: no...instead of using printf
09:47  neonoe_: ah ok
09:47  pgas: also the loop is pointless
09:48  pgas: hmm, your code is bad,
09:48  neonoe_: yeah may be
09:49  neonoe_: the point is: I want to printf only lines matching
09:49  pgas: yeah but you use a loop and then never use the index
09:50  pgas: either use the loop and if ($i == "1"){ print $i;break }
09:50  pgas: or don't use a loop and if ($11 == 1 || $12 == 1 ...) print $i
09:50  neonoe_: ho yeah...
09:50  neonoe_: That's right
09:50  neonoe_: ... /o\
09:58  neonoe_: ok, if I want the $i parameter between (11 and 16) and between (18 and 20) for example, how would you write it in one line ? Is it possible ?
10:12  pgas: for (i=11;i<=20;i++) if (i!=17 && $i == 1) {print $i;break}
10:13  neonoe_: nice. But it works for this example. Suppose i has to be between [1..20] and [50..100]
10:15  pgas: I would probably define a function and use 2 loops. or maybe one while loop
10:15  neonoe_: ok thx
13:26  karthee: hi .. is there a way to check if a file exists  using awk ?
13:36  cthuluh: awk 'BEGIN { if (!system("[ -e somefile ]")) { print "ok"} }'
13:37  cthuluh: alternatively, you could try to test if a file is readable with getline
15:49 --- pr3d4t0r is now known as pr3d4k4t
15:53  crouton: hmmm.. not sure where to ask this but anyway: i've got text of the form \section{blah} \subsection{otherthing} \subsubsection{something} .. i want to insert the text \label{blah} after \section{blah} .. \label{otherthing} after \subsection{otherthing} .. \label{something} after \subsubsection{something}.
15:53  crouton: each \*section is on a seperate line in the file
15:53  pr3d4k4t: crouton: Are those in separate lines?
15:53  crouton: yes
15:54  pr3d4k4t: crouton: Can you post an example of the input here?  http://ciurana.eu/pastebin
15:55  crouton: sure, gimme a sec
15:55  crouton: http://ciurana.eu/pastebin/pastebin.php?show=43509
15:57  crouton: there is a pattern.. so i think it should be possible to do it. the trick is to first capture all the "section" "subsection" and so forth.. then grab what's inside the curly braces..  and add \label{[grabbed text]} to the next line..
15:58  crouton: i can grep the section lines out and i can grep again to get only the stuff in the curly braces..
16:00 --- pr3d4k4t is now known as pr3d4t0r
--- Log closed Wed Nov 03 09:20:57 2010
